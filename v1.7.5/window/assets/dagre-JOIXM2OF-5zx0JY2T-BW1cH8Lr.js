import{_ as X,au as j,av as F,aw as Y,ax as H,l as i,c as V,ay as z,az as U,ai as $,an as q,aj as P,ah as K,aA as Q,aB as W,aC as Z}from"./mermaid.core-CAqkCmS1-DWfzuUNC.js";import{G as B}from"./graph-3zJxsO-i-Bcl3JfK9.js";import{l as I}from"./layout-sGZIJplX-Tbyy20yQ.js";import{i as x}from"./_baseUniq-BXtq6_NW-B20VNhy6.js";import{c as L}from"./clone-CEJtuQzg-CaKs6iOI.js";import{m as A}from"./min-BngCxx8g-CHJcCUp6.js";import"./index-Bbg2dFko.js";function E(e){var n={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:ee(e),edges:ne(e)};return x(e.graph())||(n.value=L(e.graph())),n}function ee(e){return A(e.nodes(),function(n){var t=e.node(n),c=e.parent(n),d={v:n};return x(t)||(d.value=t),x(c)||(d.parent=c),d})}function ne(e){return A(e.edges(),function(n){var t=e.edge(n),c={v:n.v,w:n.w};return x(n.name)||(c.name=n.name),x(t)||(c.value=t),c})}var u=new Map,b=new Map,_=new Map,te=X(()=>{b.clear(),_.clear(),u.clear()},"clear"),O=X((e,n)=>{const t=b.get(n)||[];return i.trace("In isDescendant",n," ",e," = ",t.includes(e)),t.includes(e)},"isDescendant"),ie=X((e,n)=>{const t=b.get(n)||[];return i.info("Descendants of ",n," is ",t),i.info("Edge is ",e),e.v===n||e.w===n?!1:t?t.includes(e.v)||O(e.v,n)||O(e.w,n)||t.includes(e.w):(i.debug("Tilt, ",n,",not in descendants"),!1)},"edgeInCluster"),J=X((e,n,t,c)=>{i.warn("Copying children of ",e,"root",c,"data",n.node(e),c);const d=n.children(e)||[];e!==c&&d.push(e),i.warn("Copying (nodes) clusterId",e,"nodes",d),d.forEach(l=>{if(n.children(l).length>0)J(l,n,t,c);else{const r=n.node(l);i.info("cp ",l," to ",c," with parent ",e),t.setNode(l,r),c!==n.parent(l)&&(i.warn("Setting parent",l,n.parent(l)),t.setParent(l,n.parent(l))),e!==c&&l!==e?(i.debug("Setting parent",l,e),t.setParent(l,e)):(i.info("In copy ",e,"root",c,"data",n.node(e),c),i.debug("Not Setting parent for node=",l,"cluster!==rootId",e!==c,"node!==clusterId",l!==e));const g=n.edges(l);i.debug("Copying Edges",g),g.forEach(a=>{i.info("Edge",a);const h=n.edge(a.v,a.w,a.name);i.info("Edge data",h,c);try{ie(a,c)?(i.info("Copying as ",a.v,a.w,h,a.name),t.setEdge(a.v,a.w,h,a.name),i.info("newGraph edges ",t.edges(),t.edge(t.edges()[0]))):i.info("Skipping copy of edge ",a.v,"-->",a.w," rootId: ",c," clusterId:",e)}catch(S){i.error(S)}})}i.debug("Removing node",l),n.removeNode(l)})},"copy"),G=X((e,n)=>{const t=n.children(e);let c=[...t];for(const d of t)_.set(d,e),c=[...c,...G(d,n)];return c},"extractDescendants"),se=X((e,n,t)=>{const c=e.edges().filter(a=>a.v===n||a.w===n),d=e.edges().filter(a=>a.v===t||a.w===t),l=c.map(a=>({v:a.v===n?t:a.v,w:a.w===n?n:a.w})),r=d.map(a=>({v:a.v,w:a.w}));return l.filter(a=>r.some(h=>a.v===h.v&&a.w===h.w))},"findCommonEdges"),D=X((e,n,t)=>{const c=n.children(e);if(i.trace("Searching children of id ",e,c),c.length<1)return e;let d;for(const l of c){const r=D(l,n,t),g=se(n,t,r);if(r)if(g.length>0)d=r;else return r}return d},"findNonClusterChild"),k=X(e=>!u.has(e)||!u.get(e).externalConnections?e:u.has(e)?u.get(e).id:e,"getAnchorId"),re=X((e,n)=>{if(!e||n>10){i.debug("Opting out, no graph ");return}else i.debug("Opting in, graph ");e.nodes().forEach(function(t){e.children(t).length>0&&(i.warn("Cluster identified",t," Replacement id in edges: ",D(t,e,t)),b.set(t,G(t,e)),u.set(t,{id:D(t,e,t),clusterData:e.node(t)}))}),e.nodes().forEach(function(t){const c=e.children(t),d=e.edges();c.length>0?(i.debug("Cluster identified",t,b),d.forEach(l=>{const r=O(l.v,t),g=O(l.w,t);r^g&&(i.warn("Edge: ",l," leaves cluster ",t),i.warn("Descendants of XXX ",t,": ",b.get(t)),u.get(t).externalConnections=!0)})):i.debug("Not a cluster ",t,b)});for(let t of u.keys()){const c=u.get(t).id,d=e.parent(c);d!==t&&u.has(d)&&!u.get(d).externalConnections&&(u.get(t).id=d)}e.edges().forEach(function(t){const c=e.edge(t);i.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),i.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(e.edge(t)));let d=t.v,l=t.w;if(i.warn("Fix XXX",u,"ids:",t.v,t.w,"Translating: ",u.get(t.v)," --- ",u.get(t.w)),u.get(t.v)||u.get(t.w)){if(i.warn("Fixing and trying - removing XXX",t.v,t.w,t.name),d=k(t.v),l=k(t.w),e.removeEdge(t.v,t.w,t.name),d!==t.v){const r=e.parent(d);u.get(r).externalConnections=!0,c.fromCluster=t.v}if(l!==t.w){const r=e.parent(l);u.get(r).externalConnections=!0,c.toCluster=t.w}i.warn("Fix Replacing with XXX",d,l,t.name),e.setEdge(d,l,c,t.name)}}),i.warn("Adjusted Graph",E(e)),R(e,0),i.trace(u)},"adjustClustersAndEdges"),R=X((e,n)=>{var t,c;if(i.warn("extractor - ",n,E(e),e.children("D")),n>10){i.error("Bailing out");return}let d=e.nodes(),l=!1;for(const r of d){const g=e.children(r);l=l||g.length>0}if(!l){i.debug("Done, no node has children",e.nodes());return}i.debug("Nodes = ",d,n);for(const r of d)if(i.debug("Extracting node",r,u,u.has(r)&&!u.get(r).externalConnections,!e.parent(r),e.node(r),e.children("D")," Depth ",n),!u.has(r))i.debug("Not a cluster",r,n);else if(!u.get(r).externalConnections&&e.children(r)&&e.children(r).length>0){i.warn("Cluster without external connections, without a parent and with children",r,n);let a=e.graph().rankdir==="TB"?"LR":"TB";(c=(t=u.get(r))==null?void 0:t.clusterData)!=null&&c.dir&&(a=u.get(r).clusterData.dir,i.warn("Fixing dir",u.get(r).clusterData.dir,a));const h=new B({multigraph:!0,compound:!0}).setGraph({rankdir:a,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});i.warn("Old graph before copy",E(e)),J(r,e,h,r),e.setNode(r,{clusterNode:!0,id:r,clusterData:u.get(r).clusterData,label:u.get(r).label,graph:h}),i.warn("New graph after copy node: (",r,")",E(h)),i.debug("Old graph after copy",E(e))}else i.warn("Cluster ** ",r," **not meeting the criteria !externalConnections:",!u.get(r).externalConnections," no parent: ",!e.parent(r)," children ",e.children(r)&&e.children(r).length>0,e.children("D"),n),i.debug(u);d=e.nodes(),i.warn("New list of nodes",d);for(const r of d){const g=e.node(r);i.warn(" Now next level",r,g),g!=null&&g.clusterNode&&R(g.graph,n+1)}},"extractor"),T=X((e,n)=>{if(n.length===0)return[];let t=Object.assign([],n);return n.forEach(c=>{const d=e.children(c),l=T(e,d);t=[...t,...l]}),t},"sorter"),oe=X(e=>T(e,e.children()),"sortNodesByHierarchy"),M=X(async(e,n,t,c,d,l)=>{i.warn("Graph in recursive render:XAX",E(n),d);const r=n.graph().rankdir;i.trace("Dir in recursive render - dir:",r);const g=e.insert("g").attr("class","root");n.nodes()?i.info("Recursive render XXX",n.nodes()):i.info("No nodes found for",n),n.edges().length>0&&i.info("Recursive edges",n.edge(n.edges()[0]));const a=g.insert("g").attr("class","clusters"),h=g.insert("g").attr("class","edgePaths"),S=g.insert("g").attr("class","edgeLabels"),w=g.insert("g").attr("class","nodes");await Promise.all(n.nodes().map(async function(f){const o=n.node(f);if(d!==void 0){const s=JSON.parse(JSON.stringify(d.clusterData));i.trace(`Setting data for parent cluster XXX
 Node.id = `,f,`
 data=`,s.height,`
Parent cluster`,d.height),n.setNode(d.id,s),n.parent(f)||(i.trace("Setting parent",f,d.id),n.setParent(f,d.id,s))}if(i.info("(Insert) Node XXX"+f+": "+JSON.stringify(n.node(f))),o!=null&&o.clusterNode){i.info("Cluster identified XBX",f,o.width,n.node(f));const{ranksep:s,nodesep:m}=n.graph();o.graph.setGraph({...o.graph.graph(),ranksep:s+25,nodesep:m});const N=await M(w,o.graph,t,c,n.node(f),l),C=N.elem;z(o,C),o.diff=N.diff||0,i.info("New compound node after recursive render XAX",f,"width",o.width,"height",o.height),U(C,o)}else n.children(f).length>0?(i.trace("Cluster - the non recursive path XBX",f,o.id,o,o.width,"Graph:",n),i.trace(D(o.id,n)),u.set(o.id,{id:D(o.id,n),node:o})):(i.trace("Node - the non recursive path XAX",f,w,n.node(f),r),await $(w,n.node(f),{config:l,dir:r}))})),await X(async()=>{const f=n.edges().map(async function(o){const s=n.edge(o.v,o.w,o.name);i.info("Edge "+o.v+" -> "+o.w+": "+JSON.stringify(o)),i.info("Edge "+o.v+" -> "+o.w+": ",o," ",JSON.stringify(n.edge(o))),i.info("Fix",u,"ids:",o.v,o.w,"Translating: ",u.get(o.v),u.get(o.w)),await Z(S,s)});await Promise.all(f)},"processEdges")(),i.info("Graph before layout:",JSON.stringify(E(n))),i.info("############################################# XXX"),i.info("###                Layout                 ### XXX"),i.info("############################################# XXX"),I(n),i.info("Graph after layout:",JSON.stringify(E(n)));let y=0,{subGraphTitleTotalMargin:p}=q(l);return await Promise.all(oe(n).map(async function(f){var o;const s=n.node(f);if(i.info("Position XBX => "+f+": ("+s.x,","+s.y,") width: ",s.width," height: ",s.height),s!=null&&s.clusterNode)s.y+=p,i.info("A tainted cluster node XBX1",f,s.id,s.width,s.height,s.x,s.y,n.parent(f)),u.get(s.id).node=s,P(s);else if(n.children(f).length>0){i.info("A pure cluster node XBX1",f,s.id,s.x,s.y,s.width,s.height,n.parent(f)),s.height+=p,n.node(s.parentId);const m=(s==null?void 0:s.padding)/2||0,N=((o=s==null?void 0:s.labelBBox)==null?void 0:o.height)||0,C=N-m||0;i.debug("OffsetY",C,"labelHeight",N,"halfPadding",m),await K(a,s),u.get(s.id).node=s}else{const m=n.node(s.parentId);s.y+=p/2,i.info("A regular node XBX1 - using the padding",s.id,"parent",s.parentId,s.width,s.height,s.x,s.y,"offsetY",s.offsetY,"parent",m,m==null?void 0:m.offsetY,s),P(s)}})),n.edges().forEach(function(f){const o=n.edge(f);i.info("Edge "+f.v+" -> "+f.w+": "+JSON.stringify(o),o),o.points.forEach(C=>C.y+=p/2);const s=n.node(f.v);var m=n.node(f.w);const N=Q(h,o,u,t,s,m,c);W(o,N)}),n.nodes().forEach(function(f){const o=n.node(f);i.info(f,o.type,o.diff),o.isGroup&&(y=o.diff)}),i.warn("Returning from recursive render XAX",g,y),{elem:g,diff:y}},"recursiveRender"),we=X(async(e,n)=>{var t,c,d,l,r,g;const a=new B({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:((t=e.config)==null?void 0:t.nodeSpacing)||((d=(c=e.config)==null?void 0:c.flowchart)==null?void 0:d.nodeSpacing)||e.nodeSpacing,ranksep:((l=e.config)==null?void 0:l.rankSpacing)||((g=(r=e.config)==null?void 0:r.flowchart)==null?void 0:g.rankSpacing)||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),h=n.select("g");j(h,e.markers,e.type,e.diagramId),F(),Y(),H(),te(),e.nodes.forEach(w=>{a.setNode(w.id,{...w}),w.parentId&&a.setParent(w.id,w.parentId)}),i.debug("Edges:",e.edges),e.edges.forEach(w=>{if(w.start===w.end){const v=w.start,y=v+"---"+v+"---1",p=v+"---"+v+"---2",f=a.node(v);a.setNode(y,{domId:y,id:y,parentId:f.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),a.setParent(y,f.parentId),a.setNode(p,{domId:p,id:p,parentId:f.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),a.setParent(p,f.parentId);const o=structuredClone(w),s=structuredClone(w),m=structuredClone(w);o.label="",o.arrowTypeEnd="none",o.id=v+"-cyclic-special-1",s.arrowTypeStart="none",s.arrowTypeEnd="none",s.id=v+"-cyclic-special-mid",m.label="",f.isGroup&&(o.fromCluster=v,m.toCluster=v),m.id=v+"-cyclic-special-2",m.arrowTypeStart="none",a.setEdge(v,y,o,v+"-cyclic-special-0"),a.setEdge(y,p,s,v+"-cyclic-special-1"),a.setEdge(p,v,m,v+"-cyc<lic-special-2")}else a.setEdge(w.start,w.end,{...w},w.id)}),i.warn("Graph at first:",JSON.stringify(E(a))),re(a),i.warn("Graph after XAX:",JSON.stringify(E(a)));const S=V();await M(h,a,e.type,e.diagramId,void 0,S)},"render");export{we as render};
