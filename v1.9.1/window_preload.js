var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/@langchain+mcp-adapters@1.0_422fcda27cc657832245d1643c939873/node_modules/@langchain/mcp-adapters/dist/_virtual/rolldown_runtime.cjs
var require_rolldown_runtime = __commonJS({
  "node_modules/.pnpm/@langchain+mcp-adapters@1.0_422fcda27cc657832245d1643c939873/node_modules/@langchain/mcp-adapters/dist/_virtual/rolldown_runtime.cjs"(exports2) {
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames2(from), i = 0, n = keys.length, key; i < n; i++) {
        key = keys[i];
        if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: ((k) => from[k]).bind(null, key),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", {
      value: mod,
      enumerable: true
    }) : target, mod));
    exports2.__toESM = __toESM2;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v3/helpers/util.cjs
var require_util = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v3/helpers/util.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getParsedType = exports2.ZodParsedType = exports2.objectUtil = exports2.util = void 0;
    var util;
    (function(util2) {
      util2.assertEqual = (_) => {
      };
      function assertIs(_arg) {
      }
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e) {
          return obj[e];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys = [];
        for (const key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util || (exports2.util = util = {}));
    var objectUtil;
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (exports2.objectUtil = objectUtil = {}));
    exports2.ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    var getParsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return exports2.ZodParsedType.undefined;
        case "string":
          return exports2.ZodParsedType.string;
        case "number":
          return Number.isNaN(data) ? exports2.ZodParsedType.nan : exports2.ZodParsedType.number;
        case "boolean":
          return exports2.ZodParsedType.boolean;
        case "function":
          return exports2.ZodParsedType.function;
        case "bigint":
          return exports2.ZodParsedType.bigint;
        case "symbol":
          return exports2.ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return exports2.ZodParsedType.array;
          }
          if (data === null) {
            return exports2.ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return exports2.ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return exports2.ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return exports2.ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return exports2.ZodParsedType.date;
          }
          return exports2.ZodParsedType.object;
        default:
          return exports2.ZodParsedType.unknown;
      }
    };
    exports2.getParsedType = getParsedType;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v3/ZodError.cjs
var require_ZodError = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v3/ZodError.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ZodError = exports2.quotelessJson = exports2.ZodIssueCode = void 0;
    var util_js_1 = require_util();
    exports2.ZodIssueCode = util_js_1.util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    var quotelessJson = (obj) => {
      const json = JSON.stringify(obj, null, 2);
      return json.replace(/"([^"]+)":/g, "$1:");
    };
    exports2.quotelessJson = quotelessJson;
    var ZodError = class _ZodError extends Error {
      get errors() {
        return this.issues;
      }
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
          for (const issue of error.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i = 0;
              while (i < issue.path.length) {
                const el = issue.path[i];
                const terminal = i === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      static assert(value) {
        if (!(value instanceof _ZodError)) {
          throw new Error(`Not a ZodError: ${value}`);
        }
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util_js_1.util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = /* @__PURE__ */ Object.create(null);
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            const firstEl = sub.path[0];
            fieldErrors[firstEl] = fieldErrors[firstEl] || [];
            fieldErrors[firstEl].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    exports2.ZodError = ZodError;
    ZodError.create = (issues) => {
      const error = new ZodError(issues);
      return error;
    };
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v3/locales/en.cjs
var require_en = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v3/locales/en.cjs"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ZodError_js_1 = require_ZodError();
    var util_js_1 = require_util();
    var errorMap = (issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodError_js_1.ZodIssueCode.invalid_type:
          if (issue.received === util_js_1.ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodError_js_1.ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_js_1.util.jsonStringifyReplacer)}`;
          break;
        case ZodError_js_1.ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util_js_1.util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util_js_1.util.joinValues(issue.options)}`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util_js_1.util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util_js_1.util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodError_js_1.ZodIssueCode.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "bigint")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodError_js_1.ZodIssueCode.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodError_js_1.ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodError_js_1.ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodError_js_1.ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util_js_1.util.assertNever(issue);
      }
      return { message };
    };
    exports2.default = errorMap;
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v3/errors.cjs
var require_errors = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v3/errors.cjs"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultErrorMap = void 0;
    exports2.setErrorMap = setErrorMap;
    exports2.getErrorMap = getErrorMap;
    var en_js_1 = __importDefault(require_en());
    exports2.defaultErrorMap = en_js_1.default;
    var overrideErrorMap = en_js_1.default;
    function setErrorMap(map) {
      overrideErrorMap = map;
    }
    function getErrorMap() {
      return overrideErrorMap;
    }
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v3/helpers/parseUtil.cjs
var require_parseUtil = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v3/helpers/parseUtil.cjs"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAsync = exports2.isValid = exports2.isDirty = exports2.isAborted = exports2.OK = exports2.DIRTY = exports2.INVALID = exports2.ParseStatus = exports2.EMPTY_PATH = exports2.makeIssue = void 0;
    exports2.addIssueToContext = addIssueToContext;
    var errors_js_1 = require_errors();
    var en_js_1 = __importDefault(require_en());
    var makeIssue = (params) => {
      const { data, path, errorMaps, issueData } = params;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      if (issueData.message !== void 0) {
        return {
          ...issueData,
          path: fullPath,
          message: issueData.message
        };
      }
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: errorMessage
      };
    };
    exports2.makeIssue = makeIssue;
    exports2.EMPTY_PATH = [];
    function addIssueToContext(ctx, issueData) {
      const overrideMap = (0, errors_js_1.getErrorMap)();
      const issue = (0, exports2.makeIssue)({
        issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          // contextual error map is first priority
          ctx.schemaErrorMap,
          // then schema-bound map if available
          overrideMap,
          // then global override map
          overrideMap === en_js_1.default ? void 0 : en_js_1.default
          // then global default map
        ].filter((x) => !!x)
      });
      ctx.common.issues.push(issue);
    }
    var ParseStatus = class _ParseStatus {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
          if (s.status === "aborted")
            return exports2.INVALID;
          if (s.status === "dirty")
            status.dirty();
          arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return exports2.INVALID;
          if (value.status === "aborted")
            return exports2.INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    exports2.ParseStatus = ParseStatus;
    exports2.INVALID = Object.freeze({
      status: "aborted"
    });
    var DIRTY = (value) => ({ status: "dirty", value });
    exports2.DIRTY = DIRTY;
    var OK = (value) => ({ status: "valid", value });
    exports2.OK = OK;
    var isAborted = (x) => x.status === "aborted";
    exports2.isAborted = isAborted;
    var isDirty = (x) => x.status === "dirty";
    exports2.isDirty = isDirty;
    var isValid = (x) => x.status === "valid";
    exports2.isValid = isValid;
    var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
    exports2.isAsync = isAsync;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v3/helpers/typeAliases.cjs
var require_typeAliases = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v3/helpers/typeAliases.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v3/helpers/errorUtil.cjs
var require_errorUtil = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v3/helpers/errorUtil.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.errorUtil = void 0;
    var errorUtil;
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
    })(errorUtil || (exports2.errorUtil = errorUtil = {}));
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v3/types.cjs
var require_types = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v3/types.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.discriminatedUnion = exports2.date = exports2.boolean = exports2.bigint = exports2.array = exports2.any = exports2.coerce = exports2.ZodFirstPartyTypeKind = exports2.late = exports2.ZodSchema = exports2.Schema = exports2.ZodReadonly = exports2.ZodPipeline = exports2.ZodBranded = exports2.BRAND = exports2.ZodNaN = exports2.ZodCatch = exports2.ZodDefault = exports2.ZodNullable = exports2.ZodOptional = exports2.ZodTransformer = exports2.ZodEffects = exports2.ZodPromise = exports2.ZodNativeEnum = exports2.ZodEnum = exports2.ZodLiteral = exports2.ZodLazy = exports2.ZodFunction = exports2.ZodSet = exports2.ZodMap = exports2.ZodRecord = exports2.ZodTuple = exports2.ZodIntersection = exports2.ZodDiscriminatedUnion = exports2.ZodUnion = exports2.ZodObject = exports2.ZodArray = exports2.ZodVoid = exports2.ZodNever = exports2.ZodUnknown = exports2.ZodAny = exports2.ZodNull = exports2.ZodUndefined = exports2.ZodSymbol = exports2.ZodDate = exports2.ZodBoolean = exports2.ZodBigInt = exports2.ZodNumber = exports2.ZodString = exports2.ZodType = void 0;
    exports2.NEVER = exports2.void = exports2.unknown = exports2.union = exports2.undefined = exports2.tuple = exports2.transformer = exports2.symbol = exports2.string = exports2.strictObject = exports2.set = exports2.record = exports2.promise = exports2.preprocess = exports2.pipeline = exports2.ostring = exports2.optional = exports2.onumber = exports2.oboolean = exports2.object = exports2.number = exports2.nullable = exports2.null = exports2.never = exports2.nativeEnum = exports2.nan = exports2.map = exports2.literal = exports2.lazy = exports2.intersection = exports2.instanceof = exports2.function = exports2.enum = exports2.effect = void 0;
    exports2.datetimeRegex = datetimeRegex;
    exports2.custom = custom;
    var ZodError_js_1 = require_ZodError();
    var errors_js_1 = require_errors();
    var errorUtil_js_1 = require_errorUtil();
    var parseUtil_js_1 = require_parseUtil();
    var util_js_1 = require_util();
    var ParseInputLazyPath = class {
      constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (Array.isArray(this._key)) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    var handleResult = (ctx, result) => {
      if ((0, parseUtil_js_1.isValid)(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error = new ZodError_js_1.ZodError(ctx.common.issues);
            this._error = error;
            return this._error;
          }
        };
      }
    };
    function processCreateParams(params) {
      if (!params)
        return {};
      const { errorMap, invalid_type_error, required_error, description } = params;
      if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
      }
      if (errorMap)
        return { errorMap, description };
      const customMap = (iss, ctx) => {
        const { message } = params;
        if (iss.code === "invalid_enum_value") {
          return { message: message ?? ctx.defaultError };
        }
        if (typeof ctx.data === "undefined") {
          return { message: message ?? required_error ?? ctx.defaultError };
        }
        if (iss.code !== "invalid_type")
          return { message: ctx.defaultError };
        return { message: message ?? invalid_type_error ?? ctx.defaultError };
      };
      return { errorMap: customMap, description };
    }
    var ZodType = class {
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return (0, util_js_1.getParsedType)(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: (0, util_js_1.getParsedType)(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new parseUtil_js_1.ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: (0, util_js_1.getParsedType)(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if ((0, parseUtil_js_1.isAsync)(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        const ctx = {
          common: {
            issues: [],
            async: params?.async ?? false,
            contextualErrorMap: params?.errorMap
          },
          path: params?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_js_1.getParsedType)(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      "~validate"(data) {
        const ctx = {
          common: {
            issues: [],
            async: !!this["~standard"].async
          },
          path: [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_js_1.getParsedType)(data)
        };
        if (!this["~standard"].async) {
          try {
            const result = this._parseSync({ data, path: [], parent: ctx });
            return (0, parseUtil_js_1.isValid)(result) ? {
              value: result.value
            } : {
              issues: ctx.common.issues
            };
          } catch (err) {
            if (err?.message?.toLowerCase()?.includes("encountered")) {
              this["~standard"].async = true;
            }
            ctx.common = {
              issues: [],
              async: true
            };
          }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => (0, parseUtil_js_1.isValid)(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        });
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params?.errorMap,
            async: true
          },
          path: params?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_js_1.getParsedType)(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await ((0, parseUtil_js_1.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check, message) {
        const getIssueProperties = (val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        };
        return this._refinement((val, ctx) => {
          const result = check(val);
          const setError = () => ctx.addIssue({
            code: ZodError_js_1.ZodIssueCode.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
          version: 1,
          vendor: "zod",
          validate: (data) => this["~validate"](data)
        };
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    exports2.ZodType = ZodType;
    exports2.Schema = ZodType;
    exports2.ZodSchema = ZodType;
    var cuidRegex = /^c[^\s-]{8,}$/i;
    var cuid2Regex = /^[0-9a-z]+$/;
    var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
    var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    var nanoidRegex = /^[a-z0-9_-]{21}$/i;
    var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
    var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    var emojiRegex;
    var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
    var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
    var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
    var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
    var dateRegex = new RegExp(`^${dateRegexSource}$`);
    function timeRegexSource(args) {
      let secondsRegexSource = `[0-5]\\d`;
      if (args.precision) {
        secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
      } else if (args.precision == null) {
        secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
      }
      const secondsQuantifier = args.precision ? "+" : "?";
      return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
    }
    function timeRegex(args) {
      return new RegExp(`^${timeRegexSource(args)}$`);
    }
    function datetimeRegex(args) {
      let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
      const opts = [];
      opts.push(args.local ? `Z?` : `Z`);
      if (args.offset)
        opts.push(`([+-]\\d{2}:?\\d{2})`);
      regex = `${regex}(${opts.join("|")})`;
      return new RegExp(`^${regex}$`);
    }
    function isValidIP(ip, version2) {
      if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
        return true;
      }
      if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
        return true;
      }
      return false;
    }
    function isValidJWT(jwt, alg) {
      if (!jwtRegex.test(jwt))
        return false;
      try {
        const [header] = jwt.split(".");
        if (!header)
          return false;
        const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
        const decoded = JSON.parse(atob(base64));
        if (typeof decoded !== "object" || decoded === null)
          return false;
        if ("typ" in decoded && decoded?.typ !== "JWT")
          return false;
        if (!decoded.alg)
          return false;
        if (alg && decoded.alg !== alg)
          return false;
        return true;
      } catch {
        return false;
      }
    }
    function isValidCidr(ip, version2) {
      if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
        return true;
      }
      if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
        return true;
      }
      return false;
    }
    var ZodString = class _ZodString extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx2, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.string,
            received: ctx2.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        const status = new parseUtil_js_1.ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                (0, parseUtil_js_1.addIssueToContext)(ctx, {
                  code: ZodError_js_1.ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                (0, parseUtil_js_1.addIssueToContext)(ctx, {
                  code: ZodError_js_1.ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "email",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "emoji",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "uuid",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "nanoid") {
            if (!nanoidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "nanoid",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "cuid",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "cuid2",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "ulid",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "url",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "regex",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "includes") {
            if (!input.data.includes(check.value, check.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                validation: { includes: check.value, position: check.position },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "date") {
            const regex = dateRegex;
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                validation: "date",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "time") {
            const regex = timeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                validation: "time",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "duration") {
            if (!durationRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "duration",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ip") {
            if (!isValidIP(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "ip",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "jwt") {
            if (!isValidJWT(input.data, check.alg)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "jwt",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cidr") {
            if (!isValidCidr(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "cidr",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64") {
            if (!base64Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "base64",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64url") {
            if (!base64urlRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "base64url",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util_js_1.util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
          validation,
          code: ZodError_js_1.ZodIssueCode.invalid_string,
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      _addCheck(check) {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      base64(message) {
        return this._addCheck({ kind: "base64", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      base64url(message) {
        return this._addCheck({
          kind: "base64url",
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      jwt(options) {
        return this._addCheck({ kind: "jwt", ...errorUtil_js_1.errorUtil.errToObj(options) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil_js_1.errorUtil.errToObj(options) });
      }
      cidr(options) {
        return this._addCheck({ kind: "cidr", ...errorUtil_js_1.errorUtil.errToObj(options) });
      }
      datetime(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          offset: options?.offset ?? false,
          local: options?.local ?? false,
          ...errorUtil_js_1.errorUtil.errToObj(options?.message)
        });
      }
      date(message) {
        return this._addCheck({ kind: "date", message });
      }
      time(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "time",
            precision: null,
            message: options
          });
        }
        return this._addCheck({
          kind: "time",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          ...errorUtil_js_1.errorUtil.errToObj(options?.message)
        });
      }
      duration(message) {
        return this._addCheck({ kind: "duration", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options?.position,
          ...errorUtil_js_1.errorUtil.errToObj(options?.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      /**
       * Equivalent to `.min(1)`
       */
      nonempty(message) {
        return this.min(1, errorUtil_js_1.errorUtil.errToObj(message));
      }
      trim() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
      }
      get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
      }
      get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
      }
      get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
      }
      get isBase64url() {
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    exports2.ZodString = ZodString;
    ZodString.create = (params) => {
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
      });
    };
    function floatSafeRemainder(val, step) {
      const valDecCount = (val.toString().split(".")[1] || "").length;
      const stepDecCount = (step.toString().split(".")[1] || "").length;
      const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
      const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
      const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
      return valInt % stepInt / 10 ** decCount;
    }
    var ZodNumber = class _ZodNumber extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx2, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.number,
            received: ctx2.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        let ctx = void 0;
        const status = new parseUtil_js_1.ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util_js_1.util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util_js_1.util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_js_1.errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_js_1.errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_js_1.errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_js_1.errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil_js_1.errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil_js_1.errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util_js_1.util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null;
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    };
    exports2.ZodNumber = ZodNumber;
    ZodNumber.create = (params) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
      });
    };
    var ZodBigInt = class _ZodBigInt extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          try {
            input.data = BigInt(input.data);
          } catch {
            return this._getInvalidInput(input);
          }
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.bigint) {
          return this._getInvalidInput(input);
        }
        let ctx = void 0;
        const status = new parseUtil_js_1.ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_small,
                type: "bigint",
                minimum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_big,
                type: "bigint",
                maximum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (input.data % check.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util_js_1.util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.bigint,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_js_1.errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_js_1.errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_js_1.errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_js_1.errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil_js_1.errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    exports2.ZodBigInt = ZodBigInt;
    ZodBigInt.create = (params) => {
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
      });
    };
    var ZodBoolean = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        return (0, parseUtil_js_1.OK)(input.data);
      }
    };
    exports2.ZodBoolean = ZodBoolean;
    ZodBoolean.create = (params) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
      });
    };
    var ZodDate = class _ZodDate extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx2, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.date,
            received: ctx2.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        if (Number.isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx2, {
            code: ZodError_js_1.ZodIssueCode.invalid_date
          });
          return parseUtil_js_1.INVALID;
        }
        const status = new parseUtil_js_1.ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util_js_1.util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    };
    exports2.ZodDate = ZodDate;
    ZodDate.create = (params) => {
      return new ZodDate({
        checks: [],
        coerce: params?.coerce || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    var ZodSymbol = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        return (0, parseUtil_js_1.OK)(input.data);
      }
    };
    exports2.ZodSymbol = ZodSymbol;
    ZodSymbol.create = (params) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    var ZodUndefined = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        return (0, parseUtil_js_1.OK)(input.data);
      }
    };
    exports2.ZodUndefined = ZodUndefined;
    ZodUndefined.create = (params) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    var ZodNull = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.null,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        return (0, parseUtil_js_1.OK)(input.data);
      }
    };
    exports2.ZodNull = ZodNull;
    ZodNull.create = (params) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    var ZodAny = class extends ZodType {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return (0, parseUtil_js_1.OK)(input.data);
      }
    };
    exports2.ZodAny = ZodAny;
    ZodAny.create = (params) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    var ZodUnknown = class extends ZodType {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return (0, parseUtil_js_1.OK)(input.data);
      }
    };
    exports2.ZodUnknown = ZodUnknown;
    ZodUnknown.create = (params) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    var ZodNever = class extends ZodType {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.never,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
    };
    exports2.ZodNever = ZodNever;
    ZodNever.create = (params) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    var ZodVoid = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.void,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        return (0, parseUtil_js_1.OK)(input.data);
      }
    };
    exports2.ZodVoid = ZodVoid;
    ZodVoid.create = (params) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    var ZodArray = class _ZodArray extends ZodType {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== util_js_1.ZodParsedType.array) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.array,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: tooBig ? ZodError_js_1.ZodIssueCode.too_big : ZodError_js_1.ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          })).then((result2) => {
            return parseUtil_js_1.ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return parseUtil_js_1.ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil_js_1.errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil_js_1.errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil_js_1.errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    exports2.ZodArray = ZodArray;
    ZodArray.create = (schema, params) => {
      return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    function deepPartialify(schema) {
      if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
          const fieldSchema = schema.shape[key];
          newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
          ...schema._def,
          shape: () => newShape
        });
      } else if (schema instanceof ZodArray) {
        return new ZodArray({
          ...schema._def,
          type: deepPartialify(schema.element)
        });
      } else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
      } else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
      } else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
      } else {
        return schema;
      }
    }
    var ZodObject = class _ZodObject extends ZodType {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util_js_1.util.objectKeys(shape);
        this._cached = { shape, keys };
        return this._cached;
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx2, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.object,
            received: ctx2.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip") {
          } else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              syncPairs.push({
                key,
                value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return parseUtil_js_1.ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return parseUtil_js_1.ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil_js_1.errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: (issue, ctx) => {
              const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: errorUtil_js_1.errorUtil.errToObj(message).message ?? defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key, schema) {
        return this.augment({ [key]: schema });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index) {
        return new _ZodObject({
          ...this._def,
          catchall: index
        });
      }
      pick(mask) {
        const shape = {};
        for (const key of util_js_1.util.objectKeys(mask)) {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        for (const key of util_js_1.util.objectKeys(this.shape)) {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        for (const key of util_js_1.util.objectKeys(this.shape)) {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        for (const key of util_js_1.util.objectKeys(this.shape)) {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util_js_1.util.objectKeys(this.shape));
      }
    };
    exports2.ZodObject = ZodObject;
    ZodObject.create = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.strictCreate = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.lazycreate = (shape, params) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    var ZodUnion = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError_js_1.ZodError(result.ctx.common.issues));
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_union,
            unionErrors
          });
          return parseUtil_js_1.INVALID;
        }
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError_js_1.ZodError(issues2));
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_union,
            unionErrors
          });
          return parseUtil_js_1.INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    exports2.ZodUnion = ZodUnion;
    ZodUnion.create = (types, params) => {
      return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    var getDiscriminator = (type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return util_js_1.util.objectValues(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else if (type instanceof ZodOptional) {
        return [void 0, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
      } else {
        return [];
      }
    };
    var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.object) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.object,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return parseUtil_js_1.INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues.length) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    };
    exports2.ZodDiscriminatedUnion = ZodDiscriminatedUnion;
    function mergeValues(a, b) {
      const aType = (0, util_js_1.getParsedType)(a);
      const bType = (0, util_js_1.getParsedType)(b);
      if (a === b) {
        return { valid: true, data: a };
      } else if (aType === util_js_1.ZodParsedType.object && bType === util_js_1.ZodParsedType.object) {
        const bKeys = util_js_1.util.objectKeys(b);
        const sharedKeys = util_js_1.util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
          const sharedValue = mergeValues(a[key], b[key]);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
      } else if (aType === util_js_1.ZodParsedType.array && bType === util_js_1.ZodParsedType.array) {
        if (a.length !== b.length) {
          return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
          const itemA = a[index];
          const itemB = b[index];
          const sharedValue = mergeValues(itemA, itemB);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
      } else if (aType === util_js_1.ZodParsedType.date && bType === util_js_1.ZodParsedType.date && +a === +b) {
        return { valid: true, data: a };
      } else {
        return { valid: false };
      }
    }
    var ZodIntersection = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if ((0, parseUtil_js_1.isAborted)(parsedLeft) || (0, parseUtil_js_1.isAborted)(parsedRight)) {
            return parseUtil_js_1.INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.invalid_intersection_types
            });
            return parseUtil_js_1.INVALID;
          }
          if ((0, parseUtil_js_1.isDirty)(parsedLeft) || (0, parseUtil_js_1.isDirty)(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    exports2.ZodIntersection = ZodIntersection;
    ZodIntersection.create = (left, right, params) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    var ZodTuple = class _ZodTuple extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.array) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.array,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return parseUtil_js_1.INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return parseUtil_js_1.ParseStatus.mergeArray(status, results);
          });
        } else {
          return parseUtil_js_1.ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    exports2.ZodTuple = ZodTuple;
    ZodTuple.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    var ZodRecord = class _ZodRecord extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.object) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.object,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (ctx.common.async) {
          return parseUtil_js_1.ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return parseUtil_js_1.ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new _ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new _ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    exports2.ZodRecord = ZodRecord;
    var ZodMap = class extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.map) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.map,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return parseUtil_js_1.INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return parseUtil_js_1.INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    exports2.ZodMap = ZodMap;
    ZodMap.create = (keyType, valueType, params) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    var ZodSet = class _ZodSet extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.set) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.set,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return parseUtil_js_1.INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil_js_1.errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil_js_1.errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    exports2.ZodSet = ZodSet;
    ZodSet.create = (valueType, params) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    var ZodFunction = class _ZodFunction extends ZodType {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.function) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.function,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        function makeArgsIssue(args, error) {
          return (0, parseUtil_js_1.makeIssue)({
            data: args,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, (0, errors_js_1.getErrorMap)(), errors_js_1.defaultErrorMap].filter((x) => !!x),
            issueData: {
              code: ZodError_js_1.ZodIssueCode.invalid_arguments,
              argumentsError: error
            }
          });
        }
        function makeReturnsIssue(returns, error) {
          return (0, parseUtil_js_1.makeIssue)({
            data: returns,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, (0, errors_js_1.getErrorMap)(), errors_js_1.defaultErrorMap].filter((x) => !!x),
            issueData: {
              code: ZodError_js_1.ZodIssueCode.invalid_return_type,
              returnTypeError: error
            }
          });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          const me = this;
          return (0, parseUtil_js_1.OK)(async function(...args) {
            const error = new ZodError_js_1.ZodError([]);
            const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
              error.addIssue(makeArgsIssue(args, e));
              throw error;
            });
            const result = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
              error.addIssue(makeReturnsIssue(result, e));
              throw error;
            });
            return parsedReturns;
          });
        } else {
          const me = this;
          return (0, parseUtil_js_1.OK)(function(...args) {
            const parsedArgs = me._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError_js_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError_js_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new _ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    };
    exports2.ZodFunction = ZodFunction;
    var ZodLazy = class extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    exports2.ZodLazy = ZodLazy;
    ZodLazy.create = (getter, params) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    var ZodLiteral = class extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_js_1.ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return parseUtil_js_1.INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    exports2.ZodLiteral = ZodLiteral;
    ZodLiteral.create = (value, params) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    function createZodEnum(values, params) {
      return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params)
      });
    }
    var ZodEnum = class _ZodEnum extends ZodType {
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            expected: util_js_1.util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodError_js_1.ZodIssueCode.invalid_type
          });
          return parseUtil_js_1.INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(this._def.values);
        }
        if (!this._cache.has(input.data)) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_js_1.ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return parseUtil_js_1.INVALID;
        }
        return (0, parseUtil_js_1.OK)(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values, newDef = this._def) {
        return _ZodEnum.create(values, {
          ...this._def,
          ...newDef
        });
      }
      exclude(values, newDef = this._def) {
        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
          ...this._def,
          ...newDef
        });
      }
    };
    exports2.ZodEnum = ZodEnum;
    ZodEnum.create = createZodEnum;
    var ZodNativeEnum = class extends ZodType {
      _parse(input) {
        const nativeEnumValues = util_js_1.util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.string && ctx.parsedType !== util_js_1.ZodParsedType.number) {
          const expectedValues = util_js_1.util.objectValues(nativeEnumValues);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            expected: util_js_1.util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodError_js_1.ZodIssueCode.invalid_type
          });
          return parseUtil_js_1.INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(util_js_1.util.getValidEnumValues(this._def.values));
        }
        if (!this._cache.has(input.data)) {
          const expectedValues = util_js_1.util.objectValues(nativeEnumValues);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_js_1.ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return parseUtil_js_1.INVALID;
        }
        return (0, parseUtil_js_1.OK)(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    exports2.ZodNativeEnum = ZodNativeEnum;
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    var ZodPromise = class extends ZodType {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.promise && ctx.common.async === false) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.promise,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        const promisified = ctx.parsedType === util_js_1.ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return (0, parseUtil_js_1.OK)(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    exports2.ZodPromise = ZodPromise;
    ZodPromise.create = (schema, params) => {
      return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    var ZodEffects = class extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: (arg) => {
            (0, parseUtil_js_1.addIssueToContext)(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(processed).then(async (processed2) => {
              if (status.value === "aborted")
                return parseUtil_js_1.INVALID;
              const result = await this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
              if (result.status === "aborted")
                return parseUtil_js_1.INVALID;
              if (result.status === "dirty")
                return (0, parseUtil_js_1.DIRTY)(result.value);
              if (status.value === "dirty")
                return (0, parseUtil_js_1.DIRTY)(result.value);
              return result;
            });
          } else {
            if (status.value === "aborted")
              return parseUtil_js_1.INVALID;
            const result = this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return parseUtil_js_1.INVALID;
            if (result.status === "dirty")
              return (0, parseUtil_js_1.DIRTY)(result.value);
            if (status.value === "dirty")
              return (0, parseUtil_js_1.DIRTY)(result.value);
            return result;
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return parseUtil_js_1.INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return parseUtil_js_1.INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!(0, parseUtil_js_1.isValid)(base))
              return parseUtil_js_1.INVALID;
            const result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!(0, parseUtil_js_1.isValid)(base))
                return parseUtil_js_1.INVALID;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
                status: status.value,
                value: result
              }));
            });
          }
        }
        util_js_1.util.assertNever(effect);
      }
    };
    exports2.ZodEffects = ZodEffects;
    exports2.ZodTransformer = ZodEffects;
    ZodEffects.create = (schema, effect, params) => {
      return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
      return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    var ZodOptional = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_js_1.ZodParsedType.undefined) {
          return (0, parseUtil_js_1.OK)(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    exports2.ZodOptional = ZodOptional;
    ZodOptional.create = (type, params) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    var ZodNullable = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_js_1.ZodParsedType.null) {
          return (0, parseUtil_js_1.OK)(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    exports2.ZodNullable = ZodNullable;
    ZodNullable.create = (type, params) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    var ZodDefault = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === util_js_1.ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    exports2.ZodDefault = ZodDefault;
    ZodDefault.create = (type, params) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    var ZodCatch = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if ((0, parseUtil_js_1.isAsync)(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError_js_1.ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError_js_1.ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    exports2.ZodCatch = ZodCatch;
    ZodCatch.create = (type, params) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params)
      });
    };
    var ZodNaN = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.nan,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    exports2.ZodNaN = ZodNaN;
    ZodNaN.create = (params) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    exports2.BRAND = Symbol("zod_brand");
    var ZodBranded = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    exports2.ZodBranded = ZodBranded;
    var ZodPipeline = class _ZodPipeline extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return parseUtil_js_1.INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return (0, parseUtil_js_1.DIRTY)(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return parseUtil_js_1.INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b) {
        return new _ZodPipeline({
          in: a,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    exports2.ZodPipeline = ZodPipeline;
    var ZodReadonly = class extends ZodType {
      _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data) => {
          if ((0, parseUtil_js_1.isValid)(data)) {
            data.value = Object.freeze(data.value);
          }
          return data;
        };
        return (0, parseUtil_js_1.isAsync)(result) ? result.then((data) => freeze(data)) : freeze(result);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    exports2.ZodReadonly = ZodReadonly;
    ZodReadonly.create = (type, params) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
      });
    };
    function cleanParams(params, data) {
      const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
      const p2 = typeof p === "string" ? { message: p } : p;
      return p2;
    }
    function custom(check, _params = {}, fatal) {
      if (check)
        return ZodAny.create().superRefine((data, ctx) => {
          const r = check(data);
          if (r instanceof Promise) {
            return r.then((r2) => {
              if (!r2) {
                const params = cleanParams(_params, data);
                const _fatal = params.fatal ?? fatal ?? true;
                ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
              }
            });
          }
          if (!r) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
          return;
        });
      return ZodAny.create();
    }
    exports2.late = {
      object: ZodObject.lazycreate
    };
    var ZodFirstPartyTypeKind;
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (exports2.ZodFirstPartyTypeKind = ZodFirstPartyTypeKind = {}));
    var instanceOfType = (cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data) => data instanceof cls, params);
    exports2.instanceof = instanceOfType;
    var stringType = ZodString.create;
    exports2.string = stringType;
    var numberType = ZodNumber.create;
    exports2.number = numberType;
    var nanType = ZodNaN.create;
    exports2.nan = nanType;
    var bigIntType = ZodBigInt.create;
    exports2.bigint = bigIntType;
    var booleanType = ZodBoolean.create;
    exports2.boolean = booleanType;
    var dateType = ZodDate.create;
    exports2.date = dateType;
    var symbolType = ZodSymbol.create;
    exports2.symbol = symbolType;
    var undefinedType = ZodUndefined.create;
    exports2.undefined = undefinedType;
    var nullType = ZodNull.create;
    exports2.null = nullType;
    var anyType = ZodAny.create;
    exports2.any = anyType;
    var unknownType = ZodUnknown.create;
    exports2.unknown = unknownType;
    var neverType = ZodNever.create;
    exports2.never = neverType;
    var voidType = ZodVoid.create;
    exports2.void = voidType;
    var arrayType = ZodArray.create;
    exports2.array = arrayType;
    var objectType = ZodObject.create;
    exports2.object = objectType;
    var strictObjectType = ZodObject.strictCreate;
    exports2.strictObject = strictObjectType;
    var unionType = ZodUnion.create;
    exports2.union = unionType;
    var discriminatedUnionType = ZodDiscriminatedUnion.create;
    exports2.discriminatedUnion = discriminatedUnionType;
    var intersectionType = ZodIntersection.create;
    exports2.intersection = intersectionType;
    var tupleType = ZodTuple.create;
    exports2.tuple = tupleType;
    var recordType = ZodRecord.create;
    exports2.record = recordType;
    var mapType = ZodMap.create;
    exports2.map = mapType;
    var setType = ZodSet.create;
    exports2.set = setType;
    var functionType = ZodFunction.create;
    exports2.function = functionType;
    var lazyType = ZodLazy.create;
    exports2.lazy = lazyType;
    var literalType = ZodLiteral.create;
    exports2.literal = literalType;
    var enumType = ZodEnum.create;
    exports2.enum = enumType;
    var nativeEnumType = ZodNativeEnum.create;
    exports2.nativeEnum = nativeEnumType;
    var promiseType = ZodPromise.create;
    exports2.promise = promiseType;
    var effectsType = ZodEffects.create;
    exports2.effect = effectsType;
    exports2.transformer = effectsType;
    var optionalType = ZodOptional.create;
    exports2.optional = optionalType;
    var nullableType = ZodNullable.create;
    exports2.nullable = nullableType;
    var preprocessType = ZodEffects.createWithPreprocess;
    exports2.preprocess = preprocessType;
    var pipelineType = ZodPipeline.create;
    exports2.pipeline = pipelineType;
    var ostring = () => stringType().optional();
    exports2.ostring = ostring;
    var onumber = () => numberType().optional();
    exports2.onumber = onumber;
    var oboolean = () => booleanType().optional();
    exports2.oboolean = oboolean;
    exports2.coerce = {
      string: ((arg) => ZodString.create({ ...arg, coerce: true })),
      number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
      boolean: ((arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      })),
      bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
      date: ((arg) => ZodDate.create({ ...arg, coerce: true }))
    };
    exports2.NEVER = parseUtil_js_1.INVALID;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v3/external.cjs
var require_external = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v3/external.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_errors(), exports2);
    __exportStar(require_parseUtil(), exports2);
    __exportStar(require_typeAliases(), exports2);
    __exportStar(require_util(), exports2);
    __exportStar(require_types(), exports2);
    __exportStar(require_ZodError(), exports2);
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v3/index.cjs
var require_v3 = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v3/index.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.z = void 0;
    var z = __importStar(require_external());
    exports2.z = z;
    __exportStar(require_external(), exports2);
    exports2.default = z;
  }
});

// node_modules/.pnpm/@langchain+mcp-adapters@1.0_422fcda27cc657832245d1643c939873/node_modules/@langchain/mcp-adapters/dist/hooks.cjs
var require_hooks = __commonJS({
  "node_modules/.pnpm/@langchain+mcp-adapters@1.0_422fcda27cc657832245d1643c939873/node_modules/@langchain/mcp-adapters/dist/hooks.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime();
    var zod_v3 = require_rolldown_runtime5.__toESM(require_v3());
    var toolCallRequestSchema = zod_v3.z.object({
      serverName: zod_v3.z.string(),
      name: zod_v3.z.string(),
      args: zod_v3.z.unknown()
    });
    var toolResultBeforeSchema = zod_v3.z.tuple([zod_v3.z.custom(), zod_v3.z.array(zod_v3.z.union([zod_v3.z.custom(), zod_v3.z.custom()]))]);
    var toolResultSchema = zod_v3.z.union([
      zod_v3.z.string(),
      zod_v3.z.custom(),
      toolResultBeforeSchema,
      zod_v3.z.custom()
    ]);
    var toolCallResultSchema = zod_v3.z.object({
      ...toolCallRequestSchema.shape,
      result: toolResultBeforeSchema
    });
    var modifiedToolCallResultSchema = zod_v3.z.object({
      ...toolCallRequestSchema.shape,
      result: toolResultSchema
    });
    var toolCallModificationSchema = zod_v3.z.object({
      headers: zod_v3.z.record(zod_v3.z.string()),
      args: zod_v3.z.unknown()
    }).partial();
    var toolHooksSchema = zod_v3.z.object({
      beforeToolCall: zod_v3.z.function().args(toolCallRequestSchema, zod_v3.z.custom(), zod_v3.z.custom()).returns(zod_v3.z.union([
        zod_v3.z.promise(toolCallModificationSchema),
        toolCallModificationSchema,
        zod_v3.z.void(),
        zod_v3.z.promise(zod_v3.z.void())
      ])).optional(),
      afterToolCall: zod_v3.z.function().args(toolCallResultSchema, zod_v3.z.custom(), zod_v3.z.custom()).returns(zod_v3.z.union([
        zod_v3.z.promise(modifiedToolCallResultSchema.pick({ result: true })),
        modifiedToolCallResultSchema.pick({ result: true }),
        zod_v3.z.void(),
        zod_v3.z.promise(zod_v3.z.void())
      ])).optional()
    });
    exports2.toolHooksSchema = toolHooksSchema;
  }
});

// node_modules/.pnpm/@langchain+mcp-adapters@1.0_422fcda27cc657832245d1643c939873/node_modules/@langchain/mcp-adapters/dist/types.cjs
var require_types2 = __commonJS({
  "node_modules/.pnpm/@langchain+mcp-adapters@1.0_422fcda27cc657832245d1643c939873/node_modules/@langchain/mcp-adapters/dist/types.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime();
    var require_hooks2 = require_hooks();
    var zod_v3 = require_rolldown_runtime5.__toESM(require_v3());
    var callToolResultContentTypes = [
      "audio",
      "image",
      "resource",
      "resource_link",
      "text"
    ];
    var LoggingLevelSchema = zod_v3.z.enum([
      "debug",
      "info",
      "notice",
      "warning",
      "error",
      "critical",
      "alert",
      "emergency"
    ]);
    var RequestIdSchema = zod_v3.z.union([zod_v3.z.string(), zod_v3.z.number().int()]);
    var outputTypesUnion = zod_v3.z.union([zod_v3.z.literal("content").describe("Put tool output into the ToolMessage.content array"), zod_v3.z.literal("artifact").describe("Put tool output into the ToolMessage.artifact array")]);
    var detailedOutputHandlingSchema = zod_v3.z.object(Object.fromEntries(callToolResultContentTypes.map((contentType) => [contentType, zod_v3.z.union([zod_v3.z.literal("content").describe(`Put all ${contentType} tool output into the ToolMessage.content array`), zod_v3.z.literal("artifact").describe(`Put all ${contentType} tool output into the ToolMessage.artifact array`)]).describe(`Where to place ${contentType} tool output in the LangChain ToolMessage`).optional()])));
    var outputHandlingSchema = zod_v3.z.union([outputTypesUnion, detailedOutputHandlingSchema]).describe("Defines where to place each tool output type in the LangChain ToolMessage.\n\nItems in the `content` field will be used as input context for the LLM, while the artifact field is\nused for capturing tool output that won't be shown to the model, to be used in some later workflow\nstep.\n\nFor example, imagine that you have a SQL query tool that can return huge result sets. Rather than\nsending these large outputs directly to the model, perhaps you want the model to be able to inspect\nthe output in a code execution environment. In this case, you would set the output handling for the\n`resource` type to `artifact` (it's default value), and then upon initialization of your code\nexecution environment, you would look through your message history for `ToolMessage`s with the\n`artifact` field set to `resource`, and use the `content` field during initialization of the\nenvironment.");
    var oAuthClientProviderSchema = zod_v3.z.custom((val) => {
      if (!val || typeof val !== "object") return false;
      const requiredMethods = [
        "redirectUrl",
        "clientMetadata",
        "clientInformation",
        "tokens",
        "saveTokens"
      ];
      if (!("redirectUrl" in val)) return false;
      if (!("clientMetadata" in val)) return false;
      for (const method of requiredMethods) if (!(method in val)) return false;
      return true;
    }, { message: "Must be a valid OAuthClientProvider implementation with required properties: redirectUrl, clientMetadata, clientInformation, tokens, saveTokens" });
    var baseConfigSchema = zod_v3.z.object({
      outputHandling: outputHandlingSchema.optional(),
      defaultToolTimeout: zod_v3.z.number().min(1).optional()
    });
    var stdioRestartSchema = zod_v3.z.object({
      enabled: zod_v3.z.boolean().describe("Whether to automatically restart the process if it exits").optional(),
      maxAttempts: zod_v3.z.number().describe("The maximum number of restart attempts").optional(),
      delayMs: zod_v3.z.number().describe("The delay in milliseconds between restart attempts").optional()
    }).describe("Configuration for stdio transport restart");
    var stdioConnectionSchema = zod_v3.z.object({
      transport: zod_v3.z.literal("stdio").optional(),
      type: zod_v3.z.literal("stdio").optional(),
      command: zod_v3.z.string().describe("The executable to run the server"),
      args: zod_v3.z.array(zod_v3.z.string()).describe("Command line arguments to pass to the executable"),
      env: zod_v3.z.record(zod_v3.z.string()).describe("The environment to use when spawning the process").optional(),
      encoding: zod_v3.z.string().describe("The encoding to use when reading from the process").optional(),
      stderr: zod_v3.z.union([
        zod_v3.z.literal("overlapped"),
        zod_v3.z.literal("pipe"),
        zod_v3.z.literal("ignore"),
        zod_v3.z.literal("inherit")
      ]).describe("How to handle stderr of the child process. This matches the semantics of Node's `child_process.spawn`").optional().default("inherit"),
      cwd: zod_v3.z.string().describe("The working directory to use when spawning the process").optional(),
      restart: stdioRestartSchema.optional()
    }).and(baseConfigSchema).describe("Configuration for stdio transport connection");
    var streamableHttpReconnectSchema = zod_v3.z.object({
      enabled: zod_v3.z.boolean().describe("Whether to automatically reconnect if the connection is lost").optional(),
      maxAttempts: zod_v3.z.number().describe("The maximum number of reconnection attempts").optional(),
      delayMs: zod_v3.z.number().describe("The delay in milliseconds between reconnection attempts").optional()
    }).describe("Configuration for streamable HTTP transport reconnection");
    var streamableHttpConnectionSchema = zod_v3.z.object({
      transport: zod_v3.z.union([zod_v3.z.literal("http"), zod_v3.z.literal("sse")]).optional(),
      type: zod_v3.z.union([zod_v3.z.literal("http"), zod_v3.z.literal("sse")]).optional(),
      url: zod_v3.z.string().url(),
      headers: zod_v3.z.record(zod_v3.z.string()).optional(),
      authProvider: oAuthClientProviderSchema.optional(),
      reconnect: streamableHttpReconnectSchema.optional(),
      automaticSSEFallback: zod_v3.z.boolean().optional().default(true)
    }).and(baseConfigSchema).describe("Configuration for streamable HTTP transport connection");
    var connectionSchema = zod_v3.z.union([stdioConnectionSchema, streamableHttpConnectionSchema]).describe("Configuration for a single MCP server");
    var toolSourceSchema = zod_v3.z.object({
      type: zod_v3.z.literal("tool"),
      name: zod_v3.z.string(),
      args: zod_v3.z.unknown(),
      server: zod_v3.z.string()
    });
    var unknownSourceSchema = zod_v3.z.object({ type: zod_v3.z.literal("unknown") });
    var eventContextSchema = zod_v3.z.union([toolSourceSchema, unknownSourceSchema]);
    var serverMessageSourceSchema = zod_v3.z.object({
      server: zod_v3.z.string(),
      options: connectionSchema
    });
    var notifications = zod_v3.z.object({
      onMessage: zod_v3.z.function().args(zod_v3.z.object({
        level: LoggingLevelSchema,
        logger: zod_v3.z.optional(zod_v3.z.string()),
        data: zod_v3.z.unknown()
      }), serverMessageSourceSchema).returns(zod_v3.z.union([zod_v3.z.void(), zod_v3.z.promise(zod_v3.z.void())])).optional(),
      onProgress: zod_v3.z.function().args(zod_v3.z.object({
        progress: zod_v3.z.number(),
        total: zod_v3.z.optional(zod_v3.z.number()),
        message: zod_v3.z.optional(zod_v3.z.string())
      }), eventContextSchema).returns(zod_v3.z.union([zod_v3.z.void(), zod_v3.z.promise(zod_v3.z.void())])).optional(),
      onCancelled: zod_v3.z.function().args(zod_v3.z.object({
        requestId: RequestIdSchema,
        reason: zod_v3.z.string().optional()
      }), serverMessageSourceSchema).returns(zod_v3.z.union([zod_v3.z.void(), zod_v3.z.promise(zod_v3.z.void())])).optional(),
      onInitialized: zod_v3.z.function().args(serverMessageSourceSchema).returns(zod_v3.z.union([zod_v3.z.void(), zod_v3.z.promise(zod_v3.z.void())])).optional(),
      onPromptsListChanged: zod_v3.z.function().args(serverMessageSourceSchema).returns(zod_v3.z.union([zod_v3.z.void(), zod_v3.z.promise(zod_v3.z.void())])).optional(),
      onResourcesListChanged: zod_v3.z.function().args(serverMessageSourceSchema).returns(zod_v3.z.union([zod_v3.z.void(), zod_v3.z.promise(zod_v3.z.void())])).optional(),
      onResourcesUpdated: zod_v3.z.function().args(zod_v3.z.object({ uri: zod_v3.z.string() }), serverMessageSourceSchema).returns(zod_v3.z.union([zod_v3.z.void(), zod_v3.z.promise(zod_v3.z.void())])).optional(),
      onRootsListChanged: zod_v3.z.function().args(serverMessageSourceSchema).returns(zod_v3.z.union([zod_v3.z.void(), zod_v3.z.promise(zod_v3.z.void())])).optional(),
      onToolsListChanged: zod_v3.z.function().args(serverMessageSourceSchema).returns(zod_v3.z.union([zod_v3.z.void(), zod_v3.z.promise(zod_v3.z.void())])).optional()
    });
    var clientConfigSchema = zod_v3.z.object({
      mcpServers: zod_v3.z.record(connectionSchema).describe("A map of server names to their configuration"),
      throwOnLoadError: zod_v3.z.boolean().describe("Whether to throw an error if a tool fails to load").optional().default(true),
      prefixToolNameWithServerName: zod_v3.z.boolean().describe("Whether to prefix tool names with the server name").optional().default(false),
      additionalToolNamePrefix: zod_v3.z.string().describe("An additional prefix to add to the tool name").optional().default(""),
      useStandardContentBlocks: zod_v3.z.boolean().describe("If true, the tool will use LangChain's standard multimodal content blocks for tools that output\nimage or audio content. When true, embedded resources will be converted to `StandardFileBlock`\nobjects. When `false`, all artifacts are left in their MCP format, but embedded resources will\nbe converted to `StandardFileBlock` objects if `outputHandling` causes embedded resources to be\ntreated as content, as otherwise ChatModel providers will not be able to interpret them.").optional().default(false)
    }).and(baseConfigSchema).and(require_hooks2.toolHooksSchema).and(notifications).describe("Configuration for the MCP client");
    function _resolveDetailedOutputHandling(outputHandling, applyDefaults = false) {
      if (outputHandling == null) return {};
      if (typeof outputHandling === "string") return Object.fromEntries(callToolResultContentTypes.map((contentType) => [contentType, outputHandling]));
      const resolved = {};
      for (const contentType of callToolResultContentTypes) if (outputHandling[contentType] || applyDefaults) resolved[contentType] = outputHandling[contentType] ?? (contentType === "resource" ? "artifact" : "content");
      return resolved;
    }
    function _resolveAndApplyOverrideHandlingOverrides(base, override) {
      const expandedBase = _resolveDetailedOutputHandling(base);
      const expandedOverride = _resolveDetailedOutputHandling(override);
      return {
        ...expandedBase,
        ...expandedOverride
      };
    }
    exports2._resolveAndApplyOverrideHandlingOverrides = _resolveAndApplyOverrideHandlingOverrides;
    exports2._resolveDetailedOutputHandling = _resolveDetailedOutputHandling;
    exports2.clientConfigSchema = clientConfigSchema;
    exports2.connectionSchema = connectionSchema;
  }
});

// node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug") || exports2.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/.pnpm/@langchain+mcp-adapters@1.0_422fcda27cc657832245d1643c939873/node_modules/@langchain/mcp-adapters/dist/logging.cjs
var require_logging = __commonJS({
  "node_modules/.pnpm/@langchain+mcp-adapters@1.0_422fcda27cc657832245d1643c939873/node_modules/@langchain/mcp-adapters/dist/logging.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime();
    var debug = require_rolldown_runtime5.__toESM(require_src());
    var packageName = "@langchain/mcp-adapters";
    var debugLog = {};
    function getDebugLog(instanceName = "client") {
      const key = `${packageName}:${instanceName}`;
      if (!debugLog[key]) debugLog[key] = (0, debug.default)(key);
      return debugLog[key];
    }
    exports2.getDebugLog = getDebugLog;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/core.cjs
var require_core = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/core.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.globalConfig = exports2.$ZodEncodeError = exports2.$ZodAsyncError = exports2.$brand = exports2.NEVER = void 0;
    exports2.$constructor = $constructor;
    exports2.config = config;
    exports2.NEVER = Object.freeze({
      status: "aborted"
    });
    function $constructor(name, initializer, params) {
      function init(inst, def) {
        var _a;
        Object.defineProperty(inst, "_zod", {
          value: inst._zod ?? {},
          enumerable: false
        });
        (_a = inst._zod).traits ?? (_a.traits = /* @__PURE__ */ new Set());
        inst._zod.traits.add(name);
        initializer(inst, def);
        for (const k in _.prototype) {
          if (!(k in inst))
            Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
        }
        inst._zod.constr = _;
        inst._zod.def = def;
      }
      const Parent = params?.Parent ?? Object;
      class Definition extends Parent {
      }
      Object.defineProperty(Definition, "name", { value: name });
      function _(def) {
        var _a;
        const inst = params?.Parent ? new Definition() : this;
        init(inst, def);
        (_a = inst._zod).deferred ?? (_a.deferred = []);
        for (const fn of inst._zod.deferred) {
          fn();
        }
        return inst;
      }
      Object.defineProperty(_, "init", { value: init });
      Object.defineProperty(_, Symbol.hasInstance, {
        value: (inst) => {
          if (params?.Parent && inst instanceof params.Parent)
            return true;
          return inst?._zod?.traits?.has(name);
        }
      });
      Object.defineProperty(_, "name", { value: name });
      return _;
    }
    exports2.$brand = Symbol("zod_brand");
    var $ZodAsyncError = class extends Error {
      constructor() {
        super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
      }
    };
    exports2.$ZodAsyncError = $ZodAsyncError;
    var $ZodEncodeError = class extends Error {
      constructor(name) {
        super(`Encountered unidirectional transform during encode: ${name}`);
        this.name = "ZodEncodeError";
      }
    };
    exports2.$ZodEncodeError = $ZodEncodeError;
    exports2.globalConfig = {};
    function config(newConfig) {
      if (newConfig)
        Object.assign(exports2.globalConfig, newConfig);
      return exports2.globalConfig;
    }
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/util.cjs
var require_util2 = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/util.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Class = exports2.BIGINT_FORMAT_RANGES = exports2.NUMBER_FORMAT_RANGES = exports2.primitiveTypes = exports2.propertyKeyTypes = exports2.getParsedType = exports2.allowsEval = exports2.captureStackTrace = void 0;
    exports2.assertEqual = assertEqual;
    exports2.assertNotEqual = assertNotEqual;
    exports2.assertIs = assertIs;
    exports2.assertNever = assertNever;
    exports2.assert = assert;
    exports2.getEnumValues = getEnumValues;
    exports2.joinValues = joinValues;
    exports2.jsonStringifyReplacer = jsonStringifyReplacer;
    exports2.cached = cached;
    exports2.nullish = nullish;
    exports2.cleanRegex = cleanRegex;
    exports2.floatSafeRemainder = floatSafeRemainder;
    exports2.defineLazy = defineLazy;
    exports2.objectClone = objectClone;
    exports2.assignProp = assignProp;
    exports2.mergeDefs = mergeDefs;
    exports2.cloneDef = cloneDef;
    exports2.getElementAtPath = getElementAtPath;
    exports2.promiseAllObject = promiseAllObject;
    exports2.randomString = randomString;
    exports2.esc = esc;
    exports2.isObject = isObject;
    exports2.isPlainObject = isPlainObject;
    exports2.shallowClone = shallowClone;
    exports2.numKeys = numKeys;
    exports2.escapeRegex = escapeRegex;
    exports2.clone = clone;
    exports2.normalizeParams = normalizeParams;
    exports2.createTransparentProxy = createTransparentProxy;
    exports2.stringifyPrimitive = stringifyPrimitive;
    exports2.optionalKeys = optionalKeys;
    exports2.pick = pick;
    exports2.omit = omit;
    exports2.extend = extend;
    exports2.safeExtend = safeExtend;
    exports2.merge = merge;
    exports2.partial = partial;
    exports2.required = required;
    exports2.aborted = aborted;
    exports2.prefixIssues = prefixIssues;
    exports2.unwrapMessage = unwrapMessage;
    exports2.finalizeIssue = finalizeIssue;
    exports2.getSizableOrigin = getSizableOrigin;
    exports2.getLengthableOrigin = getLengthableOrigin;
    exports2.issue = issue;
    exports2.cleanEnum = cleanEnum;
    exports2.base64ToUint8Array = base64ToUint8Array;
    exports2.uint8ArrayToBase64 = uint8ArrayToBase64;
    exports2.base64urlToUint8Array = base64urlToUint8Array;
    exports2.uint8ArrayToBase64url = uint8ArrayToBase64url;
    exports2.hexToUint8Array = hexToUint8Array;
    exports2.uint8ArrayToHex = uint8ArrayToHex;
    function assertEqual(val) {
      return val;
    }
    function assertNotEqual(val) {
      return val;
    }
    function assertIs(_arg) {
    }
    function assertNever(_x) {
      throw new Error();
    }
    function assert(_) {
    }
    function getEnumValues(entries) {
      const numericValues = Object.values(entries).filter((v) => typeof v === "number");
      const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
      return values;
    }
    function joinValues(array, separator = "|") {
      return array.map((val) => stringifyPrimitive(val)).join(separator);
    }
    function jsonStringifyReplacer(_, value) {
      if (typeof value === "bigint")
        return value.toString();
      return value;
    }
    function cached(getter) {
      const set = false;
      return {
        get value() {
          if (!set) {
            const value = getter();
            Object.defineProperty(this, "value", { value });
            return value;
          }
          throw new Error("cached value already set");
        }
      };
    }
    function nullish(input) {
      return input === null || input === void 0;
    }
    function cleanRegex(source) {
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      return source.slice(start, end);
    }
    function floatSafeRemainder(val, step) {
      const valDecCount = (val.toString().split(".")[1] || "").length;
      const stepString = step.toString();
      let stepDecCount = (stepString.split(".")[1] || "").length;
      if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
        const match = stepString.match(/\d?e-(\d?)/);
        if (match?.[1]) {
          stepDecCount = Number.parseInt(match[1]);
        }
      }
      const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
      const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
      const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
      return valInt % stepInt / 10 ** decCount;
    }
    var EVALUATING = Symbol("evaluating");
    function defineLazy(object, key, getter) {
      let value = void 0;
      Object.defineProperty(object, key, {
        get() {
          if (value === EVALUATING) {
            return void 0;
          }
          if (value === void 0) {
            value = EVALUATING;
            value = getter();
          }
          return value;
        },
        set(v) {
          Object.defineProperty(object, key, {
            value: v
            // configurable: true,
          });
        },
        configurable: true
      });
    }
    function objectClone(obj) {
      return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
    }
    function assignProp(target, prop, value) {
      Object.defineProperty(target, prop, {
        value,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
    function mergeDefs(...defs) {
      const mergedDescriptors = {};
      for (const def of defs) {
        const descriptors = Object.getOwnPropertyDescriptors(def);
        Object.assign(mergedDescriptors, descriptors);
      }
      return Object.defineProperties({}, mergedDescriptors);
    }
    function cloneDef(schema) {
      return mergeDefs(schema._zod.def);
    }
    function getElementAtPath(obj, path) {
      if (!path)
        return obj;
      return path.reduce((acc, key) => acc?.[key], obj);
    }
    function promiseAllObject(promisesObj) {
      const keys = Object.keys(promisesObj);
      const promises = keys.map((key) => promisesObj[key]);
      return Promise.all(promises).then((results) => {
        const resolvedObj = {};
        for (let i = 0; i < keys.length; i++) {
          resolvedObj[keys[i]] = results[i];
        }
        return resolvedObj;
      });
    }
    function randomString(length = 10) {
      const chars = "abcdefghijklmnopqrstuvwxyz";
      let str = "";
      for (let i = 0; i < length; i++) {
        str += chars[Math.floor(Math.random() * chars.length)];
      }
      return str;
    }
    function esc(str) {
      return JSON.stringify(str);
    }
    exports2.captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
    };
    function isObject(data) {
      return typeof data === "object" && data !== null && !Array.isArray(data);
    }
    exports2.allowsEval = cached(() => {
      if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
        return false;
      }
      try {
        const F = Function;
        new F("");
        return true;
      } catch (_) {
        return false;
      }
    });
    function isPlainObject(o) {
      if (isObject(o) === false)
        return false;
      const ctor = o.constructor;
      if (ctor === void 0)
        return true;
      const prot = ctor.prototype;
      if (isObject(prot) === false)
        return false;
      if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
        return false;
      }
      return true;
    }
    function shallowClone(o) {
      if (isPlainObject(o))
        return { ...o };
      if (Array.isArray(o))
        return [...o];
      return o;
    }
    function numKeys(data) {
      let keyCount = 0;
      for (const key in data) {
        if (Object.prototype.hasOwnProperty.call(data, key)) {
          keyCount++;
        }
      }
      return keyCount;
    }
    var getParsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return "undefined";
        case "string":
          return "string";
        case "number":
          return Number.isNaN(data) ? "nan" : "number";
        case "boolean":
          return "boolean";
        case "function":
          return "function";
        case "bigint":
          return "bigint";
        case "symbol":
          return "symbol";
        case "object":
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return "promise";
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return "map";
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return "set";
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return "date";
          }
          if (typeof File !== "undefined" && data instanceof File) {
            return "file";
          }
          return "object";
        default:
          throw new Error(`Unknown data type: ${t}`);
      }
    };
    exports2.getParsedType = getParsedType;
    exports2.propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
    exports2.primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
    function escapeRegex(str) {
      return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function clone(inst, def, params) {
      const cl = new inst._zod.constr(def ?? inst._zod.def);
      if (!def || params?.parent)
        cl._zod.parent = inst;
      return cl;
    }
    function normalizeParams(_params) {
      const params = _params;
      if (!params)
        return {};
      if (typeof params === "string")
        return { error: () => params };
      if (params?.message !== void 0) {
        if (params?.error !== void 0)
          throw new Error("Cannot specify both `message` and `error` params");
        params.error = params.message;
      }
      delete params.message;
      if (typeof params.error === "string")
        return { ...params, error: () => params.error };
      return params;
    }
    function createTransparentProxy(getter) {
      let target;
      return new Proxy({}, {
        get(_, prop, receiver) {
          target ?? (target = getter());
          return Reflect.get(target, prop, receiver);
        },
        set(_, prop, value, receiver) {
          target ?? (target = getter());
          return Reflect.set(target, prop, value, receiver);
        },
        has(_, prop) {
          target ?? (target = getter());
          return Reflect.has(target, prop);
        },
        deleteProperty(_, prop) {
          target ?? (target = getter());
          return Reflect.deleteProperty(target, prop);
        },
        ownKeys(_) {
          target ?? (target = getter());
          return Reflect.ownKeys(target);
        },
        getOwnPropertyDescriptor(_, prop) {
          target ?? (target = getter());
          return Reflect.getOwnPropertyDescriptor(target, prop);
        },
        defineProperty(_, prop, descriptor) {
          target ?? (target = getter());
          return Reflect.defineProperty(target, prop, descriptor);
        }
      });
    }
    function stringifyPrimitive(value) {
      if (typeof value === "bigint")
        return value.toString() + "n";
      if (typeof value === "string")
        return `"${value}"`;
      return `${value}`;
    }
    function optionalKeys(shape) {
      return Object.keys(shape).filter((k) => {
        return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
      });
    }
    exports2.NUMBER_FORMAT_RANGES = {
      safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
      int32: [-2147483648, 2147483647],
      uint32: [0, 4294967295],
      float32: [-34028234663852886e22, 34028234663852886e22],
      float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
    };
    exports2.BIGINT_FORMAT_RANGES = {
      int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
      uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
    };
    function pick(schema, mask) {
      const currDef = schema._zod.def;
      const def = mergeDefs(schema._zod.def, {
        get shape() {
          const newShape = {};
          for (const key in mask) {
            if (!(key in currDef.shape)) {
              throw new Error(`Unrecognized key: "${key}"`);
            }
            if (!mask[key])
              continue;
            newShape[key] = currDef.shape[key];
          }
          assignProp(this, "shape", newShape);
          return newShape;
        },
        checks: []
      });
      return clone(schema, def);
    }
    function omit(schema, mask) {
      const currDef = schema._zod.def;
      const def = mergeDefs(schema._zod.def, {
        get shape() {
          const newShape = { ...schema._zod.def.shape };
          for (const key in mask) {
            if (!(key in currDef.shape)) {
              throw new Error(`Unrecognized key: "${key}"`);
            }
            if (!mask[key])
              continue;
            delete newShape[key];
          }
          assignProp(this, "shape", newShape);
          return newShape;
        },
        checks: []
      });
      return clone(schema, def);
    }
    function extend(schema, shape) {
      if (!isPlainObject(shape)) {
        throw new Error("Invalid input to extend: expected a plain object");
      }
      const checks = schema._zod.def.checks;
      const hasChecks = checks && checks.length > 0;
      if (hasChecks) {
        throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
      }
      const def = mergeDefs(schema._zod.def, {
        get shape() {
          const _shape = { ...schema._zod.def.shape, ...shape };
          assignProp(this, "shape", _shape);
          return _shape;
        },
        checks: []
      });
      return clone(schema, def);
    }
    function safeExtend(schema, shape) {
      if (!isPlainObject(shape)) {
        throw new Error("Invalid input to safeExtend: expected a plain object");
      }
      const def = {
        ...schema._zod.def,
        get shape() {
          const _shape = { ...schema._zod.def.shape, ...shape };
          assignProp(this, "shape", _shape);
          return _shape;
        },
        checks: schema._zod.def.checks
      };
      return clone(schema, def);
    }
    function merge(a, b) {
      const def = mergeDefs(a._zod.def, {
        get shape() {
          const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
          assignProp(this, "shape", _shape);
          return _shape;
        },
        get catchall() {
          return b._zod.def.catchall;
        },
        checks: []
        // delete existing checks
      });
      return clone(a, def);
    }
    function partial(Class2, schema, mask) {
      const def = mergeDefs(schema._zod.def, {
        get shape() {
          const oldShape = schema._zod.def.shape;
          const shape = { ...oldShape };
          if (mask) {
            for (const key in mask) {
              if (!(key in oldShape)) {
                throw new Error(`Unrecognized key: "${key}"`);
              }
              if (!mask[key])
                continue;
              shape[key] = Class2 ? new Class2({
                type: "optional",
                innerType: oldShape[key]
              }) : oldShape[key];
            }
          } else {
            for (const key in oldShape) {
              shape[key] = Class2 ? new Class2({
                type: "optional",
                innerType: oldShape[key]
              }) : oldShape[key];
            }
          }
          assignProp(this, "shape", shape);
          return shape;
        },
        checks: []
      });
      return clone(schema, def);
    }
    function required(Class2, schema, mask) {
      const def = mergeDefs(schema._zod.def, {
        get shape() {
          const oldShape = schema._zod.def.shape;
          const shape = { ...oldShape };
          if (mask) {
            for (const key in mask) {
              if (!(key in shape)) {
                throw new Error(`Unrecognized key: "${key}"`);
              }
              if (!mask[key])
                continue;
              shape[key] = new Class2({
                type: "nonoptional",
                innerType: oldShape[key]
              });
            }
          } else {
            for (const key in oldShape) {
              shape[key] = new Class2({
                type: "nonoptional",
                innerType: oldShape[key]
              });
            }
          }
          assignProp(this, "shape", shape);
          return shape;
        },
        checks: []
      });
      return clone(schema, def);
    }
    function aborted(x, startIndex = 0) {
      if (x.aborted === true)
        return true;
      for (let i = startIndex; i < x.issues.length; i++) {
        if (x.issues[i]?.continue !== true) {
          return true;
        }
      }
      return false;
    }
    function prefixIssues(path, issues) {
      return issues.map((iss) => {
        var _a;
        (_a = iss).path ?? (_a.path = []);
        iss.path.unshift(path);
        return iss;
      });
    }
    function unwrapMessage(message) {
      return typeof message === "string" ? message : message?.message;
    }
    function finalizeIssue(iss, ctx, config) {
      const full = { ...iss, path: iss.path ?? [] };
      if (!iss.message) {
        const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config.customError?.(iss)) ?? unwrapMessage(config.localeError?.(iss)) ?? "Invalid input";
        full.message = message;
      }
      delete full.inst;
      delete full.continue;
      if (!ctx?.reportInput) {
        delete full.input;
      }
      return full;
    }
    function getSizableOrigin(input) {
      if (input instanceof Set)
        return "set";
      if (input instanceof Map)
        return "map";
      if (input instanceof File)
        return "file";
      return "unknown";
    }
    function getLengthableOrigin(input) {
      if (Array.isArray(input))
        return "array";
      if (typeof input === "string")
        return "string";
      return "unknown";
    }
    function issue(...args) {
      const [iss, input, inst] = args;
      if (typeof iss === "string") {
        return {
          message: iss,
          code: "custom",
          input,
          inst
        };
      }
      return { ...iss };
    }
    function cleanEnum(obj) {
      return Object.entries(obj).filter(([k, _]) => {
        return Number.isNaN(Number.parseInt(k, 10));
      }).map((el) => el[1]);
    }
    function base64ToUint8Array(base64) {
      const binaryString = atob(base64);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes;
    }
    function uint8ArrayToBase64(bytes) {
      let binaryString = "";
      for (let i = 0; i < bytes.length; i++) {
        binaryString += String.fromCharCode(bytes[i]);
      }
      return btoa(binaryString);
    }
    function base64urlToUint8Array(base64url) {
      const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
      const padding = "=".repeat((4 - base64.length % 4) % 4);
      return base64ToUint8Array(base64 + padding);
    }
    function uint8ArrayToBase64url(bytes) {
      return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
    }
    function hexToUint8Array(hex) {
      const cleanHex = hex.replace(/^0x/, "");
      if (cleanHex.length % 2 !== 0) {
        throw new Error("Invalid hex string length");
      }
      const bytes = new Uint8Array(cleanHex.length / 2);
      for (let i = 0; i < cleanHex.length; i += 2) {
        bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
      }
      return bytes;
    }
    function uint8ArrayToHex(bytes) {
      return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
    var Class = class {
      constructor(..._args) {
      }
    };
    exports2.Class = Class;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/errors.cjs
var require_errors2 = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/errors.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.$ZodRealError = exports2.$ZodError = void 0;
    exports2.flattenError = flattenError;
    exports2.formatError = formatError;
    exports2.treeifyError = treeifyError;
    exports2.toDotPath = toDotPath;
    exports2.prettifyError = prettifyError;
    var core_js_1 = require_core();
    var util = __importStar(require_util2());
    var initializer = (inst, def) => {
      inst.name = "$ZodError";
      Object.defineProperty(inst, "_zod", {
        value: inst._zod,
        enumerable: false
      });
      Object.defineProperty(inst, "issues", {
        value: def,
        enumerable: false
      });
      inst.message = JSON.stringify(def, util.jsonStringifyReplacer, 2);
      Object.defineProperty(inst, "toString", {
        value: () => inst.message,
        enumerable: false
      });
    };
    exports2.$ZodError = (0, core_js_1.$constructor)("$ZodError", initializer);
    exports2.$ZodRealError = (0, core_js_1.$constructor)("$ZodError", initializer, { Parent: Error });
    function flattenError(error, mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of error.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    function formatError(error, mapper = (issue) => issue.message) {
      const fieldErrors = { _errors: [] };
      const processError = (error2) => {
        for (const issue of error2.issues) {
          if (issue.code === "invalid_union" && issue.errors.length) {
            issue.errors.map((issues) => processError({ issues }));
          } else if (issue.code === "invalid_key") {
            processError({ issues: issue.issues });
          } else if (issue.code === "invalid_element") {
            processError({ issues: issue.issues });
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(error);
      return fieldErrors;
    }
    function treeifyError(error, mapper = (issue) => issue.message) {
      const result = { errors: [] };
      const processError = (error2, path = []) => {
        var _a, _b;
        for (const issue of error2.issues) {
          if (issue.code === "invalid_union" && issue.errors.length) {
            issue.errors.map((issues) => processError({ issues }, issue.path));
          } else if (issue.code === "invalid_key") {
            processError({ issues: issue.issues }, issue.path);
          } else if (issue.code === "invalid_element") {
            processError({ issues: issue.issues }, issue.path);
          } else {
            const fullpath = [...path, ...issue.path];
            if (fullpath.length === 0) {
              result.errors.push(mapper(issue));
              continue;
            }
            let curr = result;
            let i = 0;
            while (i < fullpath.length) {
              const el = fullpath[i];
              const terminal = i === fullpath.length - 1;
              if (typeof el === "string") {
                curr.properties ?? (curr.properties = {});
                (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });
                curr = curr.properties[el];
              } else {
                curr.items ?? (curr.items = []);
                (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
                curr = curr.items[el];
              }
              if (terminal) {
                curr.errors.push(mapper(issue));
              }
              i++;
            }
          }
        }
      };
      processError(error);
      return result;
    }
    function toDotPath(_path) {
      const segs = [];
      const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
      for (const seg of path) {
        if (typeof seg === "number")
          segs.push(`[${seg}]`);
        else if (typeof seg === "symbol")
          segs.push(`[${JSON.stringify(String(seg))}]`);
        else if (/[^\w$]/.test(seg))
          segs.push(`[${JSON.stringify(seg)}]`);
        else {
          if (segs.length)
            segs.push(".");
          segs.push(seg);
        }
      }
      return segs.join("");
    }
    function prettifyError(error) {
      const lines = [];
      const issues = [...error.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
      for (const issue of issues) {
        lines.push(`\u2716 ${issue.message}`);
        if (issue.path?.length)
          lines.push(`  \u2192 at ${toDotPath(issue.path)}`);
      }
      return lines.join("\n");
    }
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/parse.cjs
var require_parse = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/parse.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.safeDecodeAsync = exports2._safeDecodeAsync = exports2.safeEncodeAsync = exports2._safeEncodeAsync = exports2.safeDecode = exports2._safeDecode = exports2.safeEncode = exports2._safeEncode = exports2.decodeAsync = exports2._decodeAsync = exports2.encodeAsync = exports2._encodeAsync = exports2.decode = exports2._decode = exports2.encode = exports2._encode = exports2.safeParseAsync = exports2._safeParseAsync = exports2.safeParse = exports2._safeParse = exports2.parseAsync = exports2._parseAsync = exports2.parse = exports2._parse = void 0;
    var core = __importStar(require_core());
    var errors = __importStar(require_errors2());
    var util = __importStar(require_util2());
    var _parse = (_Err) => (schema, value, _ctx, _params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
      const result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
        throw new core.$ZodAsyncError();
      }
      if (result.issues.length) {
        const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())));
        util.captureStackTrace(e, _params?.callee);
        throw e;
      }
      return result.value;
    };
    exports2._parse = _parse;
    exports2.parse = (0, exports2._parse)(errors.$ZodRealError);
    var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
        result = await result;
      if (result.issues.length) {
        const e = new (params?.Err ?? _Err)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())));
        util.captureStackTrace(e, params?.callee);
        throw e;
      }
      return result.value;
    };
    exports2._parseAsync = _parseAsync;
    exports2.parseAsync = (0, exports2._parseAsync)(errors.$ZodRealError);
    var _safeParse = (_Err) => (schema, value, _ctx) => {
      const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
      const result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
        throw new core.$ZodAsyncError();
      }
      return result.issues.length ? {
        success: false,
        error: new (_Err ?? errors.$ZodError)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())))
      } : { success: true, data: result.value };
    };
    exports2._safeParse = _safeParse;
    exports2.safeParse = (0, exports2._safeParse)(errors.$ZodRealError);
    var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
        result = await result;
      return result.issues.length ? {
        success: false,
        error: new _Err(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())))
      } : { success: true, data: result.value };
    };
    exports2._safeParseAsync = _safeParseAsync;
    exports2.safeParseAsync = (0, exports2._safeParseAsync)(errors.$ZodRealError);
    var _encode = (_Err) => (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return (0, exports2._parse)(_Err)(schema, value, ctx);
    };
    exports2._encode = _encode;
    exports2.encode = (0, exports2._encode)(errors.$ZodRealError);
    var _decode = (_Err) => (schema, value, _ctx) => {
      return (0, exports2._parse)(_Err)(schema, value, _ctx);
    };
    exports2._decode = _decode;
    exports2.decode = (0, exports2._decode)(errors.$ZodRealError);
    var _encodeAsync = (_Err) => async (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return (0, exports2._parseAsync)(_Err)(schema, value, ctx);
    };
    exports2._encodeAsync = _encodeAsync;
    exports2.encodeAsync = (0, exports2._encodeAsync)(errors.$ZodRealError);
    var _decodeAsync = (_Err) => async (schema, value, _ctx) => {
      return (0, exports2._parseAsync)(_Err)(schema, value, _ctx);
    };
    exports2._decodeAsync = _decodeAsync;
    exports2.decodeAsync = (0, exports2._decodeAsync)(errors.$ZodRealError);
    var _safeEncode = (_Err) => (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return (0, exports2._safeParse)(_Err)(schema, value, ctx);
    };
    exports2._safeEncode = _safeEncode;
    exports2.safeEncode = (0, exports2._safeEncode)(errors.$ZodRealError);
    var _safeDecode = (_Err) => (schema, value, _ctx) => {
      return (0, exports2._safeParse)(_Err)(schema, value, _ctx);
    };
    exports2._safeDecode = _safeDecode;
    exports2.safeDecode = (0, exports2._safeDecode)(errors.$ZodRealError);
    var _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return (0, exports2._safeParseAsync)(_Err)(schema, value, ctx);
    };
    exports2._safeEncodeAsync = _safeEncodeAsync;
    exports2.safeEncodeAsync = (0, exports2._safeEncodeAsync)(errors.$ZodRealError);
    var _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
      return (0, exports2._safeParseAsync)(_Err)(schema, value, _ctx);
    };
    exports2._safeDecodeAsync = _safeDecodeAsync;
    exports2.safeDecodeAsync = (0, exports2._safeDecodeAsync)(errors.$ZodRealError);
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/regexes.cjs
var require_regexes = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/regexes.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha384_base64 = exports2.sha384_hex = exports2.sha256_base64url = exports2.sha256_base64 = exports2.sha256_hex = exports2.sha1_base64url = exports2.sha1_base64 = exports2.sha1_hex = exports2.md5_base64url = exports2.md5_base64 = exports2.md5_hex = exports2.hex = exports2.uppercase = exports2.lowercase = exports2.undefined = exports2.null = exports2.boolean = exports2.number = exports2.integer = exports2.bigint = exports2.string = exports2.date = exports2.e164 = exports2.domain = exports2.hostname = exports2.base64url = exports2.base64 = exports2.cidrv6 = exports2.cidrv4 = exports2.ipv6 = exports2.ipv4 = exports2.browserEmail = exports2.idnEmail = exports2.unicodeEmail = exports2.rfc5322Email = exports2.html5Email = exports2.email = exports2.uuid7 = exports2.uuid6 = exports2.uuid4 = exports2.uuid = exports2.guid = exports2.extendedDuration = exports2.duration = exports2.nanoid = exports2.ksuid = exports2.xid = exports2.ulid = exports2.cuid2 = exports2.cuid = void 0;
    exports2.sha512_base64url = exports2.sha512_base64 = exports2.sha512_hex = exports2.sha384_base64url = void 0;
    exports2.emoji = emoji;
    exports2.time = time;
    exports2.datetime = datetime;
    exports2.cuid = /^[cC][^\s-]{8,}$/;
    exports2.cuid2 = /^[0-9a-z]+$/;
    exports2.ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
    exports2.xid = /^[0-9a-vA-V]{20}$/;
    exports2.ksuid = /^[A-Za-z0-9]{27}$/;
    exports2.nanoid = /^[a-zA-Z0-9_-]{21}$/;
    exports2.duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
    exports2.extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    exports2.guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
    var uuid = (version2) => {
      if (!version2)
        return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
      return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
    };
    exports2.uuid = uuid;
    exports2.uuid4 = (0, exports2.uuid)(4);
    exports2.uuid6 = (0, exports2.uuid)(6);
    exports2.uuid7 = (0, exports2.uuid)(7);
    exports2.email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
    exports2.html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    exports2.rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    exports2.unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
    exports2.idnEmail = exports2.unicodeEmail;
    exports2.browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    function emoji() {
      return new RegExp(_emoji, "u");
    }
    exports2.ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    exports2.ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
    exports2.cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
    exports2.cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    exports2.base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
    exports2.base64url = /^[A-Za-z0-9_-]*$/;
    exports2.hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
    exports2.domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
    exports2.e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
    var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
    exports2.date = new RegExp(`^${dateSource}$`);
    function timeSource(args) {
      const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
      const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
      return regex;
    }
    function time(args) {
      return new RegExp(`^${timeSource(args)}$`);
    }
    function datetime(args) {
      const time2 = timeSource({ precision: args.precision });
      const opts = ["Z"];
      if (args.local)
        opts.push("");
      if (args.offset)
        opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
      const timeRegex = `${time2}(?:${opts.join("|")})`;
      return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
    }
    var string = (params) => {
      const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
      return new RegExp(`^${regex}$`);
    };
    exports2.string = string;
    exports2.bigint = /^-?\d+n?$/;
    exports2.integer = /^-?\d+$/;
    exports2.number = /^-?\d+(?:\.\d+)?/;
    exports2.boolean = /^(?:true|false)$/i;
    var _null = /^null$/i;
    exports2.null = _null;
    var _undefined = /^undefined$/i;
    exports2.undefined = _undefined;
    exports2.lowercase = /^[^A-Z]*$/;
    exports2.uppercase = /^[^a-z]*$/;
    exports2.hex = /^[0-9a-fA-F]*$/;
    function fixedBase64(bodyLength, padding) {
      return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
    }
    function fixedBase64url(length) {
      return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
    }
    exports2.md5_hex = /^[0-9a-fA-F]{32}$/;
    exports2.md5_base64 = fixedBase64(22, "==");
    exports2.md5_base64url = fixedBase64url(22);
    exports2.sha1_hex = /^[0-9a-fA-F]{40}$/;
    exports2.sha1_base64 = fixedBase64(27, "=");
    exports2.sha1_base64url = fixedBase64url(27);
    exports2.sha256_hex = /^[0-9a-fA-F]{64}$/;
    exports2.sha256_base64 = fixedBase64(43, "=");
    exports2.sha256_base64url = fixedBase64url(43);
    exports2.sha384_hex = /^[0-9a-fA-F]{96}$/;
    exports2.sha384_base64 = fixedBase64(64, "");
    exports2.sha384_base64url = fixedBase64url(64);
    exports2.sha512_hex = /^[0-9a-fA-F]{128}$/;
    exports2.sha512_base64 = fixedBase64(86, "==");
    exports2.sha512_base64url = fixedBase64url(86);
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/checks.cjs
var require_checks = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/checks.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.$ZodCheckOverwrite = exports2.$ZodCheckMimeType = exports2.$ZodCheckProperty = exports2.$ZodCheckEndsWith = exports2.$ZodCheckStartsWith = exports2.$ZodCheckIncludes = exports2.$ZodCheckUpperCase = exports2.$ZodCheckLowerCase = exports2.$ZodCheckRegex = exports2.$ZodCheckStringFormat = exports2.$ZodCheckLengthEquals = exports2.$ZodCheckMinLength = exports2.$ZodCheckMaxLength = exports2.$ZodCheckSizeEquals = exports2.$ZodCheckMinSize = exports2.$ZodCheckMaxSize = exports2.$ZodCheckBigIntFormat = exports2.$ZodCheckNumberFormat = exports2.$ZodCheckMultipleOf = exports2.$ZodCheckGreaterThan = exports2.$ZodCheckLessThan = exports2.$ZodCheck = void 0;
    var core = __importStar(require_core());
    var regexes = __importStar(require_regexes());
    var util = __importStar(require_util2());
    exports2.$ZodCheck = core.$constructor("$ZodCheck", (inst, def) => {
      var _a;
      inst._zod ?? (inst._zod = {});
      inst._zod.def = def;
      (_a = inst._zod).onattach ?? (_a.onattach = []);
    });
    var numericOriginMap = {
      number: "number",
      bigint: "bigint",
      object: "date"
    };
    exports2.$ZodCheckLessThan = core.$constructor("$ZodCheckLessThan", (inst, def) => {
      exports2.$ZodCheck.init(inst, def);
      const origin = numericOriginMap[typeof def.value];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
        if (def.value < curr) {
          if (def.inclusive)
            bag.maximum = def.value;
          else
            bag.exclusiveMaximum = def.value;
        }
      });
      inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
          return;
        }
        payload.issues.push({
          origin,
          code: "too_big",
          maximum: def.value,
          input: payload.value,
          inclusive: def.inclusive,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckGreaterThan = core.$constructor("$ZodCheckGreaterThan", (inst, def) => {
      exports2.$ZodCheck.init(inst, def);
      const origin = numericOriginMap[typeof def.value];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
        if (def.value > curr) {
          if (def.inclusive)
            bag.minimum = def.value;
          else
            bag.exclusiveMinimum = def.value;
        }
      });
      inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
          return;
        }
        payload.issues.push({
          origin,
          code: "too_small",
          minimum: def.value,
          input: payload.value,
          inclusive: def.inclusive,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckMultipleOf = /* @__PURE__ */ core.$constructor("$ZodCheckMultipleOf", (inst, def) => {
      exports2.$ZodCheck.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        var _a;
        (_a = inst2._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
      });
      inst._zod.check = (payload) => {
        if (typeof payload.value !== typeof def.value)
          throw new Error("Cannot mix number and bigint in multiple_of check.");
        const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : util.floatSafeRemainder(payload.value, def.value) === 0;
        if (isMultiple)
          return;
        payload.issues.push({
          origin: typeof payload.value,
          code: "not_multiple_of",
          divisor: def.value,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckNumberFormat = core.$constructor("$ZodCheckNumberFormat", (inst, def) => {
      exports2.$ZodCheck.init(inst, def);
      def.format = def.format || "float64";
      const isInt = def.format?.includes("int");
      const origin = isInt ? "int" : "number";
      const [minimum, maximum] = util.NUMBER_FORMAT_RANGES[def.format];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
        if (isInt)
          bag.pattern = regexes.integer;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        if (isInt) {
          if (!Number.isInteger(input)) {
            payload.issues.push({
              expected: origin,
              format: def.format,
              code: "invalid_type",
              continue: false,
              input,
              inst
            });
            return;
          }
          if (!Number.isSafeInteger(input)) {
            if (input > 0) {
              payload.issues.push({
                input,
                code: "too_big",
                maximum: Number.MAX_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst,
                origin,
                continue: !def.abort
              });
            } else {
              payload.issues.push({
                input,
                code: "too_small",
                minimum: Number.MIN_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst,
                origin,
                continue: !def.abort
              });
            }
            return;
          }
        }
        if (input < minimum) {
          payload.issues.push({
            origin: "number",
            input,
            code: "too_small",
            minimum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
        if (input > maximum) {
          payload.issues.push({
            origin: "number",
            input,
            code: "too_big",
            maximum,
            inst
          });
        }
      };
    });
    exports2.$ZodCheckBigIntFormat = core.$constructor("$ZodCheckBigIntFormat", (inst, def) => {
      exports2.$ZodCheck.init(inst, def);
      const [minimum, maximum] = util.BIGINT_FORMAT_RANGES[def.format];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        if (input < minimum) {
          payload.issues.push({
            origin: "bigint",
            input,
            code: "too_small",
            minimum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
        if (input > maximum) {
          payload.issues.push({
            origin: "bigint",
            input,
            code: "too_big",
            maximum,
            inst
          });
        }
      };
    });
    exports2.$ZodCheckMaxSize = core.$constructor("$ZodCheckMaxSize", (inst, def) => {
      var _a;
      exports2.$ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !util.nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (def.maximum < curr)
          inst2._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size <= def.maximum)
          return;
        payload.issues.push({
          origin: util.getSizableOrigin(input),
          code: "too_big",
          maximum: def.maximum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckMinSize = core.$constructor("$ZodCheckMinSize", (inst, def) => {
      var _a;
      exports2.$ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !util.nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (def.minimum > curr)
          inst2._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size >= def.minimum)
          return;
        payload.issues.push({
          origin: util.getSizableOrigin(input),
          code: "too_small",
          minimum: def.minimum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckSizeEquals = core.$constructor("$ZodCheckSizeEquals", (inst, def) => {
      var _a;
      exports2.$ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !util.nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.minimum = def.size;
        bag.maximum = def.size;
        bag.size = def.size;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size === def.size)
          return;
        const tooBig = size > def.size;
        payload.issues.push({
          origin: util.getSizableOrigin(input),
          ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
          inclusive: true,
          exact: true,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckMaxLength = core.$constructor("$ZodCheckMaxLength", (inst, def) => {
      var _a;
      exports2.$ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !util.nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (def.maximum < curr)
          inst2._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length <= def.maximum)
          return;
        const origin = util.getLengthableOrigin(input);
        payload.issues.push({
          origin,
          code: "too_big",
          maximum: def.maximum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckMinLength = core.$constructor("$ZodCheckMinLength", (inst, def) => {
      var _a;
      exports2.$ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !util.nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (def.minimum > curr)
          inst2._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length >= def.minimum)
          return;
        const origin = util.getLengthableOrigin(input);
        payload.issues.push({
          origin,
          code: "too_small",
          minimum: def.minimum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckLengthEquals = core.$constructor("$ZodCheckLengthEquals", (inst, def) => {
      var _a;
      exports2.$ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !util.nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.minimum = def.length;
        bag.maximum = def.length;
        bag.length = def.length;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length === def.length)
          return;
        const origin = util.getLengthableOrigin(input);
        const tooBig = length > def.length;
        payload.issues.push({
          origin,
          ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
          inclusive: true,
          exact: true,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckStringFormat = core.$constructor("$ZodCheckStringFormat", (inst, def) => {
      var _a, _b;
      exports2.$ZodCheck.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        if (def.pattern) {
          bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
          bag.patterns.add(def.pattern);
        }
      });
      if (def.pattern)
        (_a = inst._zod).check ?? (_a.check = (payload) => {
          def.pattern.lastIndex = 0;
          if (def.pattern.test(payload.value))
            return;
          payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: def.format,
            input: payload.value,
            ...def.pattern ? { pattern: def.pattern.toString() } : {},
            inst,
            continue: !def.abort
          });
        });
      else
        (_b = inst._zod).check ?? (_b.check = () => {
        });
    });
    exports2.$ZodCheckRegex = core.$constructor("$ZodCheckRegex", (inst, def) => {
      exports2.$ZodCheckStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "regex",
          input: payload.value,
          pattern: def.pattern.toString(),
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckLowerCase = core.$constructor("$ZodCheckLowerCase", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.lowercase);
      exports2.$ZodCheckStringFormat.init(inst, def);
    });
    exports2.$ZodCheckUpperCase = core.$constructor("$ZodCheckUpperCase", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.uppercase);
      exports2.$ZodCheckStringFormat.init(inst, def);
    });
    exports2.$ZodCheckIncludes = core.$constructor("$ZodCheckIncludes", (inst, def) => {
      exports2.$ZodCheck.init(inst, def);
      const escapedRegex = util.escapeRegex(def.includes);
      const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
      def.pattern = pattern;
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.includes(def.includes, def.position))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "includes",
          includes: def.includes,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckStartsWith = core.$constructor("$ZodCheckStartsWith", (inst, def) => {
      exports2.$ZodCheck.init(inst, def);
      const pattern = new RegExp(`^${util.escapeRegex(def.prefix)}.*`);
      def.pattern ?? (def.pattern = pattern);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.startsWith(def.prefix))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "starts_with",
          prefix: def.prefix,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckEndsWith = core.$constructor("$ZodCheckEndsWith", (inst, def) => {
      exports2.$ZodCheck.init(inst, def);
      const pattern = new RegExp(`.*${util.escapeRegex(def.suffix)}$`);
      def.pattern ?? (def.pattern = pattern);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.endsWith(def.suffix))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "ends_with",
          suffix: def.suffix,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    function handleCheckPropertyResult(result, payload, property) {
      if (result.issues.length) {
        payload.issues.push(...util.prefixIssues(property, result.issues));
      }
    }
    exports2.$ZodCheckProperty = core.$constructor("$ZodCheckProperty", (inst, def) => {
      exports2.$ZodCheck.init(inst, def);
      inst._zod.check = (payload) => {
        const result = def.schema._zod.run({
          value: payload.value[def.property],
          issues: []
        }, {});
        if (result instanceof Promise) {
          return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
        }
        handleCheckPropertyResult(result, payload, def.property);
        return;
      };
    });
    exports2.$ZodCheckMimeType = core.$constructor("$ZodCheckMimeType", (inst, def) => {
      exports2.$ZodCheck.init(inst, def);
      const mimeSet = new Set(def.mime);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.mime = def.mime;
      });
      inst._zod.check = (payload) => {
        if (mimeSet.has(payload.value.type))
          return;
        payload.issues.push({
          code: "invalid_value",
          values: def.mime,
          input: payload.value.type,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckOverwrite = core.$constructor("$ZodCheckOverwrite", (inst, def) => {
      exports2.$ZodCheck.init(inst, def);
      inst._zod.check = (payload) => {
        payload.value = def.tx(payload.value);
      };
    });
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/doc.cjs
var require_doc = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/doc.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Doc = void 0;
    var Doc = class {
      constructor(args = []) {
        this.content = [];
        this.indent = 0;
        if (this)
          this.args = args;
      }
      indented(fn) {
        this.indent += 1;
        fn(this);
        this.indent -= 1;
      }
      write(arg) {
        if (typeof arg === "function") {
          arg(this, { execution: "sync" });
          arg(this, { execution: "async" });
          return;
        }
        const content = arg;
        const lines = content.split("\n").filter((x) => x);
        const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
        const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
        for (const line of dedented) {
          this.content.push(line);
        }
      }
      compile() {
        const F = Function;
        const args = this?.args;
        const content = this?.content ?? [``];
        const lines = [...content.map((x) => `  ${x}`)];
        return new F(...args, lines.join("\n"));
      }
    };
    exports2.Doc = Doc;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/versions.cjs
var require_versions = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/versions.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.version = void 0;
    exports2.version = {
      major: 4,
      minor: 1,
      patch: 12
    };
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/schemas.cjs
var require_schemas = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/schemas.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.$ZodMap = exports2.$ZodRecord = exports2.$ZodTuple = exports2.$ZodIntersection = exports2.$ZodDiscriminatedUnion = exports2.$ZodUnion = exports2.$ZodObjectJIT = exports2.$ZodObject = exports2.$ZodArray = exports2.$ZodDate = exports2.$ZodVoid = exports2.$ZodNever = exports2.$ZodUnknown = exports2.$ZodAny = exports2.$ZodNull = exports2.$ZodUndefined = exports2.$ZodSymbol = exports2.$ZodBigIntFormat = exports2.$ZodBigInt = exports2.$ZodBoolean = exports2.$ZodNumberFormat = exports2.$ZodNumber = exports2.$ZodCustomStringFormat = exports2.$ZodJWT = exports2.$ZodE164 = exports2.$ZodBase64URL = exports2.$ZodBase64 = exports2.$ZodCIDRv6 = exports2.$ZodCIDRv4 = exports2.$ZodIPv6 = exports2.$ZodIPv4 = exports2.$ZodISODuration = exports2.$ZodISOTime = exports2.$ZodISODate = exports2.$ZodISODateTime = exports2.$ZodKSUID = exports2.$ZodXID = exports2.$ZodULID = exports2.$ZodCUID2 = exports2.$ZodCUID = exports2.$ZodNanoID = exports2.$ZodEmoji = exports2.$ZodURL = exports2.$ZodEmail = exports2.$ZodUUID = exports2.$ZodGUID = exports2.$ZodStringFormat = exports2.$ZodString = exports2.clone = exports2.$ZodType = void 0;
    exports2.$ZodCustom = exports2.$ZodLazy = exports2.$ZodPromise = exports2.$ZodFunction = exports2.$ZodTemplateLiteral = exports2.$ZodReadonly = exports2.$ZodCodec = exports2.$ZodPipe = exports2.$ZodNaN = exports2.$ZodCatch = exports2.$ZodSuccess = exports2.$ZodNonOptional = exports2.$ZodPrefault = exports2.$ZodDefault = exports2.$ZodNullable = exports2.$ZodOptional = exports2.$ZodTransform = exports2.$ZodFile = exports2.$ZodLiteral = exports2.$ZodEnum = exports2.$ZodSet = void 0;
    exports2.isValidBase64 = isValidBase64;
    exports2.isValidBase64URL = isValidBase64URL;
    exports2.isValidJWT = isValidJWT;
    var checks = __importStar(require_checks());
    var core = __importStar(require_core());
    var doc_js_1 = require_doc();
    var parse_js_1 = require_parse();
    var regexes = __importStar(require_regexes());
    var util = __importStar(require_util2());
    var versions_js_1 = require_versions();
    exports2.$ZodType = core.$constructor("$ZodType", (inst, def) => {
      var _a;
      inst ?? (inst = {});
      inst._zod.def = def;
      inst._zod.bag = inst._zod.bag || {};
      inst._zod.version = versions_js_1.version;
      const checks2 = [...inst._zod.def.checks ?? []];
      if (inst._zod.traits.has("$ZodCheck")) {
        checks2.unshift(inst);
      }
      for (const ch of checks2) {
        for (const fn of ch._zod.onattach) {
          fn(inst);
        }
      }
      if (checks2.length === 0) {
        (_a = inst._zod).deferred ?? (_a.deferred = []);
        inst._zod.deferred?.push(() => {
          inst._zod.run = inst._zod.parse;
        });
      } else {
        const runChecks = (payload, checks3, ctx) => {
          let isAborted = util.aborted(payload);
          let asyncResult;
          for (const ch of checks3) {
            if (ch._zod.def.when) {
              const shouldRun = ch._zod.def.when(payload);
              if (!shouldRun)
                continue;
            } else if (isAborted) {
              continue;
            }
            const currLen = payload.issues.length;
            const _ = ch._zod.check(payload);
            if (_ instanceof Promise && ctx?.async === false) {
              throw new core.$ZodAsyncError();
            }
            if (asyncResult || _ instanceof Promise) {
              asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
                await _;
                const nextLen = payload.issues.length;
                if (nextLen === currLen)
                  return;
                if (!isAborted)
                  isAborted = util.aborted(payload, currLen);
              });
            } else {
              const nextLen = payload.issues.length;
              if (nextLen === currLen)
                continue;
              if (!isAborted)
                isAborted = util.aborted(payload, currLen);
            }
          }
          if (asyncResult) {
            return asyncResult.then(() => {
              return payload;
            });
          }
          return payload;
        };
        const handleCanaryResult = (canary, payload, ctx) => {
          if (util.aborted(canary)) {
            canary.aborted = true;
            return canary;
          }
          const checkResult = runChecks(payload, checks2, ctx);
          if (checkResult instanceof Promise) {
            if (ctx.async === false)
              throw new core.$ZodAsyncError();
            return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
          }
          return inst._zod.parse(checkResult, ctx);
        };
        inst._zod.run = (payload, ctx) => {
          if (ctx.skipChecks) {
            return inst._zod.parse(payload, ctx);
          }
          if (ctx.direction === "backward") {
            const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
            if (canary instanceof Promise) {
              return canary.then((canary2) => {
                return handleCanaryResult(canary2, payload, ctx);
              });
            }
            return handleCanaryResult(canary, payload, ctx);
          }
          const result = inst._zod.parse(payload, ctx);
          if (result instanceof Promise) {
            if (ctx.async === false)
              throw new core.$ZodAsyncError();
            return result.then((result2) => runChecks(result2, checks2, ctx));
          }
          return runChecks(result, checks2, ctx);
        };
      }
      inst["~standard"] = {
        validate: (value) => {
          try {
            const r = (0, parse_js_1.safeParse)(inst, value);
            return r.success ? { value: r.data } : { issues: r.error?.issues };
          } catch (_) {
            return (0, parse_js_1.safeParseAsync)(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
          }
        },
        vendor: "zod",
        version: 1
      };
    });
    var util_js_1 = require_util2();
    Object.defineProperty(exports2, "clone", { enumerable: true, get: function() {
      return util_js_1.clone;
    } });
    exports2.$ZodString = core.$constructor("$ZodString", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? regexes.string(inst._zod.bag);
      inst._zod.parse = (payload, _) => {
        if (def.coerce)
          try {
            payload.value = String(payload.value);
          } catch (_2) {
          }
        if (typeof payload.value === "string")
          return payload;
        payload.issues.push({
          expected: "string",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    exports2.$ZodStringFormat = core.$constructor("$ZodStringFormat", (inst, def) => {
      checks.$ZodCheckStringFormat.init(inst, def);
      exports2.$ZodString.init(inst, def);
    });
    exports2.$ZodGUID = core.$constructor("$ZodGUID", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.guid);
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodUUID = core.$constructor("$ZodUUID", (inst, def) => {
      if (def.version) {
        const versionMap = {
          v1: 1,
          v2: 2,
          v3: 3,
          v4: 4,
          v5: 5,
          v6: 6,
          v7: 7,
          v8: 8
        };
        const v = versionMap[def.version];
        if (v === void 0)
          throw new Error(`Invalid UUID version: "${def.version}"`);
        def.pattern ?? (def.pattern = regexes.uuid(v));
      } else
        def.pattern ?? (def.pattern = regexes.uuid());
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodEmail = core.$constructor("$ZodEmail", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.email);
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodURL = core.$constructor("$ZodURL", (inst, def) => {
      exports2.$ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        try {
          const trimmed = payload.value.trim();
          const url = new URL(trimmed);
          if (def.hostname) {
            def.hostname.lastIndex = 0;
            if (!def.hostname.test(url.hostname)) {
              payload.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid hostname",
                pattern: regexes.hostname.source,
                input: payload.value,
                inst,
                continue: !def.abort
              });
            }
          }
          if (def.protocol) {
            def.protocol.lastIndex = 0;
            if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
              payload.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid protocol",
                pattern: def.protocol.source,
                input: payload.value,
                inst,
                continue: !def.abort
              });
            }
          }
          if (def.normalize) {
            payload.value = url.href;
          } else {
            payload.value = trimmed;
          }
          return;
        } catch (_) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    exports2.$ZodEmoji = core.$constructor("$ZodEmoji", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.emoji());
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodNanoID = core.$constructor("$ZodNanoID", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.nanoid);
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodCUID = core.$constructor("$ZodCUID", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.cuid);
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodCUID2 = core.$constructor("$ZodCUID2", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.cuid2);
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodULID = core.$constructor("$ZodULID", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.ulid);
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodXID = core.$constructor("$ZodXID", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.xid);
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodKSUID = core.$constructor("$ZodKSUID", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.ksuid);
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodISODateTime = core.$constructor("$ZodISODateTime", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.datetime(def));
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodISODate = core.$constructor("$ZodISODate", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.date);
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodISOTime = core.$constructor("$ZodISOTime", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.time(def));
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodISODuration = core.$constructor("$ZodISODuration", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.duration);
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodIPv4 = core.$constructor("$ZodIPv4", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.ipv4);
      exports2.$ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = `ipv4`;
      });
    });
    exports2.$ZodIPv6 = core.$constructor("$ZodIPv6", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.ipv6);
      exports2.$ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = `ipv6`;
      });
      inst._zod.check = (payload) => {
        try {
          new URL(`http://[${payload.value}]`);
        } catch {
          payload.issues.push({
            code: "invalid_format",
            format: "ipv6",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    exports2.$ZodCIDRv4 = core.$constructor("$ZodCIDRv4", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.cidrv4);
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodCIDRv6 = core.$constructor("$ZodCIDRv6", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.cidrv6);
      exports2.$ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        const parts = payload.value.split("/");
        try {
          if (parts.length !== 2)
            throw new Error();
          const [address, prefix] = parts;
          if (!prefix)
            throw new Error();
          const prefixNum = Number(prefix);
          if (`${prefixNum}` !== prefix)
            throw new Error();
          if (prefixNum < 0 || prefixNum > 128)
            throw new Error();
          new URL(`http://[${address}]`);
        } catch {
          payload.issues.push({
            code: "invalid_format",
            format: "cidrv6",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    function isValidBase64(data) {
      if (data === "")
        return true;
      if (data.length % 4 !== 0)
        return false;
      try {
        atob(data);
        return true;
      } catch {
        return false;
      }
    }
    exports2.$ZodBase64 = core.$constructor("$ZodBase64", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.base64);
      exports2.$ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.contentEncoding = "base64";
      });
      inst._zod.check = (payload) => {
        if (isValidBase64(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "base64",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    function isValidBase64URL(data) {
      if (!regexes.base64url.test(data))
        return false;
      const base64 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
      const padded = base64.padEnd(Math.ceil(base64.length / 4) * 4, "=");
      return isValidBase64(padded);
    }
    exports2.$ZodBase64URL = core.$constructor("$ZodBase64URL", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.base64url);
      exports2.$ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.contentEncoding = "base64url";
      });
      inst._zod.check = (payload) => {
        if (isValidBase64URL(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "base64url",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodE164 = core.$constructor("$ZodE164", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.e164);
      exports2.$ZodStringFormat.init(inst, def);
    });
    function isValidJWT(token, algorithm = null) {
      try {
        const tokensParts = token.split(".");
        if (tokensParts.length !== 3)
          return false;
        const [header] = tokensParts;
        if (!header)
          return false;
        const parsedHeader = JSON.parse(atob(header));
        if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
          return false;
        if (!parsedHeader.alg)
          return false;
        if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
          return false;
        return true;
      } catch {
        return false;
      }
    }
    exports2.$ZodJWT = core.$constructor("$ZodJWT", (inst, def) => {
      exports2.$ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        if (isValidJWT(payload.value, def.alg))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "jwt",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCustomStringFormat = core.$constructor("$ZodCustomStringFormat", (inst, def) => {
      exports2.$ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        if (def.fn(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: def.format,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodNumber = core.$constructor("$ZodNumber", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.pattern = inst._zod.bag.pattern ?? regexes.number;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = Number(payload.value);
          } catch (_) {
          }
        const input = payload.value;
        if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
          return payload;
        }
        const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
        payload.issues.push({
          expected: "number",
          code: "invalid_type",
          input,
          inst,
          ...received ? { received } : {}
        });
        return payload;
      };
    });
    exports2.$ZodNumberFormat = core.$constructor("$ZodNumber", (inst, def) => {
      checks.$ZodCheckNumberFormat.init(inst, def);
      exports2.$ZodNumber.init(inst, def);
    });
    exports2.$ZodBoolean = core.$constructor("$ZodBoolean", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.pattern = regexes.boolean;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = Boolean(payload.value);
          } catch (_) {
          }
        const input = payload.value;
        if (typeof input === "boolean")
          return payload;
        payload.issues.push({
          expected: "boolean",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    exports2.$ZodBigInt = core.$constructor("$ZodBigInt", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.pattern = regexes.bigint;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = BigInt(payload.value);
          } catch (_) {
          }
        if (typeof payload.value === "bigint")
          return payload;
        payload.issues.push({
          expected: "bigint",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    exports2.$ZodBigIntFormat = core.$constructor("$ZodBigInt", (inst, def) => {
      checks.$ZodCheckBigIntFormat.init(inst, def);
      exports2.$ZodBigInt.init(inst, def);
    });
    exports2.$ZodSymbol = core.$constructor("$ZodSymbol", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "symbol")
          return payload;
        payload.issues.push({
          expected: "symbol",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    exports2.$ZodUndefined = core.$constructor("$ZodUndefined", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.pattern = regexes.undefined;
      inst._zod.values = /* @__PURE__ */ new Set([void 0]);
      inst._zod.optin = "optional";
      inst._zod.optout = "optional";
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "undefined")
          return payload;
        payload.issues.push({
          expected: "undefined",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    exports2.$ZodNull = core.$constructor("$ZodNull", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.pattern = regexes.null;
      inst._zod.values = /* @__PURE__ */ new Set([null]);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (input === null)
          return payload;
        payload.issues.push({
          expected: "null",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    exports2.$ZodAny = core.$constructor("$ZodAny", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload) => payload;
    });
    exports2.$ZodUnknown = core.$constructor("$ZodUnknown", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload) => payload;
    });
    exports2.$ZodNever = core.$constructor("$ZodNever", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        payload.issues.push({
          expected: "never",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    exports2.$ZodVoid = core.$constructor("$ZodVoid", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "undefined")
          return payload;
        payload.issues.push({
          expected: "void",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    exports2.$ZodDate = core.$constructor("$ZodDate", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce) {
          try {
            payload.value = new Date(payload.value);
          } catch (_err) {
          }
        }
        const input = payload.value;
        const isDate = input instanceof Date;
        const isValidDate = isDate && !Number.isNaN(input.getTime());
        if (isValidDate)
          return payload;
        payload.issues.push({
          expected: "date",
          code: "invalid_type",
          input,
          ...isDate ? { received: "Invalid Date" } : {},
          inst
        });
        return payload;
      };
    });
    function handleArrayResult(result, final, index) {
      if (result.issues.length) {
        final.issues.push(...util.prefixIssues(index, result.issues));
      }
      final.value[index] = result.value;
    }
    exports2.$ZodArray = core.$constructor("$ZodArray", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
          payload.issues.push({
            expected: "array",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        payload.value = Array(input.length);
        const proms = [];
        for (let i = 0; i < input.length; i++) {
          const item = input[i];
          const result = def.element._zod.run({
            value: item,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
          } else {
            handleArrayResult(result, payload, i);
          }
        }
        if (proms.length) {
          return Promise.all(proms).then(() => payload);
        }
        return payload;
      };
    });
    function handlePropertyResult(result, final, key, input) {
      if (result.issues.length) {
        final.issues.push(...util.prefixIssues(key, result.issues));
      }
      if (result.value === void 0) {
        if (key in input) {
          final.value[key] = void 0;
        }
      } else {
        final.value[key] = result.value;
      }
    }
    function normalizeDef(def) {
      const keys = Object.keys(def.shape);
      for (const k of keys) {
        if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
          throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
        }
      }
      const okeys = util.optionalKeys(def.shape);
      return {
        ...def,
        keys,
        keySet: new Set(keys),
        numKeys: keys.length,
        optionalKeys: new Set(okeys)
      };
    }
    function handleCatchall(proms, input, payload, ctx, def, inst) {
      const unrecognized = [];
      const keySet = def.keySet;
      const _catchall = def.catchall._zod;
      const t = _catchall.def.type;
      for (const key of Object.keys(input)) {
        if (keySet.has(key))
          continue;
        if (t === "never") {
          unrecognized.push(key);
          continue;
        }
        const r = _catchall.run({ value: input[key], issues: [] }, ctx);
        if (r instanceof Promise) {
          proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
        } else {
          handlePropertyResult(r, payload, key, input);
        }
      }
      if (unrecognized.length) {
        payload.issues.push({
          code: "unrecognized_keys",
          keys: unrecognized,
          input,
          inst
        });
      }
      if (!proms.length)
        return payload;
      return Promise.all(proms).then(() => {
        return payload;
      });
    }
    exports2.$ZodObject = core.$constructor("$ZodObject", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      const desc = Object.getOwnPropertyDescriptor(def, "shape");
      if (!desc?.get) {
        const sh = def.shape;
        Object.defineProperty(def, "shape", {
          get: () => {
            const newSh = { ...sh };
            Object.defineProperty(def, "shape", {
              value: newSh
            });
            return newSh;
          }
        });
      }
      const _normalized = util.cached(() => normalizeDef(def));
      util.defineLazy(inst._zod, "propValues", () => {
        const shape = def.shape;
        const propValues = {};
        for (const key in shape) {
          const field = shape[key]._zod;
          if (field.values) {
            propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
            for (const v of field.values)
              propValues[key].add(v);
          }
        }
        return propValues;
      });
      const isObject = util.isObject;
      const catchall = def.catchall;
      let value;
      inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject(input)) {
          payload.issues.push({
            expected: "object",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        payload.value = {};
        const proms = [];
        const shape = value.shape;
        for (const key of value.keys) {
          const el = shape[key];
          const r = el._zod.run({ value: input[key], issues: [] }, ctx);
          if (r instanceof Promise) {
            proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
          } else {
            handlePropertyResult(r, payload, key, input);
          }
        }
        if (!catchall) {
          return proms.length ? Promise.all(proms).then(() => payload) : payload;
        }
        return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
      };
    });
    exports2.$ZodObjectJIT = core.$constructor("$ZodObjectJIT", (inst, def) => {
      exports2.$ZodObject.init(inst, def);
      const superParse = inst._zod.parse;
      const _normalized = util.cached(() => normalizeDef(def));
      const generateFastpass = (shape) => {
        const doc = new doc_js_1.Doc(["shape", "payload", "ctx"]);
        const normalized = _normalized.value;
        const parseStr = (key) => {
          const k = util.esc(key);
          return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
        };
        doc.write(`const input = payload.value;`);
        const ids = /* @__PURE__ */ Object.create(null);
        let counter = 0;
        for (const key of normalized.keys) {
          ids[key] = `key_${counter++}`;
        }
        doc.write(`const newResult = {};`);
        for (const key of normalized.keys) {
          const id = ids[key];
          const k = util.esc(key);
          doc.write(`const ${id} = ${parseStr(key)};`);
          doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
        }
        doc.write(`payload.value = newResult;`);
        doc.write(`return payload;`);
        const fn = doc.compile();
        return (payload, ctx) => fn(shape, payload, ctx);
      };
      let fastpass;
      const isObject = util.isObject;
      const jit = !core.globalConfig.jitless;
      const allowsEval = util.allowsEval;
      const fastEnabled = jit && allowsEval.value;
      const catchall = def.catchall;
      let value;
      inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject(input)) {
          payload.issues.push({
            expected: "object",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
          if (!fastpass)
            fastpass = generateFastpass(def.shape);
          payload = fastpass(payload, ctx);
          if (!catchall)
            return payload;
          return handleCatchall([], input, payload, ctx, value, inst);
        }
        return superParse(payload, ctx);
      };
    });
    function handleUnionResults(results, final, inst, ctx) {
      for (const result of results) {
        if (result.issues.length === 0) {
          final.value = result.value;
          return final;
        }
      }
      const nonaborted = results.filter((r) => !util.aborted(r));
      if (nonaborted.length === 1) {
        final.value = nonaborted[0].value;
        return nonaborted[0];
      }
      final.issues.push({
        code: "invalid_union",
        input: final.value,
        inst,
        errors: results.map((result) => result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())))
      });
      return final;
    }
    exports2.$ZodUnion = core.$constructor("$ZodUnion", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      util.defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
      util.defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
      util.defineLazy(inst._zod, "values", () => {
        if (def.options.every((o) => o._zod.values)) {
          return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
        }
        return void 0;
      });
      util.defineLazy(inst._zod, "pattern", () => {
        if (def.options.every((o) => o._zod.pattern)) {
          const patterns = def.options.map((o) => o._zod.pattern);
          return new RegExp(`^(${patterns.map((p) => util.cleanRegex(p.source)).join("|")})$`);
        }
        return void 0;
      });
      const single = def.options.length === 1;
      const first = def.options[0]._zod.run;
      inst._zod.parse = (payload, ctx) => {
        if (single) {
          return first(payload, ctx);
        }
        let async = false;
        const results = [];
        for (const option of def.options) {
          const result = option._zod.run({
            value: payload.value,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            results.push(result);
            async = true;
          } else {
            if (result.issues.length === 0)
              return result;
            results.push(result);
          }
        }
        if (!async)
          return handleUnionResults(results, payload, inst, ctx);
        return Promise.all(results).then((results2) => {
          return handleUnionResults(results2, payload, inst, ctx);
        });
      };
    });
    exports2.$ZodDiscriminatedUnion = /* @__PURE__ */ core.$constructor("$ZodDiscriminatedUnion", (inst, def) => {
      exports2.$ZodUnion.init(inst, def);
      const _super = inst._zod.parse;
      util.defineLazy(inst._zod, "propValues", () => {
        const propValues = {};
        for (const option of def.options) {
          const pv = option._zod.propValues;
          if (!pv || Object.keys(pv).length === 0)
            throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
          for (const [k, v] of Object.entries(pv)) {
            if (!propValues[k])
              propValues[k] = /* @__PURE__ */ new Set();
            for (const val of v) {
              propValues[k].add(val);
            }
          }
        }
        return propValues;
      });
      const disc = util.cached(() => {
        const opts = def.options;
        const map = /* @__PURE__ */ new Map();
        for (const o of opts) {
          const values = o._zod.propValues?.[def.discriminator];
          if (!values || values.size === 0)
            throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
          for (const v of values) {
            if (map.has(v)) {
              throw new Error(`Duplicate discriminator value "${String(v)}"`);
            }
            map.set(v, o);
          }
        }
        return map;
      });
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!util.isObject(input)) {
          payload.issues.push({
            code: "invalid_type",
            expected: "object",
            input,
            inst
          });
          return payload;
        }
        const opt = disc.value.get(input?.[def.discriminator]);
        if (opt) {
          return opt._zod.run(payload, ctx);
        }
        if (def.unionFallback) {
          return _super(payload, ctx);
        }
        payload.issues.push({
          code: "invalid_union",
          errors: [],
          note: "No matching discriminator",
          discriminator: def.discriminator,
          input,
          path: [def.discriminator],
          inst
        });
        return payload;
      };
    });
    exports2.$ZodIntersection = core.$constructor("$ZodIntersection", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        const left = def.left._zod.run({ value: input, issues: [] }, ctx);
        const right = def.right._zod.run({ value: input, issues: [] }, ctx);
        const async = left instanceof Promise || right instanceof Promise;
        if (async) {
          return Promise.all([left, right]).then(([left2, right2]) => {
            return handleIntersectionResults(payload, left2, right2);
          });
        }
        return handleIntersectionResults(payload, left, right);
      };
    });
    function mergeValues(a, b) {
      if (a === b) {
        return { valid: true, data: a };
      }
      if (a instanceof Date && b instanceof Date && +a === +b) {
        return { valid: true, data: a };
      }
      if (util.isPlainObject(a) && util.isPlainObject(b)) {
        const bKeys = Object.keys(b);
        const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
          const sharedValue = mergeValues(a[key], b[key]);
          if (!sharedValue.valid) {
            return {
              valid: false,
              mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
            };
          }
          newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
      }
      if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
          return { valid: false, mergeErrorPath: [] };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
          const itemA = a[index];
          const itemB = b[index];
          const sharedValue = mergeValues(itemA, itemB);
          if (!sharedValue.valid) {
            return {
              valid: false,
              mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
            };
          }
          newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
      }
      return { valid: false, mergeErrorPath: [] };
    }
    function handleIntersectionResults(result, left, right) {
      if (left.issues.length) {
        result.issues.push(...left.issues);
      }
      if (right.issues.length) {
        result.issues.push(...right.issues);
      }
      if (util.aborted(result))
        return result;
      const merged = mergeValues(left.value, right.value);
      if (!merged.valid) {
        throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
      }
      result.value = merged.data;
      return result;
    }
    exports2.$ZodTuple = core.$constructor("$ZodTuple", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      const items = def.items;
      const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
          payload.issues.push({
            input,
            inst,
            expected: "tuple",
            code: "invalid_type"
          });
          return payload;
        }
        payload.value = [];
        const proms = [];
        if (!def.rest) {
          const tooBig = input.length > items.length;
          const tooSmall = input.length < optStart - 1;
          if (tooBig || tooSmall) {
            payload.issues.push({
              ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length },
              input,
              inst,
              origin: "array"
            });
            return payload;
          }
        }
        let i = -1;
        for (const item of items) {
          i++;
          if (i >= input.length) {
            if (i >= optStart)
              continue;
          }
          const result = item._zod.run({
            value: input[i],
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
          } else {
            handleTupleResult(result, payload, i);
          }
        }
        if (def.rest) {
          const rest = input.slice(items.length);
          for (const el of rest) {
            i++;
            const result = def.rest._zod.run({
              value: el,
              issues: []
            }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
            } else {
              handleTupleResult(result, payload, i);
            }
          }
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    function handleTupleResult(result, final, index) {
      if (result.issues.length) {
        final.issues.push(...util.prefixIssues(index, result.issues));
      }
      final.value[index] = result.value;
    }
    exports2.$ZodRecord = core.$constructor("$ZodRecord", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!util.isPlainObject(input)) {
          payload.issues.push({
            expected: "record",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        if (def.keyType._zod.values) {
          const values = def.keyType._zod.values;
          payload.value = {};
          for (const key of values) {
            if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
              const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
              if (result instanceof Promise) {
                proms.push(result.then((result2) => {
                  if (result2.issues.length) {
                    payload.issues.push(...util.prefixIssues(key, result2.issues));
                  }
                  payload.value[key] = result2.value;
                }));
              } else {
                if (result.issues.length) {
                  payload.issues.push(...util.prefixIssues(key, result.issues));
                }
                payload.value[key] = result.value;
              }
            }
          }
          let unrecognized;
          for (const key in input) {
            if (!values.has(key)) {
              unrecognized = unrecognized ?? [];
              unrecognized.push(key);
            }
          }
          if (unrecognized && unrecognized.length > 0) {
            payload.issues.push({
              code: "unrecognized_keys",
              input,
              inst,
              keys: unrecognized
            });
          }
        } else {
          payload.value = {};
          for (const key of Reflect.ownKeys(input)) {
            if (key === "__proto__")
              continue;
            const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
            if (keyResult instanceof Promise) {
              throw new Error("Async schemas not supported in object keys currently");
            }
            if (keyResult.issues.length) {
              payload.issues.push({
                code: "invalid_key",
                origin: "record",
                issues: keyResult.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),
                input: key,
                path: [key],
                inst
              });
              payload.value[keyResult.value] = keyResult.value;
              continue;
            }
            const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => {
                if (result2.issues.length) {
                  payload.issues.push(...util.prefixIssues(key, result2.issues));
                }
                payload.value[keyResult.value] = result2.value;
              }));
            } else {
              if (result.issues.length) {
                payload.issues.push(...util.prefixIssues(key, result.issues));
              }
              payload.value[keyResult.value] = result.value;
            }
          }
        }
        if (proms.length) {
          return Promise.all(proms).then(() => payload);
        }
        return payload;
      };
    });
    exports2.$ZodMap = core.$constructor("$ZodMap", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Map)) {
          payload.issues.push({
            expected: "map",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        payload.value = /* @__PURE__ */ new Map();
        for (const [key, value] of input) {
          const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
          const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
          if (keyResult instanceof Promise || valueResult instanceof Promise) {
            proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
              handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
            }));
          } else {
            handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
          }
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
      if (keyResult.issues.length) {
        if (util.propertyKeyTypes.has(typeof key)) {
          final.issues.push(...util.prefixIssues(key, keyResult.issues));
        } else {
          final.issues.push({
            code: "invalid_key",
            origin: "map",
            input,
            inst,
            issues: keyResult.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))
          });
        }
      }
      if (valueResult.issues.length) {
        if (util.propertyKeyTypes.has(typeof key)) {
          final.issues.push(...util.prefixIssues(key, valueResult.issues));
        } else {
          final.issues.push({
            origin: "map",
            code: "invalid_element",
            input,
            inst,
            key,
            issues: valueResult.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))
          });
        }
      }
      final.value.set(keyResult.value, valueResult.value);
    }
    exports2.$ZodSet = core.$constructor("$ZodSet", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Set)) {
          payload.issues.push({
            input,
            inst,
            expected: "set",
            code: "invalid_type"
          });
          return payload;
        }
        const proms = [];
        payload.value = /* @__PURE__ */ new Set();
        for (const item of input) {
          const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleSetResult(result2, payload)));
          } else
            handleSetResult(result, payload);
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    function handleSetResult(result, final) {
      if (result.issues.length) {
        final.issues.push(...result.issues);
      }
      final.value.add(result.value);
    }
    exports2.$ZodEnum = core.$constructor("$ZodEnum", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      const values = util.getEnumValues(def.entries);
      const valuesSet = new Set(values);
      inst._zod.values = valuesSet;
      inst._zod.pattern = new RegExp(`^(${values.filter((k) => util.propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? util.escapeRegex(o) : o.toString()).join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (valuesSet.has(input)) {
          return payload;
        }
        payload.issues.push({
          code: "invalid_value",
          values,
          input,
          inst
        });
        return payload;
      };
    });
    exports2.$ZodLiteral = core.$constructor("$ZodLiteral", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      if (def.values.length === 0) {
        throw new Error("Cannot create literal schema with no valid values");
      }
      inst._zod.values = new Set(def.values);
      inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? util.escapeRegex(o) : o ? util.escapeRegex(o.toString()) : String(o)).join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (inst._zod.values.has(input)) {
          return payload;
        }
        payload.issues.push({
          code: "invalid_value",
          values: def.values,
          input,
          inst
        });
        return payload;
      };
    });
    exports2.$ZodFile = core.$constructor("$ZodFile", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (input instanceof File)
          return payload;
        payload.issues.push({
          expected: "file",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    exports2.$ZodTransform = core.$constructor("$ZodTransform", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          throw new core.$ZodEncodeError(inst.constructor.name);
        }
        const _out = def.transform(payload.value, payload);
        if (ctx.async) {
          const output = _out instanceof Promise ? _out : Promise.resolve(_out);
          return output.then((output2) => {
            payload.value = output2;
            return payload;
          });
        }
        if (_out instanceof Promise) {
          throw new core.$ZodAsyncError();
        }
        payload.value = _out;
        return payload;
      };
    });
    function handleOptionalResult(result, input) {
      if (result.issues.length && input === void 0) {
        return { issues: [], value: void 0 };
      }
      return result;
    }
    exports2.$ZodOptional = core.$constructor("$ZodOptional", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.optin = "optional";
      inst._zod.optout = "optional";
      util.defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
      });
      util.defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${util.cleanRegex(pattern.source)})?$`) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        if (def.innerType._zod.optin === "optional") {
          const result = def.innerType._zod.run(payload, ctx);
          if (result instanceof Promise)
            return result.then((r) => handleOptionalResult(r, payload.value));
          return handleOptionalResult(result, payload.value);
        }
        if (payload.value === void 0) {
          return payload;
        }
        return def.innerType._zod.run(payload, ctx);
      };
    });
    exports2.$ZodNullable = core.$constructor("$ZodNullable", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      util.defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      util.defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      util.defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${util.cleanRegex(pattern.source)}|null)$`) : void 0;
      });
      util.defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        if (payload.value === null)
          return payload;
        return def.innerType._zod.run(payload, ctx);
      };
    });
    exports2.$ZodDefault = core.$constructor("$ZodDefault", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.optin = "optional";
      util.defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        if (payload.value === void 0) {
          payload.value = def.defaultValue;
          return payload;
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => handleDefaultResult(result2, def));
        }
        return handleDefaultResult(result, def);
      };
    });
    function handleDefaultResult(payload, def) {
      if (payload.value === void 0) {
        payload.value = def.defaultValue;
      }
      return payload;
    }
    exports2.$ZodPrefault = core.$constructor("$ZodPrefault", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.optin = "optional";
      util.defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        if (payload.value === void 0) {
          payload.value = def.defaultValue;
        }
        return def.innerType._zod.run(payload, ctx);
      };
    });
    exports2.$ZodNonOptional = core.$constructor("$ZodNonOptional", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      util.defineLazy(inst._zod, "values", () => {
        const v = def.innerType._zod.values;
        return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => handleNonOptionalResult(result2, inst));
        }
        return handleNonOptionalResult(result, inst);
      };
    });
    function handleNonOptionalResult(payload, inst) {
      if (!payload.issues.length && payload.value === void 0) {
        payload.issues.push({
          code: "invalid_type",
          expected: "nonoptional",
          input: payload.value,
          inst
        });
      }
      return payload;
    }
    exports2.$ZodSuccess = core.$constructor("$ZodSuccess", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          throw new core.$ZodEncodeError("ZodSuccess");
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => {
            payload.value = result2.issues.length === 0;
            return payload;
          });
        }
        payload.value = result.issues.length === 0;
        return payload;
      };
    });
    exports2.$ZodCatch = core.$constructor("$ZodCatch", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      util.defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      util.defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      util.defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => {
            payload.value = result2.value;
            if (result2.issues.length) {
              payload.value = def.catchValue({
                ...payload,
                error: {
                  issues: result2.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))
                },
                input: payload.value
              });
              payload.issues = [];
            }
            return payload;
          });
        }
        payload.value = result.value;
        if (result.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      };
    });
    exports2.$ZodNaN = core.$constructor("$ZodNaN", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
          payload.issues.push({
            input: payload.value,
            inst,
            expected: "nan",
            code: "invalid_type"
          });
          return payload;
        }
        return payload;
      };
    });
    exports2.$ZodPipe = core.$constructor("$ZodPipe", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      util.defineLazy(inst._zod, "values", () => def.in._zod.values);
      util.defineLazy(inst._zod, "optin", () => def.in._zod.optin);
      util.defineLazy(inst._zod, "optout", () => def.out._zod.optout);
      util.defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          const right = def.out._zod.run(payload, ctx);
          if (right instanceof Promise) {
            return right.then((right2) => handlePipeResult(right2, def.in, ctx));
          }
          return handlePipeResult(right, def.in, ctx);
        }
        const left = def.in._zod.run(payload, ctx);
        if (left instanceof Promise) {
          return left.then((left2) => handlePipeResult(left2, def.out, ctx));
        }
        return handlePipeResult(left, def.out, ctx);
      };
    });
    function handlePipeResult(left, next, ctx) {
      if (left.issues.length) {
        left.aborted = true;
        return left;
      }
      return next._zod.run({ value: left.value, issues: left.issues }, ctx);
    }
    exports2.$ZodCodec = core.$constructor("$ZodCodec", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      util.defineLazy(inst._zod, "values", () => def.in._zod.values);
      util.defineLazy(inst._zod, "optin", () => def.in._zod.optin);
      util.defineLazy(inst._zod, "optout", () => def.out._zod.optout);
      util.defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
      inst._zod.parse = (payload, ctx) => {
        const direction = ctx.direction || "forward";
        if (direction === "forward") {
          const left = def.in._zod.run(payload, ctx);
          if (left instanceof Promise) {
            return left.then((left2) => handleCodecAResult(left2, def, ctx));
          }
          return handleCodecAResult(left, def, ctx);
        } else {
          const right = def.out._zod.run(payload, ctx);
          if (right instanceof Promise) {
            return right.then((right2) => handleCodecAResult(right2, def, ctx));
          }
          return handleCodecAResult(right, def, ctx);
        }
      };
    });
    function handleCodecAResult(result, def, ctx) {
      if (result.issues.length) {
        result.aborted = true;
        return result;
      }
      const direction = ctx.direction || "forward";
      if (direction === "forward") {
        const transformed = def.transform(result.value, result);
        if (transformed instanceof Promise) {
          return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
        }
        return handleCodecTxResult(result, transformed, def.out, ctx);
      } else {
        const transformed = def.reverseTransform(result.value, result);
        if (transformed instanceof Promise) {
          return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
        }
        return handleCodecTxResult(result, transformed, def.in, ctx);
      }
    }
    function handleCodecTxResult(left, value, nextSchema, ctx) {
      if (left.issues.length) {
        left.aborted = true;
        return left;
      }
      return nextSchema._zod.run({ value, issues: left.issues }, ctx);
    }
    exports2.$ZodReadonly = core.$constructor("$ZodReadonly", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      util.defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
      util.defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      util.defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      util.defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then(handleReadonlyResult);
        }
        return handleReadonlyResult(result);
      };
    });
    function handleReadonlyResult(payload) {
      payload.value = Object.freeze(payload.value);
      return payload;
    }
    exports2.$ZodTemplateLiteral = core.$constructor("$ZodTemplateLiteral", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      const regexParts = [];
      for (const part of def.parts) {
        if (typeof part === "object" && part !== null) {
          if (!part._zod.pattern) {
            throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
          }
          const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
          if (!source)
            throw new Error(`Invalid template literal part: ${part._zod.traits}`);
          const start = source.startsWith("^") ? 1 : 0;
          const end = source.endsWith("$") ? source.length - 1 : source.length;
          regexParts.push(source.slice(start, end));
        } else if (part === null || util.primitiveTypes.has(typeof part)) {
          regexParts.push(util.escapeRegex(`${part}`));
        } else {
          throw new Error(`Invalid template literal part: ${part}`);
        }
      }
      inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "string") {
          payload.issues.push({
            input: payload.value,
            inst,
            expected: "template_literal",
            code: "invalid_type"
          });
          return payload;
        }
        inst._zod.pattern.lastIndex = 0;
        if (!inst._zod.pattern.test(payload.value)) {
          payload.issues.push({
            input: payload.value,
            inst,
            code: "invalid_format",
            format: def.format ?? "template_literal",
            pattern: inst._zod.pattern.source
          });
          return payload;
        }
        return payload;
      };
    });
    exports2.$ZodFunction = core.$constructor("$ZodFunction", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._def = def;
      inst._zod.def = def;
      inst.implement = (func) => {
        if (typeof func !== "function") {
          throw new Error("implement() must be called with a function");
        }
        return function(...args) {
          const parsedArgs = inst._def.input ? (0, parse_js_1.parse)(inst._def.input, args) : args;
          const result = Reflect.apply(func, this, parsedArgs);
          if (inst._def.output) {
            return (0, parse_js_1.parse)(inst._def.output, result);
          }
          return result;
        };
      };
      inst.implementAsync = (func) => {
        if (typeof func !== "function") {
          throw new Error("implementAsync() must be called with a function");
        }
        return async function(...args) {
          const parsedArgs = inst._def.input ? await (0, parse_js_1.parseAsync)(inst._def.input, args) : args;
          const result = await Reflect.apply(func, this, parsedArgs);
          if (inst._def.output) {
            return await (0, parse_js_1.parseAsync)(inst._def.output, result);
          }
          return result;
        };
      };
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "function") {
          payload.issues.push({
            code: "invalid_type",
            expected: "function",
            input: payload.value,
            inst
          });
          return payload;
        }
        const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
        if (hasPromiseOutput) {
          payload.value = inst.implementAsync(payload.value);
        } else {
          payload.value = inst.implement(payload.value);
        }
        return payload;
      };
      inst.input = (...args) => {
        const F = inst.constructor;
        if (Array.isArray(args[0])) {
          return new F({
            type: "function",
            input: new exports2.$ZodTuple({
              type: "tuple",
              items: args[0],
              rest: args[1]
            }),
            output: inst._def.output
          });
        }
        return new F({
          type: "function",
          input: args[0],
          output: inst._def.output
        });
      };
      inst.output = (output) => {
        const F = inst.constructor;
        return new F({
          type: "function",
          input: inst._def.input,
          output
        });
      };
      return inst;
    });
    exports2.$ZodPromise = core.$constructor("$ZodPromise", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
      };
    });
    exports2.$ZodLazy = core.$constructor("$ZodLazy", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      util.defineLazy(inst._zod, "innerType", () => def.getter());
      util.defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
      util.defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
      util.defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin ?? void 0);
      util.defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout ?? void 0);
      inst._zod.parse = (payload, ctx) => {
        const inner = inst._zod.innerType;
        return inner._zod.run(payload, ctx);
      };
    });
    exports2.$ZodCustom = core.$constructor("$ZodCustom", (inst, def) => {
      checks.$ZodCheck.init(inst, def);
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, _) => {
        return payload;
      };
      inst._zod.check = (payload) => {
        const input = payload.value;
        const r = def.fn(input);
        if (r instanceof Promise) {
          return r.then((r2) => handleRefineResult(r2, payload, input, inst));
        }
        handleRefineResult(r, payload, input, inst);
        return;
      };
    });
    function handleRefineResult(result, payload, input, inst) {
      if (!result) {
        const _iss = {
          code: "custom",
          input,
          inst,
          // incorporates params.error into issue reporting
          path: [...inst._zod.def.path ?? []],
          // incorporates params.error into issue reporting
          continue: !inst._zod.def.abort
          // params: inst._zod.def.params,
        };
        if (inst._zod.def.params)
          _iss.params = inst._zod.def.params;
        payload.issues.push(util.issue(_iss));
      }
    }
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ar.cjs
var require_ar = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ar.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0645\u062F\u062E\u0644",
        email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
        url: "\u0631\u0627\u0628\u0637",
        emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
        ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
        cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
        cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
        base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
        base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
        json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
        e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
        jwt: "JWT",
        template_literal: "\u0645\u062F\u062E\u0644"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${issue.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
            return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
          }
          case "not_multiple_of":
            return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue.divisor}`;
          case "unrecognized_keys":
            return `\u0645\u0639\u0631\u0641${issue.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue.keys.length > 1 ? "\u0629" : ""}: ${util.joinValues(issue.keys, "\u060C ")}`;
          case "invalid_key":
            return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue.origin}`;
          case "invalid_union":
            return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
          case "invalid_element":
            return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue.origin}`;
          default:
            return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/az.cjs
var require_az = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/az.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
        file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
        array: { unit: "element", verb: "olmal\u0131d\u0131r" },
        set: { unit: "element", verb: "olmal\u0131d\u0131r" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "email address",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datetime",
        date: "ISO date",
        time: "ISO time",
        duration: "ISO duration",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded string",
        base64url: "base64url-encoded string",
        json_string: "JSON string",
        e164: "E.164 number",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${issue.expected}, daxil olan ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${util.stringifyPrimitive(issue.values[0])}`;
            return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue.origin ?? "d\u0259y\u0259r"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "element"}`;
            return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue.origin ?? "d\u0259y\u0259r"} ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue.origin} ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
            if (_issue.format === "ends_with")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
            if (_issue.format === "includes")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
            if (_issue.format === "regex")
              return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
            return `Yanl\u0131\u015F ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Yanl\u0131\u015F \u0259d\u0259d: ${issue.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan a\xE7ar${issue.keys.length > 1 ? "lar" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `${issue.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
          case "invalid_union":
            return "Yanl\u0131\u015F d\u0259y\u0259r";
          case "invalid_element":
            return `${issue.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
          default:
            return `Yanl\u0131\u015F d\u0259y\u0259r`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/be.cjs
var require_be = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/be.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    function getBelarusianPlural(count, one, few, many) {
      const absCount = Math.abs(count);
      const lastDigit = absCount % 10;
      const lastTwoDigits = absCount % 100;
      if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
        return many;
      }
      if (lastDigit === 1) {
        return one;
      }
      if (lastDigit >= 2 && lastDigit <= 4) {
        return few;
      }
      return many;
    }
    var error = () => {
      const Sizable = {
        string: {
          unit: {
            one: "\u0441\u0456\u043C\u0432\u0430\u043B",
            few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
            many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        array: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        set: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        file: {
          unit: {
            one: "\u0431\u0430\u0439\u0442",
            few: "\u0431\u0430\u0439\u0442\u044B",
            many: "\u0431\u0430\u0439\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u043B\u0456\u043A";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043C\u0430\u0441\u0456\u045E";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0443\u0432\u043E\u0434",
        email: "email \u0430\u0434\u0440\u0430\u0441",
        url: "URL",
        emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0447\u0430\u0441",
        duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
        ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
        cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
        base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
        base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
        json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
        e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0443\u0432\u043E\u0434"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${issue.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              const maxValue = Number(issue.maximum);
              const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue.maximum.toString()} ${unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              const minValue = Number(issue.minimum);
              const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue.minimum.toString()} ${unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue.origin}`;
          case "invalid_union":
            return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
          case "invalid_element":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue.origin}`;
          default:
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/bg.cjs
var require_bg = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/bg.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parsedType = void 0;
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var parsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "\u043C\u0430\u0441\u0438\u0432";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    exports2.parsedType = parsedType;
    var error = () => {
      const Sizable = {
        string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
        file: { unit: "\u0431\u0430\u0439\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
        array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
        set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "\u0432\u0445\u043E\u0434",
        email: "\u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u0434\u0436\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0432\u0440\u0435\u043C\u0435",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0432\u0440\u0435\u043C\u0435",
        duration: "ISO \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
        cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        base64: "base64-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
        base64url: "base64url-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
        json_string: "JSON \u043D\u0438\u0437",
        e164: "E.164 \u043D\u043E\u043C\u0435\u0440",
        jwt: "JWT",
        template_literal: "\u0432\u0445\u043E\u0434"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${issue.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${(0, exports2.parsedType)(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u043E\u043F\u0446\u0438\u044F: \u043E\u0447\u0430\u043A\u0432\u0430\u043D\u043E \u0435\u0434\u043D\u043E \u043E\u0442 ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430"}`;
            return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue.origin} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue.origin} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u0441 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0432\u043A\u043B\u044E\u0447\u0432\u0430 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0441\u044A\u0432\u043F\u0430\u0434\u0430 \u0441 ${_issue.pattern}`;
            let invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D";
            if (_issue.format === "emoji")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
            if (_issue.format === "datetime")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
            if (_issue.format === "date")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
            if (_issue.format === "time")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
            if (_issue.format === "duration")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
            return `${invalid_adj} ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E \u0447\u0438\u0441\u043B\u043E: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043A\u0440\u0430\u0442\u043D\u043E \u043D\u0430 ${issue.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0437\u043F\u043E\u0437\u043D\u0430\u0442${issue.keys.length > 1 ? "\u0438" : ""} \u043A\u043B\u044E\u0447${issue.keys.length > 1 ? "\u043E\u0432\u0435" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043A\u043B\u044E\u0447 \u0432 ${issue.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434";
          case "invalid_element":
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442 \u0432 ${issue.origin}`;
          default:
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ca.cjs
var require_ca = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ca.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "car\xE0cters", verb: "contenir" },
        file: { unit: "bytes", verb: "contenir" },
        array: { unit: "elements", verb: "contenir" },
        set: { unit: "elements", verb: "contenir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "entrada",
        email: "adre\xE7a electr\xF2nica",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data i hora ISO",
        date: "data ISO",
        time: "hora ISO",
        duration: "durada ISO",
        ipv4: "adre\xE7a IPv4",
        ipv6: "adre\xE7a IPv6",
        cidrv4: "rang IPv4",
        cidrv6: "rang IPv6",
        base64: "cadena codificada en base64",
        base64url: "cadena codificada en base64url",
        json_string: "cadena JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Tipus inv\xE0lid: s'esperava ${issue.expected}, s'ha rebut ${parsedType(issue.input)}`;
          // return `Tipus invlid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Valor inv\xE0lid: s'esperava ${util.stringifyPrimitive(issue.values[0])}`;
            return `Opci\xF3 inv\xE0lida: s'esperava una de ${util.joinValues(issue.values, " o ")}`;
          case "too_big": {
            const adj = issue.inclusive ? "com a m\xE0xim" : "menys de";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Massa gran: s'esperava que ${issue.origin ?? "el valor"} contingu\xE9s ${adj} ${issue.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `Massa gran: s'esperava que ${issue.origin ?? "el valor"} fos ${adj} ${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? "com a m\xEDnim" : "m\xE9s de";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Massa petit: s'esperava que ${issue.origin} contingu\xE9s ${adj} ${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Massa petit: s'esperava que ${issue.origin} fos ${adj} ${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
            return `Format inv\xE0lid per a ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue.divisor}`;
          case "unrecognized_keys":
            return `Clau${issue.keys.length > 1 ? "s" : ""} no reconeguda${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Clau inv\xE0lida a ${issue.origin}`;
          case "invalid_union":
            return "Entrada inv\xE0lida";
          // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
          case "invalid_element":
            return `Element inv\xE0lid a ${issue.origin}`;
          default:
            return `Entrada inv\xE0lida`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/cs.cjs
var require_cs = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/cs.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "znak\u016F", verb: "m\xEDt" },
        file: { unit: "bajt\u016F", verb: "m\xEDt" },
        array: { unit: "prvk\u016F", verb: "m\xEDt" },
        set: { unit: "prvk\u016F", verb: "m\xEDt" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u010D\xEDslo";
          }
          case "string": {
            return "\u0159et\u011Bzec";
          }
          case "boolean": {
            return "boolean";
          }
          case "bigint": {
            return "bigint";
          }
          case "function": {
            return "funkce";
          }
          case "symbol": {
            return "symbol";
          }
          case "undefined": {
            return "undefined";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "pole";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "regul\xE1rn\xED v\xFDraz",
        email: "e-mailov\xE1 adresa",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "datum a \u010Das ve form\xE1tu ISO",
        date: "datum ve form\xE1tu ISO",
        time: "\u010Das ve form\xE1tu ISO",
        duration: "doba trv\xE1n\xED ISO",
        ipv4: "IPv4 adresa",
        ipv6: "IPv6 adresa",
        cidrv4: "rozsah IPv4",
        cidrv6: "rozsah IPv6",
        base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
        base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
        json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
        e164: "\u010D\xEDslo E.164",
        jwt: "JWT",
        template_literal: "vstup"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${issue.expected}, obdr\u017Eeno ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${util.stringifyPrimitive(issue.values[0])}`;
            return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
            }
            return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
            }
            return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
            return `Neplatn\xFD form\xE1t ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue.divisor}`;
          case "unrecognized_keys":
            return `Nezn\xE1m\xE9 kl\xED\u010De: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Neplatn\xFD kl\xED\u010D v ${issue.origin}`;
          case "invalid_union":
            return "Neplatn\xFD vstup";
          case "invalid_element":
            return `Neplatn\xE1 hodnota v ${issue.origin}`;
          default:
            return `Neplatn\xFD vstup`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/da.cjs
var require_da = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/da.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "tegn", verb: "havde" },
        file: { unit: "bytes", verb: "havde" },
        array: { unit: "elementer", verb: "indeholdt" },
        set: { unit: "elementer", verb: "indeholdt" }
      };
      const TypeNames = {
        string: "streng",
        number: "tal",
        boolean: "boolean",
        array: "liste",
        object: "objekt",
        set: "s\xE6t",
        file: "fil"
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      function getTypeName(type) {
        return TypeNames[type] ?? type;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "tal";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "liste";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
            return "objekt";
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "e-mailadresse",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dato- og klokkesl\xE6t",
        date: "ISO-dato",
        time: "ISO-klokkesl\xE6t",
        duration: "ISO-varighed",
        ipv4: "IPv4-omr\xE5de",
        ipv6: "IPv6-omr\xE5de",
        cidrv4: "IPv4-spektrum",
        cidrv6: "IPv6-spektrum",
        base64: "base64-kodet streng",
        base64url: "base64url-kodet streng",
        json_string: "JSON-streng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Ugyldigt input: forventede ${getTypeName(issue.expected)}, fik ${getTypeName(parsedType(issue.input))}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Ugyldig v\xE6rdi: forventede ${util.stringifyPrimitive(issue.values[0])}`;
            return `Ugyldigt valg: forventede en af f\xF8lgende ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            const origin = getTypeName(issue.origin);
            if (sizing)
              return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? "elementer"}`;
            return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            const origin = getTypeName(issue.origin);
            if (sizing) {
              return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `For lille: forventede ${origin} havde ${adj} ${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
            return `Ugyldig ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Ugyldigt tal: skal v\xE6re deleligt med ${issue.divisor}`;
          case "unrecognized_keys":
            return `${issue.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Ugyldig n\xF8gle i ${issue.origin}`;
          case "invalid_union":
            return "Ugyldigt input: matcher ingen af de tilladte typer";
          case "invalid_element":
            return `Ugyldig v\xE6rdi i ${issue.origin}`;
          default:
            return `Ugyldigt input`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/de.cjs
var require_de = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/de.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "Zeichen", verb: "zu haben" },
        file: { unit: "Bytes", verb: "zu haben" },
        array: { unit: "Elemente", verb: "zu haben" },
        set: { unit: "Elemente", verb: "zu haben" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "Zahl";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "Array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "Eingabe",
        email: "E-Mail-Adresse",
        url: "URL",
        emoji: "Emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-Datum und -Uhrzeit",
        date: "ISO-Datum",
        time: "ISO-Uhrzeit",
        duration: "ISO-Dauer",
        ipv4: "IPv4-Adresse",
        ipv6: "IPv6-Adresse",
        cidrv4: "IPv4-Bereich",
        cidrv6: "IPv6-Bereich",
        base64: "Base64-codierter String",
        base64url: "Base64-URL-codierter String",
        json_string: "JSON-String",
        e164: "E.164-Nummer",
        jwt: "JWT",
        template_literal: "Eingabe"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Ung\xFCltige Eingabe: erwartet ${issue.expected}, erhalten ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Ung\xFCltige Eingabe: erwartet ${util.stringifyPrimitive(issue.values[0])}`;
            return `Ung\xFCltige Option: erwartet eine von ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Zu gro\xDF: erwartet, dass ${issue.origin ?? "Wert"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
            return `Zu gro\xDF: erwartet, dass ${issue.origin ?? "Wert"} ${adj}${issue.maximum.toString()} ist`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Zu klein: erwartet, dass ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit} hat`;
            }
            return `Zu klein: erwartet, dass ${issue.origin} ${adj}${issue.minimum.toString()} ist`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
            if (_issue.format === "ends_with")
              return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
            if (_issue.format === "includes")
              return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
            if (_issue.format === "regex")
              return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
            return `Ung\xFCltig: ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue.divisor} sein`;
          case "unrecognized_keys":
            return `${issue.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Ung\xFCltiger Schl\xFCssel in ${issue.origin}`;
          case "invalid_union":
            return "Ung\xFCltige Eingabe";
          case "invalid_element":
            return `Ung\xFCltiger Wert in ${issue.origin}`;
          default:
            return `Ung\xFCltige Eingabe`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/en.cjs
var require_en2 = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/en.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parsedType = void 0;
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var parsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    exports2.parsedType = parsedType;
    var error = () => {
      const Sizable = {
        string: { unit: "characters", verb: "to have" },
        file: { unit: "bytes", verb: "to have" },
        array: { unit: "items", verb: "to have" },
        set: { unit: "items", verb: "to have" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "input",
        email: "email address",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datetime",
        date: "ISO date",
        time: "ISO time",
        duration: "ISO duration",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded string",
        base64url: "base64url-encoded string",
        json_string: "JSON string",
        e164: "E.164 number",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Invalid input: expected ${issue.expected}, received ${(0, exports2.parsedType)(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Invalid input: expected ${util.stringifyPrimitive(issue.values[0])}`;
            return `Invalid option: expected one of ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Too big: expected ${issue.origin ?? "value"} to have ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `Too big: expected ${issue.origin ?? "value"} to be ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Too small: expected ${issue.origin} to have ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Too small: expected ${issue.origin} to be ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `Invalid string: must start with "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Invalid string: must end with "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Invalid string: must include "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Invalid string: must match pattern ${_issue.pattern}`;
            return `Invalid ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Invalid number: must be a multiple of ${issue.divisor}`;
          case "unrecognized_keys":
            return `Unrecognized key${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Invalid key in ${issue.origin}`;
          case "invalid_union":
            return "Invalid input";
          case "invalid_element":
            return `Invalid value in ${issue.origin}`;
          default:
            return `Invalid input`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/eo.cjs
var require_eo = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/eo.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parsedType = void 0;
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var parsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "nombro";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "tabelo";
          }
          if (data === null) {
            return "senvalora";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    exports2.parsedType = parsedType;
    var error = () => {
      const Sizable = {
        string: { unit: "karaktrojn", verb: "havi" },
        file: { unit: "bajtojn", verb: "havi" },
        array: { unit: "elementojn", verb: "havi" },
        set: { unit: "elementojn", verb: "havi" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "enigo",
        email: "retadreso",
        url: "URL",
        emoji: "emo\u011Dio",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-datotempo",
        date: "ISO-dato",
        time: "ISO-tempo",
        duration: "ISO-da\u016Dro",
        ipv4: "IPv4-adreso",
        ipv6: "IPv6-adreso",
        cidrv4: "IPv4-rango",
        cidrv6: "IPv6-rango",
        base64: "64-ume kodita karaktraro",
        base64url: "URL-64-ume kodita karaktraro",
        json_string: "JSON-karaktraro",
        e164: "E.164-nombro",
        jwt: "JWT",
        template_literal: "enigo"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Nevalida enigo: atendi\u011Dis ${issue.expected}, ricevi\u011Dis ${(0, exports2.parsedType)(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Nevalida enigo: atendi\u011Dis ${util.stringifyPrimitive(issue.values[0])}`;
            return `Nevalida opcio: atendi\u011Dis unu el ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Tro granda: atendi\u011Dis ke ${issue.origin ?? "valoro"} havu ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
            return `Tro granda: atendi\u011Dis ke ${issue.origin ?? "valoro"} havu ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Tro malgranda: atendi\u011Dis ke ${issue.origin} havu ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Tro malgranda: atendi\u011Dis ke ${issue.origin} estu ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
            return `Nevalida ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Nevalida nombro: devas esti oblo de ${issue.divisor}`;
          case "unrecognized_keys":
            return `Nekonata${issue.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue.keys.length > 1 ? "j" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Nevalida \u015Dlosilo en ${issue.origin}`;
          case "invalid_union":
            return "Nevalida enigo";
          case "invalid_element":
            return `Nevalida valoro en ${issue.origin}`;
          default:
            return `Nevalida enigo`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/es.cjs
var require_es = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/es.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "caracteres", verb: "tener" },
        file: { unit: "bytes", verb: "tener" },
        array: { unit: "elementos", verb: "tener" },
        set: { unit: "elementos", verb: "tener" }
      };
      const TypeNames = {
        string: "texto",
        number: "n\xFAmero",
        boolean: "booleano",
        array: "arreglo",
        object: "objeto",
        set: "conjunto",
        file: "archivo",
        date: "fecha",
        bigint: "n\xFAmero grande",
        symbol: "s\xEDmbolo",
        undefined: "indefinido",
        null: "nulo",
        function: "funci\xF3n",
        map: "mapa",
        record: "registro",
        tuple: "tupla",
        enum: "enumeraci\xF3n",
        union: "uni\xF3n",
        literal: "literal",
        promise: "promesa",
        void: "vac\xEDo",
        never: "nunca",
        unknown: "desconocido",
        any: "cualquiera"
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      function getTypeName(type) {
        return TypeNames[type] ?? type;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype) {
              return data.constructor.name;
            }
            return "object";
          }
        }
        return t;
      };
      const Nouns = {
        regex: "entrada",
        email: "direcci\xF3n de correo electr\xF3nico",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "fecha y hora ISO",
        date: "fecha ISO",
        time: "hora ISO",
        duration: "duraci\xF3n ISO",
        ipv4: "direcci\xF3n IPv4",
        ipv6: "direcci\xF3n IPv6",
        cidrv4: "rango IPv4",
        cidrv6: "rango IPv6",
        base64: "cadena codificada en base64",
        base64url: "URL codificada en base64",
        json_string: "cadena JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Entrada inv\xE1lida: se esperaba ${getTypeName(issue.expected)}, recibido ${getTypeName(parsedType(issue.input))}`;
          // return `Entrada invlida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Entrada inv\xE1lida: se esperaba ${util.stringifyPrimitive(issue.values[0])}`;
            return `Opci\xF3n inv\xE1lida: se esperaba una de ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            const origin = getTypeName(issue.origin);
            if (sizing)
              return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementos"}`;
            return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            const origin = getTypeName(issue.origin);
            if (sizing) {
              return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
            return `Inv\xE1lido ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue.divisor}`;
          case "unrecognized_keys":
            return `Llave${issue.keys.length > 1 ? "s" : ""} desconocida${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Llave inv\xE1lida en ${getTypeName(issue.origin)}`;
          case "invalid_union":
            return "Entrada inv\xE1lida";
          case "invalid_element":
            return `Valor inv\xE1lido en ${getTypeName(issue.origin)}`;
          default:
            return `Entrada inv\xE1lida`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/fa.cjs
var require_fa = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/fa.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0622\u0631\u0627\u06CC\u0647";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0648\u0631\u0648\u062F\u06CC",
        email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
        url: "URL",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
        time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        ipv4: "IPv4 \u0622\u062F\u0631\u0633",
        ipv6: "IPv6 \u0622\u062F\u0631\u0633",
        cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
        cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
        base64: "base64-encoded \u0631\u0634\u062A\u0647",
        base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
        json_string: "JSON \u0631\u0634\u062A\u0647",
        e164: "E.164 \u0639\u062F\u062F",
        jwt: "JWT",
        template_literal: "\u0648\u0631\u0648\u062F\u06CC"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${issue.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${parsedType(issue.input)} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
          case "invalid_value":
            if (issue.values.length === 1) {
              return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${util.stringifyPrimitive(issue.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
            }
            return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${util.joinValues(issue.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
            }
            return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue.maximum.toString()} \u0628\u0627\u0634\u062F`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue.origin} \u0628\u0627\u06CC\u062F ${adj}${issue.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
            }
            return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue.origin} \u0628\u0627\u06CC\u062F ${adj}${issue.minimum.toString()} \u0628\u0627\u0634\u062F`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
            }
            if (_issue.format === "ends_with") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
            }
            if (_issue.format === "includes") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
            }
            if (_issue.format === "regex") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
            }
            return `${Nouns[_issue.format] ?? issue.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
          }
          case "not_multiple_of":
            return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue.divisor} \u0628\u0627\u0634\u062F`;
          case "unrecognized_keys":
            return `\u06A9\u0644\u06CC\u062F${issue.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue.origin}`;
          case "invalid_union":
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
          case "invalid_element":
            return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue.origin}`;
          default:
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/fi.cjs
var require_fi = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/fi.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "merkki\xE4", subject: "merkkijonon" },
        file: { unit: "tavua", subject: "tiedoston" },
        array: { unit: "alkiota", subject: "listan" },
        set: { unit: "alkiota", subject: "joukon" },
        number: { unit: "", subject: "luvun" },
        bigint: { unit: "", subject: "suuren kokonaisluvun" },
        int: { unit: "", subject: "kokonaisluvun" },
        date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "s\xE4\xE4nn\xF6llinen lauseke",
        email: "s\xE4hk\xF6postiosoite",
        url: "URL-osoite",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-aikaleima",
        date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
        time: "ISO-aika",
        duration: "ISO-kesto",
        ipv4: "IPv4-osoite",
        ipv6: "IPv6-osoite",
        cidrv4: "IPv4-alue",
        cidrv6: "IPv6-alue",
        base64: "base64-koodattu merkkijono",
        base64url: "base64url-koodattu merkkijono",
        json_string: "JSON-merkkijono",
        e164: "E.164-luku",
        jwt: "JWT",
        template_literal: "templaattimerkkijono"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Virheellinen tyyppi: odotettiin ${issue.expected}, oli ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Virheellinen sy\xF6te: t\xE4ytyy olla ${util.stringifyPrimitive(issue.values[0])}`;
            return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue.maximum.toString()} ${sizing.unit}`.trim();
            }
            return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue.minimum.toString()} ${sizing.unit}`.trim();
            }
            return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
            if (_issue.format === "regex") {
              return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
            }
            return `Virheellinen ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Virheellinen luku: t\xE4ytyy olla luvun ${issue.divisor} monikerta`;
          case "unrecognized_keys":
            return `${issue.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return "Virheellinen avain tietueessa";
          case "invalid_union":
            return "Virheellinen unioni";
          case "invalid_element":
            return "Virheellinen arvo joukossa";
          default:
            return `Virheellinen sy\xF6te`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/fr.cjs
var require_fr = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/fr.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "caract\xE8res", verb: "avoir" },
        file: { unit: "octets", verb: "avoir" },
        array: { unit: "\xE9l\xE9ments", verb: "avoir" },
        set: { unit: "\xE9l\xE9ments", verb: "avoir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "nombre";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "tableau";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "entr\xE9e",
        email: "adresse e-mail",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "date et heure ISO",
        date: "date ISO",
        time: "heure ISO",
        duration: "dur\xE9e ISO",
        ipv4: "adresse IPv4",
        ipv6: "adresse IPv6",
        cidrv4: "plage IPv4",
        cidrv6: "plage IPv6",
        base64: "cha\xEEne encod\xE9e en base64",
        base64url: "cha\xEEne encod\xE9e en base64url",
        json_string: "cha\xEEne JSON",
        e164: "num\xE9ro E.164",
        jwt: "JWT",
        template_literal: "entr\xE9e"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Entr\xE9e invalide : ${issue.expected} attendu, ${parsedType(issue.input)} re\xE7u`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Entr\xE9e invalide : ${util.stringifyPrimitive(issue.values[0])} attendu`;
            return `Option invalide : une valeur parmi ${util.joinValues(issue.values, "|")} attendue`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Trop grand : ${issue.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
            return `Trop grand : ${issue.origin ?? "valeur"} doit \xEAtre ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Trop petit : ${issue.origin} doit ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Trop petit : ${issue.origin} doit \xEAtre ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue.format} invalide`;
          }
          case "not_multiple_of":
            return `Nombre invalide : doit \xEAtre un multiple de ${issue.divisor}`;
          case "unrecognized_keys":
            return `Cl\xE9${issue.keys.length > 1 ? "s" : ""} non reconnue${issue.keys.length > 1 ? "s" : ""} : ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Cl\xE9 invalide dans ${issue.origin}`;
          case "invalid_union":
            return "Entr\xE9e invalide";
          case "invalid_element":
            return `Valeur invalide dans ${issue.origin}`;
          default:
            return `Entr\xE9e invalide`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/fr-CA.cjs
var require_fr_CA = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/fr-CA.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "caract\xE8res", verb: "avoir" },
        file: { unit: "octets", verb: "avoir" },
        array: { unit: "\xE9l\xE9ments", verb: "avoir" },
        set: { unit: "\xE9l\xE9ments", verb: "avoir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "entr\xE9e",
        email: "adresse courriel",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "date-heure ISO",
        date: "date ISO",
        time: "heure ISO",
        duration: "dur\xE9e ISO",
        ipv4: "adresse IPv4",
        ipv6: "adresse IPv6",
        cidrv4: "plage IPv4",
        cidrv6: "plage IPv6",
        base64: "cha\xEEne encod\xE9e en base64",
        base64url: "cha\xEEne encod\xE9e en base64url",
        json_string: "cha\xEEne JSON",
        e164: "num\xE9ro E.164",
        jwt: "JWT",
        template_literal: "entr\xE9e"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Entr\xE9e invalide : attendu ${issue.expected}, re\xE7u ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Entr\xE9e invalide : attendu ${util.stringifyPrimitive(issue.values[0])}`;
            return `Option invalide : attendu l'une des valeurs suivantes ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "\u2264" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Trop grand : attendu que ${issue.origin ?? "la valeur"} ait ${adj}${issue.maximum.toString()} ${sizing.unit}`;
            return `Trop grand : attendu que ${issue.origin ?? "la valeur"} soit ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? "\u2265" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Trop petit : attendu que ${issue.origin} ait ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Trop petit : attendu que ${issue.origin} soit ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue.format} invalide`;
          }
          case "not_multiple_of":
            return `Nombre invalide : doit \xEAtre un multiple de ${issue.divisor}`;
          case "unrecognized_keys":
            return `Cl\xE9${issue.keys.length > 1 ? "s" : ""} non reconnue${issue.keys.length > 1 ? "s" : ""} : ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Cl\xE9 invalide dans ${issue.origin}`;
          case "invalid_union":
            return "Entr\xE9e invalide";
          case "invalid_element":
            return `Valeur invalide dans ${issue.origin}`;
          default:
            return `Entr\xE9e invalide`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/he.cjs
var require_he = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/he.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
        file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
        array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
        set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u05E7\u05DC\u05D8",
        email: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC",
        url: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA",
        emoji: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO",
        date: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO",
        time: "\u05D6\u05DE\u05DF ISO",
        duration: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO",
        ipv4: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4",
        ipv6: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6",
        cidrv4: "\u05D8\u05D5\u05D5\u05D7 IPv4",
        cidrv6: "\u05D8\u05D5\u05D5\u05D7 IPv6",
        base64: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64",
        base64url: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA",
        json_string: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON",
        e164: "\u05DE\u05E1\u05E4\u05E8 E.164",
        jwt: "JWT",
        template_literal: "\u05E7\u05DC\u05D8"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${issue.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${parsedType(issue.input)}`;
          // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05D0\u05D7\u05EA \u05DE\u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA  ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1"${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue.format} \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
          }
          case "not_multiple_of":
            return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue.divisor}`;
          case "unrecognized_keys":
            return `\u05DE\u05E4\u05EA\u05D7${issue.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\u05DE\u05E4\u05EA\u05D7 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue.origin}`;
          case "invalid_union":
            return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
          case "invalid_element":
            return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue.origin}`;
          default:
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/hu.cjs
var require_hu = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/hu.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "legyen" },
        file: { unit: "byte", verb: "legyen" },
        array: { unit: "elem", verb: "legyen" },
        set: { unit: "elem", verb: "legyen" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "sz\xE1m";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "t\xF6mb";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "bemenet",
        email: "email c\xEDm",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO id\u0151b\xE9lyeg",
        date: "ISO d\xE1tum",
        time: "ISO id\u0151",
        duration: "ISO id\u0151intervallum",
        ipv4: "IPv4 c\xEDm",
        ipv6: "IPv6 c\xEDm",
        cidrv4: "IPv4 tartom\xE1ny",
        cidrv6: "IPv6 tartom\xE1ny",
        base64: "base64-k\xF3dolt string",
        base64url: "base64url-k\xF3dolt string",
        json_string: "JSON string",
        e164: "E.164 sz\xE1m",
        jwt: "JWT",
        template_literal: "bemenet"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${issue.expected}, a kapott \xE9rt\xE9k ${parsedType(issue.input)}`;
          // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${util.stringifyPrimitive(issue.values[0])}`;
            return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `T\xFAl nagy: ${issue.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elem"}`;
            return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue.origin} m\xE9rete t\xFAl kicsi ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue.origin} t\xFAl kicsi ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
            if (_issue.format === "ends_with")
              return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
            if (_issue.format === "includes")
              return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
            if (_issue.format === "regex")
              return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
            return `\xC9rv\xE9nytelen ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\xC9rv\xE9nytelen sz\xE1m: ${issue.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
          case "unrecognized_keys":
            return `Ismeretlen kulcs${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\xC9rv\xE9nytelen kulcs ${issue.origin}`;
          case "invalid_union":
            return "\xC9rv\xE9nytelen bemenet";
          case "invalid_element":
            return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue.origin}`;
          default:
            return `\xC9rv\xE9nytelen bemenet`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/id.cjs
var require_id = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/id.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "memiliki" },
        file: { unit: "byte", verb: "memiliki" },
        array: { unit: "item", verb: "memiliki" },
        set: { unit: "item", verb: "memiliki" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "alamat email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "tanggal dan waktu format ISO",
        date: "tanggal format ISO",
        time: "jam format ISO",
        duration: "durasi format ISO",
        ipv4: "alamat IPv4",
        ipv6: "alamat IPv6",
        cidrv4: "rentang alamat IPv4",
        cidrv6: "rentang alamat IPv6",
        base64: "string dengan enkode base64",
        base64url: "string dengan enkode base64url",
        json_string: "string JSON",
        e164: "angka E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Input tidak valid: diharapkan ${issue.expected}, diterima ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Input tidak valid: diharapkan ${util.stringifyPrimitive(issue.values[0])}`;
            return `Pilihan tidak valid: diharapkan salah satu dari ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Terlalu besar: diharapkan ${issue.origin ?? "value"} memiliki ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elemen"}`;
            return `Terlalu besar: diharapkan ${issue.origin ?? "value"} menjadi ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Terlalu kecil: diharapkan ${issue.origin} memiliki ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Terlalu kecil: diharapkan ${issue.origin} menjadi ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `String tidak valid: harus menyertakan "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue.format} tidak valid`;
          }
          case "not_multiple_of":
            return `Angka tidak valid: harus kelipatan dari ${issue.divisor}`;
          case "unrecognized_keys":
            return `Kunci tidak dikenali ${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Kunci tidak valid di ${issue.origin}`;
          case "invalid_union":
            return "Input tidak valid";
          case "invalid_element":
            return `Nilai tidak valid di ${issue.origin}`;
          default:
            return `Input tidak valid`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/is.cjs
var require_is = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/is.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parsedType = void 0;
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var parsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "n\xFAmer";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "fylki";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    exports2.parsedType = parsedType;
    var error = () => {
      const Sizable = {
        string: { unit: "stafi", verb: "a\xF0 hafa" },
        file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
        array: { unit: "hluti", verb: "a\xF0 hafa" },
        set: { unit: "hluti", verb: "a\xF0 hafa" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "gildi",
        email: "netfang",
        url: "vefsl\xF3\xF0",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dagsetning og t\xEDmi",
        date: "ISO dagsetning",
        time: "ISO t\xEDmi",
        duration: "ISO t\xEDmalengd",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded strengur",
        base64url: "base64url-encoded strengur",
        json_string: "JSON strengur",
        e164: "E.164 t\xF6lugildi",
        jwt: "JWT",
        template_literal: "gildi"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Rangt gildi: \xDE\xFA sl\xF3st inn ${(0, exports2.parsedType)(issue.input)} \xFEar sem \xE1 a\xF0 vera ${issue.expected}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Rangt gildi: gert r\xE1\xF0 fyrir ${util.stringifyPrimitive(issue.values[0])}`;
            return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue.origin ?? "gildi"} hafi ${adj}${issue.maximum.toString()} ${sizing.unit ?? "hluti"}`;
            return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue.origin ?? "gildi"} s\xE9 ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue.origin} hafi ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue.origin} s\xE9 ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
            return `Rangt ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue.divisor}`;
          case "unrecognized_keys":
            return `\xD3\xFEekkt ${issue.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Rangur lykill \xED ${issue.origin}`;
          case "invalid_union":
            return "Rangt gildi";
          case "invalid_element":
            return `Rangt gildi \xED ${issue.origin}`;
          default:
            return `Rangt gildi`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/it.cjs
var require_it = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/it.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "caratteri", verb: "avere" },
        file: { unit: "byte", verb: "avere" },
        array: { unit: "elementi", verb: "avere" },
        set: { unit: "elementi", verb: "avere" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "numero";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "vettore";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "indirizzo email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data e ora ISO",
        date: "data ISO",
        time: "ora ISO",
        duration: "durata ISO",
        ipv4: "indirizzo IPv4",
        ipv6: "indirizzo IPv6",
        cidrv4: "intervallo IPv4",
        cidrv6: "intervallo IPv6",
        base64: "stringa codificata in base64",
        base64url: "URL codificata in base64",
        json_string: "stringa JSON",
        e164: "numero E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Input non valido: atteso ${issue.expected}, ricevuto ${parsedType(issue.input)}`;
          // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Input non valido: atteso ${util.stringifyPrimitive(issue.values[0])}`;
            return `Opzione non valida: atteso uno tra ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Troppo grande: ${issue.origin ?? "valore"} deve avere ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementi"}`;
            return `Troppo grande: ${issue.origin ?? "valore"} deve essere ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Troppo piccolo: ${issue.origin} deve avere ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Troppo piccolo: ${issue.origin} deve essere ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Stringa non valida: deve includere "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
            return `Invalid ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Numero non valido: deve essere un multiplo di ${issue.divisor}`;
          case "unrecognized_keys":
            return `Chiav${issue.keys.length > 1 ? "i" : "e"} non riconosciut${issue.keys.length > 1 ? "e" : "a"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Chiave non valida in ${issue.origin}`;
          case "invalid_union":
            return "Input non valido";
          case "invalid_element":
            return `Valore non valido in ${issue.origin}`;
          default:
            return `Input non valido`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ja.cjs
var require_ja = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ja.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
        file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
        array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
        set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u6570\u5024";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u914D\u5217";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u5165\u529B\u5024",
        email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
        url: "URL",
        emoji: "\u7D75\u6587\u5B57",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO\u65E5\u6642",
        date: "ISO\u65E5\u4ED8",
        time: "ISO\u6642\u523B",
        duration: "ISO\u671F\u9593",
        ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
        ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
        cidrv4: "IPv4\u7BC4\u56F2",
        cidrv6: "IPv6\u7BC4\u56F2",
        base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
        base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
        json_string: "JSON\u6587\u5B57\u5217",
        e164: "E.164\u756A\u53F7",
        jwt: "JWT",
        template_literal: "\u5165\u529B\u5024"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u7121\u52B9\u306A\u5165\u529B: ${issue.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${parsedType(issue.input)}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u7121\u52B9\u306A\u5165\u529B: ${util.stringifyPrimitive(issue.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
            return `\u7121\u52B9\u306A\u9078\u629E: ${util.joinValues(issue.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          case "too_big": {
            const adj = issue.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue.origin ?? "\u5024"}\u306F${issue.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue.origin ?? "\u5024"}\u306F${issue.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          }
          case "too_small": {
            const adj = issue.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue.origin}\u306F${issue.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue.origin}\u306F${issue.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "ends_with")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "includes")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "regex")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u7121\u52B9\u306A${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u7121\u52B9\u306A\u6570\u5024: ${issue.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          case "unrecognized_keys":
            return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue.keys.length > 1 ? "\u7FA4" : ""}: ${util.joinValues(issue.keys, "\u3001")}`;
          case "invalid_key":
            return `${issue.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
          case "invalid_union":
            return "\u7121\u52B9\u306A\u5165\u529B";
          case "invalid_element":
            return `${issue.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
          default:
            return `\u7121\u52B9\u306A\u5165\u529B`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ka.cjs
var require_ka = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ka.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parsedType = void 0;
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var parsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      const typeMap = {
        string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
        undefined: "undefined",
        bigint: "bigint",
        symbol: "symbol",
        function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0"
      };
      return typeMap[t] ?? t;
    };
    exports2.parsedType = parsedType;
    var error = () => {
      const Sizable = {
        string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
        file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
        array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
        set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
        email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
        url: "URL",
        emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
        date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
        time: "\u10D3\u10E0\u10DD",
        duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
        ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
        ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
        cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
        cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
        base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
        jwt: "JWT",
        template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${(0, exports2.parsedType)(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${util.joinValues(issue.values, "|")}-\u10D3\u10D0\u10DC`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit}`;
            return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
            }
            if (_issue.format === "ends_with")
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
            if (_issue.format === "includes")
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
            if (_issue.format === "regex")
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
          case "unrecognized_keys":
            return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue.origin}-\u10E8\u10D8`;
          case "invalid_union":
            return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
          case "invalid_element":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue.origin}-\u10E8\u10D8`;
          default:
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/km.cjs
var require_km = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/km.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u1798\u17B7\u1793\u1798\u17C2\u1793\u1787\u17B6\u179B\u17C1\u1781 (NaN)" : "\u179B\u17C1\u1781";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u17A2\u17B6\u179A\u17C1 (Array)";
            }
            if (data === null) {
              return "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
        email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
        url: "URL",
        emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
        date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
        time: "\u1798\u17C9\u17C4\u1784 ISO",
        duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
        ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
        ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
        cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
        cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
        base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
        base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
        json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
        e164: "\u179B\u17C1\u1781 E.164",
        jwt: "JWT",
        template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
            return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue.origin} ${adj} ${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue.origin} ${adj} ${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
            return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue.divisor}`;
          case "unrecognized_keys":
            return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue.origin}`;
          case "invalid_union":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
          case "invalid_element":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue.origin}`;
          default:
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/kh.cjs
var require_kh = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/kh.cjs"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var km_js_1 = __importDefault(require_km());
    function default_1() {
      return (0, km_js_1.default)();
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ko.cjs
var require_ko = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ko.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "\uBB38\uC790", verb: "to have" },
        file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
        array: { unit: "\uAC1C", verb: "to have" },
        set: { unit: "\uAC1C", verb: "to have" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\uC785\uB825",
        email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
        url: "URL",
        emoji: "\uC774\uBAA8\uC9C0",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
        date: "ISO \uB0A0\uC9DC",
        time: "ISO \uC2DC\uAC04",
        duration: "ISO \uAE30\uAC04",
        ipv4: "IPv4 \uC8FC\uC18C",
        ipv6: "IPv6 \uC8FC\uC18C",
        cidrv4: "IPv4 \uBC94\uC704",
        cidrv6: "IPv6 \uBC94\uC704",
        base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
        base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
        json_string: "JSON \uBB38\uC790\uC5F4",
        e164: "E.164 \uBC88\uD638",
        jwt: "JWT",
        template_literal: "\uC785\uB825"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${issue.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${parsedType(issue.input)}\uC785\uB2C8\uB2E4`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${util.stringifyPrimitive(issue.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
            return `\uC798\uBABB\uB41C \uC635\uC158: ${util.joinValues(issue.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
          case "too_big": {
            const adj = issue.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
            const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
            const sizing = getSizing(issue.origin);
            const unit = sizing?.unit ?? "\uC694\uC18C";
            if (sizing)
              return `${issue.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue.maximum.toString()}${unit} ${adj}${suffix}`;
            return `${issue.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue.maximum.toString()} ${adj}${suffix}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
            const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
            const sizing = getSizing(issue.origin);
            const unit = sizing?.unit ?? "\uC694\uC18C";
            if (sizing) {
              return `${issue.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue.minimum.toString()}${unit} ${adj}${suffix}`;
            }
            return `${issue.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue.minimum.toString()} ${adj}${suffix}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
            }
            if (_issue.format === "ends_with")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
            if (_issue.format === "includes")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
            if (_issue.format === "regex")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
            return `\uC798\uBABB\uB41C ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
          case "unrecognized_keys":
            return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\uC798\uBABB\uB41C \uD0A4: ${issue.origin}`;
          case "invalid_union":
            return `\uC798\uBABB\uB41C \uC785\uB825`;
          case "invalid_element":
            return `\uC798\uBABB\uB41C \uAC12: ${issue.origin}`;
          default:
            return `\uC798\uBABB\uB41C \uC785\uB825`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/lt.cjs
var require_lt = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/lt.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parsedType = void 0;
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var parsedType = (data) => {
      const t = typeof data;
      return parsedTypeFromType(t, data);
    };
    exports2.parsedType = parsedType;
    var parsedTypeFromType = (t, data = void 0) => {
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "skai\u010Dius";
        }
        case "bigint": {
          return "sveikasis skai\u010Dius";
        }
        case "string": {
          return "eilut\u0117";
        }
        case "boolean": {
          return "login\u0117 reik\u0161m\u0117";
        }
        case "undefined":
        case "void": {
          return "neapibr\u0117\u017Eta reik\u0161m\u0117";
        }
        case "function": {
          return "funkcija";
        }
        case "symbol": {
          return "simbolis";
        }
        case "object": {
          if (data === void 0)
            return "ne\u017Einomas objektas";
          if (data === null)
            return "nulin\u0117 reik\u0161m\u0117";
          if (Array.isArray(data))
            return "masyvas";
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
          return "objektas";
        }
        //Zod types below
        case "null": {
          return "nulin\u0117 reik\u0161m\u0117";
        }
      }
      return t;
    };
    var capitalizeFirstCharacter = (text) => {
      return text.charAt(0).toUpperCase() + text.slice(1);
    };
    function getUnitTypeFromNumber(number) {
      const abs = Math.abs(number);
      const last = abs % 10;
      const last2 = abs % 100;
      if (last2 >= 11 && last2 <= 19 || last === 0)
        return "many";
      if (last === 1)
        return "one";
      return "few";
    }
    var error = () => {
      const Sizable = {
        string: {
          unit: {
            one: "simbolis",
            few: "simboliai",
            many: "simboli\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
              notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
            },
            bigger: {
              inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
              notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
            }
          }
        },
        file: {
          unit: {
            one: "baitas",
            few: "baitai",
            many: "bait\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi b\u016Bti ne didesnis kaip",
              notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
            },
            bigger: {
              inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
              notInclusive: "turi b\u016Bti didesnis kaip"
            }
          }
        },
        array: {
          unit: {
            one: "element\u0105",
            few: "elementus",
            many: "element\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi tur\u0117ti ne daugiau kaip",
              notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
            },
            bigger: {
              inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
              notInclusive: "turi tur\u0117ti daugiau kaip"
            }
          }
        },
        set: {
          unit: {
            one: "element\u0105",
            few: "elementus",
            many: "element\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi tur\u0117ti ne daugiau kaip",
              notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
            },
            bigger: {
              inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
              notInclusive: "turi tur\u0117ti daugiau kaip"
            }
          }
        }
      };
      function getSizing(origin, unitType, inclusive, targetShouldBe) {
        const result = Sizable[origin] ?? null;
        if (result === null)
          return result;
        return {
          unit: result.unit[unitType],
          verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
        };
      }
      const Nouns = {
        regex: "\u012Fvestis",
        email: "el. pa\u0161to adresas",
        url: "URL",
        emoji: "jaustukas",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO data ir laikas",
        date: "ISO data",
        time: "ISO laikas",
        duration: "ISO trukm\u0117",
        ipv4: "IPv4 adresas",
        ipv6: "IPv6 adresas",
        cidrv4: "IPv4 tinklo prefiksas (CIDR)",
        cidrv6: "IPv6 tinklo prefiksas (CIDR)",
        base64: "base64 u\u017Ekoduota eilut\u0117",
        base64url: "base64url u\u017Ekoduota eilut\u0117",
        json_string: "JSON eilut\u0117",
        e164: "E.164 numeris",
        jwt: "JWT",
        template_literal: "\u012Fvestis"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Gautas tipas ${(0, exports2.parsedType)(issue.input)}, o tik\u0117tasi - ${parsedTypeFromType(issue.expected)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Privalo b\u016Bti ${util.stringifyPrimitive(issue.values[0])}`;
            return `Privalo b\u016Bti vienas i\u0161 ${util.joinValues(issue.values, "|")} pasirinkim\u0173`;
          case "too_big": {
            const origin = parsedTypeFromType(issue.origin);
            const sizing = getSizing(issue.origin, getUnitTypeFromNumber(Number(issue.maximum)), issue.inclusive ?? false, "smaller");
            if (sizing?.verb)
              return `${capitalizeFirstCharacter(origin ?? issue.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
            const adj = issue.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
            return `${capitalizeFirstCharacter(origin ?? issue.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue.maximum.toString()} ${sizing?.unit}`;
          }
          case "too_small": {
            const origin = parsedTypeFromType(issue.origin);
            const sizing = getSizing(issue.origin, getUnitTypeFromNumber(Number(issue.minimum)), issue.inclusive ?? false, "bigger");
            if (sizing?.verb)
              return `${capitalizeFirstCharacter(origin ?? issue.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
            const adj = issue.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
            return `${capitalizeFirstCharacter(origin ?? issue.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue.minimum.toString()} ${sizing?.unit}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
            return `Neteisingas ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Skai\u010Dius privalo b\u016Bti ${issue.divisor} kartotinis.`;
          case "unrecognized_keys":
            return `Neatpa\u017Eint${issue.keys.length > 1 ? "i" : "as"} rakt${issue.keys.length > 1 ? "ai" : "as"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return "Rastas klaidingas raktas";
          case "invalid_union":
            return "Klaidinga \u012Fvestis";
          case "invalid_element": {
            const origin = parsedTypeFromType(issue.origin);
            return `${capitalizeFirstCharacter(origin ?? issue.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
          }
          default:
            return "Klaidinga \u012Fvestis";
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/mk.cjs
var require_mk = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/mk.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0431\u0440\u043E\u0458";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043D\u0438\u0437\u0430";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0432\u043D\u0435\u0441",
        email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u045F\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
        date: "ISO \u0434\u0430\u0442\u0443\u043C",
        time: "ISO \u0432\u0440\u0435\u043C\u0435",
        duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
        cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
        cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
        base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
        base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
        json_string: "JSON \u043D\u0438\u0437\u0430",
        e164: "E.164 \u0431\u0440\u043E\u0458",
        jwt: "JWT",
        template_literal: "\u0432\u043D\u0435\u0441"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${parsedType(issue.input)}`;
          // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Invalid input: expected ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
            return `Invalid ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue.divisor}`;
          case "unrecognized_keys":
            return `${issue.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue.origin}`;
          case "invalid_union":
            return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
          case "invalid_element":
            return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue.origin}`;
          default:
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ms.cjs
var require_ms2 = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ms.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "aksara", verb: "mempunyai" },
        file: { unit: "bait", verb: "mempunyai" },
        array: { unit: "elemen", verb: "mempunyai" },
        set: { unit: "elemen", verb: "mempunyai" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "nombor";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "alamat e-mel",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "tarikh masa ISO",
        date: "tarikh ISO",
        time: "masa ISO",
        duration: "tempoh ISO",
        ipv4: "alamat IPv4",
        ipv6: "alamat IPv6",
        cidrv4: "julat IPv4",
        cidrv6: "julat IPv6",
        base64: "string dikodkan base64",
        base64url: "string dikodkan base64url",
        json_string: "string JSON",
        e164: "nombor E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Input tidak sah: dijangka ${issue.expected}, diterima ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Input tidak sah: dijangka ${util.stringifyPrimitive(issue.values[0])}`;
            return `Pilihan tidak sah: dijangka salah satu daripada ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Terlalu besar: dijangka ${issue.origin ?? "nilai"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elemen"}`;
            return `Terlalu besar: dijangka ${issue.origin ?? "nilai"} adalah ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Terlalu kecil: dijangka ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Terlalu kecil: dijangka ${issue.origin} adalah ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue.format} tidak sah`;
          }
          case "not_multiple_of":
            return `Nombor tidak sah: perlu gandaan ${issue.divisor}`;
          case "unrecognized_keys":
            return `Kunci tidak dikenali: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Kunci tidak sah dalam ${issue.origin}`;
          case "invalid_union":
            return "Input tidak sah";
          case "invalid_element":
            return `Nilai tidak sah dalam ${issue.origin}`;
          default:
            return `Input tidak sah`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/nl.cjs
var require_nl = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/nl.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "tekens" },
        file: { unit: "bytes" },
        array: { unit: "elementen" },
        set: { unit: "elementen" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "getal";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "invoer",
        email: "emailadres",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datum en tijd",
        date: "ISO datum",
        time: "ISO tijd",
        duration: "ISO duur",
        ipv4: "IPv4-adres",
        ipv6: "IPv6-adres",
        cidrv4: "IPv4-bereik",
        cidrv6: "IPv6-bereik",
        base64: "base64-gecodeerde tekst",
        base64url: "base64 URL-gecodeerde tekst",
        json_string: "JSON string",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "invoer"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Ongeldige invoer: verwacht ${issue.expected}, ontving ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Ongeldige invoer: verwacht ${util.stringifyPrimitive(issue.values[0])}`;
            return `Ongeldige optie: verwacht \xE9\xE9n van ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Te lang: verwacht dat ${issue.origin ?? "waarde"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
            return `Te lang: verwacht dat ${issue.origin ?? "waarde"} ${adj}${issue.maximum.toString()} is`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Te kort: verwacht dat ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit} bevat`;
            }
            return `Te kort: verwacht dat ${issue.origin} ${adj}${issue.minimum.toString()} is`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
            }
            if (_issue.format === "ends_with")
              return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
            if (_issue.format === "includes")
              return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
            if (_issue.format === "regex")
              return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
            return `Ongeldig: ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Ongeldig getal: moet een veelvoud van ${issue.divisor} zijn`;
          case "unrecognized_keys":
            return `Onbekende key${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Ongeldige key in ${issue.origin}`;
          case "invalid_union":
            return "Ongeldige invoer";
          case "invalid_element":
            return `Ongeldige waarde in ${issue.origin}`;
          default:
            return `Ongeldige invoer`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/no.cjs
var require_no = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/no.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "tegn", verb: "\xE5 ha" },
        file: { unit: "bytes", verb: "\xE5 ha" },
        array: { unit: "elementer", verb: "\xE5 inneholde" },
        set: { unit: "elementer", verb: "\xE5 inneholde" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "tall";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "liste";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "e-postadresse",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dato- og klokkeslett",
        date: "ISO-dato",
        time: "ISO-klokkeslett",
        duration: "ISO-varighet",
        ipv4: "IPv4-omr\xE5de",
        ipv6: "IPv6-omr\xE5de",
        cidrv4: "IPv4-spekter",
        cidrv6: "IPv6-spekter",
        base64: "base64-enkodet streng",
        base64url: "base64url-enkodet streng",
        json_string: "JSON-streng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Ugyldig input: forventet ${issue.expected}, fikk ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Ugyldig verdi: forventet ${util.stringifyPrimitive(issue.values[0])}`;
            return `Ugyldig valg: forventet en av ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `For stor(t): forventet ${issue.origin ?? "value"} til \xE5 ha ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementer"}`;
            return `For stor(t): forventet ${issue.origin ?? "value"} til \xE5 ha ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `For lite(n): forventet ${issue.origin} til \xE5 ha ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `For lite(n): forventet ${issue.origin} til \xE5 ha ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
            return `Ugyldig ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue.divisor}`;
          case "unrecognized_keys":
            return `${issue.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Ugyldig n\xF8kkel i ${issue.origin}`;
          case "invalid_union":
            return "Ugyldig input";
          case "invalid_element":
            return `Ugyldig verdi i ${issue.origin}`;
          default:
            return `Ugyldig input`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ota.cjs
var require_ota = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ota.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
        file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
        array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
        set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "numara";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "saf";
            }
            if (data === null) {
              return "gayb";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "giren",
        email: "epostag\xE2h",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO heng\xE2m\u0131",
        date: "ISO tarihi",
        time: "ISO zaman\u0131",
        duration: "ISO m\xFCddeti",
        ipv4: "IPv4 ni\u015F\xE2n\u0131",
        ipv6: "IPv6 ni\u015F\xE2n\u0131",
        cidrv4: "IPv4 menzili",
        cidrv6: "IPv6 menzili",
        base64: "base64-\u015Fifreli metin",
        base64url: "base64url-\u015Fifreli metin",
        json_string: "JSON metin",
        e164: "E.164 say\u0131s\u0131",
        jwt: "JWT",
        template_literal: "giren"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `F\xE2sit giren: umulan ${issue.expected}, al\u0131nan ${parsedType(issue.input)}`;
          // return `Fsit giren: umulan ${issue.expected}, alnan ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `F\xE2sit giren: umulan ${util.stringifyPrimitive(issue.values[0])}`;
            return `F\xE2sit tercih: m\xFBteberler ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Fazla b\xFCy\xFCk: ${issue.origin ?? "value"}, ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
            return `Fazla b\xFCy\xFCk: ${issue.origin ?? "value"}, ${adj}${issue.maximum.toString()} olmal\u0131yd\u0131.`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Fazla k\xFC\xE7\xFCk: ${issue.origin}, ${adj}${issue.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
            }
            return `Fazla k\xFC\xE7\xFCk: ${issue.origin}, ${adj}${issue.minimum.toString()} olmal\u0131yd\u0131.`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
            if (_issue.format === "ends_with")
              return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
            if (_issue.format === "includes")
              return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
            if (_issue.format === "regex")
              return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
            return `F\xE2sit ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `F\xE2sit say\u0131: ${issue.divisor} kat\u0131 olmal\u0131yd\u0131.`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan anahtar ${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `${issue.origin} i\xE7in tan\u0131nmayan anahtar var.`;
          case "invalid_union":
            return "Giren tan\u0131namad\u0131.";
          case "invalid_element":
            return `${issue.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
          default:
            return `K\u0131ymet tan\u0131namad\u0131.`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ps.cjs
var require_ps = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ps.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
        file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
        array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
        set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0627\u0631\u06D0";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0648\u0631\u0648\u062F\u064A",
        email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
        url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
        date: "\u0646\u06D0\u067C\u0647",
        time: "\u0648\u062E\u062A",
        duration: "\u0645\u0648\u062F\u0647",
        ipv4: "\u062F IPv4 \u067E\u062A\u0647",
        ipv6: "\u062F IPv6 \u067E\u062A\u0647",
        cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
        cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
        base64: "base64-encoded \u0645\u062A\u0646",
        base64url: "base64url-encoded \u0645\u062A\u0646",
        json_string: "JSON \u0645\u062A\u0646",
        e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
        jwt: "JWT",
        template_literal: "\u0648\u0631\u0648\u062F\u064A"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${issue.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${parsedType(issue.input)} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
          case "invalid_value":
            if (issue.values.length === 1) {
              return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${util.stringifyPrimitive(issue.values[0])} \u0648\u0627\u06CC`;
            }
            return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${util.joinValues(issue.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
            }
            return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue.maximum.toString()} \u0648\u064A`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue.origin} \u0628\u0627\u06CC\u062F ${adj}${issue.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
            }
            return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue.origin} \u0628\u0627\u06CC\u062F ${adj}${issue.minimum.toString()} \u0648\u064A`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
            }
            if (_issue.format === "ends_with") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
            }
            if (_issue.format === "includes") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
            }
            if (_issue.format === "regex") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
            }
            return `${Nouns[_issue.format] ?? issue.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
          }
          case "not_multiple_of":
            return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
          case "unrecognized_keys":
            return `\u0646\u0627\u0633\u0645 ${issue.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue.origin} \u06A9\u06D0`;
          case "invalid_union":
            return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
          case "invalid_element":
            return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue.origin} \u06A9\u06D0`;
          default:
            return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/pl.cjs
var require_pl = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/pl.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "znak\xF3w", verb: "mie\u0107" },
        file: { unit: "bajt\xF3w", verb: "mie\u0107" },
        array: { unit: "element\xF3w", verb: "mie\u0107" },
        set: { unit: "element\xF3w", verb: "mie\u0107" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "liczba";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "tablica";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "wyra\u017Cenie",
        email: "adres email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data i godzina w formacie ISO",
        date: "data w formacie ISO",
        time: "godzina w formacie ISO",
        duration: "czas trwania ISO",
        ipv4: "adres IPv4",
        ipv6: "adres IPv6",
        cidrv4: "zakres IPv4",
        cidrv6: "zakres IPv6",
        base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
        base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
        json_string: "ci\u0105g znak\xF3w w formacie JSON",
        e164: "liczba E.164",
        jwt: "JWT",
        template_literal: "wej\u015Bcie"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${issue.expected}, otrzymano ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${util.stringifyPrimitive(issue.values[0])}`;
            return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
            }
            return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
            }
            return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
            return `Nieprawid\u0142ow(y/a/e) ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue.divisor}`;
          case "unrecognized_keys":
            return `Nierozpoznane klucze${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Nieprawid\u0142owy klucz w ${issue.origin}`;
          case "invalid_union":
            return "Nieprawid\u0142owe dane wej\u015Bciowe";
          case "invalid_element":
            return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue.origin}`;
          default:
            return `Nieprawid\u0142owe dane wej\u015Bciowe`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/pt.cjs
var require_pt = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/pt.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "caracteres", verb: "ter" },
        file: { unit: "bytes", verb: "ter" },
        array: { unit: "itens", verb: "ter" },
        set: { unit: "itens", verb: "ter" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "n\xFAmero";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "nulo";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "padr\xE3o",
        email: "endere\xE7o de e-mail",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data e hora ISO",
        date: "data ISO",
        time: "hora ISO",
        duration: "dura\xE7\xE3o ISO",
        ipv4: "endere\xE7o IPv4",
        ipv6: "endere\xE7o IPv6",
        cidrv4: "faixa de IPv4",
        cidrv6: "faixa de IPv6",
        base64: "texto codificado em base64",
        base64url: "URL codificada em base64",
        json_string: "texto JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Tipo inv\xE1lido: esperado ${issue.expected}, recebido ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Entrada inv\xE1lida: esperado ${util.stringifyPrimitive(issue.values[0])}`;
            return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Muito grande: esperado que ${issue.origin ?? "valor"} tivesse ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementos"}`;
            return `Muito grande: esperado que ${issue.origin ?? "valor"} fosse ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Muito pequeno: esperado que ${issue.origin} tivesse ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Muito pequeno: esperado que ${issue.origin} fosse ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue.format} inv\xE1lido`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue.divisor}`;
          case "unrecognized_keys":
            return `Chave${issue.keys.length > 1 ? "s" : ""} desconhecida${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Chave inv\xE1lida em ${issue.origin}`;
          case "invalid_union":
            return "Entrada inv\xE1lida";
          case "invalid_element":
            return `Valor inv\xE1lido em ${issue.origin}`;
          default:
            return `Campo inv\xE1lido`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ru.cjs
var require_ru = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ru.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    function getRussianPlural(count, one, few, many) {
      const absCount = Math.abs(count);
      const lastDigit = absCount % 10;
      const lastTwoDigits = absCount % 100;
      if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
        return many;
      }
      if (lastDigit === 1) {
        return one;
      }
      if (lastDigit >= 2 && lastDigit <= 4) {
        return few;
      }
      return many;
    }
    var error = () => {
      const Sizable = {
        string: {
          unit: {
            one: "\u0441\u0438\u043C\u0432\u043E\u043B",
            few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
            many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        file: {
          unit: {
            one: "\u0431\u0430\u0439\u0442",
            few: "\u0431\u0430\u0439\u0442\u0430",
            many: "\u0431\u0430\u0439\u0442"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        array: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        set: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043C\u0430\u0441\u0441\u0438\u0432";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0432\u0432\u043E\u0434",
        email: "email \u0430\u0434\u0440\u0435\u0441",
        url: "URL",
        emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0432\u0440\u0435\u043C\u044F",
        duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
        cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
        base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
        json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
        e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0432\u0432\u043E\u0434"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${issue.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              const maxValue = Number(issue.maximum);
              const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue.maximum.toString()} ${unit}`;
            }
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              const minValue = Number(issue.minimum);
              const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue.minimum.toString()} ${unit}`;
            }
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue.keys.length > 1 ? "\u0438" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
          case "invalid_element":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue.origin}`;
          default:
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/sl.cjs
var require_sl = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/sl.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "znakov", verb: "imeti" },
        file: { unit: "bajtov", verb: "imeti" },
        array: { unit: "elementov", verb: "imeti" },
        set: { unit: "elementov", verb: "imeti" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0161tevilo";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "tabela";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "vnos",
        email: "e-po\u0161tni naslov",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datum in \u010Das",
        date: "ISO datum",
        time: "ISO \u010Das",
        duration: "ISO trajanje",
        ipv4: "IPv4 naslov",
        ipv6: "IPv6 naslov",
        cidrv4: "obseg IPv4",
        cidrv6: "obseg IPv6",
        base64: "base64 kodiran niz",
        base64url: "base64url kodiran niz",
        json_string: "JSON niz",
        e164: "E.164 \u0161tevilka",
        jwt: "JWT",
        template_literal: "vnos"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Neveljaven vnos: pri\u010Dakovano ${issue.expected}, prejeto ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Neveljaven vnos: pri\u010Dakovano ${util.stringifyPrimitive(issue.values[0])}`;
            return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Preveliko: pri\u010Dakovano, da bo ${issue.origin ?? "vrednost"} imelo ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementov"}`;
            return `Preveliko: pri\u010Dakovano, da bo ${issue.origin ?? "vrednost"} ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Premajhno: pri\u010Dakovano, da bo ${issue.origin} imelo ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Premajhno: pri\u010Dakovano, da bo ${issue.origin} ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
            return `Neveljaven ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue.divisor}`;
          case "unrecognized_keys":
            return `Neprepoznan${issue.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Neveljaven klju\u010D v ${issue.origin}`;
          case "invalid_union":
            return "Neveljaven vnos";
          case "invalid_element":
            return `Neveljavna vrednost v ${issue.origin}`;
          default:
            return "Neveljaven vnos";
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/sv.cjs
var require_sv = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/sv.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "tecken", verb: "att ha" },
        file: { unit: "bytes", verb: "att ha" },
        array: { unit: "objekt", verb: "att inneh\xE5lla" },
        set: { unit: "objekt", verb: "att inneh\xE5lla" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "antal";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "lista";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "regulj\xE4rt uttryck",
        email: "e-postadress",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-datum och tid",
        date: "ISO-datum",
        time: "ISO-tid",
        duration: "ISO-varaktighet",
        ipv4: "IPv4-intervall",
        ipv6: "IPv6-intervall",
        cidrv4: "IPv4-spektrum",
        cidrv6: "IPv6-spektrum",
        base64: "base64-kodad str\xE4ng",
        base64url: "base64url-kodad str\xE4ng",
        json_string: "JSON-str\xE4ng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "mall-literal"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Ogiltig inmatning: f\xF6rv\xE4ntat ${issue.expected}, fick ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Ogiltig inmatning: f\xF6rv\xE4ntat ${util.stringifyPrimitive(issue.values[0])}`;
            return `Ogiltigt val: f\xF6rv\xE4ntade en av ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue.origin ?? "v\xE4rdet"} att ha ${adj}${issue.maximum.toString()} ${sizing.unit ?? "element"}`;
            }
            return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue.origin ?? "v\xE4rdet"} att ha ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue.origin ?? "v\xE4rdet"} att ha ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue.origin ?? "v\xE4rdet"} att ha ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
            return `Ogiltig(t) ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue.divisor}`;
          case "unrecognized_keys":
            return `${issue.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Ogiltig nyckel i ${issue.origin ?? "v\xE4rdet"}`;
          case "invalid_union":
            return "Ogiltig input";
          case "invalid_element":
            return `Ogiltigt v\xE4rde i ${issue.origin ?? "v\xE4rdet"}`;
          default:
            return `Ogiltig input`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ta.cjs
var require_ta = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ta.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u0B8E\u0BA3\u0BCD \u0B85\u0BB2\u0BCD\u0BB2\u0BBE\u0BA4\u0BA4\u0BC1" : "\u0B8E\u0BA3\u0BCD";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0B85\u0BA3\u0BBF";
            }
            if (data === null) {
              return "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
        email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
        date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
        time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
        duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
        ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
        cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
        base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
        base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
        json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
        e164: "E.164 \u0B8E\u0BA3\u0BCD",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${util.joinValues(issue.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue.origin} ${adj}${issue.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "ends_with")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "includes")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "regex")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          case "unrecognized_keys":
            return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `${issue.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
          case "invalid_union":
            return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
          case "invalid_element":
            return `${issue.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
          default:
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/th.cjs
var require_th = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/th.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02 (NaN)" : "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)";
            }
            if (data === null) {
              return "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
        email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
        url: "URL",
        emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
        time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
        ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
        cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
        cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
        base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
        base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
        json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
        e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
        jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
        template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${issue.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
            return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
            if (_issue.format === "regex")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
            return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
          case "unrecognized_keys":
            return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue.origin}`;
          case "invalid_union":
            return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
          case "invalid_element":
            return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue.origin}`;
          default:
            return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/tr.cjs
var require_tr = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/tr.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parsedType = void 0;
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var parsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    exports2.parsedType = parsedType;
    var error = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "olmal\u0131" },
        file: { unit: "bayt", verb: "olmal\u0131" },
        array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
        set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "girdi",
        email: "e-posta adresi",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO tarih ve saat",
        date: "ISO tarih",
        time: "ISO saat",
        duration: "ISO s\xFCre",
        ipv4: "IPv4 adresi",
        ipv6: "IPv6 adresi",
        cidrv4: "IPv4 aral\u0131\u011F\u0131",
        cidrv6: "IPv6 aral\u0131\u011F\u0131",
        base64: "base64 ile \u015Fifrelenmi\u015F metin",
        base64url: "base64url ile \u015Fifrelenmi\u015F metin",
        json_string: "JSON dizesi",
        e164: "E.164 say\u0131s\u0131",
        jwt: "JWT",
        template_literal: "\u015Eablon dizesi"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Ge\xE7ersiz de\u011Fer: beklenen ${issue.expected}, al\u0131nan ${(0, exports2.parsedType)(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Ge\xE7ersiz de\u011Fer: beklenen ${util.stringifyPrimitive(issue.values[0])}`;
            return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\xC7ok b\xFCy\xFCk: beklenen ${issue.origin ?? "de\u011Fer"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
            return `\xC7ok b\xFCy\xFCk: beklenen ${issue.origin ?? "de\u011Fer"} ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue.origin} ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
            if (_issue.format === "ends_with")
              return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
            if (_issue.format === "includes")
              return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
            if (_issue.format === "regex")
              return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
            return `Ge\xE7ersiz ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Ge\xE7ersiz say\u0131: ${issue.divisor} ile tam b\xF6l\xFCnebilmeli`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan anahtar${issue.keys.length > 1 ? "lar" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `${issue.origin} i\xE7inde ge\xE7ersiz anahtar`;
          case "invalid_union":
            return "Ge\xE7ersiz de\u011Fer";
          case "invalid_element":
            return `${issue.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
          default:
            return `Ge\xE7ersiz de\u011Fer`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/uk.cjs
var require_uk = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/uk.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043C\u0430\u0441\u0438\u0432";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
        email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
        date: "\u0434\u0430\u0442\u0430 ISO",
        time: "\u0447\u0430\u0441 ISO",
        duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
        ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
        ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
        cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
        cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
        base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
        base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
        json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
        e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${issue.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${parsedType(issue.input)}`;
          // return `  :  ${issue.expected},  ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue.origin} \u0431\u0443\u0434\u0435 ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue.keys.length > 1 ? "\u0456" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
          case "invalid_element":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue.origin}`;
          default:
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ua.cjs
var require_ua = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ua.cjs"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var uk_js_1 = __importDefault(require_uk());
    function default_1() {
      return (0, uk_js_1.default)();
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ur.cjs
var require_ur = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/ur.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
        file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
        array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
        set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0646\u0645\u0628\u0631";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0622\u0631\u06D2";
            }
            if (data === null) {
              return "\u0646\u0644";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0627\u0646 \u067E\u0679",
        email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
        uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
        uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
        nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
        ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
        xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
        ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
        date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
        time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
        duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
        ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
        cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
        base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
        base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
        json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
        e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
        jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
        template_literal: "\u0627\u0646 \u067E\u0679"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${issue.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${parsedType(issue.input)} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${util.stringifyPrimitive(issue.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
            return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${util.joinValues(issue.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
            return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue.origin} \u06A9\u06D2 ${adj}${issue.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
            }
            return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue.origin} \u06A9\u0627 ${adj}${issue.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            }
            if (_issue.format === "ends_with")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            if (_issue.format === "includes")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            if (_issue.format === "regex")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            return `\u063A\u0644\u0637 ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
          case "unrecognized_keys":
            return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue.keys.length > 1 ? "\u0632" : ""}: ${util.joinValues(issue.keys, "\u060C ")}`;
          case "invalid_key":
            return `${issue.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
          case "invalid_union":
            return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
          case "invalid_element":
            return `${issue.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
          default:
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/vi.cjs
var require_vi = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/vi.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
        file: { unit: "byte", verb: "c\xF3" },
        array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
        set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "s\u1ED1";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "m\u1EA3ng";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0111\u1EA7u v\xE0o",
        email: "\u0111\u1ECBa ch\u1EC9 email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ng\xE0y gi\u1EDD ISO",
        date: "ng\xE0y ISO",
        time: "gi\u1EDD ISO",
        duration: "kho\u1EA3ng th\u1EDDi gian ISO",
        ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
        ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
        cidrv4: "d\u1EA3i IPv4",
        cidrv6: "d\u1EA3i IPv6",
        base64: "chu\u1ED7i m\xE3 h\xF3a base64",
        base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
        json_string: "chu\u1ED7i JSON",
        e164: "s\u1ED1 E.164",
        jwt: "JWT",
        template_literal: "\u0111\u1EA7u v\xE0o"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${issue.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${util.stringifyPrimitive(issue.values[0])}`;
            return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
            return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue.origin} ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue.format} kh\xF4ng h\u1EE3p l\u1EC7`;
          }
          case "not_multiple_of":
            return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue.divisor}`;
          case "unrecognized_keys":
            return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue.origin}`;
          case "invalid_union":
            return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
          case "invalid_element":
            return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue.origin}`;
          default:
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/zh-CN.cjs
var require_zh_CN = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/zh-CN.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
        file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
        array: { unit: "\u9879", verb: "\u5305\u542B" },
        set: { unit: "\u9879", verb: "\u5305\u542B" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u975E\u6570\u5B57(NaN)" : "\u6570\u5B57";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u6570\u7EC4";
            }
            if (data === null) {
              return "\u7A7A\u503C(null)";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u8F93\u5165",
        email: "\u7535\u5B50\u90AE\u4EF6",
        url: "URL",
        emoji: "\u8868\u60C5\u7B26\u53F7",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO\u65E5\u671F\u65F6\u95F4",
        date: "ISO\u65E5\u671F",
        time: "ISO\u65F6\u95F4",
        duration: "ISO\u65F6\u957F",
        ipv4: "IPv4\u5730\u5740",
        ipv6: "IPv6\u5730\u5740",
        cidrv4: "IPv4\u7F51\u6BB5",
        cidrv6: "IPv6\u7F51\u6BB5",
        base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
        base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
        json_string: "JSON\u5B57\u7B26\u4E32",
        e164: "E.164\u53F7\u7801",
        jwt: "JWT",
        template_literal: "\u8F93\u5165"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${issue.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue.origin ?? "\u503C"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
            return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue.origin ?? "\u503C"} ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue.origin} ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
            if (_issue.format === "ends_with")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
            if (_issue.format === "includes")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
            return `\u65E0\u6548${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue.divisor} \u7684\u500D\u6570`;
          case "unrecognized_keys":
            return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `${issue.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
          case "invalid_union":
            return "\u65E0\u6548\u8F93\u5165";
          case "invalid_element":
            return `${issue.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
          default:
            return `\u65E0\u6548\u8F93\u5165`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/zh-TW.cjs
var require_zh_TW = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/zh-TW.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
        file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
        array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
        set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u8F38\u5165",
        email: "\u90F5\u4EF6\u5730\u5740",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u65E5\u671F\u6642\u9593",
        date: "ISO \u65E5\u671F",
        time: "ISO \u6642\u9593",
        duration: "ISO \u671F\u9593",
        ipv4: "IPv4 \u4F4D\u5740",
        ipv6: "IPv6 \u4F4D\u5740",
        cidrv4: "IPv4 \u7BC4\u570D",
        cidrv6: "IPv6 \u7BC4\u570D",
        base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
        base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
        json_string: "JSON \u5B57\u4E32",
        e164: "E.164 \u6578\u503C",
        jwt: "JWT",
        template_literal: "\u8F38\u5165"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${issue.expected}\uFF0C\u4F46\u6536\u5230 ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
            return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue.origin} \u61C9\u70BA ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue.origin} \u61C9\u70BA ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
            }
            if (_issue.format === "ends_with")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
            if (_issue.format === "includes")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
            return `\u7121\u6548\u7684 ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue.divisor} \u7684\u500D\u6578`;
          case "unrecognized_keys":
            return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue.keys.length > 1 ? "\u5011" : ""}\uFF1A${util.joinValues(issue.keys, "\u3001")}`;
          case "invalid_key":
            return `${issue.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
          case "invalid_union":
            return "\u7121\u6548\u7684\u8F38\u5165\u503C";
          case "invalid_element":
            return `${issue.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
          default:
            return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/yo.cjs
var require_yo = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/yo.cjs"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util2());
    var error = () => {
      const Sizable = {
        string: { unit: "\xE0mi", verb: "n\xED" },
        file: { unit: "bytes", verb: "n\xED" },
        array: { unit: "nkan", verb: "n\xED" },
        set: { unit: "nkan", verb: "n\xED" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "n\u1ECD\u0301mb\xE0";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "akop\u1ECD";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
        email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\xE0k\xF3k\xF2 ISO",
        date: "\u1ECDj\u1ECD\u0301 ISO",
        time: "\xE0k\xF3k\xF2 ISO",
        duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
        ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
        ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
        cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
        cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
        base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
        base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
        json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
        e164: "n\u1ECD\u0301mb\xE0 E.164",
        jwt: "JWT",
        template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${issue.expected}, \xE0m\u1ECD\u0300 a r\xED ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${util.stringifyPrimitive(issue.values[0])}`;
            return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue.origin ?? "iye"} ${sizing.verb} ${adj}${issue.maximum} ${sizing.unit}`;
            return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue.maximum}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue.origin} ${sizing.verb} ${adj}${issue.minimum} ${sizing.unit}`;
            return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue.minimum}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
            return `A\u1E63\xEC\u1E63e: ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue.divisor}`;
          case "unrecognized_keys":
            return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue.origin}`;
          case "invalid_union":
            return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
          case "invalid_element":
            return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue.origin}`;
          default:
            return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/index.cjs
var require_locales = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/locales/index.cjs"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.yo = exports2.zhTW = exports2.zhCN = exports2.vi = exports2.ur = exports2.uk = exports2.ua = exports2.tr = exports2.th = exports2.ta = exports2.sv = exports2.sl = exports2.ru = exports2.pt = exports2.pl = exports2.ps = exports2.ota = exports2.no = exports2.nl = exports2.ms = exports2.mk = exports2.lt = exports2.ko = exports2.km = exports2.kh = exports2.ka = exports2.ja = exports2.it = exports2.is = exports2.id = exports2.hu = exports2.he = exports2.frCA = exports2.fr = exports2.fi = exports2.fa = exports2.es = exports2.eo = exports2.en = exports2.de = exports2.da = exports2.cs = exports2.ca = exports2.bg = exports2.be = exports2.az = exports2.ar = void 0;
    var ar_js_1 = require_ar();
    Object.defineProperty(exports2, "ar", { enumerable: true, get: function() {
      return __importDefault(ar_js_1).default;
    } });
    var az_js_1 = require_az();
    Object.defineProperty(exports2, "az", { enumerable: true, get: function() {
      return __importDefault(az_js_1).default;
    } });
    var be_js_1 = require_be();
    Object.defineProperty(exports2, "be", { enumerable: true, get: function() {
      return __importDefault(be_js_1).default;
    } });
    var bg_js_1 = require_bg();
    Object.defineProperty(exports2, "bg", { enumerable: true, get: function() {
      return __importDefault(bg_js_1).default;
    } });
    var ca_js_1 = require_ca();
    Object.defineProperty(exports2, "ca", { enumerable: true, get: function() {
      return __importDefault(ca_js_1).default;
    } });
    var cs_js_1 = require_cs();
    Object.defineProperty(exports2, "cs", { enumerable: true, get: function() {
      return __importDefault(cs_js_1).default;
    } });
    var da_js_1 = require_da();
    Object.defineProperty(exports2, "da", { enumerable: true, get: function() {
      return __importDefault(da_js_1).default;
    } });
    var de_js_1 = require_de();
    Object.defineProperty(exports2, "de", { enumerable: true, get: function() {
      return __importDefault(de_js_1).default;
    } });
    var en_js_1 = require_en2();
    Object.defineProperty(exports2, "en", { enumerable: true, get: function() {
      return __importDefault(en_js_1).default;
    } });
    var eo_js_1 = require_eo();
    Object.defineProperty(exports2, "eo", { enumerable: true, get: function() {
      return __importDefault(eo_js_1).default;
    } });
    var es_js_1 = require_es();
    Object.defineProperty(exports2, "es", { enumerable: true, get: function() {
      return __importDefault(es_js_1).default;
    } });
    var fa_js_1 = require_fa();
    Object.defineProperty(exports2, "fa", { enumerable: true, get: function() {
      return __importDefault(fa_js_1).default;
    } });
    var fi_js_1 = require_fi();
    Object.defineProperty(exports2, "fi", { enumerable: true, get: function() {
      return __importDefault(fi_js_1).default;
    } });
    var fr_js_1 = require_fr();
    Object.defineProperty(exports2, "fr", { enumerable: true, get: function() {
      return __importDefault(fr_js_1).default;
    } });
    var fr_CA_js_1 = require_fr_CA();
    Object.defineProperty(exports2, "frCA", { enumerable: true, get: function() {
      return __importDefault(fr_CA_js_1).default;
    } });
    var he_js_1 = require_he();
    Object.defineProperty(exports2, "he", { enumerable: true, get: function() {
      return __importDefault(he_js_1).default;
    } });
    var hu_js_1 = require_hu();
    Object.defineProperty(exports2, "hu", { enumerable: true, get: function() {
      return __importDefault(hu_js_1).default;
    } });
    var id_js_1 = require_id();
    Object.defineProperty(exports2, "id", { enumerable: true, get: function() {
      return __importDefault(id_js_1).default;
    } });
    var is_js_1 = require_is();
    Object.defineProperty(exports2, "is", { enumerable: true, get: function() {
      return __importDefault(is_js_1).default;
    } });
    var it_js_1 = require_it();
    Object.defineProperty(exports2, "it", { enumerable: true, get: function() {
      return __importDefault(it_js_1).default;
    } });
    var ja_js_1 = require_ja();
    Object.defineProperty(exports2, "ja", { enumerable: true, get: function() {
      return __importDefault(ja_js_1).default;
    } });
    var ka_js_1 = require_ka();
    Object.defineProperty(exports2, "ka", { enumerable: true, get: function() {
      return __importDefault(ka_js_1).default;
    } });
    var kh_js_1 = require_kh();
    Object.defineProperty(exports2, "kh", { enumerable: true, get: function() {
      return __importDefault(kh_js_1).default;
    } });
    var km_js_1 = require_km();
    Object.defineProperty(exports2, "km", { enumerable: true, get: function() {
      return __importDefault(km_js_1).default;
    } });
    var ko_js_1 = require_ko();
    Object.defineProperty(exports2, "ko", { enumerable: true, get: function() {
      return __importDefault(ko_js_1).default;
    } });
    var lt_js_1 = require_lt();
    Object.defineProperty(exports2, "lt", { enumerable: true, get: function() {
      return __importDefault(lt_js_1).default;
    } });
    var mk_js_1 = require_mk();
    Object.defineProperty(exports2, "mk", { enumerable: true, get: function() {
      return __importDefault(mk_js_1).default;
    } });
    var ms_js_1 = require_ms2();
    Object.defineProperty(exports2, "ms", { enumerable: true, get: function() {
      return __importDefault(ms_js_1).default;
    } });
    var nl_js_1 = require_nl();
    Object.defineProperty(exports2, "nl", { enumerable: true, get: function() {
      return __importDefault(nl_js_1).default;
    } });
    var no_js_1 = require_no();
    Object.defineProperty(exports2, "no", { enumerable: true, get: function() {
      return __importDefault(no_js_1).default;
    } });
    var ota_js_1 = require_ota();
    Object.defineProperty(exports2, "ota", { enumerable: true, get: function() {
      return __importDefault(ota_js_1).default;
    } });
    var ps_js_1 = require_ps();
    Object.defineProperty(exports2, "ps", { enumerable: true, get: function() {
      return __importDefault(ps_js_1).default;
    } });
    var pl_js_1 = require_pl();
    Object.defineProperty(exports2, "pl", { enumerable: true, get: function() {
      return __importDefault(pl_js_1).default;
    } });
    var pt_js_1 = require_pt();
    Object.defineProperty(exports2, "pt", { enumerable: true, get: function() {
      return __importDefault(pt_js_1).default;
    } });
    var ru_js_1 = require_ru();
    Object.defineProperty(exports2, "ru", { enumerable: true, get: function() {
      return __importDefault(ru_js_1).default;
    } });
    var sl_js_1 = require_sl();
    Object.defineProperty(exports2, "sl", { enumerable: true, get: function() {
      return __importDefault(sl_js_1).default;
    } });
    var sv_js_1 = require_sv();
    Object.defineProperty(exports2, "sv", { enumerable: true, get: function() {
      return __importDefault(sv_js_1).default;
    } });
    var ta_js_1 = require_ta();
    Object.defineProperty(exports2, "ta", { enumerable: true, get: function() {
      return __importDefault(ta_js_1).default;
    } });
    var th_js_1 = require_th();
    Object.defineProperty(exports2, "th", { enumerable: true, get: function() {
      return __importDefault(th_js_1).default;
    } });
    var tr_js_1 = require_tr();
    Object.defineProperty(exports2, "tr", { enumerable: true, get: function() {
      return __importDefault(tr_js_1).default;
    } });
    var ua_js_1 = require_ua();
    Object.defineProperty(exports2, "ua", { enumerable: true, get: function() {
      return __importDefault(ua_js_1).default;
    } });
    var uk_js_1 = require_uk();
    Object.defineProperty(exports2, "uk", { enumerable: true, get: function() {
      return __importDefault(uk_js_1).default;
    } });
    var ur_js_1 = require_ur();
    Object.defineProperty(exports2, "ur", { enumerable: true, get: function() {
      return __importDefault(ur_js_1).default;
    } });
    var vi_js_1 = require_vi();
    Object.defineProperty(exports2, "vi", { enumerable: true, get: function() {
      return __importDefault(vi_js_1).default;
    } });
    var zh_CN_js_1 = require_zh_CN();
    Object.defineProperty(exports2, "zhCN", { enumerable: true, get: function() {
      return __importDefault(zh_CN_js_1).default;
    } });
    var zh_TW_js_1 = require_zh_TW();
    Object.defineProperty(exports2, "zhTW", { enumerable: true, get: function() {
      return __importDefault(zh_TW_js_1).default;
    } });
    var yo_js_1 = require_yo();
    Object.defineProperty(exports2, "yo", { enumerable: true, get: function() {
      return __importDefault(yo_js_1).default;
    } });
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/registries.cjs
var require_registries = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/registries.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.globalRegistry = exports2.$ZodRegistry = exports2.$input = exports2.$output = void 0;
    exports2.registry = registry;
    exports2.$output = Symbol("ZodOutput");
    exports2.$input = Symbol("ZodInput");
    var $ZodRegistry = class {
      constructor() {
        this._map = /* @__PURE__ */ new WeakMap();
        this._idmap = /* @__PURE__ */ new Map();
      }
      add(schema, ..._meta) {
        const meta = _meta[0];
        this._map.set(schema, meta);
        if (meta && typeof meta === "object" && "id" in meta) {
          if (this._idmap.has(meta.id)) {
            throw new Error(`ID ${meta.id} already exists in the registry`);
          }
          this._idmap.set(meta.id, schema);
        }
        return this;
      }
      clear() {
        this._map = /* @__PURE__ */ new WeakMap();
        this._idmap = /* @__PURE__ */ new Map();
        return this;
      }
      remove(schema) {
        const meta = this._map.get(schema);
        if (meta && typeof meta === "object" && "id" in meta) {
          this._idmap.delete(meta.id);
        }
        this._map.delete(schema);
        return this;
      }
      get(schema) {
        const p = schema._zod.parent;
        if (p) {
          const pm = { ...this.get(p) ?? {} };
          delete pm.id;
          const f = { ...pm, ...this._map.get(schema) };
          return Object.keys(f).length ? f : void 0;
        }
        return this._map.get(schema);
      }
      has(schema) {
        return this._map.has(schema);
      }
    };
    exports2.$ZodRegistry = $ZodRegistry;
    function registry() {
      return new $ZodRegistry();
    }
    exports2.globalRegistry = registry();
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/api.cjs
var require_api = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/api.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TimePrecision = void 0;
    exports2._string = _string;
    exports2._coercedString = _coercedString;
    exports2._email = _email;
    exports2._guid = _guid;
    exports2._uuid = _uuid;
    exports2._uuidv4 = _uuidv4;
    exports2._uuidv6 = _uuidv6;
    exports2._uuidv7 = _uuidv7;
    exports2._url = _url;
    exports2._emoji = _emoji;
    exports2._nanoid = _nanoid;
    exports2._cuid = _cuid;
    exports2._cuid2 = _cuid2;
    exports2._ulid = _ulid;
    exports2._xid = _xid;
    exports2._ksuid = _ksuid;
    exports2._ipv4 = _ipv4;
    exports2._ipv6 = _ipv6;
    exports2._cidrv4 = _cidrv4;
    exports2._cidrv6 = _cidrv6;
    exports2._base64 = _base64;
    exports2._base64url = _base64url;
    exports2._e164 = _e164;
    exports2._jwt = _jwt;
    exports2._isoDateTime = _isoDateTime;
    exports2._isoDate = _isoDate;
    exports2._isoTime = _isoTime;
    exports2._isoDuration = _isoDuration;
    exports2._number = _number;
    exports2._coercedNumber = _coercedNumber;
    exports2._int = _int;
    exports2._float32 = _float32;
    exports2._float64 = _float64;
    exports2._int32 = _int32;
    exports2._uint32 = _uint32;
    exports2._boolean = _boolean;
    exports2._coercedBoolean = _coercedBoolean;
    exports2._bigint = _bigint;
    exports2._coercedBigint = _coercedBigint;
    exports2._int64 = _int64;
    exports2._uint64 = _uint64;
    exports2._symbol = _symbol;
    exports2._undefined = _undefined;
    exports2._null = _null;
    exports2._any = _any;
    exports2._unknown = _unknown;
    exports2._never = _never;
    exports2._void = _void;
    exports2._date = _date;
    exports2._coercedDate = _coercedDate;
    exports2._nan = _nan;
    exports2._lt = _lt;
    exports2._lte = _lte;
    exports2._max = _lte;
    exports2._lte = _lte;
    exports2._max = _lte;
    exports2._gt = _gt;
    exports2._gte = _gte;
    exports2._min = _gte;
    exports2._gte = _gte;
    exports2._min = _gte;
    exports2._positive = _positive;
    exports2._negative = _negative;
    exports2._nonpositive = _nonpositive;
    exports2._nonnegative = _nonnegative;
    exports2._multipleOf = _multipleOf;
    exports2._maxSize = _maxSize;
    exports2._minSize = _minSize;
    exports2._size = _size;
    exports2._maxLength = _maxLength;
    exports2._minLength = _minLength;
    exports2._length = _length;
    exports2._regex = _regex;
    exports2._lowercase = _lowercase;
    exports2._uppercase = _uppercase;
    exports2._includes = _includes;
    exports2._startsWith = _startsWith;
    exports2._endsWith = _endsWith;
    exports2._property = _property;
    exports2._mime = _mime;
    exports2._overwrite = _overwrite;
    exports2._normalize = _normalize;
    exports2._trim = _trim;
    exports2._toLowerCase = _toLowerCase;
    exports2._toUpperCase = _toUpperCase;
    exports2._array = _array;
    exports2._union = _union;
    exports2._discriminatedUnion = _discriminatedUnion;
    exports2._intersection = _intersection;
    exports2._tuple = _tuple;
    exports2._record = _record;
    exports2._map = _map;
    exports2._set = _set;
    exports2._enum = _enum;
    exports2._nativeEnum = _nativeEnum;
    exports2._literal = _literal;
    exports2._file = _file;
    exports2._transform = _transform;
    exports2._optional = _optional;
    exports2._nullable = _nullable;
    exports2._default = _default;
    exports2._nonoptional = _nonoptional;
    exports2._success = _success;
    exports2._catch = _catch;
    exports2._pipe = _pipe;
    exports2._readonly = _readonly;
    exports2._templateLiteral = _templateLiteral;
    exports2._lazy = _lazy;
    exports2._promise = _promise;
    exports2._custom = _custom;
    exports2._refine = _refine;
    exports2._superRefine = _superRefine;
    exports2._check = _check;
    exports2._stringbool = _stringbool;
    exports2._stringFormat = _stringFormat;
    var checks = __importStar(require_checks());
    var schemas = __importStar(require_schemas());
    var util = __importStar(require_util2());
    function _string(Class, params) {
      return new Class({
        type: "string",
        ...util.normalizeParams(params)
      });
    }
    function _coercedString(Class, params) {
      return new Class({
        type: "string",
        coerce: true,
        ...util.normalizeParams(params)
      });
    }
    function _email(Class, params) {
      return new Class({
        type: "string",
        format: "email",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _guid(Class, params) {
      return new Class({
        type: "string",
        format: "guid",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _uuid(Class, params) {
      return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _uuidv4(Class, params) {
      return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        version: "v4",
        ...util.normalizeParams(params)
      });
    }
    function _uuidv6(Class, params) {
      return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        version: "v6",
        ...util.normalizeParams(params)
      });
    }
    function _uuidv7(Class, params) {
      return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        version: "v7",
        ...util.normalizeParams(params)
      });
    }
    function _url(Class, params) {
      return new Class({
        type: "string",
        format: "url",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _emoji(Class, params) {
      return new Class({
        type: "string",
        format: "emoji",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _nanoid(Class, params) {
      return new Class({
        type: "string",
        format: "nanoid",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _cuid(Class, params) {
      return new Class({
        type: "string",
        format: "cuid",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _cuid2(Class, params) {
      return new Class({
        type: "string",
        format: "cuid2",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _ulid(Class, params) {
      return new Class({
        type: "string",
        format: "ulid",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _xid(Class, params) {
      return new Class({
        type: "string",
        format: "xid",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _ksuid(Class, params) {
      return new Class({
        type: "string",
        format: "ksuid",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _ipv4(Class, params) {
      return new Class({
        type: "string",
        format: "ipv4",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _ipv6(Class, params) {
      return new Class({
        type: "string",
        format: "ipv6",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _cidrv4(Class, params) {
      return new Class({
        type: "string",
        format: "cidrv4",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _cidrv6(Class, params) {
      return new Class({
        type: "string",
        format: "cidrv6",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _base64(Class, params) {
      return new Class({
        type: "string",
        format: "base64",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _base64url(Class, params) {
      return new Class({
        type: "string",
        format: "base64url",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _e164(Class, params) {
      return new Class({
        type: "string",
        format: "e164",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _jwt(Class, params) {
      return new Class({
        type: "string",
        format: "jwt",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    exports2.TimePrecision = {
      Any: null,
      Minute: -1,
      Second: 0,
      Millisecond: 3,
      Microsecond: 6
    };
    function _isoDateTime(Class, params) {
      return new Class({
        type: "string",
        format: "datetime",
        check: "string_format",
        offset: false,
        local: false,
        precision: null,
        ...util.normalizeParams(params)
      });
    }
    function _isoDate(Class, params) {
      return new Class({
        type: "string",
        format: "date",
        check: "string_format",
        ...util.normalizeParams(params)
      });
    }
    function _isoTime(Class, params) {
      return new Class({
        type: "string",
        format: "time",
        check: "string_format",
        precision: null,
        ...util.normalizeParams(params)
      });
    }
    function _isoDuration(Class, params) {
      return new Class({
        type: "string",
        format: "duration",
        check: "string_format",
        ...util.normalizeParams(params)
      });
    }
    function _number(Class, params) {
      return new Class({
        type: "number",
        checks: [],
        ...util.normalizeParams(params)
      });
    }
    function _coercedNumber(Class, params) {
      return new Class({
        type: "number",
        coerce: true,
        checks: [],
        ...util.normalizeParams(params)
      });
    }
    function _int(Class, params) {
      return new Class({
        type: "number",
        check: "number_format",
        abort: false,
        format: "safeint",
        ...util.normalizeParams(params)
      });
    }
    function _float32(Class, params) {
      return new Class({
        type: "number",
        check: "number_format",
        abort: false,
        format: "float32",
        ...util.normalizeParams(params)
      });
    }
    function _float64(Class, params) {
      return new Class({
        type: "number",
        check: "number_format",
        abort: false,
        format: "float64",
        ...util.normalizeParams(params)
      });
    }
    function _int32(Class, params) {
      return new Class({
        type: "number",
        check: "number_format",
        abort: false,
        format: "int32",
        ...util.normalizeParams(params)
      });
    }
    function _uint32(Class, params) {
      return new Class({
        type: "number",
        check: "number_format",
        abort: false,
        format: "uint32",
        ...util.normalizeParams(params)
      });
    }
    function _boolean(Class, params) {
      return new Class({
        type: "boolean",
        ...util.normalizeParams(params)
      });
    }
    function _coercedBoolean(Class, params) {
      return new Class({
        type: "boolean",
        coerce: true,
        ...util.normalizeParams(params)
      });
    }
    function _bigint(Class, params) {
      return new Class({
        type: "bigint",
        ...util.normalizeParams(params)
      });
    }
    function _coercedBigint(Class, params) {
      return new Class({
        type: "bigint",
        coerce: true,
        ...util.normalizeParams(params)
      });
    }
    function _int64(Class, params) {
      return new Class({
        type: "bigint",
        check: "bigint_format",
        abort: false,
        format: "int64",
        ...util.normalizeParams(params)
      });
    }
    function _uint64(Class, params) {
      return new Class({
        type: "bigint",
        check: "bigint_format",
        abort: false,
        format: "uint64",
        ...util.normalizeParams(params)
      });
    }
    function _symbol(Class, params) {
      return new Class({
        type: "symbol",
        ...util.normalizeParams(params)
      });
    }
    function _undefined(Class, params) {
      return new Class({
        type: "undefined",
        ...util.normalizeParams(params)
      });
    }
    function _null(Class, params) {
      return new Class({
        type: "null",
        ...util.normalizeParams(params)
      });
    }
    function _any(Class) {
      return new Class({
        type: "any"
      });
    }
    function _unknown(Class) {
      return new Class({
        type: "unknown"
      });
    }
    function _never(Class, params) {
      return new Class({
        type: "never",
        ...util.normalizeParams(params)
      });
    }
    function _void(Class, params) {
      return new Class({
        type: "void",
        ...util.normalizeParams(params)
      });
    }
    function _date(Class, params) {
      return new Class({
        type: "date",
        ...util.normalizeParams(params)
      });
    }
    function _coercedDate(Class, params) {
      return new Class({
        type: "date",
        coerce: true,
        ...util.normalizeParams(params)
      });
    }
    function _nan(Class, params) {
      return new Class({
        type: "nan",
        ...util.normalizeParams(params)
      });
    }
    function _lt(value, params) {
      return new checks.$ZodCheckLessThan({
        check: "less_than",
        ...util.normalizeParams(params),
        value,
        inclusive: false
      });
    }
    function _lte(value, params) {
      return new checks.$ZodCheckLessThan({
        check: "less_than",
        ...util.normalizeParams(params),
        value,
        inclusive: true
      });
    }
    function _gt(value, params) {
      return new checks.$ZodCheckGreaterThan({
        check: "greater_than",
        ...util.normalizeParams(params),
        value,
        inclusive: false
      });
    }
    function _gte(value, params) {
      return new checks.$ZodCheckGreaterThan({
        check: "greater_than",
        ...util.normalizeParams(params),
        value,
        inclusive: true
      });
    }
    function _positive(params) {
      return _gt(0, params);
    }
    function _negative(params) {
      return _lt(0, params);
    }
    function _nonpositive(params) {
      return _lte(0, params);
    }
    function _nonnegative(params) {
      return _gte(0, params);
    }
    function _multipleOf(value, params) {
      return new checks.$ZodCheckMultipleOf({
        check: "multiple_of",
        ...util.normalizeParams(params),
        value
      });
    }
    function _maxSize(maximum, params) {
      return new checks.$ZodCheckMaxSize({
        check: "max_size",
        ...util.normalizeParams(params),
        maximum
      });
    }
    function _minSize(minimum, params) {
      return new checks.$ZodCheckMinSize({
        check: "min_size",
        ...util.normalizeParams(params),
        minimum
      });
    }
    function _size(size, params) {
      return new checks.$ZodCheckSizeEquals({
        check: "size_equals",
        ...util.normalizeParams(params),
        size
      });
    }
    function _maxLength(maximum, params) {
      const ch = new checks.$ZodCheckMaxLength({
        check: "max_length",
        ...util.normalizeParams(params),
        maximum
      });
      return ch;
    }
    function _minLength(minimum, params) {
      return new checks.$ZodCheckMinLength({
        check: "min_length",
        ...util.normalizeParams(params),
        minimum
      });
    }
    function _length(length, params) {
      return new checks.$ZodCheckLengthEquals({
        check: "length_equals",
        ...util.normalizeParams(params),
        length
      });
    }
    function _regex(pattern, params) {
      return new checks.$ZodCheckRegex({
        check: "string_format",
        format: "regex",
        ...util.normalizeParams(params),
        pattern
      });
    }
    function _lowercase(params) {
      return new checks.$ZodCheckLowerCase({
        check: "string_format",
        format: "lowercase",
        ...util.normalizeParams(params)
      });
    }
    function _uppercase(params) {
      return new checks.$ZodCheckUpperCase({
        check: "string_format",
        format: "uppercase",
        ...util.normalizeParams(params)
      });
    }
    function _includes(includes, params) {
      return new checks.$ZodCheckIncludes({
        check: "string_format",
        format: "includes",
        ...util.normalizeParams(params),
        includes
      });
    }
    function _startsWith(prefix, params) {
      return new checks.$ZodCheckStartsWith({
        check: "string_format",
        format: "starts_with",
        ...util.normalizeParams(params),
        prefix
      });
    }
    function _endsWith(suffix, params) {
      return new checks.$ZodCheckEndsWith({
        check: "string_format",
        format: "ends_with",
        ...util.normalizeParams(params),
        suffix
      });
    }
    function _property(property, schema, params) {
      return new checks.$ZodCheckProperty({
        check: "property",
        property,
        schema,
        ...util.normalizeParams(params)
      });
    }
    function _mime(types, params) {
      return new checks.$ZodCheckMimeType({
        check: "mime_type",
        mime: types,
        ...util.normalizeParams(params)
      });
    }
    function _overwrite(tx) {
      return new checks.$ZodCheckOverwrite({
        check: "overwrite",
        tx
      });
    }
    function _normalize(form) {
      return _overwrite((input) => input.normalize(form));
    }
    function _trim() {
      return _overwrite((input) => input.trim());
    }
    function _toLowerCase() {
      return _overwrite((input) => input.toLowerCase());
    }
    function _toUpperCase() {
      return _overwrite((input) => input.toUpperCase());
    }
    function _array(Class, element, params) {
      return new Class({
        type: "array",
        element,
        // get element() {
        //   return element;
        // },
        ...util.normalizeParams(params)
      });
    }
    function _union(Class, options, params) {
      return new Class({
        type: "union",
        options,
        ...util.normalizeParams(params)
      });
    }
    function _discriminatedUnion(Class, discriminator, options, params) {
      return new Class({
        type: "union",
        options,
        discriminator,
        ...util.normalizeParams(params)
      });
    }
    function _intersection(Class, left, right) {
      return new Class({
        type: "intersection",
        left,
        right
      });
    }
    function _tuple(Class, items, _paramsOrRest, _params) {
      const hasRest = _paramsOrRest instanceof schemas.$ZodType;
      const params = hasRest ? _params : _paramsOrRest;
      const rest = hasRest ? _paramsOrRest : null;
      return new Class({
        type: "tuple",
        items,
        rest,
        ...util.normalizeParams(params)
      });
    }
    function _record(Class, keyType, valueType, params) {
      return new Class({
        type: "record",
        keyType,
        valueType,
        ...util.normalizeParams(params)
      });
    }
    function _map(Class, keyType, valueType, params) {
      return new Class({
        type: "map",
        keyType,
        valueType,
        ...util.normalizeParams(params)
      });
    }
    function _set(Class, valueType, params) {
      return new Class({
        type: "set",
        valueType,
        ...util.normalizeParams(params)
      });
    }
    function _enum(Class, values, params) {
      const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
      return new Class({
        type: "enum",
        entries,
        ...util.normalizeParams(params)
      });
    }
    function _nativeEnum(Class, entries, params) {
      return new Class({
        type: "enum",
        entries,
        ...util.normalizeParams(params)
      });
    }
    function _literal(Class, value, params) {
      return new Class({
        type: "literal",
        values: Array.isArray(value) ? value : [value],
        ...util.normalizeParams(params)
      });
    }
    function _file(Class, params) {
      return new Class({
        type: "file",
        ...util.normalizeParams(params)
      });
    }
    function _transform(Class, fn) {
      return new Class({
        type: "transform",
        transform: fn
      });
    }
    function _optional(Class, innerType) {
      return new Class({
        type: "optional",
        innerType
      });
    }
    function _nullable(Class, innerType) {
      return new Class({
        type: "nullable",
        innerType
      });
    }
    function _default(Class, innerType, defaultValue) {
      return new Class({
        type: "default",
        innerType,
        get defaultValue() {
          return typeof defaultValue === "function" ? defaultValue() : util.shallowClone(defaultValue);
        }
      });
    }
    function _nonoptional(Class, innerType, params) {
      return new Class({
        type: "nonoptional",
        innerType,
        ...util.normalizeParams(params)
      });
    }
    function _success(Class, innerType) {
      return new Class({
        type: "success",
        innerType
      });
    }
    function _catch(Class, innerType, catchValue) {
      return new Class({
        type: "catch",
        innerType,
        catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
      });
    }
    function _pipe(Class, in_, out) {
      return new Class({
        type: "pipe",
        in: in_,
        out
      });
    }
    function _readonly(Class, innerType) {
      return new Class({
        type: "readonly",
        innerType
      });
    }
    function _templateLiteral(Class, parts, params) {
      return new Class({
        type: "template_literal",
        parts,
        ...util.normalizeParams(params)
      });
    }
    function _lazy(Class, getter) {
      return new Class({
        type: "lazy",
        getter
      });
    }
    function _promise(Class, innerType) {
      return new Class({
        type: "promise",
        innerType
      });
    }
    function _custom(Class, fn, _params) {
      const norm = util.normalizeParams(_params);
      norm.abort ?? (norm.abort = true);
      const schema = new Class({
        type: "custom",
        check: "custom",
        fn,
        ...norm
      });
      return schema;
    }
    function _refine(Class, fn, _params) {
      const schema = new Class({
        type: "custom",
        check: "custom",
        fn,
        ...util.normalizeParams(_params)
      });
      return schema;
    }
    function _superRefine(fn) {
      const ch = _check((payload) => {
        payload.addIssue = (issue) => {
          if (typeof issue === "string") {
            payload.issues.push(util.issue(issue, payload.value, ch._zod.def));
          } else {
            const _issue = issue;
            if (_issue.fatal)
              _issue.continue = false;
            _issue.code ?? (_issue.code = "custom");
            _issue.input ?? (_issue.input = payload.value);
            _issue.inst ?? (_issue.inst = ch);
            _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
            payload.issues.push(util.issue(_issue));
          }
        };
        return fn(payload.value, payload);
      });
      return ch;
    }
    function _check(fn, params) {
      const ch = new checks.$ZodCheck({
        check: "custom",
        ...util.normalizeParams(params)
      });
      ch._zod.check = fn;
      return ch;
    }
    function _stringbool(Classes, _params) {
      const params = util.normalizeParams(_params);
      let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
      let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
      if (params.case !== "sensitive") {
        truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
        falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
      }
      const truthySet = new Set(truthyArray);
      const falsySet = new Set(falsyArray);
      const _Codec = Classes.Codec ?? schemas.$ZodCodec;
      const _Boolean = Classes.Boolean ?? schemas.$ZodBoolean;
      const _String = Classes.String ?? schemas.$ZodString;
      const stringSchema = new _String({ type: "string", error: params.error });
      const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
      const codec = new _Codec({
        type: "pipe",
        in: stringSchema,
        out: booleanSchema,
        transform: ((input, payload) => {
          let data = input;
          if (params.case !== "sensitive")
            data = data.toLowerCase();
          if (truthySet.has(data)) {
            return true;
          } else if (falsySet.has(data)) {
            return false;
          } else {
            payload.issues.push({
              code: "invalid_value",
              expected: "stringbool",
              values: [...truthySet, ...falsySet],
              input: payload.value,
              inst: codec,
              continue: false
            });
            return {};
          }
        }),
        reverseTransform: ((input, _payload) => {
          if (input === true) {
            return truthyArray[0] || "true";
          } else {
            return falsyArray[0] || "false";
          }
        }),
        error: params.error
      });
      return codec;
    }
    function _stringFormat(Class, format, fnOrRegex, _params = {}) {
      const params = util.normalizeParams(_params);
      const def = {
        ...util.normalizeParams(_params),
        check: "string_format",
        type: "string",
        format,
        fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
        ...params
      };
      if (fnOrRegex instanceof RegExp) {
        def.pattern = fnOrRegex;
      }
      const inst = new Class(def);
      return inst;
    }
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/to-json-schema.cjs
var require_to_json_schema = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/to-json-schema.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JSONSchemaGenerator = void 0;
    exports2.toJSONSchema = toJSONSchema;
    var registries_js_1 = require_registries();
    var util_js_1 = require_util2();
    var JSONSchemaGenerator = class {
      constructor(params) {
        this.counter = 0;
        this.metadataRegistry = params?.metadata ?? registries_js_1.globalRegistry;
        this.target = params?.target ?? "draft-2020-12";
        this.unrepresentable = params?.unrepresentable ?? "throw";
        this.override = params?.override ?? (() => {
        });
        this.io = params?.io ?? "output";
        this.seen = /* @__PURE__ */ new Map();
      }
      process(schema, _params = { path: [], schemaPath: [] }) {
        var _a;
        const def = schema._zod.def;
        const formatMap = {
          guid: "uuid",
          url: "uri",
          datetime: "date-time",
          json_string: "json-string",
          regex: ""
          // do not set
        };
        const seen = this.seen.get(schema);
        if (seen) {
          seen.count++;
          const isCycle = _params.schemaPath.includes(schema);
          if (isCycle) {
            seen.cycle = _params.path;
          }
          return seen.schema;
        }
        const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
        this.seen.set(schema, result);
        const overrideSchema = schema._zod.toJSONSchema?.();
        if (overrideSchema) {
          result.schema = overrideSchema;
        } else {
          const params = {
            ..._params,
            schemaPath: [..._params.schemaPath, schema],
            path: _params.path
          };
          const parent = schema._zod.parent;
          if (parent) {
            result.ref = parent;
            this.process(parent, params);
            this.seen.get(parent).isParent = true;
          } else {
            const _json = result.schema;
            switch (def.type) {
              case "string": {
                const json = _json;
                json.type = "string";
                const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
                if (typeof minimum === "number")
                  json.minLength = minimum;
                if (typeof maximum === "number")
                  json.maxLength = maximum;
                if (format) {
                  json.format = formatMap[format] ?? format;
                  if (json.format === "")
                    delete json.format;
                }
                if (contentEncoding)
                  json.contentEncoding = contentEncoding;
                if (patterns && patterns.size > 0) {
                  const regexes = [...patterns];
                  if (regexes.length === 1)
                    json.pattern = regexes[0].source;
                  else if (regexes.length > 1) {
                    result.schema.allOf = [
                      ...regexes.map((regex) => ({
                        ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {},
                        pattern: regex.source
                      }))
                    ];
                  }
                }
                break;
              }
              case "number": {
                const json = _json;
                const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
                if (typeof format === "string" && format.includes("int"))
                  json.type = "integer";
                else
                  json.type = "number";
                if (typeof exclusiveMinimum === "number") {
                  if (this.target === "draft-4" || this.target === "openapi-3.0") {
                    json.minimum = exclusiveMinimum;
                    json.exclusiveMinimum = true;
                  } else {
                    json.exclusiveMinimum = exclusiveMinimum;
                  }
                }
                if (typeof minimum === "number") {
                  json.minimum = minimum;
                  if (typeof exclusiveMinimum === "number" && this.target !== "draft-4") {
                    if (exclusiveMinimum >= minimum)
                      delete json.minimum;
                    else
                      delete json.exclusiveMinimum;
                  }
                }
                if (typeof exclusiveMaximum === "number") {
                  if (this.target === "draft-4" || this.target === "openapi-3.0") {
                    json.maximum = exclusiveMaximum;
                    json.exclusiveMaximum = true;
                  } else {
                    json.exclusiveMaximum = exclusiveMaximum;
                  }
                }
                if (typeof maximum === "number") {
                  json.maximum = maximum;
                  if (typeof exclusiveMaximum === "number" && this.target !== "draft-4") {
                    if (exclusiveMaximum <= maximum)
                      delete json.maximum;
                    else
                      delete json.exclusiveMaximum;
                  }
                }
                if (typeof multipleOf === "number")
                  json.multipleOf = multipleOf;
                break;
              }
              case "boolean": {
                const json = _json;
                json.type = "boolean";
                break;
              }
              case "bigint": {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt cannot be represented in JSON Schema");
                }
                break;
              }
              case "symbol": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Symbols cannot be represented in JSON Schema");
                }
                break;
              }
              case "null": {
                if (this.target === "openapi-3.0") {
                  _json.type = "string";
                  _json.nullable = true;
                  _json.enum = [null];
                } else
                  _json.type = "null";
                break;
              }
              case "any": {
                break;
              }
              case "unknown": {
                break;
              }
              case "undefined": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Undefined cannot be represented in JSON Schema");
                }
                break;
              }
              case "void": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Void cannot be represented in JSON Schema");
                }
                break;
              }
              case "never": {
                _json.not = {};
                break;
              }
              case "date": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Date cannot be represented in JSON Schema");
                }
                break;
              }
              case "array": {
                const json = _json;
                const { minimum, maximum } = schema._zod.bag;
                if (typeof minimum === "number")
                  json.minItems = minimum;
                if (typeof maximum === "number")
                  json.maxItems = maximum;
                json.type = "array";
                json.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
                break;
              }
              case "object": {
                const json = _json;
                json.type = "object";
                json.properties = {};
                const shape = def.shape;
                for (const key in shape) {
                  json.properties[key] = this.process(shape[key], {
                    ...params,
                    path: [...params.path, "properties", key]
                  });
                }
                const allKeys = new Set(Object.keys(shape));
                const requiredKeys = new Set([...allKeys].filter((key) => {
                  const v = def.shape[key]._zod;
                  if (this.io === "input") {
                    return v.optin === void 0;
                  } else {
                    return v.optout === void 0;
                  }
                }));
                if (requiredKeys.size > 0) {
                  json.required = Array.from(requiredKeys);
                }
                if (def.catchall?._zod.def.type === "never") {
                  json.additionalProperties = false;
                } else if (!def.catchall) {
                  if (this.io === "output")
                    json.additionalProperties = false;
                } else if (def.catchall) {
                  json.additionalProperties = this.process(def.catchall, {
                    ...params,
                    path: [...params.path, "additionalProperties"]
                  });
                }
                break;
              }
              case "union": {
                const json = _json;
                const options = def.options.map((x, i) => this.process(x, {
                  ...params,
                  path: [...params.path, "anyOf", i]
                }));
                json.anyOf = options;
                break;
              }
              case "intersection": {
                const json = _json;
                const a = this.process(def.left, {
                  ...params,
                  path: [...params.path, "allOf", 0]
                });
                const b = this.process(def.right, {
                  ...params,
                  path: [...params.path, "allOf", 1]
                });
                const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
                const allOf = [
                  ...isSimpleIntersection(a) ? a.allOf : [a],
                  ...isSimpleIntersection(b) ? b.allOf : [b]
                ];
                json.allOf = allOf;
                break;
              }
              case "tuple": {
                const json = _json;
                json.type = "array";
                const prefixPath = this.target === "draft-2020-12" ? "prefixItems" : "items";
                const restPath = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems";
                const prefixItems = def.items.map((x, i) => this.process(x, {
                  ...params,
                  path: [...params.path, prefixPath, i]
                }));
                const rest = def.rest ? this.process(def.rest, {
                  ...params,
                  path: [...params.path, restPath, ...this.target === "openapi-3.0" ? [def.items.length] : []]
                }) : null;
                if (this.target === "draft-2020-12") {
                  json.prefixItems = prefixItems;
                  if (rest) {
                    json.items = rest;
                  }
                } else if (this.target === "openapi-3.0") {
                  json.items = {
                    anyOf: prefixItems
                  };
                  if (rest) {
                    json.items.anyOf.push(rest);
                  }
                  json.minItems = prefixItems.length;
                  if (!rest) {
                    json.maxItems = prefixItems.length;
                  }
                } else {
                  json.items = prefixItems;
                  if (rest) {
                    json.additionalItems = rest;
                  }
                }
                const { minimum, maximum } = schema._zod.bag;
                if (typeof minimum === "number")
                  json.minItems = minimum;
                if (typeof maximum === "number")
                  json.maxItems = maximum;
                break;
              }
              case "record": {
                const json = _json;
                json.type = "object";
                if (this.target === "draft-7" || this.target === "draft-2020-12") {
                  json.propertyNames = this.process(def.keyType, {
                    ...params,
                    path: [...params.path, "propertyNames"]
                  });
                }
                json.additionalProperties = this.process(def.valueType, {
                  ...params,
                  path: [...params.path, "additionalProperties"]
                });
                break;
              }
              case "map": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Map cannot be represented in JSON Schema");
                }
                break;
              }
              case "set": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Set cannot be represented in JSON Schema");
                }
                break;
              }
              case "enum": {
                const json = _json;
                const values = (0, util_js_1.getEnumValues)(def.entries);
                if (values.every((v) => typeof v === "number"))
                  json.type = "number";
                if (values.every((v) => typeof v === "string"))
                  json.type = "string";
                json.enum = values;
                break;
              }
              case "literal": {
                const json = _json;
                const vals = [];
                for (const val of def.values) {
                  if (val === void 0) {
                    if (this.unrepresentable === "throw") {
                      throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                    } else {
                    }
                  } else if (typeof val === "bigint") {
                    if (this.unrepresentable === "throw") {
                      throw new Error("BigInt literals cannot be represented in JSON Schema");
                    } else {
                      vals.push(Number(val));
                    }
                  } else {
                    vals.push(val);
                  }
                }
                if (vals.length === 0) {
                } else if (vals.length === 1) {
                  const val = vals[0];
                  json.type = val === null ? "null" : typeof val;
                  if (this.target === "draft-4" || this.target === "openapi-3.0") {
                    json.enum = [val];
                  } else {
                    json.const = val;
                  }
                } else {
                  if (vals.every((v) => typeof v === "number"))
                    json.type = "number";
                  if (vals.every((v) => typeof v === "string"))
                    json.type = "string";
                  if (vals.every((v) => typeof v === "boolean"))
                    json.type = "string";
                  if (vals.every((v) => v === null))
                    json.type = "null";
                  json.enum = vals;
                }
                break;
              }
              case "file": {
                const json = _json;
                const file = {
                  type: "string",
                  format: "binary",
                  contentEncoding: "binary"
                };
                const { minimum, maximum, mime } = schema._zod.bag;
                if (minimum !== void 0)
                  file.minLength = minimum;
                if (maximum !== void 0)
                  file.maxLength = maximum;
                if (mime) {
                  if (mime.length === 1) {
                    file.contentMediaType = mime[0];
                    Object.assign(json, file);
                  } else {
                    json.anyOf = mime.map((m) => {
                      const mFile = { ...file, contentMediaType: m };
                      return mFile;
                    });
                  }
                } else {
                  Object.assign(json, file);
                }
                break;
              }
              case "transform": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Transforms cannot be represented in JSON Schema");
                }
                break;
              }
              case "nullable": {
                const inner = this.process(def.innerType, params);
                if (this.target === "openapi-3.0") {
                  result.ref = def.innerType;
                  _json.nullable = true;
                } else {
                  _json.anyOf = [inner, { type: "null" }];
                }
                break;
              }
              case "nonoptional": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                break;
              }
              case "success": {
                const json = _json;
                json.type = "boolean";
                break;
              }
              case "default": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                _json.default = JSON.parse(JSON.stringify(def.defaultValue));
                break;
              }
              case "prefault": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                if (this.io === "input")
                  _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
                break;
              }
              case "catch": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                let catchValue;
                try {
                  catchValue = def.catchValue(void 0);
                } catch {
                  throw new Error("Dynamic catch values are not supported in JSON Schema");
                }
                _json.default = catchValue;
                break;
              }
              case "nan": {
                if (this.unrepresentable === "throw") {
                  throw new Error("NaN cannot be represented in JSON Schema");
                }
                break;
              }
              case "template_literal": {
                const json = _json;
                const pattern = schema._zod.pattern;
                if (!pattern)
                  throw new Error("Pattern not found in template literal");
                json.type = "string";
                json.pattern = pattern.source;
                break;
              }
              case "pipe": {
                const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
                this.process(innerType, params);
                result.ref = innerType;
                break;
              }
              case "readonly": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                _json.readOnly = true;
                break;
              }
              // passthrough types
              case "promise": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                break;
              }
              case "optional": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                break;
              }
              case "lazy": {
                const innerType = schema._zod.innerType;
                this.process(innerType, params);
                result.ref = innerType;
                break;
              }
              case "custom": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Custom types cannot be represented in JSON Schema");
                }
                break;
              }
              case "function": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Function types cannot be represented in JSON Schema");
                }
                break;
              }
              default: {
                def;
              }
            }
          }
        }
        const meta = this.metadataRegistry.get(schema);
        if (meta)
          Object.assign(result.schema, meta);
        if (this.io === "input" && isTransforming(schema)) {
          delete result.schema.examples;
          delete result.schema.default;
        }
        if (this.io === "input" && result.schema._prefault)
          (_a = result.schema).default ?? (_a.default = result.schema._prefault);
        delete result.schema._prefault;
        const _result = this.seen.get(schema);
        return _result.schema;
      }
      emit(schema, _params) {
        const params = {
          cycles: _params?.cycles ?? "ref",
          reused: _params?.reused ?? "inline",
          // unrepresentable: _params?.unrepresentable ?? "throw",
          // uri: _params?.uri ?? ((id) => `${id}`),
          external: _params?.external ?? void 0
        };
        const root = this.seen.get(schema);
        if (!root)
          throw new Error("Unprocessed schema. This is a bug in Zod.");
        const makeURI = (entry) => {
          const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
          if (params.external) {
            const externalId = params.external.registry.get(entry[0])?.id;
            const uriGenerator = params.external.uri ?? ((id2) => id2);
            if (externalId) {
              return { ref: uriGenerator(externalId) };
            }
            const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
            entry[1].defId = id;
            return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
          }
          if (entry[1] === root) {
            return { ref: "#" };
          }
          const uriPrefix = `#`;
          const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
          const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
          return { defId, ref: defUriPrefix + defId };
        };
        const extractToDef = (entry) => {
          if (entry[1].schema.$ref) {
            return;
          }
          const seen = entry[1];
          const { ref, defId } = makeURI(entry);
          seen.def = { ...seen.schema };
          if (defId)
            seen.defId = defId;
          const schema2 = seen.schema;
          for (const key in schema2) {
            delete schema2[key];
          }
          schema2.$ref = ref;
        };
        if (params.cycles === "throw") {
          for (const entry of this.seen.entries()) {
            const seen = entry[1];
            if (seen.cycle) {
              throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
            }
          }
        }
        for (const entry of this.seen.entries()) {
          const seen = entry[1];
          if (schema === entry[0]) {
            extractToDef(entry);
            continue;
          }
          if (params.external) {
            const ext = params.external.registry.get(entry[0])?.id;
            if (schema !== entry[0] && ext) {
              extractToDef(entry);
              continue;
            }
          }
          const id = this.metadataRegistry.get(entry[0])?.id;
          if (id) {
            extractToDef(entry);
            continue;
          }
          if (seen.cycle) {
            extractToDef(entry);
            continue;
          }
          if (seen.count > 1) {
            if (params.reused === "ref") {
              extractToDef(entry);
              continue;
            }
          }
        }
        const flattenRef = (zodSchema, params2) => {
          const seen = this.seen.get(zodSchema);
          const schema2 = seen.def ?? seen.schema;
          const _cached = { ...schema2 };
          if (seen.ref === null) {
            return;
          }
          const ref = seen.ref;
          seen.ref = null;
          if (ref) {
            flattenRef(ref, params2);
            const refSchema = this.seen.get(ref).schema;
            if (refSchema.$ref && (params2.target === "draft-7" || params2.target === "draft-4" || params2.target === "openapi-3.0")) {
              schema2.allOf = schema2.allOf ?? [];
              schema2.allOf.push(refSchema);
            } else {
              Object.assign(schema2, refSchema);
              Object.assign(schema2, _cached);
            }
          }
          if (!seen.isParent)
            this.override({
              zodSchema,
              jsonSchema: schema2,
              path: seen.path ?? []
            });
        };
        for (const entry of [...this.seen.entries()].reverse()) {
          flattenRef(entry[0], { target: this.target });
        }
        const result = {};
        if (this.target === "draft-2020-12") {
          result.$schema = "https://json-schema.org/draft/2020-12/schema";
        } else if (this.target === "draft-7") {
          result.$schema = "http://json-schema.org/draft-07/schema#";
        } else if (this.target === "draft-4") {
          result.$schema = "http://json-schema.org/draft-04/schema#";
        } else if (this.target === "openapi-3.0") {
        } else {
          console.warn(`Invalid target: ${this.target}`);
        }
        if (params.external?.uri) {
          const id = params.external.registry.get(schema)?.id;
          if (!id)
            throw new Error("Schema is missing an `id` property");
          result.$id = params.external.uri(id);
        }
        Object.assign(result, root.def);
        const defs = params.external?.defs ?? {};
        for (const entry of this.seen.entries()) {
          const seen = entry[1];
          if (seen.def && seen.defId) {
            defs[seen.defId] = seen.def;
          }
        }
        if (params.external) {
        } else {
          if (Object.keys(defs).length > 0) {
            if (this.target === "draft-2020-12") {
              result.$defs = defs;
            } else {
              result.definitions = defs;
            }
          }
        }
        try {
          return JSON.parse(JSON.stringify(result));
        } catch (_err) {
          throw new Error("Error converting schema to JSON.");
        }
      }
    };
    exports2.JSONSchemaGenerator = JSONSchemaGenerator;
    function toJSONSchema(input, _params) {
      if (input instanceof registries_js_1.$ZodRegistry) {
        const gen2 = new JSONSchemaGenerator(_params);
        const defs = {};
        for (const entry of input._idmap.entries()) {
          const [_, schema] = entry;
          gen2.process(schema);
        }
        const schemas = {};
        const external = {
          registry: input,
          uri: _params?.uri,
          defs
        };
        for (const entry of input._idmap.entries()) {
          const [key, schema] = entry;
          schemas[key] = gen2.emit(schema, {
            ..._params,
            external
          });
        }
        if (Object.keys(defs).length > 0) {
          const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
          schemas.__shared = {
            [defsSegment]: defs
          };
        }
        return { schemas };
      }
      const gen = new JSONSchemaGenerator(_params);
      gen.process(input);
      return gen.emit(input, _params);
    }
    function isTransforming(_schema, _ctx) {
      const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
      if (ctx.seen.has(_schema))
        return false;
      ctx.seen.add(_schema);
      const schema = _schema;
      const def = schema._zod.def;
      switch (def.type) {
        case "string":
        case "number":
        case "bigint":
        case "boolean":
        case "date":
        case "symbol":
        case "undefined":
        case "null":
        case "any":
        case "unknown":
        case "never":
        case "void":
        case "literal":
        case "enum":
        case "nan":
        case "file":
        case "template_literal":
          return false;
        case "array": {
          return isTransforming(def.element, ctx);
        }
        case "object": {
          for (const key in def.shape) {
            if (isTransforming(def.shape[key], ctx))
              return true;
          }
          return false;
        }
        case "union": {
          for (const option of def.options) {
            if (isTransforming(option, ctx))
              return true;
          }
          return false;
        }
        case "intersection": {
          return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
        }
        case "tuple": {
          for (const item of def.items) {
            if (isTransforming(item, ctx))
              return true;
          }
          if (def.rest && isTransforming(def.rest, ctx))
            return true;
          return false;
        }
        case "record": {
          return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
        }
        case "map": {
          return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
        }
        case "set": {
          return isTransforming(def.valueType, ctx);
        }
        // inner types
        case "promise":
        case "optional":
        case "nonoptional":
        case "nullable":
        case "readonly":
          return isTransforming(def.innerType, ctx);
        case "lazy":
          return isTransforming(def.getter(), ctx);
        case "default": {
          return isTransforming(def.innerType, ctx);
        }
        case "prefault": {
          return isTransforming(def.innerType, ctx);
        }
        case "custom": {
          return false;
        }
        case "transform": {
          return true;
        }
        case "pipe": {
          return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
        }
        case "success": {
          return false;
        }
        case "catch": {
          return false;
        }
        case "function": {
          return false;
        }
        default:
          def;
      }
      throw new Error(`Unknown schema type: ${def.type}`);
    }
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/json-schema.cjs
var require_json_schema = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/json-schema.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/index.cjs
var require_core2 = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/core/index.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JSONSchema = exports2.locales = exports2.regexes = exports2.util = void 0;
    __exportStar(require_core(), exports2);
    __exportStar(require_parse(), exports2);
    __exportStar(require_errors2(), exports2);
    __exportStar(require_schemas(), exports2);
    __exportStar(require_checks(), exports2);
    __exportStar(require_versions(), exports2);
    exports2.util = __importStar(require_util2());
    exports2.regexes = __importStar(require_regexes());
    exports2.locales = __importStar(require_locales());
    __exportStar(require_registries(), exports2);
    __exportStar(require_doc(), exports2);
    __exportStar(require_api(), exports2);
    __exportStar(require_to_json_schema(), exports2);
    exports2.JSONSchema = __importStar(require_json_schema());
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/classic/checks.cjs
var require_checks2 = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/classic/checks.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toUpperCase = exports2.toLowerCase = exports2.trim = exports2.normalize = exports2.overwrite = exports2.mime = exports2.property = exports2.endsWith = exports2.startsWith = exports2.includes = exports2.uppercase = exports2.lowercase = exports2.regex = exports2.length = exports2.minLength = exports2.maxLength = exports2.size = exports2.minSize = exports2.maxSize = exports2.multipleOf = exports2.nonnegative = exports2.nonpositive = exports2.negative = exports2.positive = exports2.gte = exports2.gt = exports2.lte = exports2.lt = void 0;
    var index_js_1 = require_core2();
    Object.defineProperty(exports2, "lt", { enumerable: true, get: function() {
      return index_js_1._lt;
    } });
    Object.defineProperty(exports2, "lte", { enumerable: true, get: function() {
      return index_js_1._lte;
    } });
    Object.defineProperty(exports2, "gt", { enumerable: true, get: function() {
      return index_js_1._gt;
    } });
    Object.defineProperty(exports2, "gte", { enumerable: true, get: function() {
      return index_js_1._gte;
    } });
    Object.defineProperty(exports2, "positive", { enumerable: true, get: function() {
      return index_js_1._positive;
    } });
    Object.defineProperty(exports2, "negative", { enumerable: true, get: function() {
      return index_js_1._negative;
    } });
    Object.defineProperty(exports2, "nonpositive", { enumerable: true, get: function() {
      return index_js_1._nonpositive;
    } });
    Object.defineProperty(exports2, "nonnegative", { enumerable: true, get: function() {
      return index_js_1._nonnegative;
    } });
    Object.defineProperty(exports2, "multipleOf", { enumerable: true, get: function() {
      return index_js_1._multipleOf;
    } });
    Object.defineProperty(exports2, "maxSize", { enumerable: true, get: function() {
      return index_js_1._maxSize;
    } });
    Object.defineProperty(exports2, "minSize", { enumerable: true, get: function() {
      return index_js_1._minSize;
    } });
    Object.defineProperty(exports2, "size", { enumerable: true, get: function() {
      return index_js_1._size;
    } });
    Object.defineProperty(exports2, "maxLength", { enumerable: true, get: function() {
      return index_js_1._maxLength;
    } });
    Object.defineProperty(exports2, "minLength", { enumerable: true, get: function() {
      return index_js_1._minLength;
    } });
    Object.defineProperty(exports2, "length", { enumerable: true, get: function() {
      return index_js_1._length;
    } });
    Object.defineProperty(exports2, "regex", { enumerable: true, get: function() {
      return index_js_1._regex;
    } });
    Object.defineProperty(exports2, "lowercase", { enumerable: true, get: function() {
      return index_js_1._lowercase;
    } });
    Object.defineProperty(exports2, "uppercase", { enumerable: true, get: function() {
      return index_js_1._uppercase;
    } });
    Object.defineProperty(exports2, "includes", { enumerable: true, get: function() {
      return index_js_1._includes;
    } });
    Object.defineProperty(exports2, "startsWith", { enumerable: true, get: function() {
      return index_js_1._startsWith;
    } });
    Object.defineProperty(exports2, "endsWith", { enumerable: true, get: function() {
      return index_js_1._endsWith;
    } });
    Object.defineProperty(exports2, "property", { enumerable: true, get: function() {
      return index_js_1._property;
    } });
    Object.defineProperty(exports2, "mime", { enumerable: true, get: function() {
      return index_js_1._mime;
    } });
    Object.defineProperty(exports2, "overwrite", { enumerable: true, get: function() {
      return index_js_1._overwrite;
    } });
    Object.defineProperty(exports2, "normalize", { enumerable: true, get: function() {
      return index_js_1._normalize;
    } });
    Object.defineProperty(exports2, "trim", { enumerable: true, get: function() {
      return index_js_1._trim;
    } });
    Object.defineProperty(exports2, "toLowerCase", { enumerable: true, get: function() {
      return index_js_1._toLowerCase;
    } });
    Object.defineProperty(exports2, "toUpperCase", { enumerable: true, get: function() {
      return index_js_1._toUpperCase;
    } });
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/classic/iso.cjs
var require_iso = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/classic/iso.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ZodISODuration = exports2.ZodISOTime = exports2.ZodISODate = exports2.ZodISODateTime = void 0;
    exports2.datetime = datetime;
    exports2.date = date;
    exports2.time = time;
    exports2.duration = duration;
    var core = __importStar(require_core2());
    var schemas = __importStar(require_schemas2());
    exports2.ZodISODateTime = core.$constructor("ZodISODateTime", (inst, def) => {
      core.$ZodISODateTime.init(inst, def);
      schemas.ZodStringFormat.init(inst, def);
    });
    function datetime(params) {
      return core._isoDateTime(exports2.ZodISODateTime, params);
    }
    exports2.ZodISODate = core.$constructor("ZodISODate", (inst, def) => {
      core.$ZodISODate.init(inst, def);
      schemas.ZodStringFormat.init(inst, def);
    });
    function date(params) {
      return core._isoDate(exports2.ZodISODate, params);
    }
    exports2.ZodISOTime = core.$constructor("ZodISOTime", (inst, def) => {
      core.$ZodISOTime.init(inst, def);
      schemas.ZodStringFormat.init(inst, def);
    });
    function time(params) {
      return core._isoTime(exports2.ZodISOTime, params);
    }
    exports2.ZodISODuration = core.$constructor("ZodISODuration", (inst, def) => {
      core.$ZodISODuration.init(inst, def);
      schemas.ZodStringFormat.init(inst, def);
    });
    function duration(params) {
      return core._isoDuration(exports2.ZodISODuration, params);
    }
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/classic/errors.cjs
var require_errors3 = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/classic/errors.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ZodRealError = exports2.ZodError = void 0;
    var core = __importStar(require_core2());
    var index_js_1 = require_core2();
    var util = __importStar(require_util2());
    var initializer = (inst, issues) => {
      index_js_1.$ZodError.init(inst, issues);
      inst.name = "ZodError";
      Object.defineProperties(inst, {
        format: {
          value: (mapper) => core.formatError(inst, mapper)
          // enumerable: false,
        },
        flatten: {
          value: (mapper) => core.flattenError(inst, mapper)
          // enumerable: false,
        },
        addIssue: {
          value: (issue) => {
            inst.issues.push(issue);
            inst.message = JSON.stringify(inst.issues, util.jsonStringifyReplacer, 2);
          }
          // enumerable: false,
        },
        addIssues: {
          value: (issues2) => {
            inst.issues.push(...issues2);
            inst.message = JSON.stringify(inst.issues, util.jsonStringifyReplacer, 2);
          }
          // enumerable: false,
        },
        isEmpty: {
          get() {
            return inst.issues.length === 0;
          }
          // enumerable: false,
        }
      });
    };
    exports2.ZodError = core.$constructor("ZodError", initializer);
    exports2.ZodRealError = core.$constructor("ZodError", initializer, {
      Parent: Error
    });
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/classic/parse.cjs
var require_parse2 = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/classic/parse.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.safeDecodeAsync = exports2.safeEncodeAsync = exports2.safeDecode = exports2.safeEncode = exports2.decodeAsync = exports2.encodeAsync = exports2.decode = exports2.encode = exports2.safeParseAsync = exports2.safeParse = exports2.parseAsync = exports2.parse = void 0;
    var core = __importStar(require_core2());
    var errors_js_1 = require_errors3();
    exports2.parse = core._parse(errors_js_1.ZodRealError);
    exports2.parseAsync = core._parseAsync(errors_js_1.ZodRealError);
    exports2.safeParse = core._safeParse(errors_js_1.ZodRealError);
    exports2.safeParseAsync = core._safeParseAsync(errors_js_1.ZodRealError);
    exports2.encode = core._encode(errors_js_1.ZodRealError);
    exports2.decode = core._decode(errors_js_1.ZodRealError);
    exports2.encodeAsync = core._encodeAsync(errors_js_1.ZodRealError);
    exports2.decodeAsync = core._decodeAsync(errors_js_1.ZodRealError);
    exports2.safeEncode = core._safeEncode(errors_js_1.ZodRealError);
    exports2.safeDecode = core._safeDecode(errors_js_1.ZodRealError);
    exports2.safeEncodeAsync = core._safeEncodeAsync(errors_js_1.ZodRealError);
    exports2.safeDecodeAsync = core._safeDecodeAsync(errors_js_1.ZodRealError);
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/classic/schemas.cjs
var require_schemas2 = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/classic/schemas.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ZodTransform = exports2.ZodFile = exports2.ZodLiteral = exports2.ZodEnum = exports2.ZodSet = exports2.ZodMap = exports2.ZodRecord = exports2.ZodTuple = exports2.ZodIntersection = exports2.ZodDiscriminatedUnion = exports2.ZodUnion = exports2.ZodObject = exports2.ZodArray = exports2.ZodDate = exports2.ZodVoid = exports2.ZodNever = exports2.ZodUnknown = exports2.ZodAny = exports2.ZodNull = exports2.ZodUndefined = exports2.ZodSymbol = exports2.ZodBigIntFormat = exports2.ZodBigInt = exports2.ZodBoolean = exports2.ZodNumberFormat = exports2.ZodNumber = exports2.ZodCustomStringFormat = exports2.ZodJWT = exports2.ZodE164 = exports2.ZodBase64URL = exports2.ZodBase64 = exports2.ZodCIDRv6 = exports2.ZodCIDRv4 = exports2.ZodIPv6 = exports2.ZodIPv4 = exports2.ZodKSUID = exports2.ZodXID = exports2.ZodULID = exports2.ZodCUID2 = exports2.ZodCUID = exports2.ZodNanoID = exports2.ZodEmoji = exports2.ZodURL = exports2.ZodUUID = exports2.ZodGUID = exports2.ZodEmail = exports2.ZodStringFormat = exports2.ZodString = exports2._ZodString = exports2.ZodType = void 0;
    exports2.stringbool = exports2.ZodCustom = exports2.ZodFunction = exports2.ZodPromise = exports2.ZodLazy = exports2.ZodTemplateLiteral = exports2.ZodReadonly = exports2.ZodCodec = exports2.ZodPipe = exports2.ZodNaN = exports2.ZodCatch = exports2.ZodSuccess = exports2.ZodNonOptional = exports2.ZodPrefault = exports2.ZodDefault = exports2.ZodNullable = exports2.ZodOptional = void 0;
    exports2.string = string;
    exports2.email = email;
    exports2.guid = guid;
    exports2.uuid = uuid;
    exports2.uuidv4 = uuidv4;
    exports2.uuidv6 = uuidv6;
    exports2.uuidv7 = uuidv7;
    exports2.url = url;
    exports2.httpUrl = httpUrl;
    exports2.emoji = emoji;
    exports2.nanoid = nanoid;
    exports2.cuid = cuid;
    exports2.cuid2 = cuid2;
    exports2.ulid = ulid;
    exports2.xid = xid;
    exports2.ksuid = ksuid;
    exports2.ipv4 = ipv4;
    exports2.ipv6 = ipv6;
    exports2.cidrv4 = cidrv4;
    exports2.cidrv6 = cidrv6;
    exports2.base64 = base64;
    exports2.base64url = base64url;
    exports2.e164 = e164;
    exports2.jwt = jwt;
    exports2.stringFormat = stringFormat;
    exports2.hostname = hostname;
    exports2.hex = hex;
    exports2.hash = hash;
    exports2.number = number;
    exports2.int = int;
    exports2.float32 = float32;
    exports2.float64 = float64;
    exports2.int32 = int32;
    exports2.uint32 = uint32;
    exports2.boolean = boolean;
    exports2.bigint = bigint;
    exports2.int64 = int64;
    exports2.uint64 = uint64;
    exports2.symbol = symbol;
    exports2.undefined = _undefined;
    exports2.null = _null;
    exports2.any = any;
    exports2.unknown = unknown;
    exports2.never = never;
    exports2.void = _void;
    exports2.date = date;
    exports2.array = array;
    exports2.keyof = keyof;
    exports2.object = object;
    exports2.strictObject = strictObject;
    exports2.looseObject = looseObject;
    exports2.union = union;
    exports2.discriminatedUnion = discriminatedUnion;
    exports2.intersection = intersection;
    exports2.tuple = tuple;
    exports2.record = record;
    exports2.partialRecord = partialRecord;
    exports2.map = map;
    exports2.set = set;
    exports2.enum = _enum;
    exports2.nativeEnum = nativeEnum;
    exports2.literal = literal;
    exports2.file = file;
    exports2.transform = transform;
    exports2.optional = optional;
    exports2.nullable = nullable;
    exports2.nullish = nullish;
    exports2._default = _default;
    exports2.prefault = prefault;
    exports2.nonoptional = nonoptional;
    exports2.success = success;
    exports2.catch = _catch;
    exports2.nan = nan;
    exports2.pipe = pipe;
    exports2.codec = codec;
    exports2.readonly = readonly;
    exports2.templateLiteral = templateLiteral;
    exports2.lazy = lazy;
    exports2.promise = promise;
    exports2._function = _function;
    exports2.function = _function;
    exports2._function = _function;
    exports2.function = _function;
    exports2.check = check;
    exports2.custom = custom;
    exports2.refine = refine;
    exports2.superRefine = superRefine;
    exports2.instanceof = _instanceof;
    exports2.json = json;
    exports2.preprocess = preprocess;
    var core = __importStar(require_core2());
    var index_js_1 = require_core2();
    var checks = __importStar(require_checks2());
    var iso = __importStar(require_iso());
    var parse2 = __importStar(require_parse2());
    exports2.ZodType = core.$constructor("ZodType", (inst, def) => {
      core.$ZodType.init(inst, def);
      inst.def = def;
      inst.type = def.type;
      Object.defineProperty(inst, "_def", { value: def });
      inst.check = (...checks2) => {
        return inst.clone(index_js_1.util.mergeDefs(def, {
          checks: [
            ...def.checks ?? [],
            ...checks2.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
          ]
        }));
      };
      inst.clone = (def2, params) => core.clone(inst, def2, params);
      inst.brand = () => inst;
      inst.register = ((reg, meta) => {
        reg.add(inst, meta);
        return inst;
      });
      inst.parse = (data, params) => parse2.parse(inst, data, params, { callee: inst.parse });
      inst.safeParse = (data, params) => parse2.safeParse(inst, data, params);
      inst.parseAsync = async (data, params) => parse2.parseAsync(inst, data, params, { callee: inst.parseAsync });
      inst.safeParseAsync = async (data, params) => parse2.safeParseAsync(inst, data, params);
      inst.spa = inst.safeParseAsync;
      inst.encode = (data, params) => parse2.encode(inst, data, params);
      inst.decode = (data, params) => parse2.decode(inst, data, params);
      inst.encodeAsync = async (data, params) => parse2.encodeAsync(inst, data, params);
      inst.decodeAsync = async (data, params) => parse2.decodeAsync(inst, data, params);
      inst.safeEncode = (data, params) => parse2.safeEncode(inst, data, params);
      inst.safeDecode = (data, params) => parse2.safeDecode(inst, data, params);
      inst.safeEncodeAsync = async (data, params) => parse2.safeEncodeAsync(inst, data, params);
      inst.safeDecodeAsync = async (data, params) => parse2.safeDecodeAsync(inst, data, params);
      inst.refine = (check2, params) => inst.check(refine(check2, params));
      inst.superRefine = (refinement) => inst.check(superRefine(refinement));
      inst.overwrite = (fn) => inst.check(checks.overwrite(fn));
      inst.optional = () => optional(inst);
      inst.nullable = () => nullable(inst);
      inst.nullish = () => optional(nullable(inst));
      inst.nonoptional = (params) => nonoptional(inst, params);
      inst.array = () => array(inst);
      inst.or = (arg) => union([inst, arg]);
      inst.and = (arg) => intersection(inst, arg);
      inst.transform = (tx) => pipe(inst, transform(tx));
      inst.default = (def2) => _default(inst, def2);
      inst.prefault = (def2) => prefault(inst, def2);
      inst.catch = (params) => _catch(inst, params);
      inst.pipe = (target) => pipe(inst, target);
      inst.readonly = () => readonly(inst);
      inst.describe = (description) => {
        const cl = inst.clone();
        core.globalRegistry.add(cl, { description });
        return cl;
      };
      Object.defineProperty(inst, "description", {
        get() {
          return core.globalRegistry.get(inst)?.description;
        },
        configurable: true
      });
      inst.meta = (...args) => {
        if (args.length === 0) {
          return core.globalRegistry.get(inst);
        }
        const cl = inst.clone();
        core.globalRegistry.add(cl, args[0]);
        return cl;
      };
      inst.isOptional = () => inst.safeParse(void 0).success;
      inst.isNullable = () => inst.safeParse(null).success;
      return inst;
    });
    exports2._ZodString = core.$constructor("_ZodString", (inst, def) => {
      core.$ZodString.init(inst, def);
      exports2.ZodType.init(inst, def);
      const bag = inst._zod.bag;
      inst.format = bag.format ?? null;
      inst.minLength = bag.minimum ?? null;
      inst.maxLength = bag.maximum ?? null;
      inst.regex = (...args) => inst.check(checks.regex(...args));
      inst.includes = (...args) => inst.check(checks.includes(...args));
      inst.startsWith = (...args) => inst.check(checks.startsWith(...args));
      inst.endsWith = (...args) => inst.check(checks.endsWith(...args));
      inst.min = (...args) => inst.check(checks.minLength(...args));
      inst.max = (...args) => inst.check(checks.maxLength(...args));
      inst.length = (...args) => inst.check(checks.length(...args));
      inst.nonempty = (...args) => inst.check(checks.minLength(1, ...args));
      inst.lowercase = (params) => inst.check(checks.lowercase(params));
      inst.uppercase = (params) => inst.check(checks.uppercase(params));
      inst.trim = () => inst.check(checks.trim());
      inst.normalize = (...args) => inst.check(checks.normalize(...args));
      inst.toLowerCase = () => inst.check(checks.toLowerCase());
      inst.toUpperCase = () => inst.check(checks.toUpperCase());
    });
    exports2.ZodString = core.$constructor("ZodString", (inst, def) => {
      core.$ZodString.init(inst, def);
      exports2._ZodString.init(inst, def);
      inst.email = (params) => inst.check(core._email(exports2.ZodEmail, params));
      inst.url = (params) => inst.check(core._url(exports2.ZodURL, params));
      inst.jwt = (params) => inst.check(core._jwt(exports2.ZodJWT, params));
      inst.emoji = (params) => inst.check(core._emoji(exports2.ZodEmoji, params));
      inst.guid = (params) => inst.check(core._guid(exports2.ZodGUID, params));
      inst.uuid = (params) => inst.check(core._uuid(exports2.ZodUUID, params));
      inst.uuidv4 = (params) => inst.check(core._uuidv4(exports2.ZodUUID, params));
      inst.uuidv6 = (params) => inst.check(core._uuidv6(exports2.ZodUUID, params));
      inst.uuidv7 = (params) => inst.check(core._uuidv7(exports2.ZodUUID, params));
      inst.nanoid = (params) => inst.check(core._nanoid(exports2.ZodNanoID, params));
      inst.guid = (params) => inst.check(core._guid(exports2.ZodGUID, params));
      inst.cuid = (params) => inst.check(core._cuid(exports2.ZodCUID, params));
      inst.cuid2 = (params) => inst.check(core._cuid2(exports2.ZodCUID2, params));
      inst.ulid = (params) => inst.check(core._ulid(exports2.ZodULID, params));
      inst.base64 = (params) => inst.check(core._base64(exports2.ZodBase64, params));
      inst.base64url = (params) => inst.check(core._base64url(exports2.ZodBase64URL, params));
      inst.xid = (params) => inst.check(core._xid(exports2.ZodXID, params));
      inst.ksuid = (params) => inst.check(core._ksuid(exports2.ZodKSUID, params));
      inst.ipv4 = (params) => inst.check(core._ipv4(exports2.ZodIPv4, params));
      inst.ipv6 = (params) => inst.check(core._ipv6(exports2.ZodIPv6, params));
      inst.cidrv4 = (params) => inst.check(core._cidrv4(exports2.ZodCIDRv4, params));
      inst.cidrv6 = (params) => inst.check(core._cidrv6(exports2.ZodCIDRv6, params));
      inst.e164 = (params) => inst.check(core._e164(exports2.ZodE164, params));
      inst.datetime = (params) => inst.check(iso.datetime(params));
      inst.date = (params) => inst.check(iso.date(params));
      inst.time = (params) => inst.check(iso.time(params));
      inst.duration = (params) => inst.check(iso.duration(params));
    });
    function string(params) {
      return core._string(exports2.ZodString, params);
    }
    exports2.ZodStringFormat = core.$constructor("ZodStringFormat", (inst, def) => {
      core.$ZodStringFormat.init(inst, def);
      exports2._ZodString.init(inst, def);
    });
    exports2.ZodEmail = core.$constructor("ZodEmail", (inst, def) => {
      core.$ZodEmail.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function email(params) {
      return core._email(exports2.ZodEmail, params);
    }
    exports2.ZodGUID = core.$constructor("ZodGUID", (inst, def) => {
      core.$ZodGUID.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function guid(params) {
      return core._guid(exports2.ZodGUID, params);
    }
    exports2.ZodUUID = core.$constructor("ZodUUID", (inst, def) => {
      core.$ZodUUID.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function uuid(params) {
      return core._uuid(exports2.ZodUUID, params);
    }
    function uuidv4(params) {
      return core._uuidv4(exports2.ZodUUID, params);
    }
    function uuidv6(params) {
      return core._uuidv6(exports2.ZodUUID, params);
    }
    function uuidv7(params) {
      return core._uuidv7(exports2.ZodUUID, params);
    }
    exports2.ZodURL = core.$constructor("ZodURL", (inst, def) => {
      core.$ZodURL.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function url(params) {
      return core._url(exports2.ZodURL, params);
    }
    function httpUrl(params) {
      return core._url(exports2.ZodURL, {
        protocol: /^https?$/,
        hostname: core.regexes.domain,
        ...index_js_1.util.normalizeParams(params)
      });
    }
    exports2.ZodEmoji = core.$constructor("ZodEmoji", (inst, def) => {
      core.$ZodEmoji.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function emoji(params) {
      return core._emoji(exports2.ZodEmoji, params);
    }
    exports2.ZodNanoID = core.$constructor("ZodNanoID", (inst, def) => {
      core.$ZodNanoID.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function nanoid(params) {
      return core._nanoid(exports2.ZodNanoID, params);
    }
    exports2.ZodCUID = core.$constructor("ZodCUID", (inst, def) => {
      core.$ZodCUID.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function cuid(params) {
      return core._cuid(exports2.ZodCUID, params);
    }
    exports2.ZodCUID2 = core.$constructor("ZodCUID2", (inst, def) => {
      core.$ZodCUID2.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function cuid2(params) {
      return core._cuid2(exports2.ZodCUID2, params);
    }
    exports2.ZodULID = core.$constructor("ZodULID", (inst, def) => {
      core.$ZodULID.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function ulid(params) {
      return core._ulid(exports2.ZodULID, params);
    }
    exports2.ZodXID = core.$constructor("ZodXID", (inst, def) => {
      core.$ZodXID.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function xid(params) {
      return core._xid(exports2.ZodXID, params);
    }
    exports2.ZodKSUID = core.$constructor("ZodKSUID", (inst, def) => {
      core.$ZodKSUID.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function ksuid(params) {
      return core._ksuid(exports2.ZodKSUID, params);
    }
    exports2.ZodIPv4 = core.$constructor("ZodIPv4", (inst, def) => {
      core.$ZodIPv4.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function ipv4(params) {
      return core._ipv4(exports2.ZodIPv4, params);
    }
    exports2.ZodIPv6 = core.$constructor("ZodIPv6", (inst, def) => {
      core.$ZodIPv6.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function ipv6(params) {
      return core._ipv6(exports2.ZodIPv6, params);
    }
    exports2.ZodCIDRv4 = core.$constructor("ZodCIDRv4", (inst, def) => {
      core.$ZodCIDRv4.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function cidrv4(params) {
      return core._cidrv4(exports2.ZodCIDRv4, params);
    }
    exports2.ZodCIDRv6 = core.$constructor("ZodCIDRv6", (inst, def) => {
      core.$ZodCIDRv6.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function cidrv6(params) {
      return core._cidrv6(exports2.ZodCIDRv6, params);
    }
    exports2.ZodBase64 = core.$constructor("ZodBase64", (inst, def) => {
      core.$ZodBase64.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function base64(params) {
      return core._base64(exports2.ZodBase64, params);
    }
    exports2.ZodBase64URL = core.$constructor("ZodBase64URL", (inst, def) => {
      core.$ZodBase64URL.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function base64url(params) {
      return core._base64url(exports2.ZodBase64URL, params);
    }
    exports2.ZodE164 = core.$constructor("ZodE164", (inst, def) => {
      core.$ZodE164.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function e164(params) {
      return core._e164(exports2.ZodE164, params);
    }
    exports2.ZodJWT = core.$constructor("ZodJWT", (inst, def) => {
      core.$ZodJWT.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function jwt(params) {
      return core._jwt(exports2.ZodJWT, params);
    }
    exports2.ZodCustomStringFormat = core.$constructor("ZodCustomStringFormat", (inst, def) => {
      core.$ZodCustomStringFormat.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function stringFormat(format, fnOrRegex, _params = {}) {
      return core._stringFormat(exports2.ZodCustomStringFormat, format, fnOrRegex, _params);
    }
    function hostname(_params) {
      return core._stringFormat(exports2.ZodCustomStringFormat, "hostname", core.regexes.hostname, _params);
    }
    function hex(_params) {
      return core._stringFormat(exports2.ZodCustomStringFormat, "hex", core.regexes.hex, _params);
    }
    function hash(alg, params) {
      const enc = params?.enc ?? "hex";
      const format = `${alg}_${enc}`;
      const regex = core.regexes[format];
      if (!regex)
        throw new Error(`Unrecognized hash format: ${format}`);
      return core._stringFormat(exports2.ZodCustomStringFormat, format, regex, params);
    }
    exports2.ZodNumber = core.$constructor("ZodNumber", (inst, def) => {
      core.$ZodNumber.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.gt = (value, params) => inst.check(checks.gt(value, params));
      inst.gte = (value, params) => inst.check(checks.gte(value, params));
      inst.min = (value, params) => inst.check(checks.gte(value, params));
      inst.lt = (value, params) => inst.check(checks.lt(value, params));
      inst.lte = (value, params) => inst.check(checks.lte(value, params));
      inst.max = (value, params) => inst.check(checks.lte(value, params));
      inst.int = (params) => inst.check(int(params));
      inst.safe = (params) => inst.check(int(params));
      inst.positive = (params) => inst.check(checks.gt(0, params));
      inst.nonnegative = (params) => inst.check(checks.gte(0, params));
      inst.negative = (params) => inst.check(checks.lt(0, params));
      inst.nonpositive = (params) => inst.check(checks.lte(0, params));
      inst.multipleOf = (value, params) => inst.check(checks.multipleOf(value, params));
      inst.step = (value, params) => inst.check(checks.multipleOf(value, params));
      inst.finite = () => inst;
      const bag = inst._zod.bag;
      inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
      inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
      inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
      inst.isFinite = true;
      inst.format = bag.format ?? null;
    });
    function number(params) {
      return core._number(exports2.ZodNumber, params);
    }
    exports2.ZodNumberFormat = core.$constructor("ZodNumberFormat", (inst, def) => {
      core.$ZodNumberFormat.init(inst, def);
      exports2.ZodNumber.init(inst, def);
    });
    function int(params) {
      return core._int(exports2.ZodNumberFormat, params);
    }
    function float32(params) {
      return core._float32(exports2.ZodNumberFormat, params);
    }
    function float64(params) {
      return core._float64(exports2.ZodNumberFormat, params);
    }
    function int32(params) {
      return core._int32(exports2.ZodNumberFormat, params);
    }
    function uint32(params) {
      return core._uint32(exports2.ZodNumberFormat, params);
    }
    exports2.ZodBoolean = core.$constructor("ZodBoolean", (inst, def) => {
      core.$ZodBoolean.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function boolean(params) {
      return core._boolean(exports2.ZodBoolean, params);
    }
    exports2.ZodBigInt = core.$constructor("ZodBigInt", (inst, def) => {
      core.$ZodBigInt.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.gte = (value, params) => inst.check(checks.gte(value, params));
      inst.min = (value, params) => inst.check(checks.gte(value, params));
      inst.gt = (value, params) => inst.check(checks.gt(value, params));
      inst.gte = (value, params) => inst.check(checks.gte(value, params));
      inst.min = (value, params) => inst.check(checks.gte(value, params));
      inst.lt = (value, params) => inst.check(checks.lt(value, params));
      inst.lte = (value, params) => inst.check(checks.lte(value, params));
      inst.max = (value, params) => inst.check(checks.lte(value, params));
      inst.positive = (params) => inst.check(checks.gt(BigInt(0), params));
      inst.negative = (params) => inst.check(checks.lt(BigInt(0), params));
      inst.nonpositive = (params) => inst.check(checks.lte(BigInt(0), params));
      inst.nonnegative = (params) => inst.check(checks.gte(BigInt(0), params));
      inst.multipleOf = (value, params) => inst.check(checks.multipleOf(value, params));
      const bag = inst._zod.bag;
      inst.minValue = bag.minimum ?? null;
      inst.maxValue = bag.maximum ?? null;
      inst.format = bag.format ?? null;
    });
    function bigint(params) {
      return core._bigint(exports2.ZodBigInt, params);
    }
    exports2.ZodBigIntFormat = core.$constructor("ZodBigIntFormat", (inst, def) => {
      core.$ZodBigIntFormat.init(inst, def);
      exports2.ZodBigInt.init(inst, def);
    });
    function int64(params) {
      return core._int64(exports2.ZodBigIntFormat, params);
    }
    function uint64(params) {
      return core._uint64(exports2.ZodBigIntFormat, params);
    }
    exports2.ZodSymbol = core.$constructor("ZodSymbol", (inst, def) => {
      core.$ZodSymbol.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function symbol(params) {
      return core._symbol(exports2.ZodSymbol, params);
    }
    exports2.ZodUndefined = core.$constructor("ZodUndefined", (inst, def) => {
      core.$ZodUndefined.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function _undefined(params) {
      return core._undefined(exports2.ZodUndefined, params);
    }
    exports2.ZodNull = core.$constructor("ZodNull", (inst, def) => {
      core.$ZodNull.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function _null(params) {
      return core._null(exports2.ZodNull, params);
    }
    exports2.ZodAny = core.$constructor("ZodAny", (inst, def) => {
      core.$ZodAny.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function any() {
      return core._any(exports2.ZodAny);
    }
    exports2.ZodUnknown = core.$constructor("ZodUnknown", (inst, def) => {
      core.$ZodUnknown.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function unknown() {
      return core._unknown(exports2.ZodUnknown);
    }
    exports2.ZodNever = core.$constructor("ZodNever", (inst, def) => {
      core.$ZodNever.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function never(params) {
      return core._never(exports2.ZodNever, params);
    }
    exports2.ZodVoid = core.$constructor("ZodVoid", (inst, def) => {
      core.$ZodVoid.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function _void(params) {
      return core._void(exports2.ZodVoid, params);
    }
    exports2.ZodDate = core.$constructor("ZodDate", (inst, def) => {
      core.$ZodDate.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.min = (value, params) => inst.check(checks.gte(value, params));
      inst.max = (value, params) => inst.check(checks.lte(value, params));
      const c = inst._zod.bag;
      inst.minDate = c.minimum ? new Date(c.minimum) : null;
      inst.maxDate = c.maximum ? new Date(c.maximum) : null;
    });
    function date(params) {
      return core._date(exports2.ZodDate, params);
    }
    exports2.ZodArray = core.$constructor("ZodArray", (inst, def) => {
      core.$ZodArray.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.element = def.element;
      inst.min = (minLength, params) => inst.check(checks.minLength(minLength, params));
      inst.nonempty = (params) => inst.check(checks.minLength(1, params));
      inst.max = (maxLength, params) => inst.check(checks.maxLength(maxLength, params));
      inst.length = (len, params) => inst.check(checks.length(len, params));
      inst.unwrap = () => inst.element;
    });
    function array(element, params) {
      return core._array(exports2.ZodArray, element, params);
    }
    function keyof(schema) {
      const shape = schema._zod.def.shape;
      return _enum(Object.keys(shape));
    }
    exports2.ZodObject = core.$constructor("ZodObject", (inst, def) => {
      core.$ZodObjectJIT.init(inst, def);
      exports2.ZodType.init(inst, def);
      index_js_1.util.defineLazy(inst, "shape", () => {
        return def.shape;
      });
      inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
      inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
      inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
      inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
      inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
      inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
      inst.extend = (incoming) => {
        return index_js_1.util.extend(inst, incoming);
      };
      inst.safeExtend = (incoming) => {
        return index_js_1.util.safeExtend(inst, incoming);
      };
      inst.merge = (other) => index_js_1.util.merge(inst, other);
      inst.pick = (mask) => index_js_1.util.pick(inst, mask);
      inst.omit = (mask) => index_js_1.util.omit(inst, mask);
      inst.partial = (...args) => index_js_1.util.partial(exports2.ZodOptional, inst, args[0]);
      inst.required = (...args) => index_js_1.util.required(exports2.ZodNonOptional, inst, args[0]);
    });
    function object(shape, params) {
      const def = {
        type: "object",
        shape: shape ?? {},
        ...index_js_1.util.normalizeParams(params)
      };
      return new exports2.ZodObject(def);
    }
    function strictObject(shape, params) {
      return new exports2.ZodObject({
        type: "object",
        shape,
        catchall: never(),
        ...index_js_1.util.normalizeParams(params)
      });
    }
    function looseObject(shape, params) {
      return new exports2.ZodObject({
        type: "object",
        shape,
        catchall: unknown(),
        ...index_js_1.util.normalizeParams(params)
      });
    }
    exports2.ZodUnion = core.$constructor("ZodUnion", (inst, def) => {
      core.$ZodUnion.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.options = def.options;
    });
    function union(options, params) {
      return new exports2.ZodUnion({
        type: "union",
        options,
        ...index_js_1.util.normalizeParams(params)
      });
    }
    exports2.ZodDiscriminatedUnion = core.$constructor("ZodDiscriminatedUnion", (inst, def) => {
      exports2.ZodUnion.init(inst, def);
      core.$ZodDiscriminatedUnion.init(inst, def);
    });
    function discriminatedUnion(discriminator, options, params) {
      return new exports2.ZodDiscriminatedUnion({
        type: "union",
        options,
        discriminator,
        ...index_js_1.util.normalizeParams(params)
      });
    }
    exports2.ZodIntersection = core.$constructor("ZodIntersection", (inst, def) => {
      core.$ZodIntersection.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function intersection(left, right) {
      return new exports2.ZodIntersection({
        type: "intersection",
        left,
        right
      });
    }
    exports2.ZodTuple = core.$constructor("ZodTuple", (inst, def) => {
      core.$ZodTuple.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.rest = (rest) => inst.clone({
        ...inst._zod.def,
        rest
      });
    });
    function tuple(items, _paramsOrRest, _params) {
      const hasRest = _paramsOrRest instanceof core.$ZodType;
      const params = hasRest ? _params : _paramsOrRest;
      const rest = hasRest ? _paramsOrRest : null;
      return new exports2.ZodTuple({
        type: "tuple",
        items,
        rest,
        ...index_js_1.util.normalizeParams(params)
      });
    }
    exports2.ZodRecord = core.$constructor("ZodRecord", (inst, def) => {
      core.$ZodRecord.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
    });
    function record(keyType, valueType, params) {
      return new exports2.ZodRecord({
        type: "record",
        keyType,
        valueType,
        ...index_js_1.util.normalizeParams(params)
      });
    }
    function partialRecord(keyType, valueType, params) {
      const k = core.clone(keyType);
      k._zod.values = void 0;
      return new exports2.ZodRecord({
        type: "record",
        keyType: k,
        valueType,
        ...index_js_1.util.normalizeParams(params)
      });
    }
    exports2.ZodMap = core.$constructor("ZodMap", (inst, def) => {
      core.$ZodMap.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
    });
    function map(keyType, valueType, params) {
      return new exports2.ZodMap({
        type: "map",
        keyType,
        valueType,
        ...index_js_1.util.normalizeParams(params)
      });
    }
    exports2.ZodSet = core.$constructor("ZodSet", (inst, def) => {
      core.$ZodSet.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.min = (...args) => inst.check(core._minSize(...args));
      inst.nonempty = (params) => inst.check(core._minSize(1, params));
      inst.max = (...args) => inst.check(core._maxSize(...args));
      inst.size = (...args) => inst.check(core._size(...args));
    });
    function set(valueType, params) {
      return new exports2.ZodSet({
        type: "set",
        valueType,
        ...index_js_1.util.normalizeParams(params)
      });
    }
    exports2.ZodEnum = core.$constructor("ZodEnum", (inst, def) => {
      core.$ZodEnum.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.enum = def.entries;
      inst.options = Object.values(def.entries);
      const keys = new Set(Object.keys(def.entries));
      inst.extract = (values, params) => {
        const newEntries = {};
        for (const value of values) {
          if (keys.has(value)) {
            newEntries[value] = def.entries[value];
          } else
            throw new Error(`Key ${value} not found in enum`);
        }
        return new exports2.ZodEnum({
          ...def,
          checks: [],
          ...index_js_1.util.normalizeParams(params),
          entries: newEntries
        });
      };
      inst.exclude = (values, params) => {
        const newEntries = { ...def.entries };
        for (const value of values) {
          if (keys.has(value)) {
            delete newEntries[value];
          } else
            throw new Error(`Key ${value} not found in enum`);
        }
        return new exports2.ZodEnum({
          ...def,
          checks: [],
          ...index_js_1.util.normalizeParams(params),
          entries: newEntries
        });
      };
    });
    function _enum(values, params) {
      const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
      return new exports2.ZodEnum({
        type: "enum",
        entries,
        ...index_js_1.util.normalizeParams(params)
      });
    }
    function nativeEnum(entries, params) {
      return new exports2.ZodEnum({
        type: "enum",
        entries,
        ...index_js_1.util.normalizeParams(params)
      });
    }
    exports2.ZodLiteral = core.$constructor("ZodLiteral", (inst, def) => {
      core.$ZodLiteral.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.values = new Set(def.values);
      Object.defineProperty(inst, "value", {
        get() {
          if (def.values.length > 1) {
            throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
          }
          return def.values[0];
        }
      });
    });
    function literal(value, params) {
      return new exports2.ZodLiteral({
        type: "literal",
        values: Array.isArray(value) ? value : [value],
        ...index_js_1.util.normalizeParams(params)
      });
    }
    exports2.ZodFile = core.$constructor("ZodFile", (inst, def) => {
      core.$ZodFile.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.min = (size, params) => inst.check(core._minSize(size, params));
      inst.max = (size, params) => inst.check(core._maxSize(size, params));
      inst.mime = (types, params) => inst.check(core._mime(Array.isArray(types) ? types : [types], params));
    });
    function file(params) {
      return core._file(exports2.ZodFile, params);
    }
    exports2.ZodTransform = core.$constructor("ZodTransform", (inst, def) => {
      core.$ZodTransform.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (_ctx.direction === "backward") {
          throw new core.$ZodEncodeError(inst.constructor.name);
        }
        payload.addIssue = (issue) => {
          if (typeof issue === "string") {
            payload.issues.push(index_js_1.util.issue(issue, payload.value, def));
          } else {
            const _issue = issue;
            if (_issue.fatal)
              _issue.continue = false;
            _issue.code ?? (_issue.code = "custom");
            _issue.input ?? (_issue.input = payload.value);
            _issue.inst ?? (_issue.inst = inst);
            payload.issues.push(index_js_1.util.issue(_issue));
          }
        };
        const output = def.transform(payload.value, payload);
        if (output instanceof Promise) {
          return output.then((output2) => {
            payload.value = output2;
            return payload;
          });
        }
        payload.value = output;
        return payload;
      };
    });
    function transform(fn) {
      return new exports2.ZodTransform({
        type: "transform",
        transform: fn
      });
    }
    exports2.ZodOptional = core.$constructor("ZodOptional", (inst, def) => {
      core.$ZodOptional.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    function optional(innerType) {
      return new exports2.ZodOptional({
        type: "optional",
        innerType
      });
    }
    exports2.ZodNullable = core.$constructor("ZodNullable", (inst, def) => {
      core.$ZodNullable.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    function nullable(innerType) {
      return new exports2.ZodNullable({
        type: "nullable",
        innerType
      });
    }
    function nullish(innerType) {
      return optional(nullable(innerType));
    }
    exports2.ZodDefault = core.$constructor("ZodDefault", (inst, def) => {
      core.$ZodDefault.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeDefault = inst.unwrap;
    });
    function _default(innerType, defaultValue) {
      return new exports2.ZodDefault({
        type: "default",
        innerType,
        get defaultValue() {
          return typeof defaultValue === "function" ? defaultValue() : index_js_1.util.shallowClone(defaultValue);
        }
      });
    }
    exports2.ZodPrefault = core.$constructor("ZodPrefault", (inst, def) => {
      core.$ZodPrefault.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    function prefault(innerType, defaultValue) {
      return new exports2.ZodPrefault({
        type: "prefault",
        innerType,
        get defaultValue() {
          return typeof defaultValue === "function" ? defaultValue() : index_js_1.util.shallowClone(defaultValue);
        }
      });
    }
    exports2.ZodNonOptional = core.$constructor("ZodNonOptional", (inst, def) => {
      core.$ZodNonOptional.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    function nonoptional(innerType, params) {
      return new exports2.ZodNonOptional({
        type: "nonoptional",
        innerType,
        ...index_js_1.util.normalizeParams(params)
      });
    }
    exports2.ZodSuccess = core.$constructor("ZodSuccess", (inst, def) => {
      core.$ZodSuccess.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    function success(innerType) {
      return new exports2.ZodSuccess({
        type: "success",
        innerType
      });
    }
    exports2.ZodCatch = core.$constructor("ZodCatch", (inst, def) => {
      core.$ZodCatch.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeCatch = inst.unwrap;
    });
    function _catch(innerType, catchValue) {
      return new exports2.ZodCatch({
        type: "catch",
        innerType,
        catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
      });
    }
    exports2.ZodNaN = core.$constructor("ZodNaN", (inst, def) => {
      core.$ZodNaN.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function nan(params) {
      return core._nan(exports2.ZodNaN, params);
    }
    exports2.ZodPipe = core.$constructor("ZodPipe", (inst, def) => {
      core.$ZodPipe.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.in = def.in;
      inst.out = def.out;
    });
    function pipe(in_, out) {
      return new exports2.ZodPipe({
        type: "pipe",
        in: in_,
        out
        // ...util.normalizeParams(params),
      });
    }
    exports2.ZodCodec = core.$constructor("ZodCodec", (inst, def) => {
      exports2.ZodPipe.init(inst, def);
      core.$ZodCodec.init(inst, def);
    });
    function codec(in_, out, params) {
      return new exports2.ZodCodec({
        type: "pipe",
        in: in_,
        out,
        transform: params.decode,
        reverseTransform: params.encode
      });
    }
    exports2.ZodReadonly = core.$constructor("ZodReadonly", (inst, def) => {
      core.$ZodReadonly.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    function readonly(innerType) {
      return new exports2.ZodReadonly({
        type: "readonly",
        innerType
      });
    }
    exports2.ZodTemplateLiteral = core.$constructor("ZodTemplateLiteral", (inst, def) => {
      core.$ZodTemplateLiteral.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function templateLiteral(parts, params) {
      return new exports2.ZodTemplateLiteral({
        type: "template_literal",
        parts,
        ...index_js_1.util.normalizeParams(params)
      });
    }
    exports2.ZodLazy = core.$constructor("ZodLazy", (inst, def) => {
      core.$ZodLazy.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.getter();
    });
    function lazy(getter) {
      return new exports2.ZodLazy({
        type: "lazy",
        getter
      });
    }
    exports2.ZodPromise = core.$constructor("ZodPromise", (inst, def) => {
      core.$ZodPromise.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    function promise(innerType) {
      return new exports2.ZodPromise({
        type: "promise",
        innerType
      });
    }
    exports2.ZodFunction = core.$constructor("ZodFunction", (inst, def) => {
      core.$ZodFunction.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function _function(params) {
      return new exports2.ZodFunction({
        type: "function",
        input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
        output: params?.output ?? unknown()
      });
    }
    exports2.ZodCustom = core.$constructor("ZodCustom", (inst, def) => {
      core.$ZodCustom.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function check(fn) {
      const ch = new core.$ZodCheck({
        check: "custom"
        // ...util.normalizeParams(params),
      });
      ch._zod.check = fn;
      return ch;
    }
    function custom(fn, _params) {
      return core._custom(exports2.ZodCustom, fn ?? (() => true), _params);
    }
    function refine(fn, _params = {}) {
      return core._refine(exports2.ZodCustom, fn, _params);
    }
    function superRefine(fn) {
      return core._superRefine(fn);
    }
    function _instanceof(cls, params = {
      error: `Input not instance of ${cls.name}`
    }) {
      const inst = new exports2.ZodCustom({
        type: "custom",
        check: "custom",
        fn: (data) => data instanceof cls,
        abort: true,
        ...index_js_1.util.normalizeParams(params)
      });
      inst._zod.bag.Class = cls;
      return inst;
    }
    var stringbool = (...args) => core._stringbool({
      Codec: exports2.ZodCodec,
      Boolean: exports2.ZodBoolean,
      String: exports2.ZodString
    }, ...args);
    exports2.stringbool = stringbool;
    function json(params) {
      const jsonSchema = lazy(() => {
        return union([string(params), number(), boolean(), _null(), array(jsonSchema), record(string(), jsonSchema)]);
      });
      return jsonSchema;
    }
    function preprocess(fn, schema) {
      return pipe(transform(fn), schema);
    }
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/classic/compat.cjs
var require_compat = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/classic/compat.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ZodFirstPartyTypeKind = exports2.config = exports2.$brand = exports2.ZodIssueCode = void 0;
    exports2.setErrorMap = setErrorMap;
    exports2.getErrorMap = getErrorMap;
    var core = __importStar(require_core2());
    exports2.ZodIssueCode = {
      invalid_type: "invalid_type",
      too_big: "too_big",
      too_small: "too_small",
      invalid_format: "invalid_format",
      not_multiple_of: "not_multiple_of",
      unrecognized_keys: "unrecognized_keys",
      invalid_union: "invalid_union",
      invalid_key: "invalid_key",
      invalid_element: "invalid_element",
      invalid_value: "invalid_value",
      custom: "custom"
    };
    var index_js_1 = require_core2();
    Object.defineProperty(exports2, "$brand", { enumerable: true, get: function() {
      return index_js_1.$brand;
    } });
    Object.defineProperty(exports2, "config", { enumerable: true, get: function() {
      return index_js_1.config;
    } });
    function setErrorMap(map) {
      core.config({
        customError: map
      });
    }
    function getErrorMap() {
      return core.config().customError;
    }
    var ZodFirstPartyTypeKind;
    /* @__PURE__ */ (function(ZodFirstPartyTypeKind2) {
    })(ZodFirstPartyTypeKind || (exports2.ZodFirstPartyTypeKind = ZodFirstPartyTypeKind = {}));
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/classic/coerce.cjs
var require_coerce = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/classic/coerce.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.string = string;
    exports2.number = number;
    exports2.boolean = boolean;
    exports2.bigint = bigint;
    exports2.date = date;
    var core = __importStar(require_core2());
    var schemas = __importStar(require_schemas2());
    function string(params) {
      return core._coercedString(schemas.ZodString, params);
    }
    function number(params) {
      return core._coercedNumber(schemas.ZodNumber, params);
    }
    function boolean(params) {
      return core._coercedBoolean(schemas.ZodBoolean, params);
    }
    function bigint(params) {
      return core._coercedBigint(schemas.ZodBigInt, params);
    }
    function date(params) {
      return core._coercedDate(schemas.ZodDate, params);
    }
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/classic/external.cjs
var require_external2 = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/classic/external.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.coerce = exports2.iso = exports2.ZodISODuration = exports2.ZodISOTime = exports2.ZodISODate = exports2.ZodISODateTime = exports2.locales = exports2.NEVER = exports2.util = exports2.TimePrecision = exports2.toJSONSchema = exports2.flattenError = exports2.formatError = exports2.prettifyError = exports2.treeifyError = exports2.regexes = exports2.clone = exports2.$brand = exports2.$input = exports2.$output = exports2.config = exports2.registry = exports2.globalRegistry = exports2.core = void 0;
    exports2.core = __importStar(require_core2());
    __exportStar(require_schemas2(), exports2);
    __exportStar(require_checks2(), exports2);
    __exportStar(require_errors3(), exports2);
    __exportStar(require_parse2(), exports2);
    __exportStar(require_compat(), exports2);
    var index_js_1 = require_core2();
    var en_js_1 = __importDefault(require_en2());
    (0, index_js_1.config)((0, en_js_1.default)());
    var index_js_2 = require_core2();
    Object.defineProperty(exports2, "globalRegistry", { enumerable: true, get: function() {
      return index_js_2.globalRegistry;
    } });
    Object.defineProperty(exports2, "registry", { enumerable: true, get: function() {
      return index_js_2.registry;
    } });
    Object.defineProperty(exports2, "config", { enumerable: true, get: function() {
      return index_js_2.config;
    } });
    Object.defineProperty(exports2, "$output", { enumerable: true, get: function() {
      return index_js_2.$output;
    } });
    Object.defineProperty(exports2, "$input", { enumerable: true, get: function() {
      return index_js_2.$input;
    } });
    Object.defineProperty(exports2, "$brand", { enumerable: true, get: function() {
      return index_js_2.$brand;
    } });
    Object.defineProperty(exports2, "clone", { enumerable: true, get: function() {
      return index_js_2.clone;
    } });
    Object.defineProperty(exports2, "regexes", { enumerable: true, get: function() {
      return index_js_2.regexes;
    } });
    Object.defineProperty(exports2, "treeifyError", { enumerable: true, get: function() {
      return index_js_2.treeifyError;
    } });
    Object.defineProperty(exports2, "prettifyError", { enumerable: true, get: function() {
      return index_js_2.prettifyError;
    } });
    Object.defineProperty(exports2, "formatError", { enumerable: true, get: function() {
      return index_js_2.formatError;
    } });
    Object.defineProperty(exports2, "flattenError", { enumerable: true, get: function() {
      return index_js_2.flattenError;
    } });
    Object.defineProperty(exports2, "toJSONSchema", { enumerable: true, get: function() {
      return index_js_2.toJSONSchema;
    } });
    Object.defineProperty(exports2, "TimePrecision", { enumerable: true, get: function() {
      return index_js_2.TimePrecision;
    } });
    Object.defineProperty(exports2, "util", { enumerable: true, get: function() {
      return index_js_2.util;
    } });
    Object.defineProperty(exports2, "NEVER", { enumerable: true, get: function() {
      return index_js_2.NEVER;
    } });
    exports2.locales = __importStar(require_locales());
    var iso_js_1 = require_iso();
    Object.defineProperty(exports2, "ZodISODateTime", { enumerable: true, get: function() {
      return iso_js_1.ZodISODateTime;
    } });
    Object.defineProperty(exports2, "ZodISODate", { enumerable: true, get: function() {
      return iso_js_1.ZodISODate;
    } });
    Object.defineProperty(exports2, "ZodISOTime", { enumerable: true, get: function() {
      return iso_js_1.ZodISOTime;
    } });
    Object.defineProperty(exports2, "ZodISODuration", { enumerable: true, get: function() {
      return iso_js_1.ZodISODuration;
    } });
    exports2.iso = __importStar(require_iso());
    exports2.coerce = __importStar(require_coerce());
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/classic/index.cjs
var require_classic = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/classic/index.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.z = void 0;
    var z = __importStar(require_external2());
    exports2.z = z;
    __exportStar(require_external2(), exports2);
    exports2.default = z;
  }
});

// node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/index.cjs
var require_v4 = __commonJS({
  "node_modules/.pnpm/zod@4.1.12/node_modules/zod/v4/index.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var index_js_1 = __importDefault(require_classic());
    __exportStar(require_classic(), exports2);
    exports2.default = index_js_1.default;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/_virtual/rolldown_runtime.cjs
var require_rolldown_runtime2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/_virtual/rolldown_runtime.cjs"(exports2) {
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all) __defProp2(target, name, {
        get: all[name],
        enumerable: true
      });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames2(from), i = 0, n = keys.length, key; i < n; i++) {
        key = keys[i];
        if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: ((k) => from[k]).bind(null, key),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", {
      value: mod,
      enumerable: true
    }) : target, mod));
    exports2.__export = __export2;
    exports2.__toESM = __toESM2;
  }
});

// node_modules/.pnpm/decamelize@1.2.0/node_modules/decamelize/index.js
var require_decamelize = __commonJS({
  "node_modules/.pnpm/decamelize@1.2.0/node_modules/decamelize/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(str, sep) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      sep = typeof sep === "undefined" ? "_" : sep;
      return str.replace(/([a-z\d])([A-Z])/g, "$1" + sep + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + sep + "$2").toLowerCase();
    };
  }
});

// node_modules/.pnpm/camelcase@6.3.0/node_modules/camelcase/index.js
var require_camelcase = __commonJS({
  "node_modules/.pnpm/camelcase@6.3.0/node_modules/camelcase/index.js"(exports2, module2) {
    "use strict";
    var UPPERCASE = /[\p{Lu}]/u;
    var LOWERCASE = /[\p{Ll}]/u;
    var LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
    var IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
    var SEPARATORS = /[_.\- ]+/;
    var LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
    var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
    var NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
    var preserveCamelCase = (string, toLowerCase, toUpperCase) => {
      let isLastCharLower = false;
      let isLastCharUpper = false;
      let isLastLastCharUpper = false;
      for (let i = 0; i < string.length; i++) {
        const character = string[i];
        if (isLastCharLower && UPPERCASE.test(character)) {
          string = string.slice(0, i) + "-" + string.slice(i);
          isLastCharLower = false;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = true;
          i++;
        } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
          string = string.slice(0, i - 1) + "-" + string.slice(i - 1);
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = false;
          isLastCharLower = true;
        } else {
          isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
        }
      }
      return string;
    };
    var preserveConsecutiveUppercase = (input, toLowerCase) => {
      LEADING_CAPITAL.lastIndex = 0;
      return input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1));
    };
    var postProcess = (input, toUpperCase) => {
      SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
      NUMBERS_AND_IDENTIFIER.lastIndex = 0;
      return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m) => toUpperCase(m));
    };
    var camelCase = (input, options) => {
      if (!(typeof input === "string" || Array.isArray(input))) {
        throw new TypeError("Expected the input to be `string | string[]`");
      }
      options = {
        pascalCase: false,
        preserveConsecutiveUppercase: false,
        ...options
      };
      if (Array.isArray(input)) {
        input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
      } else {
        input = input.trim();
      }
      if (input.length === 0) {
        return "";
      }
      const toLowerCase = options.locale === false ? (string) => string.toLowerCase() : (string) => string.toLocaleLowerCase(options.locale);
      const toUpperCase = options.locale === false ? (string) => string.toUpperCase() : (string) => string.toLocaleUpperCase(options.locale);
      if (input.length === 1) {
        return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
      }
      const hasUpperCase = input !== toLowerCase(input);
      if (hasUpperCase) {
        input = preserveCamelCase(input, toLowerCase, toUpperCase);
      }
      input = input.replace(LEADING_SEPARATORS, "");
      if (options.preserveConsecutiveUppercase) {
        input = preserveConsecutiveUppercase(input, toLowerCase);
      } else {
        input = toLowerCase(input);
      }
      if (options.pascalCase) {
        input = toUpperCase(input.charAt(0)) + input.slice(1);
      }
      return postProcess(input, toUpperCase);
    };
    module2.exports = camelCase;
    module2.exports.default = camelCase;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/load/map_keys.cjs
var require_map_keys = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/load/map_keys.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var decamelize = require_rolldown_runtime5.__toESM(require_decamelize());
    var camelcase = require_rolldown_runtime5.__toESM(require_camelcase());
    function keyToJson(key, map) {
      return map?.[key] || (0, decamelize.default)(key);
    }
    function keyFromJson(key, map) {
      return map?.[key] || (0, camelcase.default)(key);
    }
    function mapKeys(fields, mapper, map) {
      const mapped = {};
      for (const key in fields) if (Object.hasOwn(fields, key)) mapped[mapper(key, map)] = fields[key];
      return mapped;
    }
    exports2.keyFromJson = keyFromJson;
    exports2.keyToJson = keyToJson;
    exports2.mapKeys = mapKeys;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/load/serializable.cjs
var require_serializable = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/load/serializable.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_map_keys2 = require_map_keys();
    var serializable_exports = {};
    require_rolldown_runtime5.__export(serializable_exports, {
      Serializable: () => Serializable,
      get_lc_unique_name: () => get_lc_unique_name
    });
    function shallowCopy(obj) {
      return Array.isArray(obj) ? [...obj] : { ...obj };
    }
    function replaceSecrets(root, secretsMap) {
      const result = shallowCopy(root);
      for (const [path, secretId] of Object.entries(secretsMap)) {
        const [last, ...partsReverse] = path.split(".").reverse();
        let current = result;
        for (const part of partsReverse.reverse()) {
          if (current[part] === void 0) break;
          current[part] = shallowCopy(current[part]);
          current = current[part];
        }
        if (current[last] !== void 0) current[last] = {
          lc: 1,
          type: "secret",
          id: [secretId]
        };
      }
      return result;
    }
    function get_lc_unique_name(serializableClass) {
      const parentClass = Object.getPrototypeOf(serializableClass);
      const lcNameIsSubclassed = typeof serializableClass.lc_name === "function" && (typeof parentClass.lc_name !== "function" || serializableClass.lc_name() !== parentClass.lc_name());
      if (lcNameIsSubclassed) return serializableClass.lc_name();
      else return serializableClass.name;
    }
    var Serializable = class Serializable2 {
      lc_serializable = false;
      lc_kwargs;
      /**
      * The name of the serializable. Override to provide an alias or
      * to preserve the serialized module name in minified environments.
      *
      * Implemented as a static method to support loading logic.
      */
      static lc_name() {
        return this.name;
      }
      /**
      * The final serialized identifier for the module.
      */
      get lc_id() {
        return [...this.lc_namespace, get_lc_unique_name(this.constructor)];
      }
      /**
      * A map of secrets, which will be omitted from serialization.
      * Keys are paths to the secret in constructor args, e.g. "foo.bar.baz".
      * Values are the secret ids, which will be used when deserializing.
      */
      get lc_secrets() {
        return void 0;
      }
      /**
      * A map of additional attributes to merge with constructor args.
      * Keys are the attribute names, e.g. "foo".
      * Values are the attribute values, which will be serialized.
      * These attributes need to be accepted by the constructor as arguments.
      */
      get lc_attributes() {
        return void 0;
      }
      /**
      * A map of aliases for constructor args.
      * Keys are the attribute names, e.g. "foo".
      * Values are the alias that will replace the key in serialization.
      * This is used to eg. make argument names match Python.
      */
      get lc_aliases() {
        return void 0;
      }
      /**
      * A manual list of keys that should be serialized.
      * If not overridden, all fields passed into the constructor will be serialized.
      */
      get lc_serializable_keys() {
        return void 0;
      }
      constructor(kwargs, ..._args) {
        if (this.lc_serializable_keys !== void 0) this.lc_kwargs = Object.fromEntries(Object.entries(kwargs || {}).filter(([key]) => this.lc_serializable_keys?.includes(key)));
        else this.lc_kwargs = kwargs ?? {};
      }
      toJSON() {
        if (!this.lc_serializable) return this.toJSONNotImplemented();
        if (this.lc_kwargs instanceof Serializable2 || typeof this.lc_kwargs !== "object" || Array.isArray(this.lc_kwargs)) return this.toJSONNotImplemented();
        const aliases = {};
        const secrets = {};
        const kwargs = Object.keys(this.lc_kwargs).reduce((acc, key) => {
          acc[key] = key in this ? this[key] : this.lc_kwargs[key];
          return acc;
        }, {});
        for (let current = Object.getPrototypeOf(this); current; current = Object.getPrototypeOf(current)) {
          Object.assign(aliases, Reflect.get(current, "lc_aliases", this));
          Object.assign(secrets, Reflect.get(current, "lc_secrets", this));
          Object.assign(kwargs, Reflect.get(current, "lc_attributes", this));
        }
        Object.keys(secrets).forEach((keyPath) => {
          let read = this;
          let write = kwargs;
          const [last, ...partsReverse] = keyPath.split(".").reverse();
          for (const key of partsReverse.reverse()) {
            if (!(key in read) || read[key] === void 0) return;
            if (!(key in write) || write[key] === void 0) {
              if (typeof read[key] === "object" && read[key] != null) write[key] = {};
              else if (Array.isArray(read[key])) write[key] = [];
            }
            read = read[key];
            write = write[key];
          }
          if (last in read && read[last] !== void 0) write[last] = write[last] || read[last];
        });
        return {
          lc: 1,
          type: "constructor",
          id: this.lc_id,
          kwargs: require_map_keys2.mapKeys(Object.keys(secrets).length ? replaceSecrets(kwargs, secrets) : kwargs, require_map_keys2.keyToJson, aliases)
        };
      }
      toJSONNotImplemented() {
        return {
          lc: 1,
          type: "not_implemented",
          id: this.lc_id
        };
      }
    };
    exports2.Serializable = Serializable;
    exports2.get_lc_unique_name = get_lc_unique_name;
    Object.defineProperty(exports2, "serializable_exports", {
      enumerable: true,
      get: function() {
        return serializable_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/content/data.cjs
var require_data = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/content/data.cjs"(exports2) {
    function isDataContentBlock(content_block) {
      return typeof content_block === "object" && content_block !== null && "type" in content_block && typeof content_block.type === "string" && "source_type" in content_block && (content_block.source_type === "url" || content_block.source_type === "base64" || content_block.source_type === "text" || content_block.source_type === "id");
    }
    function isURLContentBlock(content_block) {
      return isDataContentBlock(content_block) && content_block.source_type === "url" && "url" in content_block && typeof content_block.url === "string";
    }
    function isBase64ContentBlock(content_block) {
      return isDataContentBlock(content_block) && content_block.source_type === "base64" && "data" in content_block && typeof content_block.data === "string";
    }
    function isPlainTextContentBlock(content_block) {
      return isDataContentBlock(content_block) && content_block.source_type === "text" && "text" in content_block && typeof content_block.text === "string";
    }
    function isIDContentBlock(content_block) {
      return isDataContentBlock(content_block) && content_block.source_type === "id" && "id" in content_block && typeof content_block.id === "string";
    }
    function convertToOpenAIImageBlock(content_block) {
      if (isDataContentBlock(content_block)) {
        if (content_block.source_type === "url") return {
          type: "image_url",
          image_url: { url: content_block.url }
        };
        if (content_block.source_type === "base64") {
          if (!content_block.mime_type) throw new Error("mime_type key is required for base64 data.");
          const mime_type = content_block.mime_type;
          return {
            type: "image_url",
            image_url: { url: `data:${mime_type};base64,${content_block.data}` }
          };
        }
      }
      throw new Error("Unsupported source type. Only 'url' and 'base64' are supported.");
    }
    function parseMimeType(mime_type) {
      const parts = mime_type.split(";")[0].split("/");
      if (parts.length !== 2) throw new Error(`Invalid mime type: "${mime_type}" - does not match type/subtype format.`);
      const type = parts[0].trim();
      const subtype = parts[1].trim();
      if (type === "" || subtype === "") throw new Error(`Invalid mime type: "${mime_type}" - type or subtype is empty.`);
      const parameters = {};
      for (const parameterKvp of mime_type.split(";").slice(1)) {
        const parameterParts = parameterKvp.split("=");
        if (parameterParts.length !== 2) throw new Error(`Invalid parameter syntax in mime type: "${mime_type}".`);
        const key = parameterParts[0].trim();
        const value = parameterParts[1].trim();
        if (key === "") throw new Error(`Invalid parameter syntax in mime type: "${mime_type}".`);
        parameters[key] = value;
      }
      return {
        type,
        subtype,
        parameters
      };
    }
    function parseBase64DataUrl({ dataUrl: data_url, asTypedArray = false }) {
      const formatMatch = data_url.match(/^data:(\w+\/\w+);base64,([A-Za-z0-9+/]+=*)$/);
      let mime_type;
      if (formatMatch) {
        mime_type = formatMatch[1].toLowerCase();
        const data = asTypedArray ? Uint8Array.from(atob(formatMatch[2]), (c) => c.charCodeAt(0)) : formatMatch[2];
        return {
          mime_type,
          data
        };
      }
      return void 0;
    }
    function convertToProviderContentBlock(block, converter) {
      if (block.type === "text") {
        if (!converter.fromStandardTextBlock) throw new Error(`Converter for ${converter.providerName} does not implement \`fromStandardTextBlock\` method.`);
        return converter.fromStandardTextBlock(block);
      }
      if (block.type === "image") {
        if (!converter.fromStandardImageBlock) throw new Error(`Converter for ${converter.providerName} does not implement \`fromStandardImageBlock\` method.`);
        return converter.fromStandardImageBlock(block);
      }
      if (block.type === "audio") {
        if (!converter.fromStandardAudioBlock) throw new Error(`Converter for ${converter.providerName} does not implement \`fromStandardAudioBlock\` method.`);
        return converter.fromStandardAudioBlock(block);
      }
      if (block.type === "file") {
        if (!converter.fromStandardFileBlock) throw new Error(`Converter for ${converter.providerName} does not implement \`fromStandardFileBlock\` method.`);
        return converter.fromStandardFileBlock(block);
      }
      throw new Error(`Unable to convert content block type '${block.type}' to provider-specific format: not recognized.`);
    }
    exports2.convertToOpenAIImageBlock = convertToOpenAIImageBlock;
    exports2.convertToProviderContentBlock = convertToProviderContentBlock;
    exports2.isBase64ContentBlock = isBase64ContentBlock;
    exports2.isDataContentBlock = isDataContentBlock;
    exports2.isIDContentBlock = isIDContentBlock;
    exports2.isPlainTextContentBlock = isPlainTextContentBlock;
    exports2.isURLContentBlock = isURLContentBlock;
    exports2.parseBase64DataUrl = parseBase64DataUrl;
    exports2.parseMimeType = parseMimeType;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/block_translators/utils.cjs
var require_utils = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/block_translators/utils.cjs"(exports2) {
    function _isContentBlock(block, type) {
      return _isObject(block) && block.type === type;
    }
    function _isObject(value) {
      return typeof value === "object" && value !== null;
    }
    function _isArray(value) {
      return Array.isArray(value);
    }
    function _isString(value) {
      return typeof value === "string";
    }
    function _isNumber(value) {
      return typeof value === "number";
    }
    function _isBytesArray(value) {
      return value instanceof Uint8Array;
    }
    function safeParseJson(value) {
      try {
        return JSON.parse(value);
      } catch {
        return void 0;
      }
    }
    var iife = (fn) => fn();
    exports2._isArray = _isArray;
    exports2._isBytesArray = _isBytesArray;
    exports2._isContentBlock = _isContentBlock;
    exports2._isNumber = _isNumber;
    exports2._isObject = _isObject;
    exports2._isString = _isString;
    exports2.iife = iife;
    exports2.safeParseJson = safeParseJson;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/block_translators/anthropic.cjs
var require_anthropic = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/block_translators/anthropic.cjs"(exports2) {
    var require_utils10 = require_utils();
    function convertAnthropicAnnotation(citation) {
      if (citation.type === "char_location" && require_utils10._isString(citation.document_title) && require_utils10._isNumber(citation.start_char_index) && require_utils10._isNumber(citation.end_char_index) && require_utils10._isString(citation.cited_text)) {
        const { document_title, start_char_index, end_char_index, cited_text, ...rest } = citation;
        return {
          ...rest,
          type: "citation",
          source: "char",
          title: document_title ?? void 0,
          startIndex: start_char_index,
          endIndex: end_char_index,
          citedText: cited_text
        };
      }
      if (citation.type === "page_location" && require_utils10._isString(citation.document_title) && require_utils10._isNumber(citation.start_page_number) && require_utils10._isNumber(citation.end_page_number) && require_utils10._isString(citation.cited_text)) {
        const { document_title, start_page_number, end_page_number, cited_text, ...rest } = citation;
        return {
          ...rest,
          type: "citation",
          source: "page",
          title: document_title ?? void 0,
          startIndex: start_page_number,
          endIndex: end_page_number,
          citedText: cited_text
        };
      }
      if (citation.type === "content_block_location" && require_utils10._isString(citation.document_title) && require_utils10._isNumber(citation.start_block_index) && require_utils10._isNumber(citation.end_block_index) && require_utils10._isString(citation.cited_text)) {
        const { document_title, start_block_index, end_block_index, cited_text, ...rest } = citation;
        return {
          ...rest,
          type: "citation",
          source: "block",
          title: document_title ?? void 0,
          startIndex: start_block_index,
          endIndex: end_block_index,
          citedText: cited_text
        };
      }
      if (citation.type === "web_search_result_location" && require_utils10._isString(citation.url) && require_utils10._isString(citation.title) && require_utils10._isString(citation.encrypted_index) && require_utils10._isString(citation.cited_text)) {
        const { url, title, encrypted_index, cited_text, ...rest } = citation;
        return {
          ...rest,
          type: "citation",
          source: "url",
          url,
          title,
          startIndex: Number(encrypted_index),
          endIndex: Number(encrypted_index),
          citedText: cited_text
        };
      }
      if (citation.type === "search_result_location" && require_utils10._isString(citation.source) && require_utils10._isString(citation.title) && require_utils10._isNumber(citation.start_block_index) && require_utils10._isNumber(citation.end_block_index) && require_utils10._isString(citation.cited_text)) {
        const { source, title, start_block_index, end_block_index, cited_text, ...rest } = citation;
        return {
          ...rest,
          type: "citation",
          source: "search",
          url: source,
          title: title ?? void 0,
          startIndex: start_block_index,
          endIndex: end_block_index,
          citedText: cited_text
        };
      }
      return void 0;
    }
    function convertToV1FromAnthropicContentBlock(block) {
      if (require_utils10._isContentBlock(block, "document") && require_utils10._isObject(block.source) && "type" in block.source) {
        if (block.source.type === "base64" && require_utils10._isString(block.source.media_type) && require_utils10._isString(block.source.data)) return {
          type: "file",
          mimeType: block.source.media_type,
          data: block.source.data
        };
        else if (block.source.type === "url" && require_utils10._isString(block.source.url)) return {
          type: "file",
          url: block.source.url
        };
        else if (block.source.type === "file" && require_utils10._isString(block.source.file_id)) return {
          type: "file",
          fileId: block.source.file_id
        };
        else if (block.source.type === "text" && require_utils10._isString(block.source.data)) return {
          type: "file",
          mimeType: String(block.source.media_type ?? "text/plain"),
          data: block.source.data
        };
      } else if (require_utils10._isContentBlock(block, "image") && require_utils10._isObject(block.source) && "type" in block.source) {
        if (block.source.type === "base64" && require_utils10._isString(block.source.media_type) && require_utils10._isString(block.source.data)) return {
          type: "image",
          mimeType: block.source.media_type,
          data: block.source.data
        };
        else if (block.source.type === "url" && require_utils10._isString(block.source.url)) return {
          type: "image",
          url: block.source.url
        };
        else if (block.source.type === "file" && require_utils10._isString(block.source.file_id)) return {
          type: "image",
          fileId: block.source.file_id
        };
      }
      return void 0;
    }
    function convertToV1FromAnthropicInput(content) {
      function* iterateContent() {
        for (const block of content) {
          const stdBlock = convertToV1FromAnthropicContentBlock(block);
          if (stdBlock) yield stdBlock;
          else yield block;
        }
      }
      return Array.from(iterateContent());
    }
    function convertToV1FromAnthropicMessage(message) {
      function* iterateContent() {
        const content = typeof message.content === "string" ? [{
          type: "text",
          text: message.content
        }] : message.content;
        for (const block of content) {
          if (require_utils10._isContentBlock(block, "text") && require_utils10._isString(block.text)) {
            const { text, citations, ...rest } = block;
            if (require_utils10._isArray(citations) && citations.length) {
              const _citations = citations.reduce((acc, item) => {
                const citation = convertAnthropicAnnotation(item);
                if (citation) return [...acc, citation];
                return acc;
              }, []);
              yield {
                ...rest,
                type: "text",
                text,
                annotations: _citations
              };
              continue;
            } else {
              yield {
                ...rest,
                type: "text",
                text
              };
              continue;
            }
          } else if (require_utils10._isContentBlock(block, "thinking") && require_utils10._isString(block.thinking)) {
            const { thinking, signature, ...rest } = block;
            yield {
              ...rest,
              type: "reasoning",
              reasoning: thinking,
              signature
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "redacted_thinking")) {
            yield {
              type: "non_standard",
              value: block
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "tool_use") && require_utils10._isString(block.name) && require_utils10._isString(block.id)) {
            yield {
              type: "tool_call",
              id: block.id,
              name: block.name,
              args: block.input
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "input_json_delta")) {
            if (_isAIMessageChunk(message) && message.tool_call_chunks?.length) {
              const tool_call_chunk = message.tool_call_chunks[0];
              yield {
                type: "tool_call_chunk",
                id: tool_call_chunk.id,
                name: tool_call_chunk.name,
                args: tool_call_chunk.args,
                index: tool_call_chunk.index
              };
              continue;
            }
          } else if (require_utils10._isContentBlock(block, "server_tool_use") && require_utils10._isString(block.name) && require_utils10._isString(block.id)) {
            const { name, id } = block;
            if (name === "web_search") {
              const query = require_utils10.iife(() => {
                if (typeof block.input === "string") return block.input;
                else if (require_utils10._isObject(block.input) && require_utils10._isString(block.input.query)) return block.input.query;
                else if (require_utils10._isString(block.partial_json)) {
                  const json = require_utils10.safeParseJson(block.partial_json);
                  if (json?.query) return json.query;
                }
                return "";
              });
              yield {
                id,
                type: "server_tool_call",
                name: "web_search",
                args: { query }
              };
              continue;
            } else if (block.name === "code_execution") {
              const code = require_utils10.iife(() => {
                if (typeof block.input === "string") return block.input;
                else if (require_utils10._isObject(block.input) && require_utils10._isString(block.input.code)) return block.input.code;
                else if (require_utils10._isString(block.partial_json)) {
                  const json = require_utils10.safeParseJson(block.partial_json);
                  if (json?.code) return json.code;
                }
                return "";
              });
              yield {
                id,
                type: "server_tool_call",
                name: "code_execution",
                args: { code }
              };
              continue;
            }
          } else if (require_utils10._isContentBlock(block, "web_search_tool_result") && require_utils10._isString(block.tool_use_id) && require_utils10._isArray(block.content)) {
            const { content: content$1, tool_use_id } = block;
            const urls = content$1.reduce((acc, content$2) => {
              if (require_utils10._isContentBlock(content$2, "web_search_result")) return [...acc, content$2.url];
              return acc;
            }, []);
            yield {
              type: "server_tool_call_result",
              name: "web_search",
              toolCallId: tool_use_id,
              status: "success",
              output: { urls }
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "code_execution_tool_result") && require_utils10._isString(block.tool_use_id) && require_utils10._isObject(block.content)) {
            yield {
              type: "server_tool_call_result",
              name: "code_execution",
              toolCallId: block.tool_use_id,
              status: "success",
              output: block.content
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "mcp_tool_use")) {
            yield {
              id: block.id,
              type: "server_tool_call",
              name: "mcp_tool_use",
              args: block.input
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "mcp_tool_result") && require_utils10._isString(block.tool_use_id) && require_utils10._isObject(block.content)) {
            yield {
              type: "server_tool_call_result",
              name: "mcp_tool_use",
              toolCallId: block.tool_use_id,
              status: "success",
              output: block.content
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "container_upload")) {
            yield {
              type: "server_tool_call",
              name: "container_upload",
              args: block.input
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "search_result")) {
            yield {
              id: block.id,
              type: "non_standard",
              value: block
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "tool_result")) {
            yield {
              id: block.id,
              type: "non_standard",
              value: block
            };
            continue;
          } else {
            const stdBlock = convertToV1FromAnthropicContentBlock(block);
            if (stdBlock) {
              yield stdBlock;
              continue;
            }
          }
          yield {
            type: "non_standard",
            value: block
          };
        }
      }
      return Array.from(iterateContent());
    }
    var ChatAnthropicTranslator = {
      translateContent: convertToV1FromAnthropicMessage,
      translateContentChunk: convertToV1FromAnthropicMessage
    };
    function _isAIMessageChunk(message) {
      return typeof message?._getType === "function" && typeof message.concat === "function" && message._getType() === "ai";
    }
    exports2.ChatAnthropicTranslator = ChatAnthropicTranslator;
    exports2.convertToV1FromAnthropicInput = convertToV1FromAnthropicInput;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/block_translators/data.cjs
var require_data2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/block_translators/data.cjs"(exports2) {
    var require_data6 = require_data();
    var require_utils10 = require_utils();
    function convertToV1FromDataContentBlock(block) {
      if (require_data6.isURLContentBlock(block)) return {
        type: block.type,
        mimeType: block.mime_type,
        url: block.url,
        metadata: block.metadata
      };
      if (require_data6.isBase64ContentBlock(block)) return {
        type: block.type,
        mimeType: block.mime_type ?? "application/octet-stream",
        data: block.data,
        metadata: block.metadata
      };
      if (require_data6.isIDContentBlock(block)) return {
        type: block.type,
        mimeType: block.mime_type,
        fileId: block.id,
        metadata: block.metadata
      };
      return block;
    }
    function convertToV1FromDataContent(content) {
      return content.map(convertToV1FromDataContentBlock);
    }
    function isOpenAIDataBlock(block) {
      if (require_utils10._isContentBlock(block, "image_url") && require_utils10._isObject(block.image_url)) return true;
      if (require_utils10._isContentBlock(block, "input_audio") && require_utils10._isObject(block.input_audio)) return true;
      if (require_utils10._isContentBlock(block, "file") && require_utils10._isObject(block.file)) return true;
      return false;
    }
    function convertToV1FromOpenAIDataBlock(block) {
      if (require_utils10._isContentBlock(block, "image_url") && require_utils10._isObject(block.image_url) && require_utils10._isString(block.image_url.url)) {
        const parsed = require_data6.parseBase64DataUrl({ dataUrl: block.image_url.url });
        if (parsed) return {
          type: "image",
          mimeType: parsed.mime_type,
          data: parsed.data
        };
        else return {
          type: "image",
          url: block.image_url.url
        };
      } else if (require_utils10._isContentBlock(block, "input_audio") && require_utils10._isObject(block.input_audio) && require_utils10._isString(block.input_audio.data) && require_utils10._isString(block.input_audio.format)) return {
        type: "audio",
        data: block.input_audio.data,
        mimeType: `audio/${block.input_audio.format}`
      };
      else if (require_utils10._isContentBlock(block, "file") && require_utils10._isObject(block.file) && require_utils10._isString(block.file.data)) {
        const parsed = require_data6.parseBase64DataUrl({ dataUrl: block.file.data });
        if (parsed) return {
          type: "file",
          data: parsed.data,
          mimeType: parsed.mime_type
        };
        else if (require_utils10._isString(block.file.file_id)) return {
          type: "file",
          fileId: block.file.file_id
        };
      }
      return block;
    }
    exports2.convertToV1FromDataContent = convertToV1FromDataContent;
    exports2.convertToV1FromOpenAIDataBlock = convertToV1FromOpenAIDataBlock;
    exports2.isOpenAIDataBlock = isOpenAIDataBlock;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/block_translators/openai.cjs
var require_openai = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/block_translators/openai.cjs"(exports2) {
    var require_utils10 = require_utils();
    var require_data6 = require_data2();
    function convertToV1FromChatCompletions(message) {
      const blocks = [];
      if (typeof message.content === "string") blocks.push({
        type: "text",
        text: message.content
      });
      else blocks.push(...convertToV1FromChatCompletionsInput(message.content));
      for (const toolCall of message.tool_calls ?? []) blocks.push({
        type: "tool_call",
        id: toolCall.id,
        name: toolCall.name,
        args: toolCall.args
      });
      return blocks;
    }
    function convertToV1FromChatCompletionsChunk(message) {
      const blocks = [];
      if (typeof message.content === "string") blocks.push({
        type: "text",
        text: message.content
      });
      else blocks.push(...convertToV1FromChatCompletionsInput(message.content));
      for (const toolCall of message.tool_calls ?? []) blocks.push({
        type: "tool_call",
        id: toolCall.id,
        name: toolCall.name,
        args: toolCall.args
      });
      return blocks;
    }
    function convertToV1FromChatCompletionsInput(blocks) {
      const convertedBlocks = [];
      for (const block of blocks) if (require_data6.isOpenAIDataBlock(block)) convertedBlocks.push(require_data6.convertToV1FromOpenAIDataBlock(block));
      else convertedBlocks.push(block);
      return convertedBlocks;
    }
    function convertResponsesAnnotation(annotation) {
      if (annotation.type === "url_citation") {
        const { url, title, start_index, end_index } = annotation;
        return {
          type: "citation",
          url,
          title,
          startIndex: start_index,
          endIndex: end_index
        };
      }
      if (annotation.type === "file_citation") {
        const { file_id, filename, index } = annotation;
        return {
          type: "citation",
          title: filename,
          startIndex: index,
          endIndex: index,
          fileId: file_id
        };
      }
      return annotation;
    }
    function convertToV1FromResponses(message) {
      function* iterateContent() {
        if (require_utils10._isObject(message.additional_kwargs?.reasoning) && require_utils10._isArray(message.additional_kwargs.reasoning.summary)) {
          const summary = message.additional_kwargs.reasoning.summary.reduce((acc, item) => {
            if (require_utils10._isObject(item) && require_utils10._isString(item.text)) return `${acc}${item.text}`;
            return acc;
          }, "");
          yield {
            type: "reasoning",
            reasoning: summary
          };
        }
        const content = typeof message.content === "string" ? [{
          type: "text",
          text: message.content
        }] : message.content;
        for (const block of content) if (require_utils10._isContentBlock(block, "text")) {
          const { text, annotations, ...rest } = block;
          if (Array.isArray(annotations)) yield {
            ...rest,
            type: "text",
            text: String(text),
            annotations: annotations.map(convertResponsesAnnotation)
          };
          else yield {
            ...rest,
            type: "text",
            text: String(text)
          };
        }
        for (const toolCall of message.tool_calls ?? []) yield {
          type: "tool_call",
          id: toolCall.id,
          name: toolCall.name,
          args: toolCall.args
        };
        if (require_utils10._isObject(message.additional_kwargs) && require_utils10._isArray(message.additional_kwargs.tool_outputs)) for (const toolOutput of message.additional_kwargs.tool_outputs) {
          if (require_utils10._isContentBlock(toolOutput, "web_search_call")) {
            yield {
              id: toolOutput.id,
              type: "server_tool_call",
              name: "web_search",
              args: { query: toolOutput.query }
            };
            continue;
          } else if (require_utils10._isContentBlock(toolOutput, "file_search_call")) {
            yield {
              id: toolOutput.id,
              type: "server_tool_call",
              name: "file_search",
              args: { query: toolOutput.query }
            };
            continue;
          } else if (require_utils10._isContentBlock(toolOutput, "computer_call")) {
            yield {
              type: "non_standard",
              value: toolOutput
            };
            continue;
          } else if (require_utils10._isContentBlock(toolOutput, "code_interpreter_call")) {
            if (require_utils10._isString(toolOutput.code)) yield {
              id: toolOutput.id,
              type: "server_tool_call",
              name: "code_interpreter",
              args: { code: toolOutput.code }
            };
            if (require_utils10._isArray(toolOutput.outputs)) {
              const returnCode = require_utils10.iife(() => {
                if (toolOutput.status === "in_progress") return void 0;
                if (toolOutput.status === "completed") return 0;
                if (toolOutput.status === "incomplete") return 127;
                if (toolOutput.status === "interpreting") return void 0;
                if (toolOutput.status === "failed") return 1;
                return void 0;
              });
              for (const output of toolOutput.outputs) if (require_utils10._isContentBlock(output, "logs")) {
                yield {
                  type: "server_tool_call_result",
                  toolCallId: toolOutput.id ?? "",
                  status: "success",
                  output: {
                    type: "code_interpreter_output",
                    returnCode: returnCode ?? 0,
                    stderr: [0, void 0].includes(returnCode) ? void 0 : String(output.logs),
                    stdout: [0, void 0].includes(returnCode) ? String(output.logs) : void 0
                  }
                };
                continue;
              }
            }
            continue;
          } else if (require_utils10._isContentBlock(toolOutput, "mcp_call")) {
            yield {
              id: toolOutput.id,
              type: "server_tool_call",
              name: "mcp_call",
              args: toolOutput.input
            };
            continue;
          } else if (require_utils10._isContentBlock(toolOutput, "mcp_list_tools")) {
            yield {
              id: toolOutput.id,
              type: "server_tool_call",
              name: "mcp_list_tools",
              args: toolOutput.input
            };
            continue;
          } else if (require_utils10._isContentBlock(toolOutput, "mcp_approval_request")) {
            yield {
              type: "non_standard",
              value: toolOutput
            };
            continue;
          } else if (require_utils10._isContentBlock(toolOutput, "image_generation_call")) {
            yield {
              type: "non_standard",
              value: toolOutput
            };
            continue;
          }
          if (require_utils10._isObject(toolOutput)) yield {
            type: "non_standard",
            value: toolOutput
          };
        }
      }
      return Array.from(iterateContent());
    }
    function convertToV1FromResponsesChunk(message) {
      function* iterateContent() {
        yield* convertToV1FromResponses(message);
        for (const toolCallChunk of message.tool_call_chunks ?? []) yield {
          type: "tool_call_chunk",
          id: toolCallChunk.id,
          name: toolCallChunk.name,
          args: toolCallChunk.args
        };
      }
      return Array.from(iterateContent());
    }
    var ChatOpenAITranslator = {
      translateContent: (message) => {
        if (typeof message.content === "string") return convertToV1FromChatCompletions(message);
        return convertToV1FromResponses(message);
      },
      translateContentChunk: (message) => {
        if (typeof message.content === "string") return convertToV1FromChatCompletionsChunk(message);
        return convertToV1FromResponsesChunk(message);
      }
    };
    exports2.ChatOpenAITranslator = ChatOpenAITranslator;
    exports2.convertToV1FromChatCompletionsInput = convertToV1FromChatCompletionsInput;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/message.cjs
var require_message = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/message.cjs"(exports2) {
    function isMessage(message) {
      return typeof message === "object" && message !== null && "type" in message && "content" in message && (typeof message.content === "string" || Array.isArray(message.content));
    }
    exports2.isMessage = isMessage;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/format.cjs
var require_format = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/format.cjs"(exports2) {
    function convertToFormattedString(message, format = "pretty") {
      if (format === "pretty") return convertToPrettyString(message);
      return JSON.stringify(message);
    }
    function convertToPrettyString(message) {
      const lines = [];
      const title = ` ${message.type.charAt(0).toUpperCase() + message.type.slice(1)} Message `;
      const sepLen = Math.floor((80 - title.length) / 2);
      const sep = "=".repeat(sepLen);
      const secondSep = title.length % 2 === 0 ? sep : `${sep}=`;
      lines.push(`${sep}${title}${secondSep}`);
      if (message.type === "ai") {
        const aiMessage = message;
        if (aiMessage.tool_calls && aiMessage.tool_calls.length > 0) {
          lines.push("Tool Calls:");
          for (const tc of aiMessage.tool_calls) {
            lines.push(`  ${tc.name} (${tc.id})`);
            lines.push(` Call ID: ${tc.id}`);
            lines.push("  Args:");
            for (const [key, value] of Object.entries(tc.args)) lines.push(`    ${key}: ${value}`);
          }
        }
      }
      if (message.type === "tool") {
        const toolMessage = message;
        if (toolMessage.name) lines.push(`Name: ${toolMessage.name}`);
      }
      if (typeof message.content === "string" && message.content.trim()) {
        if (lines.length > 1) lines.push("");
        lines.push(message.content);
      }
      return lines.join("\n");
    }
    exports2.convertToFormattedString = convertToFormattedString;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/base.cjs
var require_base = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/base.cjs"(exports2) {
    var require_load_serializable = require_serializable();
    var require_data6 = require_data();
    var require_anthropic2 = require_anthropic();
    var require_data$1 = require_data2();
    var require_openai2 = require_openai();
    var require_message3 = require_message();
    var require_format4 = require_format();
    var MESSAGE_SYMBOL = Symbol.for("langchain.message");
    function mergeContent(firstContent, secondContent) {
      if (typeof firstContent === "string") {
        if (firstContent === "") return secondContent;
        if (typeof secondContent === "string") return firstContent + secondContent;
        else if (Array.isArray(secondContent) && secondContent.some((c) => require_data6.isDataContentBlock(c))) return [{
          type: "text",
          source_type: "text",
          text: firstContent
        }, ...secondContent];
        else return [{
          type: "text",
          text: firstContent
        }, ...secondContent];
      } else if (Array.isArray(secondContent)) return _mergeLists(firstContent, secondContent) ?? [...firstContent, ...secondContent];
      else if (secondContent === "") return firstContent;
      else if (Array.isArray(firstContent) && firstContent.some((c) => require_data6.isDataContentBlock(c))) return [...firstContent, {
        type: "file",
        source_type: "text",
        text: secondContent
      }];
      else return [...firstContent, {
        type: "text",
        text: secondContent
      }];
    }
    function _mergeStatus(left, right) {
      if (left === "error" || right === "error") return "error";
      return "success";
    }
    function stringifyWithDepthLimit(obj, depthLimit) {
      function helper(obj$1, currentDepth) {
        if (typeof obj$1 !== "object" || obj$1 === null || obj$1 === void 0) return obj$1;
        if (currentDepth >= depthLimit) {
          if (Array.isArray(obj$1)) return "[Array]";
          return "[Object]";
        }
        if (Array.isArray(obj$1)) return obj$1.map((item) => helper(item, currentDepth + 1));
        const result = {};
        for (const key of Object.keys(obj$1)) result[key] = helper(obj$1[key], currentDepth + 1);
        return result;
      }
      return JSON.stringify(helper(obj, 0), null, 2);
    }
    var BaseMessage = class extends require_load_serializable.Serializable {
      lc_namespace = ["langchain_core", "messages"];
      lc_serializable = true;
      get lc_aliases() {
        return {
          additional_kwargs: "additional_kwargs",
          response_metadata: "response_metadata"
        };
      }
      [MESSAGE_SYMBOL] = true;
      id;
      name;
      content;
      additional_kwargs;
      response_metadata;
      /**
      * @deprecated Use .getType() instead or import the proper typeguard.
      * For example:
      *
      * ```ts
      * import { isAIMessage } from "@langchain/core/messages";
      *
      * const message = new AIMessage("Hello!");
      * isAIMessage(message); // true
      * ```
      */
      _getType() {
        return this.type;
      }
      /**
      * @deprecated Use .type instead
      * The type of the message.
      */
      getType() {
        return this._getType();
      }
      constructor(arg) {
        const fields = typeof arg === "string" || Array.isArray(arg) ? { content: arg } : arg;
        if (!fields.additional_kwargs) fields.additional_kwargs = {};
        if (!fields.response_metadata) fields.response_metadata = {};
        super(fields);
        this.name = fields.name;
        if (fields.content === void 0 && fields.contentBlocks !== void 0) {
          this.content = fields.contentBlocks;
          this.response_metadata = {
            output_version: "v1",
            ...fields.response_metadata
          };
        } else if (fields.content !== void 0) {
          this.content = fields.content ?? [];
          this.response_metadata = fields.response_metadata;
        } else {
          this.content = [];
          this.response_metadata = fields.response_metadata;
        }
        this.additional_kwargs = fields.additional_kwargs;
        this.id = fields.id;
      }
      /** Get text content of the message. */
      get text() {
        if (typeof this.content === "string") return this.content;
        if (!Array.isArray(this.content)) return "";
        return this.content.map((c) => {
          if (typeof c === "string") return c;
          if (c.type === "text") return c.text;
          return "";
        }).join("");
      }
      get contentBlocks() {
        const blocks = typeof this.content === "string" ? [{
          type: "text",
          text: this.content
        }] : this.content;
        const parsingSteps = [
          require_data$1.convertToV1FromDataContent,
          require_openai2.convertToV1FromChatCompletionsInput,
          require_anthropic2.convertToV1FromAnthropicInput
        ];
        const parsedBlocks = parsingSteps.reduce((blocks$1, step) => step(blocks$1), blocks);
        return parsedBlocks;
      }
      toDict() {
        return {
          type: this.getType(),
          data: this.toJSON().kwargs
        };
      }
      static lc_name() {
        return "BaseMessage";
      }
      get _printableFields() {
        return {
          id: this.id,
          content: this.content,
          name: this.name,
          additional_kwargs: this.additional_kwargs,
          response_metadata: this.response_metadata
        };
      }
      static isInstance(obj) {
        return typeof obj === "object" && obj !== null && MESSAGE_SYMBOL in obj && obj[MESSAGE_SYMBOL] === true && require_message3.isMessage(obj);
      }
      _updateId(value) {
        this.id = value;
        this.lc_kwargs.id = value;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.lc_name();
      }
      [Symbol.for("nodejs.util.inspect.custom")](depth) {
        if (depth === null) return this;
        const printable = stringifyWithDepthLimit(this._printableFields, Math.max(4, depth));
        return `${this.constructor.lc_name()} ${printable}`;
      }
      toFormattedString(format = "pretty") {
        return require_format4.convertToFormattedString(this, format);
      }
    };
    function isOpenAIToolCallArray(value) {
      return Array.isArray(value) && value.every((v) => typeof v.index === "number");
    }
    function _mergeDicts(left = {}, right = {}) {
      const merged = { ...left };
      for (const [key, value] of Object.entries(right)) if (merged[key] == null) merged[key] = value;
      else if (value == null) continue;
      else if (typeof merged[key] !== typeof value || Array.isArray(merged[key]) !== Array.isArray(value)) throw new Error(`field[${key}] already exists in the message chunk, but with a different type.`);
      else if (typeof merged[key] === "string") if (key === "type") continue;
      else if ([
        "id",
        "name",
        "output_version",
        "model_provider"
      ].includes(key)) merged[key] = value;
      else merged[key] += value;
      else if (typeof merged[key] === "object" && !Array.isArray(merged[key])) merged[key] = _mergeDicts(merged[key], value);
      else if (Array.isArray(merged[key])) merged[key] = _mergeLists(merged[key], value);
      else if (merged[key] === value) continue;
      else console.warn(`field[${key}] already exists in this message chunk and value has unsupported type.`);
      return merged;
    }
    function _mergeLists(left, right) {
      if (left === void 0 && right === void 0) return void 0;
      else if (left === void 0 || right === void 0) return left || right;
      else {
        const merged = [...left];
        for (const item of right) if (typeof item === "object" && item !== null && "index" in item && typeof item.index === "number") {
          const toMerge = merged.findIndex((leftItem) => {
            const isObject = typeof leftItem === "object";
            const indiciesMatch = "index" in leftItem && leftItem.index === item.index;
            const idsMatch = "id" in leftItem && "id" in item && leftItem?.id === item?.id;
            const eitherItemMissingID = !("id" in leftItem) || !leftItem?.id || !("id" in item) || !item?.id;
            return isObject && indiciesMatch && (idsMatch || eitherItemMissingID);
          });
          if (toMerge !== -1 && typeof merged[toMerge] === "object" && merged[toMerge] !== null) merged[toMerge] = _mergeDicts(merged[toMerge], item);
          else merged.push(item);
        } else if (typeof item === "object" && item !== null && "text" in item && item.text === "") continue;
        else merged.push(item);
        return merged;
      }
    }
    function _mergeObj(left, right) {
      if (!left && !right) throw new Error("Cannot merge two undefined objects.");
      if (!left || !right) return left || right;
      else if (typeof left !== typeof right) throw new Error(`Cannot merge objects of different types.
Left ${typeof left}
Right ${typeof right}`);
      else if (typeof left === "string" && typeof right === "string") return left + right;
      else if (Array.isArray(left) && Array.isArray(right)) return _mergeLists(left, right);
      else if (typeof left === "object" && typeof right === "object") return _mergeDicts(left, right);
      else if (left === right) return left;
      else throw new Error(`Can not merge objects of different types.
Left ${left}
Right ${right}`);
    }
    var BaseMessageChunk = class extends BaseMessage {
      static isInstance(obj) {
        return super.isInstance(obj) && "concat" in obj && typeof obj.concat === "function";
      }
    };
    function _isMessageFieldWithRole(x) {
      return typeof x.role === "string";
    }
    function isBaseMessage(messageLike) {
      return typeof messageLike?._getType === "function";
    }
    function isBaseMessageChunk(messageLike) {
      return isBaseMessage(messageLike) && typeof messageLike.concat === "function";
    }
    exports2.BaseMessage = BaseMessage;
    exports2.BaseMessageChunk = BaseMessageChunk;
    exports2._isMessageFieldWithRole = _isMessageFieldWithRole;
    exports2._mergeDicts = _mergeDicts;
    exports2._mergeLists = _mergeLists;
    exports2._mergeObj = _mergeObj;
    exports2._mergeStatus = _mergeStatus;
    exports2.isBaseMessage = isBaseMessage;
    exports2.isBaseMessageChunk = isBaseMessageChunk;
    exports2.isOpenAIToolCallArray = isOpenAIToolCallArray;
    exports2.mergeContent = mergeContent;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/tool.cjs
var require_tool = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/tool.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_base18 = require_base();
    var tool_exports = {};
    require_rolldown_runtime5.__export(tool_exports, {
      ToolMessage: () => ToolMessage,
      ToolMessageChunk: () => ToolMessageChunk,
      defaultToolCallParser: () => defaultToolCallParser,
      isDirectToolOutput: () => isDirectToolOutput,
      isToolMessage: () => isToolMessage,
      isToolMessageChunk: () => isToolMessageChunk
    });
    function isDirectToolOutput(x) {
      return x != null && typeof x === "object" && "lc_direct_tool_output" in x && x.lc_direct_tool_output === true;
    }
    var ToolMessage = class extends require_base18.BaseMessage {
      static lc_name() {
        return "ToolMessage";
      }
      get lc_aliases() {
        return { tool_call_id: "tool_call_id" };
      }
      lc_direct_tool_output = true;
      type = "tool";
      /**
      * Status of the tool invocation.
      * @version 0.2.19
      */
      status;
      tool_call_id;
      metadata;
      /**
      * Artifact of the Tool execution which is not meant to be sent to the model.
      *
      * Should only be specified if it is different from the message content, e.g. if only
      * a subset of the full tool output is being passed as message content but the full
      * output is needed in other parts of the code.
      */
      artifact;
      constructor(fields, tool_call_id, name) {
        const toolMessageFields = typeof fields === "string" || Array.isArray(fields) ? {
          content: fields,
          name,
          tool_call_id
        } : fields;
        super(toolMessageFields);
        this.tool_call_id = toolMessageFields.tool_call_id;
        this.artifact = toolMessageFields.artifact;
        this.status = toolMessageFields.status;
        this.metadata = toolMessageFields.metadata;
      }
      static isInstance(message) {
        return super.isInstance(message) && message.type === "tool";
      }
      get _printableFields() {
        return {
          ...super._printableFields,
          tool_call_id: this.tool_call_id,
          artifact: this.artifact
        };
      }
    };
    var ToolMessageChunk = class extends require_base18.BaseMessageChunk {
      type = "tool";
      tool_call_id;
      /**
      * Status of the tool invocation.
      * @version 0.2.19
      */
      status;
      /**
      * Artifact of the Tool execution which is not meant to be sent to the model.
      *
      * Should only be specified if it is different from the message content, e.g. if only
      * a subset of the full tool output is being passed as message content but the full
      * output is needed in other parts of the code.
      */
      artifact;
      constructor(fields) {
        super(fields);
        this.tool_call_id = fields.tool_call_id;
        this.artifact = fields.artifact;
        this.status = fields.status;
      }
      static lc_name() {
        return "ToolMessageChunk";
      }
      concat(chunk) {
        const Cls = this.constructor;
        return new Cls({
          content: require_base18.mergeContent(this.content, chunk.content),
          additional_kwargs: require_base18._mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
          response_metadata: require_base18._mergeDicts(this.response_metadata, chunk.response_metadata),
          artifact: require_base18._mergeObj(this.artifact, chunk.artifact),
          tool_call_id: this.tool_call_id,
          id: this.id ?? chunk.id,
          status: require_base18._mergeStatus(this.status, chunk.status)
        });
      }
      get _printableFields() {
        return {
          ...super._printableFields,
          tool_call_id: this.tool_call_id,
          artifact: this.artifact
        };
      }
    };
    function defaultToolCallParser(rawToolCalls) {
      const toolCalls = [];
      const invalidToolCalls = [];
      for (const toolCall of rawToolCalls) if (!toolCall.function) continue;
      else {
        const functionName = toolCall.function.name;
        try {
          const functionArgs = JSON.parse(toolCall.function.arguments);
          toolCalls.push({
            name: functionName || "",
            args: functionArgs || {},
            id: toolCall.id
          });
        } catch {
          invalidToolCalls.push({
            name: functionName,
            args: toolCall.function.arguments,
            id: toolCall.id,
            error: "Malformed args."
          });
        }
      }
      return [toolCalls, invalidToolCalls];
    }
    function isToolMessage(x) {
      return typeof x === "object" && x !== null && "getType" in x && typeof x.getType === "function" && x.getType() === "tool";
    }
    function isToolMessageChunk(x) {
      return x._getType() === "tool";
    }
    exports2.ToolMessage = ToolMessage;
    exports2.ToolMessageChunk = ToolMessageChunk;
    exports2.defaultToolCallParser = defaultToolCallParser;
    exports2.isDirectToolOutput = isDirectToolOutput;
    exports2.isToolMessage = isToolMessage;
    exports2.isToolMessageChunk = isToolMessageChunk;
    Object.defineProperty(exports2, "tool_exports", {
      enumerable: true,
      get: function() {
        return tool_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/tools/utils.cjs
var require_utils2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/tools/utils.cjs"(exports2) {
    function _isToolCall(toolCall) {
      return !!(toolCall && typeof toolCall === "object" && "type" in toolCall && toolCall.type === "tool_call");
    }
    function _configHasToolCallId(config) {
      return !!(config && typeof config === "object" && "toolCall" in config && config.toolCall != null && typeof config.toolCall === "object" && "id" in config.toolCall && typeof config.toolCall.id === "string");
    }
    var ToolInputParsingException = class extends Error {
      output;
      constructor(message, output) {
        super(message);
        this.output = output;
      }
    };
    exports2.ToolInputParsingException = ToolInputParsingException;
    exports2._configHasToolCallId = _configHasToolCallId;
    exports2._isToolCall = _isToolCall;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/json.cjs
var require_json = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/json.cjs"(exports2) {
    function parseJsonMarkdown(s, parser = parsePartialJson) {
      s = s.trim();
      const firstFenceIndex = s.indexOf("```");
      if (firstFenceIndex === -1) return parser(s);
      let contentAfterFence = s.substring(firstFenceIndex + 3);
      if (contentAfterFence.startsWith("json\n")) contentAfterFence = contentAfterFence.substring(5);
      else if (contentAfterFence.startsWith("json")) contentAfterFence = contentAfterFence.substring(4);
      else if (contentAfterFence.startsWith("\n")) contentAfterFence = contentAfterFence.substring(1);
      const closingFenceIndex = contentAfterFence.indexOf("```");
      let finalContent = contentAfterFence;
      if (closingFenceIndex !== -1) finalContent = contentAfterFence.substring(0, closingFenceIndex);
      return parser(finalContent.trim());
    }
    function parsePartialJson(s) {
      if (typeof s === "undefined") return null;
      try {
        return JSON.parse(s);
      } catch {
      }
      let new_s = "";
      const stack = [];
      let isInsideString = false;
      let escaped = false;
      for (let char of s) {
        if (isInsideString) if (char === '"' && !escaped) isInsideString = false;
        else if (char === "\n" && !escaped) char = "\\n";
        else if (char === "\\") escaped = !escaped;
        else escaped = false;
        else if (char === '"') {
          isInsideString = true;
          escaped = false;
        } else if (char === "{") stack.push("}");
        else if (char === "[") stack.push("]");
        else if (char === "}" || char === "]") if (stack && stack[stack.length - 1] === char) stack.pop();
        else return null;
        new_s += char;
      }
      if (isInsideString) new_s += '"';
      for (let i = stack.length - 1; i >= 0; i -= 1) new_s += stack[i];
      try {
        return JSON.parse(new_s);
      } catch {
        return null;
      }
    }
    exports2.parseJsonMarkdown = parseJsonMarkdown;
    exports2.parsePartialJson = parsePartialJson;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/block_translators/bedrock_converse.cjs
var require_bedrock_converse = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/block_translators/bedrock_converse.cjs"(exports2) {
    var require_utils10 = require_utils();
    function convertFileFormatToMimeType(format) {
      switch (format) {
        case "csv":
          return "text/csv";
        case "doc":
          return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
        case "docx":
          return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
        case "html":
          return "text/html";
        case "md":
          return "text/markdown";
        case "pdf":
          return "application/pdf";
        case "txt":
          return "text/plain";
        case "xls":
          return "application/vnd.ms-excel";
        case "xlsx":
          return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
        case "gif":
          return "image/gif";
        case "jpeg":
          return "image/jpeg";
        case "jpg":
          return "image/jpeg";
        case "png":
          return "image/png";
        case "webp":
          return "image/webp";
        case "flv":
          return "video/flv";
        case "mkv":
          return "video/mkv";
        case "mov":
          return "video/mov";
        case "mp4":
          return "video/mp4";
        case "mpeg":
          return "video/mpeg";
        case "mpg":
          return "video/mpg";
        case "three_gp":
          return "video/three_gp";
        case "webm":
          return "video/webm";
        case "wmv":
          return "video/wmv";
        default:
          return "application/octet-stream";
      }
    }
    function convertConverseDocumentBlock(block) {
      if (require_utils10._isObject(block.document) && require_utils10._isObject(block.document.source)) {
        const format = require_utils10._isObject(block.document) && require_utils10._isString(block.document.format) ? block.document.format : "";
        const mimeType = convertFileFormatToMimeType(format);
        if (require_utils10._isObject(block.document.source)) {
          if (require_utils10._isObject(block.document.source.s3Location) && require_utils10._isString(block.document.source.s3Location.uri)) return {
            type: "file",
            mimeType,
            fileId: block.document.source.s3Location.uri
          };
          if (require_utils10._isBytesArray(block.document.source.bytes)) return {
            type: "file",
            mimeType,
            data: block.document.source.bytes
          };
          if (require_utils10._isString(block.document.source.text)) return {
            type: "file",
            mimeType,
            data: Buffer.from(block.document.source.text).toString("base64")
          };
          if (require_utils10._isArray(block.document.source.content)) {
            const data = block.document.source.content.reduce((acc, item) => {
              if (require_utils10._isObject(item) && require_utils10._isString(item.text)) return acc + item.text;
              return acc;
            }, "");
            return {
              type: "file",
              mimeType,
              data
            };
          }
        }
      }
      return {
        type: "non_standard",
        value: block
      };
    }
    function convertConverseImageBlock(block) {
      if (require_utils10._isContentBlock(block, "image") && require_utils10._isObject(block.image)) {
        const format = require_utils10._isObject(block.image) && require_utils10._isString(block.image.format) ? block.image.format : "";
        const mimeType = convertFileFormatToMimeType(format);
        if (require_utils10._isObject(block.image.source)) {
          if (require_utils10._isObject(block.image.source.s3Location) && require_utils10._isString(block.image.source.s3Location.uri)) return {
            type: "image",
            mimeType,
            fileId: block.image.source.s3Location.uri
          };
          if (require_utils10._isBytesArray(block.image.source.bytes)) return {
            type: "image",
            mimeType,
            data: block.image.source.bytes
          };
        }
      }
      return {
        type: "non_standard",
        value: block
      };
    }
    function convertConverseVideoBlock(block) {
      if (require_utils10._isContentBlock(block, "video") && require_utils10._isObject(block.video)) {
        const format = require_utils10._isObject(block.video) && require_utils10._isString(block.video.format) ? block.video.format : "";
        const mimeType = convertFileFormatToMimeType(format);
        if (require_utils10._isObject(block.video.source)) {
          if (require_utils10._isObject(block.video.source.s3Location) && require_utils10._isString(block.video.source.s3Location.uri)) return {
            type: "video",
            mimeType,
            fileId: block.video.source.s3Location.uri
          };
          if (require_utils10._isBytesArray(block.video.source.bytes)) return {
            type: "video",
            mimeType,
            data: block.video.source.bytes
          };
        }
      }
      return {
        type: "non_standard",
        value: block
      };
    }
    function convertToV1FromChatBedrockConverseMessage(message) {
      function* iterateContent() {
        const content = typeof message.content === "string" ? [{
          type: "text",
          text: message.content
        }] : message.content;
        for (const block of content) {
          if (require_utils10._isContentBlock(block, "cache_point")) {
            yield {
              type: "non_standard",
              value: block
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "citations_content") && require_utils10._isObject(block.citationsContent)) {
            const text = require_utils10._isArray(block.citationsContent.content) ? block.citationsContent.content.reduce((acc, item) => {
              if (require_utils10._isObject(item) && require_utils10._isString(item.text)) return acc + item.text;
              return acc;
            }, "") : "";
            const annotations = require_utils10._isArray(block.citationsContent.citations) ? block.citationsContent.citations.reduce((acc, item) => {
              if (require_utils10._isObject(item)) {
                const citedText = require_utils10._isArray(item.sourceContent) ? item.sourceContent.reduce((acc$1, item$1) => {
                  if (require_utils10._isObject(item$1) && require_utils10._isString(item$1.text)) return acc$1 + item$1.text;
                  return acc$1;
                }, "") : "";
                const properties = require_utils10.iife(() => {
                  if (require_utils10._isObject(item.location)) {
                    const location2 = item.location.documentChar || item.location.documentPage || item.location.documentChunk;
                    if (require_utils10._isObject(location2)) return {
                      source: require_utils10._isNumber(location2.documentIndex) ? location2.documentIndex.toString() : void 0,
                      startIndex: require_utils10._isNumber(location2.start) ? location2.start : void 0,
                      endIndex: require_utils10._isNumber(location2.end) ? location2.end : void 0
                    };
                  }
                  return {};
                });
                acc.push({
                  type: "citation",
                  citedText,
                  ...properties
                });
              }
              return acc;
            }, []) : [];
            yield {
              type: "text",
              text,
              annotations
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "document") && require_utils10._isObject(block.document)) {
            yield convertConverseDocumentBlock(block);
            continue;
          } else if (require_utils10._isContentBlock(block, "guard_content")) {
            yield {
              type: "non_standard",
              value: block
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "image") && require_utils10._isObject(block.image)) {
            yield convertConverseImageBlock(block);
            continue;
          } else if (require_utils10._isContentBlock(block, "reasoning_content") && require_utils10._isString(block.reasoningText)) {
            yield {
              type: "reasoning",
              reasoning: block.reasoningText
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "text") && require_utils10._isString(block.text)) {
            yield {
              type: "text",
              text: block.text
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "tool_result")) {
            yield {
              type: "non_standard",
              value: block
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "tool_call")) continue;
          else if (require_utils10._isContentBlock(block, "video") && require_utils10._isObject(block.video)) {
            yield convertConverseVideoBlock(block);
            continue;
          }
          yield {
            type: "non_standard",
            value: block
          };
        }
      }
      return Array.from(iterateContent());
    }
    var ChatBedrockConverseTranslator = {
      translateContent: convertToV1FromChatBedrockConverseMessage,
      translateContentChunk: convertToV1FromChatBedrockConverseMessage
    };
    exports2.ChatBedrockConverseTranslator = ChatBedrockConverseTranslator;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/block_translators/google_genai.cjs
var require_google_genai = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/block_translators/google_genai.cjs"(exports2) {
    var require_utils10 = require_utils();
    function convertToV1FromChatGoogleMessage(message) {
      function* iterateContent() {
        const content = typeof message.content === "string" ? [{
          type: "text",
          text: message.content
        }] : message.content;
        for (const block of content) {
          if (require_utils10._isContentBlock(block, "text") && require_utils10._isString(block.text)) {
            yield {
              type: "text",
              text: block.text
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "inlineData") && require_utils10._isObject(block.inlineData) && require_utils10._isString(block.inlineData.mimeType) && require_utils10._isString(block.inlineData.data)) {
            yield {
              type: "file",
              mimeType: block.inlineData.mimeType,
              data: block.inlineData.data
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "functionCall") && require_utils10._isObject(block.functionCall) && require_utils10._isString(block.functionCall.name) && require_utils10._isObject(block.functionCall.args)) {
            yield {
              type: "tool_call",
              id: message.id,
              name: block.functionCall.name,
              args: block.functionCall.args
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "functionResponse")) {
            yield {
              type: "non_standard",
              value: block
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "fileData") && require_utils10._isObject(block.fileData) && require_utils10._isString(block.fileData.mimeType) && require_utils10._isString(block.fileData.fileUri)) {
            yield {
              type: "file",
              mimeType: block.fileData.mimeType,
              fileId: block.fileData.fileUri
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "executableCode")) {
            yield {
              type: "non_standard",
              value: block
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "codeExecutionResult")) {
            yield {
              type: "non_standard",
              value: block
            };
            continue;
          }
          yield {
            type: "non_standard",
            value: block
          };
        }
      }
      return Array.from(iterateContent());
    }
    var ChatGoogleGenAITranslator = {
      translateContent: convertToV1FromChatGoogleMessage,
      translateContentChunk: convertToV1FromChatGoogleMessage
    };
    exports2.ChatGoogleGenAITranslator = ChatGoogleGenAITranslator;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/block_translators/google_vertexai.cjs
var require_google_vertexai = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/block_translators/google_vertexai.cjs"(exports2) {
    var require_utils10 = require_utils();
    function convertToV1FromChatVertexMessage(message) {
      function* iterateContent() {
        const content = typeof message.content === "string" ? [{
          type: "text",
          text: message.content
        }] : message.content;
        for (const block of content) {
          if (require_utils10._isContentBlock(block, "reasoning") && require_utils10._isString(block.reasoning)) {
            const signature = require_utils10.iife(() => {
              const reasoningIndex = content.indexOf(block);
              if (require_utils10._isArray(message.additional_kwargs?.signatures) && reasoningIndex >= 0) return message.additional_kwargs.signatures.at(reasoningIndex);
              return void 0;
            });
            if (require_utils10._isString(signature)) yield {
              type: "reasoning",
              reasoning: block.reasoning,
              signature
            };
            else yield {
              type: "reasoning",
              reasoning: block.reasoning
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "text") && require_utils10._isString(block.text)) {
            yield {
              type: "text",
              text: block.text
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "image_url")) {
            if (require_utils10._isString(block.image_url)) if (block.image_url.startsWith("data:")) {
              const dataUrlRegex = /^data:([^;]+);base64,(.+)$/;
              const match = block.image_url.match(dataUrlRegex);
              if (match) yield {
                type: "image",
                data: match[2],
                mimeType: match[1]
              };
              else yield {
                type: "image",
                url: block.image_url
              };
            } else yield {
              type: "image",
              url: block.image_url
            };
            continue;
          } else if (require_utils10._isContentBlock(block, "media") && require_utils10._isString(block.mimeType) && require_utils10._isString(block.data)) {
            yield {
              type: "file",
              mimeType: block.mimeType,
              data: block.data
            };
            continue;
          }
          yield {
            type: "non_standard",
            value: block
          };
        }
      }
      return Array.from(iterateContent());
    }
    var ChatVertexTranslator = {
      translateContent: convertToV1FromChatVertexMessage,
      translateContentChunk: convertToV1FromChatVertexMessage
    };
    exports2.ChatVertexTranslator = ChatVertexTranslator;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/block_translators/index.cjs
var require_block_translators = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/block_translators/index.cjs"(exports2) {
    var require_anthropic2 = require_anthropic();
    var require_openai2 = require_openai();
    var require_bedrock_converse2 = require_bedrock_converse();
    var require_google_genai2 = require_google_genai();
    var require_google_vertexai2 = require_google_vertexai();
    globalThis.lc_block_translators_registry ??= /* @__PURE__ */ new Map([
      ["anthropic", require_anthropic2.ChatAnthropicTranslator],
      ["bedrock-converse", require_bedrock_converse2.ChatBedrockConverseTranslator],
      ["google-genai", require_google_genai2.ChatGoogleGenAITranslator],
      ["google-vertexai", require_google_vertexai2.ChatVertexTranslator],
      ["openai", require_openai2.ChatOpenAITranslator]
    ]);
    function getTranslator(modelProvider) {
      return globalThis.lc_block_translators_registry.get(modelProvider);
    }
    exports2.getTranslator = getTranslator;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/metadata.cjs
var require_metadata = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/metadata.cjs"(exports2) {
    var require_base18 = require_base();
    function mergeResponseMetadata(a, b) {
      const output = require_base18._mergeDicts(a ?? {}, b ?? {});
      return output;
    }
    function mergeModalitiesTokenDetails(a, b) {
      const output = {};
      if (a?.audio !== void 0 || b?.audio !== void 0) output.audio = (a?.audio ?? 0) + (b?.audio ?? 0);
      if (a?.image !== void 0 || b?.image !== void 0) output.image = (a?.image ?? 0) + (b?.image ?? 0);
      if (a?.video !== void 0 || b?.video !== void 0) output.video = (a?.video ?? 0) + (b?.video ?? 0);
      if (a?.document !== void 0 || b?.document !== void 0) output.document = (a?.document ?? 0) + (b?.document ?? 0);
      if (a?.text !== void 0 || b?.text !== void 0) output.text = (a?.text ?? 0) + (b?.text ?? 0);
      return output;
    }
    function mergeInputTokenDetails(a, b) {
      const output = { ...mergeModalitiesTokenDetails(a, b) };
      if (a?.cache_read !== void 0 || b?.cache_read !== void 0) output.cache_read = (a?.cache_read ?? 0) + (b?.cache_read ?? 0);
      if (a?.cache_creation !== void 0 || b?.cache_creation !== void 0) output.cache_creation = (a?.cache_creation ?? 0) + (b?.cache_creation ?? 0);
      return output;
    }
    function mergeOutputTokenDetails(a, b) {
      const output = { ...mergeModalitiesTokenDetails(a, b) };
      if (a?.reasoning !== void 0 || b?.reasoning !== void 0) output.reasoning = (a?.reasoning ?? 0) + (b?.reasoning ?? 0);
      return output;
    }
    function mergeUsageMetadata(a, b) {
      return {
        input_tokens: (a?.input_tokens ?? 0) + (b?.input_tokens ?? 0),
        output_tokens: (a?.output_tokens ?? 0) + (b?.output_tokens ?? 0),
        total_tokens: (a?.total_tokens ?? 0) + (b?.total_tokens ?? 0),
        input_token_details: mergeInputTokenDetails(a?.input_token_details, b?.input_token_details),
        output_token_details: mergeOutputTokenDetails(a?.output_token_details, b?.output_token_details)
      };
    }
    exports2.mergeResponseMetadata = mergeResponseMetadata;
    exports2.mergeUsageMetadata = mergeUsageMetadata;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/ai.cjs
var require_ai = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/ai.cjs"(exports2) {
    var require_json3 = require_json();
    var require_base18 = require_base();
    var require_index = require_block_translators();
    var require_metadata2 = require_metadata();
    var require_messages_tool = require_tool();
    var AIMessage = class extends require_base18.BaseMessage {
      type = "ai";
      tool_calls = [];
      invalid_tool_calls = [];
      usage_metadata;
      get lc_aliases() {
        return {
          ...super.lc_aliases,
          tool_calls: "tool_calls",
          invalid_tool_calls: "invalid_tool_calls"
        };
      }
      constructor(fields) {
        let initParams;
        if (typeof fields === "string" || Array.isArray(fields)) initParams = {
          content: fields,
          tool_calls: [],
          invalid_tool_calls: [],
          additional_kwargs: {}
        };
        else {
          initParams = fields;
          const rawToolCalls = initParams.additional_kwargs?.tool_calls;
          const toolCalls = initParams.tool_calls;
          if (!(rawToolCalls == null) && rawToolCalls.length > 0 && (toolCalls === void 0 || toolCalls.length === 0)) console.warn([
            "New LangChain packages are available that more efficiently handle",
            "tool calling.\n\nPlease upgrade your packages to versions that set",
            "message tool calls. e.g., `pnpm install @langchain/anthropic`,",
            "pnpm install @langchain/openai`, etc."
          ].join(" "));
          try {
            if (!(rawToolCalls == null) && toolCalls === void 0) {
              const [toolCalls$1, invalidToolCalls] = require_messages_tool.defaultToolCallParser(rawToolCalls);
              initParams.tool_calls = toolCalls$1 ?? [];
              initParams.invalid_tool_calls = invalidToolCalls ?? [];
            } else {
              initParams.tool_calls = initParams.tool_calls ?? [];
              initParams.invalid_tool_calls = initParams.invalid_tool_calls ?? [];
            }
          } catch {
            initParams.tool_calls = [];
            initParams.invalid_tool_calls = [];
          }
          if (initParams.response_metadata !== void 0 && "output_version" in initParams.response_metadata && initParams.response_metadata.output_version === "v1") {
            initParams.contentBlocks = initParams.content;
            initParams.content = void 0;
          }
          if (initParams.contentBlocks !== void 0) {
            initParams.contentBlocks.push(...initParams.tool_calls.map((toolCall) => ({
              type: "tool_call",
              id: toolCall.id,
              name: toolCall.name,
              args: toolCall.args
            })));
            const missingToolCalls = initParams.contentBlocks.filter((block) => block.type === "tool_call").filter((block) => !initParams.tool_calls?.some((toolCall) => toolCall.id === block.id && toolCall.name === block.name));
            if (missingToolCalls.length > 0) initParams.tool_calls = missingToolCalls.map((block) => ({
              type: "tool_call",
              id: block.id,
              name: block.name,
              args: block.args
            }));
          }
        }
        super(initParams);
        if (typeof initParams !== "string") {
          this.tool_calls = initParams.tool_calls ?? this.tool_calls;
          this.invalid_tool_calls = initParams.invalid_tool_calls ?? this.invalid_tool_calls;
        }
        this.usage_metadata = initParams.usage_metadata;
      }
      static lc_name() {
        return "AIMessage";
      }
      get contentBlocks() {
        if (this.response_metadata && "output_version" in this.response_metadata && this.response_metadata.output_version === "v1") return this.content;
        if (this.response_metadata && "model_provider" in this.response_metadata && typeof this.response_metadata.model_provider === "string") {
          const translator = require_index.getTranslator(this.response_metadata.model_provider);
          if (translator) return translator.translateContent(this);
        }
        const blocks = super.contentBlocks;
        if (this.tool_calls) {
          const missingToolCalls = this.tool_calls.filter((block) => !blocks.some((b) => b.id === block.id && b.name === block.name));
          blocks.push(...missingToolCalls.map((block) => ({
            ...block,
            type: "tool_call",
            id: block.id,
            name: block.name,
            args: block.args
          })));
        }
        return blocks;
      }
      get _printableFields() {
        return {
          ...super._printableFields,
          tool_calls: this.tool_calls,
          invalid_tool_calls: this.invalid_tool_calls,
          usage_metadata: this.usage_metadata
        };
      }
      static isInstance(obj) {
        return super.isInstance(obj) && obj.type === "ai";
      }
    };
    function isAIMessage(x) {
      return x._getType() === "ai";
    }
    function isAIMessageChunk(x) {
      return x._getType() === "ai";
    }
    var AIMessageChunk = class extends require_base18.BaseMessageChunk {
      type = "ai";
      tool_calls = [];
      invalid_tool_calls = [];
      tool_call_chunks = [];
      usage_metadata;
      constructor(fields) {
        let initParams;
        if (typeof fields === "string" || Array.isArray(fields)) initParams = {
          content: fields,
          tool_calls: [],
          invalid_tool_calls: [],
          tool_call_chunks: []
        };
        else if (fields.tool_call_chunks === void 0 || fields.tool_call_chunks.length === 0) initParams = {
          ...fields,
          tool_calls: fields.tool_calls ?? [],
          invalid_tool_calls: [],
          tool_call_chunks: [],
          usage_metadata: fields.usage_metadata !== void 0 ? fields.usage_metadata : void 0
        };
        else {
          const toolCallChunks = fields.tool_call_chunks ?? [];
          const groupedToolCallChunks = toolCallChunks.reduce((acc, chunk) => {
            const matchedChunkIndex = acc.findIndex(([match]) => {
              if ("id" in chunk && chunk.id && "index" in chunk && chunk.index !== void 0) return chunk.id === match.id && chunk.index === match.index;
              if ("id" in chunk && chunk.id) return chunk.id === match.id;
              if ("index" in chunk && chunk.index !== void 0) return chunk.index === match.index;
              return false;
            });
            if (matchedChunkIndex !== -1) acc[matchedChunkIndex].push(chunk);
            else acc.push([chunk]);
            return acc;
          }, []);
          const toolCalls = [];
          const invalidToolCalls = [];
          for (const chunks of groupedToolCallChunks) {
            let parsedArgs = null;
            const name = chunks[0]?.name ?? "";
            const joinedArgs = chunks.map((c) => c.args || "").join("");
            const argsStr = joinedArgs.length ? joinedArgs : "{}";
            const id = chunks[0]?.id;
            try {
              parsedArgs = require_json3.parsePartialJson(argsStr);
              if (!id || parsedArgs === null || typeof parsedArgs !== "object" || Array.isArray(parsedArgs)) throw new Error("Malformed tool call chunk args.");
              toolCalls.push({
                name,
                args: parsedArgs,
                id,
                type: "tool_call"
              });
            } catch {
              invalidToolCalls.push({
                name,
                args: argsStr,
                id,
                error: "Malformed args.",
                type: "invalid_tool_call"
              });
            }
          }
          initParams = {
            ...fields,
            tool_calls: toolCalls,
            invalid_tool_calls: invalidToolCalls,
            usage_metadata: fields.usage_metadata !== void 0 ? fields.usage_metadata : void 0
          };
        }
        super(initParams);
        this.tool_call_chunks = initParams.tool_call_chunks ?? this.tool_call_chunks;
        this.tool_calls = initParams.tool_calls ?? this.tool_calls;
        this.invalid_tool_calls = initParams.invalid_tool_calls ?? this.invalid_tool_calls;
        this.usage_metadata = initParams.usage_metadata;
      }
      get lc_aliases() {
        return {
          ...super.lc_aliases,
          tool_calls: "tool_calls",
          invalid_tool_calls: "invalid_tool_calls",
          tool_call_chunks: "tool_call_chunks"
        };
      }
      static lc_name() {
        return "AIMessageChunk";
      }
      get contentBlocks() {
        if (this.response_metadata && "output_version" in this.response_metadata && this.response_metadata.output_version === "v1") return this.content;
        if (this.response_metadata && "model_provider" in this.response_metadata && typeof this.response_metadata.model_provider === "string") {
          const translator = require_index.getTranslator(this.response_metadata.model_provider);
          if (translator) return translator.translateContent(this);
        }
        const blocks = super.contentBlocks;
        if (this.tool_calls) {
          if (typeof this.content !== "string") {
            const contentToolCalls = this.content.filter((block) => block.type === "tool_call").map((block) => block.id);
            for (const toolCall of this.tool_calls) if (toolCall.id && !contentToolCalls.includes(toolCall.id)) blocks.push({
              ...toolCall,
              type: "tool_call",
              id: toolCall.id,
              name: toolCall.name,
              args: toolCall.args
            });
          }
        }
        return blocks;
      }
      get _printableFields() {
        return {
          ...super._printableFields,
          tool_calls: this.tool_calls,
          tool_call_chunks: this.tool_call_chunks,
          invalid_tool_calls: this.invalid_tool_calls,
          usage_metadata: this.usage_metadata
        };
      }
      concat(chunk) {
        const combinedFields = {
          content: require_base18.mergeContent(this.content, chunk.content),
          additional_kwargs: require_base18._mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
          response_metadata: require_metadata2.mergeResponseMetadata(this.response_metadata, chunk.response_metadata),
          tool_call_chunks: [],
          id: this.id ?? chunk.id
        };
        if (this.tool_call_chunks !== void 0 || chunk.tool_call_chunks !== void 0) {
          const rawToolCalls = require_base18._mergeLists(this.tool_call_chunks, chunk.tool_call_chunks);
          if (rawToolCalls !== void 0 && rawToolCalls.length > 0) combinedFields.tool_call_chunks = rawToolCalls;
        }
        if (this.usage_metadata !== void 0 || chunk.usage_metadata !== void 0) combinedFields.usage_metadata = require_metadata2.mergeUsageMetadata(this.usage_metadata, chunk.usage_metadata);
        const Cls = this.constructor;
        return new Cls(combinedFields);
      }
      static isInstance(obj) {
        return super.isInstance(obj) && obj.type === "ai";
      }
    };
    exports2.AIMessage = AIMessage;
    exports2.AIMessageChunk = AIMessageChunk;
    exports2.isAIMessage = isAIMessage;
    exports2.isAIMessageChunk = isAIMessageChunk;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/chat.cjs
var require_chat = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/chat.cjs"(exports2) {
    var require_base18 = require_base();
    var ChatMessage = class ChatMessage2 extends require_base18.BaseMessage {
      static lc_name() {
        return "ChatMessage";
      }
      type = "generic";
      role;
      static _chatMessageClass() {
        return ChatMessage2;
      }
      constructor(fields, role) {
        if (typeof fields === "string" || Array.isArray(fields)) fields = {
          content: fields,
          role
        };
        super(fields);
        this.role = fields.role;
      }
      static isInstance(obj) {
        return super.isInstance(obj) && obj.type === "generic";
      }
      get _printableFields() {
        return {
          ...super._printableFields,
          role: this.role
        };
      }
    };
    var ChatMessageChunk = class extends require_base18.BaseMessageChunk {
      static lc_name() {
        return "ChatMessageChunk";
      }
      type = "generic";
      role;
      constructor(fields, role) {
        if (typeof fields === "string" || Array.isArray(fields)) fields = {
          content: fields,
          role
        };
        super(fields);
        this.role = fields.role;
      }
      concat(chunk) {
        const Cls = this.constructor;
        return new Cls({
          content: require_base18.mergeContent(this.content, chunk.content),
          additional_kwargs: require_base18._mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
          response_metadata: require_base18._mergeDicts(this.response_metadata, chunk.response_metadata),
          role: this.role,
          id: this.id ?? chunk.id
        });
      }
      static isInstance(obj) {
        return super.isInstance(obj) && obj.type === "generic";
      }
      get _printableFields() {
        return {
          ...super._printableFields,
          role: this.role
        };
      }
    };
    function isChatMessage(x) {
      return x._getType() === "generic";
    }
    function isChatMessageChunk(x) {
      return x._getType() === "generic";
    }
    exports2.ChatMessage = ChatMessage;
    exports2.ChatMessageChunk = ChatMessageChunk;
    exports2.isChatMessage = isChatMessage;
    exports2.isChatMessageChunk = isChatMessageChunk;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/function.cjs
var require_function = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/function.cjs"(exports2) {
    var require_base18 = require_base();
    var FunctionMessage = class extends require_base18.BaseMessage {
      static lc_name() {
        return "FunctionMessage";
      }
      type = "function";
      name;
      constructor(fields) {
        super(fields);
        this.name = fields.name;
      }
    };
    var FunctionMessageChunk = class extends require_base18.BaseMessageChunk {
      static lc_name() {
        return "FunctionMessageChunk";
      }
      type = "function";
      concat(chunk) {
        const Cls = this.constructor;
        return new Cls({
          content: require_base18.mergeContent(this.content, chunk.content),
          additional_kwargs: require_base18._mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
          response_metadata: require_base18._mergeDicts(this.response_metadata, chunk.response_metadata),
          name: this.name ?? "",
          id: this.id ?? chunk.id
        });
      }
    };
    function isFunctionMessage(x) {
      return x._getType() === "function";
    }
    function isFunctionMessageChunk(x) {
      return x._getType() === "function";
    }
    exports2.FunctionMessage = FunctionMessage;
    exports2.FunctionMessageChunk = FunctionMessageChunk;
    exports2.isFunctionMessage = isFunctionMessage;
    exports2.isFunctionMessageChunk = isFunctionMessageChunk;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/human.cjs
var require_human = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/human.cjs"(exports2) {
    var require_base18 = require_base();
    var HumanMessage = class extends require_base18.BaseMessage {
      static lc_name() {
        return "HumanMessage";
      }
      type = "human";
      constructor(fields) {
        super(fields);
      }
      static isInstance(obj) {
        return super.isInstance(obj) && obj.type === "human";
      }
    };
    var HumanMessageChunk = class extends require_base18.BaseMessageChunk {
      static lc_name() {
        return "HumanMessageChunk";
      }
      type = "human";
      constructor(fields) {
        super(fields);
      }
      concat(chunk) {
        const Cls = this.constructor;
        return new Cls({
          content: require_base18.mergeContent(this.content, chunk.content),
          additional_kwargs: require_base18._mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
          response_metadata: require_base18._mergeDicts(this.response_metadata, chunk.response_metadata),
          id: this.id ?? chunk.id
        });
      }
      static isInstance(obj) {
        return super.isInstance(obj) && obj.type === "human";
      }
    };
    function isHumanMessage(x) {
      return x.getType() === "human";
    }
    function isHumanMessageChunk(x) {
      return x.getType() === "human";
    }
    exports2.HumanMessage = HumanMessage;
    exports2.HumanMessageChunk = HumanMessageChunk;
    exports2.isHumanMessage = isHumanMessage;
    exports2.isHumanMessageChunk = isHumanMessageChunk;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/system.cjs
var require_system = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/system.cjs"(exports2) {
    var require_base18 = require_base();
    var SystemMessage = class extends require_base18.BaseMessage {
      static lc_name() {
        return "SystemMessage";
      }
      type = "system";
      constructor(fields) {
        super(fields);
      }
      static isInstance(obj) {
        return super.isInstance(obj) && obj.type === "system";
      }
    };
    var SystemMessageChunk = class extends require_base18.BaseMessageChunk {
      static lc_name() {
        return "SystemMessageChunk";
      }
      type = "system";
      constructor(fields) {
        super(fields);
      }
      concat(chunk) {
        const Cls = this.constructor;
        return new Cls({
          content: require_base18.mergeContent(this.content, chunk.content),
          additional_kwargs: require_base18._mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
          response_metadata: require_base18._mergeDicts(this.response_metadata, chunk.response_metadata),
          id: this.id ?? chunk.id
        });
      }
      static isInstance(obj) {
        return super.isInstance(obj) && obj.type === "system";
      }
    };
    function isSystemMessage(x) {
      return x._getType() === "system";
    }
    function isSystemMessageChunk(x) {
      return x._getType() === "system";
    }
    exports2.SystemMessage = SystemMessage;
    exports2.SystemMessageChunk = SystemMessageChunk;
    exports2.isSystemMessage = isSystemMessage;
    exports2.isSystemMessageChunk = isSystemMessageChunk;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/errors/index.cjs
var require_errors4 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/errors/index.cjs"(exports2) {
    function addLangChainErrorFields(error, lc_error_code) {
      error.lc_error_code = lc_error_code;
      error.message = `${error.message}

Troubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${lc_error_code}/
`;
      return error;
    }
    exports2.addLangChainErrorFields = addLangChainErrorFields;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/modifier.cjs
var require_modifier = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/modifier.cjs"(exports2) {
    var require_base18 = require_base();
    var RemoveMessage = class extends require_base18.BaseMessage {
      type = "remove";
      /**
      * The ID of the message to remove.
      */
      id;
      constructor(fields) {
        super({
          ...fields,
          content: []
        });
        this.id = fields.id;
      }
      get _printableFields() {
        return {
          ...super._printableFields,
          id: this.id
        };
      }
      static isInstance(obj) {
        return super.isInstance(obj) && obj.type === "remove";
      }
    };
    exports2.RemoveMessage = RemoveMessage;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/utils.cjs
var require_utils3 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/utils.cjs"(exports2) {
    var require_base18 = require_base();
    var require_messages_tool = require_tool();
    var require_ai2 = require_ai();
    var require_chat3 = require_chat();
    var require_function3 = require_function();
    var require_human2 = require_human();
    var require_system2 = require_system();
    var require_index = require_errors4();
    var require_utils10 = require_utils2();
    var require_modifier2 = require_modifier();
    var iife = (fn) => fn();
    function _coerceToolCall(toolCall) {
      if (require_utils10._isToolCall(toolCall)) return toolCall;
      else if (typeof toolCall.id === "string" && toolCall.type === "function" && typeof toolCall.function === "object" && toolCall.function !== null && "arguments" in toolCall.function && typeof toolCall.function.arguments === "string" && "name" in toolCall.function && typeof toolCall.function.name === "string") return {
        id: toolCall.id,
        args: JSON.parse(toolCall.function.arguments),
        name: toolCall.function.name,
        type: "tool_call"
      };
      else return toolCall;
    }
    function isSerializedConstructor(x) {
      return typeof x === "object" && x != null && x.lc === 1 && Array.isArray(x.id) && x.kwargs != null && typeof x.kwargs === "object";
    }
    function _constructMessageFromParams(params) {
      let type;
      let rest;
      if (isSerializedConstructor(params)) {
        const className = params.id.at(-1);
        if (className === "HumanMessage" || className === "HumanMessageChunk") type = "user";
        else if (className === "AIMessage" || className === "AIMessageChunk") type = "assistant";
        else if (className === "SystemMessage" || className === "SystemMessageChunk") type = "system";
        else if (className === "FunctionMessage" || className === "FunctionMessageChunk") type = "function";
        else if (className === "ToolMessage" || className === "ToolMessageChunk") type = "tool";
        else type = "unknown";
        rest = params.kwargs;
      } else {
        const { type: extractedType, ...otherParams } = params;
        type = extractedType;
        rest = otherParams;
      }
      if (type === "human" || type === "user") return new require_human2.HumanMessage(rest);
      else if (type === "ai" || type === "assistant") {
        const { tool_calls: rawToolCalls, ...other } = rest;
        if (!Array.isArray(rawToolCalls)) return new require_ai2.AIMessage(rest);
        const tool_calls = rawToolCalls.map(_coerceToolCall);
        return new require_ai2.AIMessage({
          ...other,
          tool_calls
        });
      } else if (type === "system") return new require_system2.SystemMessage(rest);
      else if (type === "developer") return new require_system2.SystemMessage({
        ...rest,
        additional_kwargs: {
          ...rest.additional_kwargs,
          __openai_role__: "developer"
        }
      });
      else if (type === "tool" && "tool_call_id" in rest) return new require_messages_tool.ToolMessage({
        ...rest,
        content: rest.content,
        tool_call_id: rest.tool_call_id,
        name: rest.name
      });
      else if (type === "remove" && "id" in rest && typeof rest.id === "string") return new require_modifier2.RemoveMessage({
        ...rest,
        id: rest.id
      });
      else {
        const error = require_index.addLangChainErrorFields(/* @__PURE__ */ new Error(`Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.

Received: ${JSON.stringify(params, null, 2)}`), "MESSAGE_COERCION_FAILURE");
        throw error;
      }
    }
    function coerceMessageLikeToMessage(messageLike) {
      if (typeof messageLike === "string") return new require_human2.HumanMessage(messageLike);
      else if (require_base18.isBaseMessage(messageLike)) return messageLike;
      if (Array.isArray(messageLike)) {
        const [type, content] = messageLike;
        return _constructMessageFromParams({
          type,
          content
        });
      } else if (require_base18._isMessageFieldWithRole(messageLike)) {
        const { role: type, ...rest } = messageLike;
        return _constructMessageFromParams({
          ...rest,
          type
        });
      } else return _constructMessageFromParams(messageLike);
    }
    function getBufferString(messages, humanPrefix = "Human", aiPrefix = "AI") {
      const string_messages = [];
      for (const m of messages) {
        let role;
        if (m._getType() === "human") role = humanPrefix;
        else if (m._getType() === "ai") role = aiPrefix;
        else if (m._getType() === "system") role = "System";
        else if (m._getType() === "tool") role = "Tool";
        else if (m._getType() === "generic") role = m.role;
        else throw new Error(`Got unsupported message type: ${m._getType()}`);
        const nameStr = m.name ? `${m.name}, ` : "";
        const readableContent = typeof m.content === "string" ? m.content : JSON.stringify(m.content, null, 2);
        string_messages.push(`${role}: ${nameStr}${readableContent}`);
      }
      return string_messages.join("\n");
    }
    function mapV1MessageToStoredMessage(message) {
      if (message.data !== void 0) return message;
      else {
        const v1Message = message;
        return {
          type: v1Message.type,
          data: {
            content: v1Message.text,
            role: v1Message.role,
            name: void 0,
            tool_call_id: void 0
          }
        };
      }
    }
    function mapStoredMessageToChatMessage(message) {
      const storedMessage = mapV1MessageToStoredMessage(message);
      switch (storedMessage.type) {
        case "human":
          return new require_human2.HumanMessage(storedMessage.data);
        case "ai":
          return new require_ai2.AIMessage(storedMessage.data);
        case "system":
          return new require_system2.SystemMessage(storedMessage.data);
        case "function":
          if (storedMessage.data.name === void 0) throw new Error("Name must be defined for function messages");
          return new require_function3.FunctionMessage(storedMessage.data);
        case "tool":
          if (storedMessage.data.tool_call_id === void 0) throw new Error("Tool call ID must be defined for tool messages");
          return new require_messages_tool.ToolMessage(storedMessage.data);
        case "generic":
          if (storedMessage.data.role === void 0) throw new Error("Role must be defined for chat messages");
          return new require_chat3.ChatMessage(storedMessage.data);
        default:
          throw new Error(`Got unexpected type: ${storedMessage.type}`);
      }
    }
    function mapStoredMessagesToChatMessages(messages) {
      return messages.map(mapStoredMessageToChatMessage);
    }
    function mapChatMessagesToStoredMessages(messages) {
      return messages.map((message) => message.toDict());
    }
    function convertToChunk(message) {
      const type = message._getType();
      if (type === "human") return new require_human2.HumanMessageChunk({ ...message });
      else if (type === "ai") {
        let aiChunkFields = { ...message };
        if ("tool_calls" in aiChunkFields) aiChunkFields = {
          ...aiChunkFields,
          tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({
            ...tc,
            type: "tool_call_chunk",
            index: void 0,
            args: JSON.stringify(tc.args)
          }))
        };
        return new require_ai2.AIMessageChunk({ ...aiChunkFields });
      } else if (type === "system") return new require_system2.SystemMessageChunk({ ...message });
      else if (type === "function") return new require_function3.FunctionMessageChunk({ ...message });
      else if (require_chat3.ChatMessage.isInstance(message)) return new require_chat3.ChatMessageChunk({ ...message });
      else throw new Error("Unknown message type.");
    }
    exports2.coerceMessageLikeToMessage = coerceMessageLikeToMessage;
    exports2.convertToChunk = convertToChunk;
    exports2.getBufferString = getBufferString;
    exports2.iife = iife;
    exports2.mapChatMessagesToStoredMessages = mapChatMessagesToStoredMessages;
    exports2.mapStoredMessageToChatMessage = mapStoredMessageToChatMessage;
    exports2.mapStoredMessagesToChatMessages = mapStoredMessagesToChatMessages;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/env.cjs
var require_env = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/env.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var env_exports = {};
    require_rolldown_runtime5.__export(env_exports, {
      getEnv: () => getEnv,
      getEnvironmentVariable: () => getEnvironmentVariable,
      getRuntimeEnvironment: () => getRuntimeEnvironment,
      isBrowser: () => isBrowser,
      isDeno: () => isDeno,
      isJsDom: () => isJsDom,
      isNode: () => isNode,
      isWebWorker: () => isWebWorker
    });
    var isBrowser = () => typeof window !== "undefined" && typeof window.document !== "undefined";
    var isWebWorker = () => typeof globalThis === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope";
    var isJsDom = () => typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && navigator.userAgent.includes("jsdom");
    var isDeno = () => typeof Deno !== "undefined";
    var isNode = () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined" && !isDeno();
    var getEnv = () => {
      let env;
      if (isBrowser()) env = "browser";
      else if (isNode()) env = "node";
      else if (isWebWorker()) env = "webworker";
      else if (isJsDom()) env = "jsdom";
      else if (isDeno()) env = "deno";
      else env = "other";
      return env;
    };
    var runtimeEnvironment;
    function getRuntimeEnvironment() {
      if (runtimeEnvironment === void 0) {
        const env = getEnv();
        runtimeEnvironment = {
          library: "langchain-js",
          runtime: env
        };
      }
      return runtimeEnvironment;
    }
    function getEnvironmentVariable(name) {
      try {
        if (typeof process !== "undefined") return process.env?.[name];
        else if (isDeno()) return Deno?.env.get(name);
        else return void 0;
      } catch {
        return void 0;
      }
    }
    Object.defineProperty(exports2, "env_exports", {
      enumerable: true,
      get: function() {
        return env_exports;
      }
    });
    exports2.getEnv = getEnv;
    exports2.getEnvironmentVariable = getEnvironmentVariable;
    exports2.getRuntimeEnvironment = getRuntimeEnvironment;
    exports2.isBrowser = isBrowser;
    exports2.isDeno = isDeno;
    exports2.isJsDom = isJsDom;
    exports2.isNode = isNode;
    exports2.isWebWorker = isWebWorker;
  }
});

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/max.js
var max_default;
var init_max = __esm({
  "node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/max.js"() {
    max_default = "ffffffff-ffff-ffff-ffff-ffffffffffff";
  }
});

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/nil.js
var nil_default;
var init_nil = __esm({
  "node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/nil.js"() {
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
  }
});

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/validate.js"() {
    init_regex();
    validate_default = validate;
  }
});

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  "node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/parse.js"() {
    init_validate();
    parse_default = parse;
  }
});

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/stringify.js
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset);
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, stringify_default;
var init_stringify = __esm({
  "node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/stringify.js"() {
    init_validate();
    byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
    stringify_default = stringify;
  }
});

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/rng.js
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    import_node_crypto.default.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var import_node_crypto, rnds8Pool, poolPtr;
var init_rng = __esm({
  "node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/rng.js"() {
    import_node_crypto = __toESM(require("node:crypto"));
    rnds8Pool = new Uint8Array(256);
    poolPtr = rnds8Pool.length;
  }
});

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v1.js
function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node;
  let clockseq = options.clockseq;
  if (!options._v6) {
    if (!node) {
      node = _nodeId;
    }
    if (clockseq == null) {
      clockseq = _clockseq;
    }
  }
  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = [seedBytes[0], seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      if (!_nodeId && !options._v6) {
        node[0] |= 1;
        _nodeId = node;
      }
    }
    if (clockseq == null) {
      clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      if (_clockseq === void 0 && !options._v6) {
        _clockseq = clockseq;
      }
    }
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || unsafeStringify(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v1.js"() {
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v1ToV6.js
function v1ToV6(uuid) {
  const v1Bytes = typeof uuid === "string" ? parse_default(uuid) : uuid;
  const v6Bytes = _v1ToV6(v1Bytes);
  return typeof uuid === "string" ? unsafeStringify(v6Bytes) : v6Bytes;
}
function _v1ToV6(v1Bytes, randomize = false) {
  return Uint8Array.of((v1Bytes[6] & 15) << 4 | v1Bytes[7] >> 4 & 15, (v1Bytes[7] & 15) << 4 | (v1Bytes[4] & 240) >> 4, (v1Bytes[4] & 15) << 4 | (v1Bytes[5] & 240) >> 4, (v1Bytes[5] & 15) << 4 | (v1Bytes[0] & 240) >> 4, (v1Bytes[0] & 15) << 4 | (v1Bytes[1] & 240) >> 4, (v1Bytes[1] & 15) << 4 | (v1Bytes[2] & 240) >> 4, 96 | v1Bytes[2] & 15, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);
}
var init_v1ToV6 = __esm({
  "node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v1ToV6.js"() {
    init_parse();
    init_stringify();
  }
});

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
function v35(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}
var DNS, URL2;
var init_v35 = __esm({
  "node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v35.js"() {
    init_stringify();
    init_parse();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/md5.js
function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return import_node_crypto2.default.createHash("md5").update(bytes).digest();
}
var import_node_crypto2, md5_default;
var init_md5 = __esm({
  "node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/md5.js"() {
    import_node_crypto2 = __toESM(require("node:crypto"));
    md5_default = md5;
  }
});

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v3.js"() {
    init_v35();
    init_md5();
    v3 = v35("v3", 48, md5_default);
    v3_default = v3;
  }
});

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/native.js
var import_node_crypto3, native_default;
var init_native = __esm({
  "node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/native.js"() {
    import_node_crypto3 = __toESM(require("node:crypto"));
    native_default = {
      randomUUID: import_node_crypto3.default.randomUUID
    };
  }
});

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v4.js"() {
    init_native();
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/sha1.js
function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return import_node_crypto4.default.createHash("sha1").update(bytes).digest();
}
var import_node_crypto4, sha1_default;
var init_sha1 = __esm({
  "node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/sha1.js"() {
    import_node_crypto4 = __toESM(require("node:crypto"));
    sha1_default = sha1;
  }
});

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v6.js
function v6(options = {}, buf, offset = 0) {
  let bytes = v1_default({
    ...options,
    _v6: true
  }, new Uint8Array(16));
  bytes = v1ToV6(bytes);
  if (buf) {
    for (let i = 0; i < 16; i++) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return unsafeStringify(bytes);
}
var init_v6 = __esm({
  "node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v6.js"() {
    init_stringify();
    init_v1();
    init_v1ToV6();
  }
});

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v6ToV1.js
function v6ToV1(uuid) {
  const v6Bytes = typeof uuid === "string" ? parse_default(uuid) : uuid;
  const v1Bytes = _v6ToV1(v6Bytes);
  return typeof uuid === "string" ? unsafeStringify(v1Bytes) : v1Bytes;
}
function _v6ToV1(v6Bytes) {
  return Uint8Array.of((v6Bytes[3] & 15) << 4 | v6Bytes[4] >> 4 & 15, (v6Bytes[4] & 15) << 4 | (v6Bytes[5] & 240) >> 4, (v6Bytes[5] & 15) << 4 | v6Bytes[6] & 15, v6Bytes[7], (v6Bytes[1] & 15) << 4 | (v6Bytes[2] & 240) >> 4, (v6Bytes[2] & 15) << 4 | (v6Bytes[3] & 240) >> 4, 16 | (v6Bytes[0] & 240) >> 4, (v6Bytes[0] & 15) << 4 | (v6Bytes[1] & 240) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
}
var init_v6ToV1 = __esm({
  "node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v6ToV1.js"() {
    init_parse();
    init_stringify();
  }
});

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v7.js
function v7(options, buf, offset) {
  options = options || {};
  let i = buf && offset || 0;
  const b = buf || new Uint8Array(16);
  const rnds = options.random || (options.rng || rng)();
  const msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let seq = options.seq !== void 0 ? options.seq : null;
  let seqHigh = _seqHigh;
  let seqLow = _seqLow;
  if (msecs > _msecs && options.msecs === void 0) {
    _msecs = msecs;
    if (seq !== null) {
      seqHigh = null;
      seqLow = null;
    }
  }
  if (seq !== null) {
    if (seq > 2147483647) {
      seq = 2147483647;
    }
    seqHigh = seq >>> 19 & 4095;
    seqLow = seq & 524287;
  }
  if (seqHigh === null || seqLow === null) {
    seqHigh = rnds[6] & 127;
    seqHigh = seqHigh << 8 | rnds[7];
    seqLow = rnds[8] & 63;
    seqLow = seqLow << 8 | rnds[9];
    seqLow = seqLow << 5 | rnds[10] >>> 3;
  }
  if (msecs + 1e4 > _msecs && seq === null) {
    if (++seqLow > 524287) {
      seqLow = 0;
      if (++seqHigh > 4095) {
        seqHigh = 0;
        _msecs++;
      }
    }
  } else {
    _msecs = msecs;
  }
  _seqHigh = seqHigh;
  _seqLow = seqLow;
  b[i++] = _msecs / 1099511627776 & 255;
  b[i++] = _msecs / 4294967296 & 255;
  b[i++] = _msecs / 16777216 & 255;
  b[i++] = _msecs / 65536 & 255;
  b[i++] = _msecs / 256 & 255;
  b[i++] = _msecs & 255;
  b[i++] = seqHigh >>> 4 & 15 | 112;
  b[i++] = seqHigh & 255;
  b[i++] = seqLow >>> 13 & 63 | 128;
  b[i++] = seqLow >>> 5 & 255;
  b[i++] = seqLow << 3 & 255 | rnds[10] & 7;
  b[i++] = rnds[11];
  b[i++] = rnds[12];
  b[i++] = rnds[13];
  b[i++] = rnds[14];
  b[i++] = rnds[15];
  return buf || unsafeStringify(b);
}
var _seqLow, _seqHigh, _msecs, v7_default;
var init_v7 = __esm({
  "node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v7.js"() {
    init_rng();
    init_stringify();
    _seqLow = null;
    _seqHigh = null;
    _msecs = 0;
    v7_default = v7;
  }
});

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.slice(14, 15), 16);
}
var version_default;
var init_version = __esm({
  "node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/version.js"() {
    init_validate();
    version_default = version;
  }
});

// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/index.js
var esm_node_exports = {};
__export(esm_node_exports, {
  MAX: () => max_default,
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v1ToV6: () => v1ToV6,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  v6: () => v6,
  v6ToV1: () => v6ToV1,
  v7: () => v7_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_node = __esm({
  "node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/index.js"() {
    init_max();
    init_nil();
    init_parse();
    init_stringify();
    init_v1();
    init_v1ToV6();
    init_v3();
    init_v4();
    init_v5();
    init_v6();
    init_v6ToV1();
    init_v7();
    init_validate();
    init_version();
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/callbacks/base.cjs
var require_base2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/callbacks/base.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_load_serializable = require_serializable();
    var require_utils_env = require_env();
    var uuid = require_rolldown_runtime5.__toESM((init_esm_node(), __toCommonJS(esm_node_exports)));
    var base_exports = {};
    require_rolldown_runtime5.__export(base_exports, {
      BaseCallbackHandler: () => BaseCallbackHandler,
      callbackHandlerPrefersStreaming: () => callbackHandlerPrefersStreaming,
      isBaseCallbackHandler: () => isBaseCallbackHandler
    });
    var BaseCallbackHandlerMethodsClass = class {
    };
    function callbackHandlerPrefersStreaming(x) {
      return "lc_prefer_streaming" in x && x.lc_prefer_streaming;
    }
    var BaseCallbackHandler = class extends BaseCallbackHandlerMethodsClass {
      lc_serializable = false;
      get lc_namespace() {
        return [
          "langchain_core",
          "callbacks",
          this.name
        ];
      }
      get lc_secrets() {
        return void 0;
      }
      get lc_attributes() {
        return void 0;
      }
      get lc_aliases() {
        return void 0;
      }
      get lc_serializable_keys() {
        return void 0;
      }
      /**
      * The name of the serializable. Override to provide an alias or
      * to preserve the serialized module name in minified environments.
      *
      * Implemented as a static method to support loading logic.
      */
      static lc_name() {
        return this.name;
      }
      /**
      * The final serialized identifier for the module.
      */
      get lc_id() {
        return [...this.lc_namespace, require_load_serializable.get_lc_unique_name(this.constructor)];
      }
      lc_kwargs;
      ignoreLLM = false;
      ignoreChain = false;
      ignoreAgent = false;
      ignoreRetriever = false;
      ignoreCustomEvent = false;
      raiseError = false;
      awaitHandlers = require_utils_env.getEnvironmentVariable("LANGCHAIN_CALLBACKS_BACKGROUND") === "false";
      constructor(input) {
        super();
        this.lc_kwargs = input || {};
        if (input) {
          this.ignoreLLM = input.ignoreLLM ?? this.ignoreLLM;
          this.ignoreChain = input.ignoreChain ?? this.ignoreChain;
          this.ignoreAgent = input.ignoreAgent ?? this.ignoreAgent;
          this.ignoreRetriever = input.ignoreRetriever ?? this.ignoreRetriever;
          this.ignoreCustomEvent = input.ignoreCustomEvent ?? this.ignoreCustomEvent;
          this.raiseError = input.raiseError ?? this.raiseError;
          this.awaitHandlers = this.raiseError || (input._awaitHandler ?? this.awaitHandlers);
        }
      }
      copy() {
        return new this.constructor(this);
      }
      toJSON() {
        return require_load_serializable.Serializable.prototype.toJSON.call(this);
      }
      toJSONNotImplemented() {
        return require_load_serializable.Serializable.prototype.toJSONNotImplemented.call(this);
      }
      static fromMethods(methods) {
        class Handler extends BaseCallbackHandler {
          name = uuid.v4();
          constructor() {
            super();
            Object.assign(this, methods);
          }
        }
        return new Handler();
      }
    };
    var isBaseCallbackHandler = (x) => {
      const callbackHandler = x;
      return callbackHandler !== void 0 && typeof callbackHandler.copy === "function" && typeof callbackHandler.name === "string" && typeof callbackHandler.awaitHandlers === "boolean";
    };
    exports2.BaseCallbackHandler = BaseCallbackHandler;
    Object.defineProperty(exports2, "base_exports", {
      enumerable: true,
      get: function() {
        return base_exports;
      }
    });
    exports2.callbackHandlerPrefersStreaming = callbackHandlerPrefersStreaming;
    exports2.isBaseCallbackHandler = isBaseCallbackHandler;
  }
});

// node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/experimental/otel/constants.cjs
var require_constants = __commonJS({
  "node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/experimental/otel/constants.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AI_SDK_TOOL_OPERATIONS = exports2.AI_SDK_LLM_OPERATIONS = exports2.GEN_AI_CHOICE = exports2.GEN_AI_ASSISTANT_MESSAGE = exports2.GEN_AI_USER_MESSAGE = exports2.GEN_AI_SYSTEM_MESSAGE = exports2.LANGSMITH_TRACEABLE_PARENT_OTEL_SPAN_ID = exports2.LANGSMITH_IS_ROOT = exports2.LANGSMITH_TRACEABLE = exports2.LANGSMITH_REFERENCE_EXAMPLE_ID = exports2.LANGSMITH_USAGE_METADATA = exports2.LANGSMITH_PARENT_RUN_ID = exports2.LANGSMITH_DOTTED_ORDER = exports2.LANGSMITH_TRACE_ID = exports2.LANGSMITH_RUN_ID = exports2.LANGSMITH_REQUEST_HEADERS = exports2.LANGSMITH_REQUEST_STREAMING = exports2.LANGSMITH_RUNTIME = exports2.LANGSMITH_TAGS = exports2.LANGSMITH_METADATA = exports2.LANGSMITH_NAME = exports2.LANGSMITH_RUN_TYPE = exports2.LANGSMITH_SESSION_NAME = exports2.LANGSMITH_SESSION_ID = exports2.GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS = exports2.GEN_AI_USAGE_INPUT_TOKEN_DETAILS = exports2.GEN_AI_RESPONSE_SYSTEM_FINGERPRINT = exports2.GEN_AI_RESPONSE_SERVICE_TIER = exports2.GEN_AI_RESPONSE_ID = exports2.GEN_AI_SERIALIZED_DOC = exports2.GEN_AI_SERIALIZED_SIGNATURE = exports2.GEN_AI_SERIALIZED_NAME = exports2.GEN_AI_REQUEST_EXTRA_BODY = exports2.GEN_AI_REQUEST_EXTRA_QUERY = exports2.GENAI_COMPLETION = exports2.GENAI_PROMPT = exports2.GEN_AI_RESPONSE_FINISH_REASONS = exports2.GEN_AI_REQUEST_PRESENCE_PENALTY = exports2.GEN_AI_REQUEST_FREQUENCY_PENALTY = exports2.GEN_AI_REQUEST_TOP_P = exports2.GEN_AI_REQUEST_TEMPERATURE = exports2.GEN_AI_REQUEST_MAX_TOKENS = exports2.GEN_AI_USAGE_TOTAL_TOKENS = exports2.GEN_AI_USAGE_OUTPUT_TOKENS = exports2.GEN_AI_USAGE_INPUT_TOKENS = exports2.GEN_AI_RESPONSE_MODEL = exports2.GEN_AI_REQUEST_MODEL = exports2.GEN_AI_SYSTEM = exports2.GEN_AI_OPERATION_NAME = void 0;
    exports2.GEN_AI_OPERATION_NAME = "gen_ai.operation.name";
    exports2.GEN_AI_SYSTEM = "gen_ai.system";
    exports2.GEN_AI_REQUEST_MODEL = "gen_ai.request.model";
    exports2.GEN_AI_RESPONSE_MODEL = "gen_ai.response.model";
    exports2.GEN_AI_USAGE_INPUT_TOKENS = "gen_ai.usage.input_tokens";
    exports2.GEN_AI_USAGE_OUTPUT_TOKENS = "gen_ai.usage.output_tokens";
    exports2.GEN_AI_USAGE_TOTAL_TOKENS = "gen_ai.usage.total_tokens";
    exports2.GEN_AI_REQUEST_MAX_TOKENS = "gen_ai.request.max_tokens";
    exports2.GEN_AI_REQUEST_TEMPERATURE = "gen_ai.request.temperature";
    exports2.GEN_AI_REQUEST_TOP_P = "gen_ai.request.top_p";
    exports2.GEN_AI_REQUEST_FREQUENCY_PENALTY = "gen_ai.request.frequency_penalty";
    exports2.GEN_AI_REQUEST_PRESENCE_PENALTY = "gen_ai.request.presence_penalty";
    exports2.GEN_AI_RESPONSE_FINISH_REASONS = "gen_ai.response.finish_reasons";
    exports2.GENAI_PROMPT = "gen_ai.prompt";
    exports2.GENAI_COMPLETION = "gen_ai.completion";
    exports2.GEN_AI_REQUEST_EXTRA_QUERY = "gen_ai.request.extra_query";
    exports2.GEN_AI_REQUEST_EXTRA_BODY = "gen_ai.request.extra_body";
    exports2.GEN_AI_SERIALIZED_NAME = "gen_ai.serialized.name";
    exports2.GEN_AI_SERIALIZED_SIGNATURE = "gen_ai.serialized.signature";
    exports2.GEN_AI_SERIALIZED_DOC = "gen_ai.serialized.doc";
    exports2.GEN_AI_RESPONSE_ID = "gen_ai.response.id";
    exports2.GEN_AI_RESPONSE_SERVICE_TIER = "gen_ai.response.service_tier";
    exports2.GEN_AI_RESPONSE_SYSTEM_FINGERPRINT = "gen_ai.response.system_fingerprint";
    exports2.GEN_AI_USAGE_INPUT_TOKEN_DETAILS = "gen_ai.usage.input_token_details";
    exports2.GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS = "gen_ai.usage.output_token_details";
    exports2.LANGSMITH_SESSION_ID = "langsmith.trace.session_id";
    exports2.LANGSMITH_SESSION_NAME = "langsmith.trace.session_name";
    exports2.LANGSMITH_RUN_TYPE = "langsmith.span.kind";
    exports2.LANGSMITH_NAME = "langsmith.trace.name";
    exports2.LANGSMITH_METADATA = "langsmith.metadata";
    exports2.LANGSMITH_TAGS = "langsmith.span.tags";
    exports2.LANGSMITH_RUNTIME = "langsmith.span.runtime";
    exports2.LANGSMITH_REQUEST_STREAMING = "langsmith.request.streaming";
    exports2.LANGSMITH_REQUEST_HEADERS = "langsmith.request.headers";
    exports2.LANGSMITH_RUN_ID = "langsmith.span.id";
    exports2.LANGSMITH_TRACE_ID = "langsmith.trace.id";
    exports2.LANGSMITH_DOTTED_ORDER = "langsmith.span.dotted_order";
    exports2.LANGSMITH_PARENT_RUN_ID = "langsmith.span.parent_id";
    exports2.LANGSMITH_USAGE_METADATA = "langsmith.usage_metadata";
    exports2.LANGSMITH_REFERENCE_EXAMPLE_ID = "langsmith.reference_example_id";
    exports2.LANGSMITH_TRACEABLE = "langsmith.traceable";
    exports2.LANGSMITH_IS_ROOT = "langsmith.is_root";
    exports2.LANGSMITH_TRACEABLE_PARENT_OTEL_SPAN_ID = "langsmith.traceable_parent_otel_span_id";
    exports2.GEN_AI_SYSTEM_MESSAGE = "gen_ai.system.message";
    exports2.GEN_AI_USER_MESSAGE = "gen_ai.user.message";
    exports2.GEN_AI_ASSISTANT_MESSAGE = "gen_ai.assistant.message";
    exports2.GEN_AI_CHOICE = "gen_ai.choice";
    exports2.AI_SDK_LLM_OPERATIONS = [
      "ai.generateText.doGenerate",
      "ai.streamText.doStream",
      "ai.generateObject.doGenerate",
      "ai.streamObject.doStream"
    ];
    exports2.AI_SDK_TOOL_OPERATIONS = ["ai.toolCall"];
  }
});

// node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/singletons/fetch.cjs
var require_fetch = __commonJS({
  "node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/singletons/fetch.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._getFetchImplementation = exports2._globalFetchImplementationIsNodeFetch = exports2.clearFetchImplementation = exports2.overrideFetchImplementation = void 0;
    var env_js_1 = require_env2();
    var DEFAULT_FETCH_IMPLEMENTATION = (...args) => fetch(...args);
    var LANGSMITH_FETCH_IMPLEMENTATION_KEY = Symbol.for("ls:fetch_implementation");
    var overrideFetchImplementation = (fetch2) => {
      globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] = fetch2;
    };
    exports2.overrideFetchImplementation = overrideFetchImplementation;
    var clearFetchImplementation = () => {
      delete globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY];
    };
    exports2.clearFetchImplementation = clearFetchImplementation;
    var _globalFetchImplementationIsNodeFetch = () => {
      const fetchImpl = globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY];
      if (!fetchImpl)
        return false;
      return typeof fetchImpl === "function" && "Headers" in fetchImpl && "Request" in fetchImpl && "Response" in fetchImpl;
    };
    exports2._globalFetchImplementationIsNodeFetch = _globalFetchImplementationIsNodeFetch;
    var _getFetchImplementation = (debug) => {
      return async (...args) => {
        if (debug || (0, env_js_1.getLangSmithEnvironmentVariable)("DEBUG") === "true") {
          const [url, options] = args;
          console.log(`\u2192 ${options?.method || "GET"} ${url}`);
        }
        const res = await (globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] ?? DEFAULT_FETCH_IMPLEMENTATION)(...args);
        if (debug || (0, env_js_1.getLangSmithEnvironmentVariable)("DEBUG") === "true") {
          console.log(`\u2190 ${res.status} ${res.statusText} ${res.url}`);
        }
        return res;
      };
    };
    exports2._getFetchImplementation = _getFetchImplementation;
  }
});

// node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/utils/project.cjs
var require_project = __commonJS({
  "node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/utils/project.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDefaultProjectName = void 0;
    var env_js_1 = require_env2();
    var getDefaultProjectName = () => {
      return (0, env_js_1.getLangSmithEnvironmentVariable)("PROJECT") ?? (0, env_js_1.getEnvironmentVariable)("LANGCHAIN_SESSION") ?? // TODO: Deprecate
      "default";
    };
    exports2.getDefaultProjectName = getDefaultProjectName;
  }
});

// node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/index.cjs
var require_dist = __commonJS({
  "node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/index.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.__version__ = exports2.getDefaultProjectName = exports2.overrideFetchImplementation = exports2.RunTree = exports2.Client = void 0;
    var client_js_1 = require_client();
    Object.defineProperty(exports2, "Client", { enumerable: true, get: function() {
      return client_js_1.Client;
    } });
    var run_trees_js_1 = require_run_trees();
    Object.defineProperty(exports2, "RunTree", { enumerable: true, get: function() {
      return run_trees_js_1.RunTree;
    } });
    var fetch_js_1 = require_fetch();
    Object.defineProperty(exports2, "overrideFetchImplementation", { enumerable: true, get: function() {
      return fetch_js_1.overrideFetchImplementation;
    } });
    var project_js_1 = require_project();
    Object.defineProperty(exports2, "getDefaultProjectName", { enumerable: true, get: function() {
      return project_js_1.getDefaultProjectName;
    } });
    exports2.__version__ = "0.3.76";
  }
});

// node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/utils/env.cjs
var require_env2 = __commonJS({
  "node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/utils/env.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEnv = exports2.isNode = exports2.isDeno = exports2.isJsDom = exports2.isWebWorker = exports2.isBrowser = void 0;
    exports2.getRuntimeEnvironment = getRuntimeEnvironment;
    exports2.getLangSmithEnvVarsMetadata = getLangSmithEnvVarsMetadata;
    exports2.getLangSmithEnvironmentVariables = getLangSmithEnvironmentVariables;
    exports2.getEnvironmentVariable = getEnvironmentVariable;
    exports2.getLangSmithEnvironmentVariable = getLangSmithEnvironmentVariable;
    exports2.setEnvironmentVariable = setEnvironmentVariable;
    exports2.getShas = getShas;
    exports2.getOtelEnabled = getOtelEnabled;
    var index_js_1 = require_dist();
    var globalEnv;
    var isBrowser = () => typeof window !== "undefined" && typeof window.document !== "undefined";
    exports2.isBrowser = isBrowser;
    var isWebWorker = () => typeof globalThis === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope";
    exports2.isWebWorker = isWebWorker;
    var isJsDom = () => typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && navigator.userAgent.includes("jsdom");
    exports2.isJsDom = isJsDom;
    var isDeno = () => typeof Deno !== "undefined";
    exports2.isDeno = isDeno;
    var isNode = () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined" && !(0, exports2.isDeno)();
    exports2.isNode = isNode;
    var getEnv = () => {
      if (globalEnv) {
        return globalEnv;
      }
      if (typeof Bun !== "undefined") {
        globalEnv = "bun";
      } else if ((0, exports2.isBrowser)()) {
        globalEnv = "browser";
      } else if ((0, exports2.isNode)()) {
        globalEnv = "node";
      } else if ((0, exports2.isWebWorker)()) {
        globalEnv = "webworker";
      } else if ((0, exports2.isJsDom)()) {
        globalEnv = "jsdom";
      } else if ((0, exports2.isDeno)()) {
        globalEnv = "deno";
      } else {
        globalEnv = "other";
      }
      return globalEnv;
    };
    exports2.getEnv = getEnv;
    var runtimeEnvironment;
    function getRuntimeEnvironment() {
      if (runtimeEnvironment === void 0) {
        const env = (0, exports2.getEnv)();
        const releaseEnv = getShas();
        runtimeEnvironment = {
          library: "langsmith",
          runtime: env,
          sdk: "langsmith-js",
          sdk_version: index_js_1.__version__,
          ...releaseEnv
        };
      }
      return runtimeEnvironment;
    }
    function getLangSmithEnvVarsMetadata() {
      const allEnvVars = getLangSmithEnvironmentVariables();
      const envVars = {};
      const excluded = [
        "LANGCHAIN_API_KEY",
        "LANGCHAIN_ENDPOINT",
        "LANGCHAIN_TRACING_V2",
        "LANGCHAIN_PROJECT",
        "LANGCHAIN_SESSION",
        "LANGSMITH_API_KEY",
        "LANGSMITH_ENDPOINT",
        "LANGSMITH_TRACING_V2",
        "LANGSMITH_PROJECT",
        "LANGSMITH_SESSION"
      ];
      for (const [key, value] of Object.entries(allEnvVars)) {
        if (typeof value === "string" && !excluded.includes(key) && !key.toLowerCase().includes("key") && !key.toLowerCase().includes("secret") && !key.toLowerCase().includes("token")) {
          if (key === "LANGCHAIN_REVISION_ID") {
            envVars["revision_id"] = value;
          } else {
            envVars[key] = value;
          }
        }
      }
      return envVars;
    }
    function getLangSmithEnvironmentVariables() {
      const envVars = {};
      try {
        if (typeof process !== "undefined" && process.env) {
          for (const [key, value] of Object.entries(process.env)) {
            if ((key.startsWith("LANGCHAIN_") || key.startsWith("LANGSMITH_")) && value != null) {
              if ((key.toLowerCase().includes("key") || key.toLowerCase().includes("secret") || key.toLowerCase().includes("token")) && typeof value === "string") {
                envVars[key] = value.slice(0, 2) + "*".repeat(value.length - 4) + value.slice(-2);
              } else {
                envVars[key] = value;
              }
            }
          }
        }
      } catch (e) {
      }
      return envVars;
    }
    function getEnvironmentVariable(name) {
      try {
        return typeof process !== "undefined" ? (
          // eslint-disable-next-line no-process-env
          process.env?.[name]
        ) : void 0;
      } catch (e) {
        return void 0;
      }
    }
    function getLangSmithEnvironmentVariable(name) {
      return getEnvironmentVariable(`LANGSMITH_${name}`) || getEnvironmentVariable(`LANGCHAIN_${name}`);
    }
    function setEnvironmentVariable(name, value) {
      if (typeof process !== "undefined") {
        process.env[name] = value;
      }
    }
    var cachedCommitSHAs;
    function getShas() {
      if (cachedCommitSHAs !== void 0) {
        return cachedCommitSHAs;
      }
      const common_release_envs = [
        "VERCEL_GIT_COMMIT_SHA",
        "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA",
        "COMMIT_REF",
        "RENDER_GIT_COMMIT",
        "CI_COMMIT_SHA",
        "CIRCLE_SHA1",
        "CF_PAGES_COMMIT_SHA",
        "REACT_APP_GIT_SHA",
        "SOURCE_VERSION",
        "GITHUB_SHA",
        "TRAVIS_COMMIT",
        "GIT_COMMIT",
        "BUILD_VCS_NUMBER",
        "bamboo_planRepository_revision",
        "Build.SourceVersion",
        "BITBUCKET_COMMIT",
        "DRONE_COMMIT_SHA",
        "SEMAPHORE_GIT_SHA",
        "BUILDKITE_COMMIT"
      ];
      const shas = {};
      for (const env of common_release_envs) {
        const envVar = getEnvironmentVariable(env);
        if (envVar !== void 0) {
          shas[env] = envVar;
        }
      }
      cachedCommitSHAs = shas;
      return shas;
    }
    function getOtelEnabled() {
      return getEnvironmentVariable("OTEL_ENABLED") === "true" || getLangSmithEnvironmentVariable("OTEL_ENABLED") === "true";
    }
  }
});

// node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/singletons/otel.cjs
var require_otel = __commonJS({
  "node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/singletons/otel.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OTELProviderSingleton = void 0;
    exports2.getOTELTrace = getOTELTrace;
    exports2.getOTELContext = getOTELContext;
    exports2.setOTELInstances = setOTELInstances;
    exports2.setDefaultOTLPTracerComponents = setDefaultOTLPTracerComponents;
    exports2.getDefaultOTLPTracerComponents = getDefaultOTLPTracerComponents;
    var env_js_1 = require_env2();
    var MockTracer = class {
      constructor() {
        Object.defineProperty(this, "hasWarned", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: false
        });
      }
      startActiveSpan(_name, ...args) {
        if (!this.hasWarned && (0, env_js_1.getOtelEnabled)()) {
          console.warn('You have enabled OTEL export via the `OTEL_ENABLED` or `LANGSMITH_OTEL_ENABLED` environment variable, but have not initialized the required OTEL instances. Please add:\n```\nimport { initializeOTEL } from "langsmith/experimental/otel/setup";\ninitializeOTEL();\n```\nat the beginning of your code.');
          this.hasWarned = true;
        }
        let fn;
        if (args.length === 1 && typeof args[0] === "function") {
          fn = args[0];
        } else if (args.length === 2 && typeof args[1] === "function") {
          fn = args[1];
        } else if (args.length === 3 && typeof args[2] === "function") {
          fn = args[2];
        }
        if (typeof fn === "function") {
          return fn();
        }
        return void 0;
      }
    };
    var MockOTELTrace = class {
      constructor() {
        Object.defineProperty(this, "mockTracer", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: new MockTracer()
        });
      }
      getTracer(_name, _version) {
        return this.mockTracer;
      }
      getActiveSpan() {
        return void 0;
      }
      setSpan(context, _span) {
        return context;
      }
      getSpan(_context) {
        return void 0;
      }
      setSpanContext(context, _spanContext) {
        return context;
      }
      getTracerProvider() {
        return void 0;
      }
      setGlobalTracerProvider(_tracerProvider) {
        return false;
      }
    };
    var MockOTELContext = class {
      active() {
        return {};
      }
      with(_context, fn) {
        return fn();
      }
    };
    var OTEL_TRACE_KEY = Symbol.for("ls:otel_trace");
    var OTEL_CONTEXT_KEY = Symbol.for("ls:otel_context");
    var OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY = Symbol.for("ls:otel_get_default_otlp_tracer_provider");
    var mockOTELTrace = new MockOTELTrace();
    var mockOTELContext = new MockOTELContext();
    var OTELProvider = class {
      getTraceInstance() {
        return globalThis[OTEL_TRACE_KEY] ?? mockOTELTrace;
      }
      getContextInstance() {
        return globalThis[OTEL_CONTEXT_KEY] ?? mockOTELContext;
      }
      initializeGlobalInstances(otel) {
        if (globalThis[OTEL_TRACE_KEY] === void 0) {
          globalThis[OTEL_TRACE_KEY] = otel.trace;
        }
        if (globalThis[OTEL_CONTEXT_KEY] === void 0) {
          globalThis[OTEL_CONTEXT_KEY] = otel.context;
        }
      }
      setDefaultOTLPTracerComponents(components) {
        globalThis[OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY] = components;
      }
      getDefaultOTLPTracerComponents() {
        return globalThis[OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY] ?? void 0;
      }
    };
    exports2.OTELProviderSingleton = new OTELProvider();
    function getOTELTrace() {
      return exports2.OTELProviderSingleton.getTraceInstance();
    }
    function getOTELContext() {
      return exports2.OTELProviderSingleton.getContextInstance();
    }
    function setOTELInstances(otel) {
      exports2.OTELProviderSingleton.initializeGlobalInstances(otel);
    }
    function setDefaultOTLPTracerComponents(components) {
      exports2.OTELProviderSingleton.setDefaultOTLPTracerComponents(components);
    }
    function getDefaultOTLPTracerComponents() {
      return exports2.OTELProviderSingleton.getDefaultOTLPTracerComponents();
    }
  }
});

// node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/experimental/otel/translator.cjs
var require_translator = __commonJS({
  "node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/experimental/otel/translator.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LangSmithToOTELTranslator = void 0;
    var constants = __importStar(require_constants());
    var otel_js_1 = require_otel();
    var WELL_KNOWN_OPERATION_NAMES = {
      llm: "chat",
      tool: "execute_tool",
      retriever: "embeddings",
      embedding: "embeddings",
      prompt: "chat"
    };
    function getOperationName(runType) {
      return WELL_KNOWN_OPERATION_NAMES[runType] || runType;
    }
    var LangSmithToOTELTranslator = class {
      constructor() {
        Object.defineProperty(this, "spans", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: /* @__PURE__ */ new Map()
        });
      }
      exportBatch(operations, otelContextMap) {
        for (const op of operations) {
          try {
            if (!op.run) {
              continue;
            }
            if (op.operation === "post") {
              const span = this.createSpanForRun(op, op.run, otelContextMap.get(op.id));
              if (span && !op.run.end_time) {
                this.spans.set(op.id, span);
              }
            } else {
              this.updateSpanForRun(op, op.run);
            }
          } catch (e) {
            console.error(`Error processing operation ${op.id}:`, e);
          }
        }
      }
      createSpanForRun(op, runInfo, otelContext) {
        const activeSpan = otelContext && (0, otel_js_1.getOTELTrace)().getSpan(otelContext);
        if (!activeSpan) {
          return;
        }
        try {
          return this.finishSpanSetup(activeSpan, runInfo, op);
        } catch (e) {
          console.error(`Failed to create span for run ${op.id}:`, e);
          return void 0;
        }
      }
      finishSpanSetup(span, runInfo, op) {
        this.setSpanAttributes(span, runInfo, op);
        if (runInfo.error) {
          span.setStatus({ code: 2 });
          span.recordException(new Error(runInfo.error));
        } else {
          span.setStatus({ code: 1 });
        }
        if (runInfo.end_time) {
          span.end(new Date(runInfo.end_time));
        }
        return span;
      }
      updateSpanForRun(op, runInfo) {
        try {
          const span = this.spans.get(op.id);
          if (!span) {
            console.debug(`No span found for run ${op.id} during update`);
            return;
          }
          this.setSpanAttributes(span, runInfo, op);
          if (runInfo.error) {
            span.setStatus({ code: 2 });
            span.recordException(new Error(runInfo.error));
          } else {
            span.setStatus({ code: 1 });
          }
          const endTime = runInfo.end_time;
          if (endTime) {
            span.end(new Date(endTime));
            this.spans.delete(op.id);
          }
        } catch (e) {
          console.error(`Failed to update span for run ${op.id}:`, e);
        }
      }
      extractModelName(runInfo) {
        if (runInfo.extra?.metadata) {
          const metadata = runInfo.extra.metadata;
          if (metadata.ls_model_name) {
            return metadata.ls_model_name;
          }
          if (metadata.invocation_params) {
            const invocationParams = metadata.invocation_params;
            if (invocationParams.model) {
              return invocationParams.model;
            } else if (invocationParams.model_name) {
              return invocationParams.model_name;
            }
          }
        }
        return;
      }
      setSpanAttributes(span, runInfo, op) {
        if ("run_type" in runInfo && runInfo.run_type) {
          span.setAttribute(constants.LANGSMITH_RUN_TYPE, runInfo.run_type);
          const operationName = getOperationName(runInfo.run_type || "chain");
          span.setAttribute(constants.GEN_AI_OPERATION_NAME, operationName);
        }
        if ("name" in runInfo && runInfo.name) {
          span.setAttribute(constants.LANGSMITH_NAME, runInfo.name);
        }
        if ("session_id" in runInfo && runInfo.session_id) {
          span.setAttribute(constants.LANGSMITH_SESSION_ID, runInfo.session_id);
        }
        if ("session_name" in runInfo && runInfo.session_name) {
          span.setAttribute(constants.LANGSMITH_SESSION_NAME, runInfo.session_name);
        }
        this.setGenAiSystem(span, runInfo);
        const modelName = this.extractModelName(runInfo);
        if (modelName) {
          span.setAttribute(constants.GEN_AI_REQUEST_MODEL, modelName);
        }
        if ("prompt_tokens" in runInfo && typeof runInfo.prompt_tokens === "number") {
          span.setAttribute(constants.GEN_AI_USAGE_INPUT_TOKENS, runInfo.prompt_tokens);
        }
        if ("completion_tokens" in runInfo && typeof runInfo.completion_tokens === "number") {
          span.setAttribute(constants.GEN_AI_USAGE_OUTPUT_TOKENS, runInfo.completion_tokens);
        }
        if ("total_tokens" in runInfo && typeof runInfo.total_tokens === "number") {
          span.setAttribute(constants.GEN_AI_USAGE_TOTAL_TOKENS, runInfo.total_tokens);
        }
        this.setInvocationParameters(span, runInfo);
        const metadata = runInfo.extra?.metadata || {};
        for (const [key, value] of Object.entries(metadata)) {
          if (value !== null && value !== void 0) {
            span.setAttribute(`${constants.LANGSMITH_METADATA}.${key}`, String(value));
          }
        }
        const tags = runInfo.tags;
        if (tags && Array.isArray(tags)) {
          span.setAttribute(constants.LANGSMITH_TAGS, tags.join(", "));
        } else if (tags) {
          span.setAttribute(constants.LANGSMITH_TAGS, String(tags));
        }
        if ("serialized" in runInfo && typeof runInfo.serialized === "object") {
          const serialized = runInfo.serialized;
          if (serialized.name) {
            span.setAttribute(constants.GEN_AI_SERIALIZED_NAME, String(serialized.name));
          }
          if (serialized.signature) {
            span.setAttribute(constants.GEN_AI_SERIALIZED_SIGNATURE, String(serialized.signature));
          }
          if (serialized.doc) {
            span.setAttribute(constants.GEN_AI_SERIALIZED_DOC, String(serialized.doc));
          }
        }
        this.setIOAttributes(span, op);
      }
      setGenAiSystem(span, runInfo) {
        let system = "langchain";
        const modelName = this.extractModelName(runInfo);
        if (modelName) {
          const modelLower = modelName.toLowerCase();
          if (modelLower.includes("anthropic") || modelLower.startsWith("claude")) {
            system = "anthropic";
          } else if (modelLower.includes("bedrock")) {
            system = "aws.bedrock";
          } else if (modelLower.includes("azure") && modelLower.includes("openai")) {
            system = "az.ai.openai";
          } else if (modelLower.includes("azure") && modelLower.includes("inference")) {
            system = "az.ai.inference";
          } else if (modelLower.includes("cohere")) {
            system = "cohere";
          } else if (modelLower.includes("deepseek")) {
            system = "deepseek";
          } else if (modelLower.includes("gemini")) {
            system = "gemini";
          } else if (modelLower.includes("groq")) {
            system = "groq";
          } else if (modelLower.includes("watson") || modelLower.includes("ibm")) {
            system = "ibm.watsonx.ai";
          } else if (modelLower.includes("mistral")) {
            system = "mistral_ai";
          } else if (modelLower.includes("gpt") || modelLower.includes("openai")) {
            system = "openai";
          } else if (modelLower.includes("perplexity") || modelLower.includes("sonar")) {
            system = "perplexity";
          } else if (modelLower.includes("vertex")) {
            system = "vertex_ai";
          } else if (modelLower.includes("xai") || modelLower.includes("grok")) {
            system = "xai";
          }
        }
        span.setAttribute(constants.GEN_AI_SYSTEM, system);
      }
      setInvocationParameters(span, runInfo) {
        if (!runInfo.extra?.metadata?.invocation_params) {
          return;
        }
        const invocationParams = runInfo.extra.metadata.invocation_params;
        if (invocationParams.max_tokens !== void 0) {
          span.setAttribute(constants.GEN_AI_REQUEST_MAX_TOKENS, invocationParams.max_tokens);
        }
        if (invocationParams.temperature !== void 0) {
          span.setAttribute(constants.GEN_AI_REQUEST_TEMPERATURE, invocationParams.temperature);
        }
        if (invocationParams.top_p !== void 0) {
          span.setAttribute(constants.GEN_AI_REQUEST_TOP_P, invocationParams.top_p);
        }
        if (invocationParams.frequency_penalty !== void 0) {
          span.setAttribute(constants.GEN_AI_REQUEST_FREQUENCY_PENALTY, invocationParams.frequency_penalty);
        }
        if (invocationParams.presence_penalty !== void 0) {
          span.setAttribute(constants.GEN_AI_REQUEST_PRESENCE_PENALTY, invocationParams.presence_penalty);
        }
      }
      setIOAttributes(span, op) {
        if (op.run.inputs) {
          try {
            const inputs = op.run.inputs;
            if (typeof inputs === "object" && inputs !== null) {
              if (inputs.model && Array.isArray(inputs.messages)) {
                span.setAttribute(constants.GEN_AI_REQUEST_MODEL, inputs.model);
              }
              if (inputs.stream !== void 0) {
                span.setAttribute(constants.LANGSMITH_REQUEST_STREAMING, inputs.stream);
              }
              if (inputs.extra_headers) {
                span.setAttribute(constants.LANGSMITH_REQUEST_HEADERS, JSON.stringify(inputs.extra_headers));
              }
              if (inputs.extra_query) {
                span.setAttribute(constants.GEN_AI_REQUEST_EXTRA_QUERY, JSON.stringify(inputs.extra_query));
              }
              if (inputs.extra_body) {
                span.setAttribute(constants.GEN_AI_REQUEST_EXTRA_BODY, JSON.stringify(inputs.extra_body));
              }
            }
            span.setAttribute(constants.GENAI_PROMPT, JSON.stringify(inputs));
          } catch (e) {
            console.debug(`Failed to process inputs for run ${op.id}`, e);
          }
        }
        if (op.run.outputs) {
          try {
            const outputs = op.run.outputs;
            const tokenUsage = this.getUnifiedRunTokens(outputs);
            if (tokenUsage) {
              span.setAttribute(constants.GEN_AI_USAGE_INPUT_TOKENS, tokenUsage[0]);
              span.setAttribute(constants.GEN_AI_USAGE_OUTPUT_TOKENS, tokenUsage[1]);
              span.setAttribute(constants.GEN_AI_USAGE_TOTAL_TOKENS, tokenUsage[0] + tokenUsage[1]);
            }
            if (outputs && typeof outputs === "object") {
              if (outputs.model) {
                span.setAttribute(constants.GEN_AI_RESPONSE_MODEL, String(outputs.model));
              }
              if (outputs.id) {
                span.setAttribute(constants.GEN_AI_RESPONSE_ID, outputs.id);
              }
              if (outputs.choices && Array.isArray(outputs.choices)) {
                const finishReasons = outputs.choices.map((choice) => choice.finish_reason).filter((reason) => reason).map(String);
                if (finishReasons.length > 0) {
                  span.setAttribute(constants.GEN_AI_RESPONSE_FINISH_REASONS, finishReasons.join(", "));
                }
              }
              if (outputs.service_tier) {
                span.setAttribute(constants.GEN_AI_RESPONSE_SERVICE_TIER, outputs.service_tier);
              }
              if (outputs.system_fingerprint) {
                span.setAttribute(constants.GEN_AI_RESPONSE_SYSTEM_FINGERPRINT, outputs.system_fingerprint);
              }
              if (outputs.usage_metadata && typeof outputs.usage_metadata === "object") {
                const usageMetadata = outputs.usage_metadata;
                if (usageMetadata.input_token_details) {
                  span.setAttribute(constants.GEN_AI_USAGE_INPUT_TOKEN_DETAILS, JSON.stringify(usageMetadata.input_token_details));
                }
                if (usageMetadata.output_token_details) {
                  span.setAttribute(constants.GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS, JSON.stringify(usageMetadata.output_token_details));
                }
              }
            }
            span.setAttribute(constants.GENAI_COMPLETION, JSON.stringify(outputs));
          } catch (e) {
            console.debug(`Failed to process outputs for run ${op.id}`, e);
          }
        }
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      getUnifiedRunTokens(outputs) {
        if (!outputs) {
          return null;
        }
        let tokenUsage = this.extractUnifiedRunTokens(outputs.usage_metadata);
        if (tokenUsage) {
          return tokenUsage;
        }
        const keys = Object.keys(outputs);
        for (const key of keys) {
          const haystack = outputs[key];
          if (!haystack || typeof haystack !== "object") {
            continue;
          }
          tokenUsage = this.extractUnifiedRunTokens(haystack.usage_metadata);
          if (tokenUsage) {
            return tokenUsage;
          }
          if (haystack.lc === 1 && haystack.kwargs && typeof haystack.kwargs === "object") {
            tokenUsage = this.extractUnifiedRunTokens(haystack.kwargs.usage_metadata);
            if (tokenUsage) {
              return tokenUsage;
            }
          }
        }
        const generations = outputs.generations || [];
        if (!Array.isArray(generations)) {
          return null;
        }
        const flatGenerations = Array.isArray(generations[0]) ? generations.flat() : generations;
        for (const generation of flatGenerations) {
          if (typeof generation === "object" && generation.message && typeof generation.message === "object" && generation.message.kwargs && typeof generation.message.kwargs === "object") {
            tokenUsage = this.extractUnifiedRunTokens(generation.message.kwargs.usage_metadata);
            if (tokenUsage) {
              return tokenUsage;
            }
          }
        }
        return null;
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      extractUnifiedRunTokens(outputs) {
        if (!outputs || typeof outputs !== "object") {
          return null;
        }
        if (typeof outputs.input_tokens !== "number" || typeof outputs.output_tokens !== "number") {
          return null;
        }
        return [outputs.input_tokens, outputs.output_tokens];
      }
    };
    exports2.LangSmithToOTELTranslator = LangSmithToOTELTranslator;
  }
});

// node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js"(exports2, module2) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self2 = this;
      this._timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js"(exports2) {
    var RetryOperation = require_retry_operation();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports2.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js"(exports2, module2) {
    module2.exports = require_retry();
  }
});

// node_modules/.pnpm/p-retry@4.6.2/node_modules/p-retry/index.js
var require_p_retry = __commonJS({
  "node_modules/.pnpm/p-retry@4.6.2/node_modules/p-retry/index.js"(exports2, module2) {
    "use strict";
    var retry = require_retry2();
    var networkErrorMsgs = [
      "Failed to fetch",
      // Chrome
      "NetworkError when attempting to fetch resource.",
      // Firefox
      "The Internet connection appears to be offline.",
      // Safari
      "Network request failed"
      // `cross-fetch`
    ];
    var AbortError = class extends Error {
      constructor(message) {
        super();
        if (message instanceof Error) {
          this.originalError = message;
          ({ message } = message);
        } else {
          this.originalError = new Error(message);
          this.originalError.stack = this.stack;
        }
        this.name = "AbortError";
        this.message = message;
      }
    };
    var decorateErrorWithCounts = (error, attemptNumber, options) => {
      const retriesLeft = options.retries - (attemptNumber - 1);
      error.attemptNumber = attemptNumber;
      error.retriesLeft = retriesLeft;
      return error;
    };
    var isNetworkError = (errorMessage) => networkErrorMsgs.includes(errorMessage);
    var pRetry = (input, options) => new Promise((resolve, reject) => {
      options = {
        onFailedAttempt: () => {
        },
        retries: 10,
        ...options
      };
      const operation = retry.operation(options);
      operation.attempt(async (attemptNumber) => {
        try {
          resolve(await input(attemptNumber));
        } catch (error) {
          if (!(error instanceof Error)) {
            reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
            return;
          }
          if (error instanceof AbortError) {
            operation.stop();
            reject(error.originalError);
          } else if (error instanceof TypeError && !isNetworkError(error.message)) {
            operation.stop();
            reject(error);
          } else {
            decorateErrorWithCounts(error, attemptNumber, options);
            try {
              await options.onFailedAttempt(error);
            } catch (error2) {
              reject(error2);
              return;
            }
            if (!operation.retry(error)) {
              reject(operation.mainError());
            }
          }
        }
      });
    });
    module2.exports = pRetry;
    module2.exports.default = pRetry;
    module2.exports.AbortError = AbortError;
  }
});

// node_modules/.pnpm/eventemitter3@4.0.7/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/.pnpm/eventemitter3@4.0.7/node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter;
    }
  }
});

// node_modules/.pnpm/p-finally@1.0.0/node_modules/p-finally/index.js
var require_p_finally = __commonJS({
  "node_modules/.pnpm/p-finally@1.0.0/node_modules/p-finally/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (promise, onFinally) => {
      onFinally = onFinally || (() => {
      });
      return promise.then(
        (val) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => val),
        (err) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => {
          throw err;
        })
      );
    };
  }
});

// node_modules/.pnpm/p-timeout@3.2.0/node_modules/p-timeout/index.js
var require_p_timeout = __commonJS({
  "node_modules/.pnpm/p-timeout@3.2.0/node_modules/p-timeout/index.js"(exports2, module2) {
    "use strict";
    var pFinally = require_p_finally();
    var TimeoutError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "TimeoutError";
      }
    };
    var pTimeout = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {
      if (typeof milliseconds !== "number" || milliseconds < 0) {
        throw new TypeError("Expected `milliseconds` to be a positive number");
      }
      if (milliseconds === Infinity) {
        resolve(promise);
        return;
      }
      const timer = setTimeout(() => {
        if (typeof fallback === "function") {
          try {
            resolve(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
        const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        reject(timeoutError);
      }, milliseconds);
      pFinally(
        // eslint-disable-next-line promise/prefer-await-to-then
        promise.then(resolve, reject),
        () => {
          clearTimeout(timer);
        }
      );
    });
    module2.exports = pTimeout;
    module2.exports.default = pTimeout;
    module2.exports.TimeoutError = TimeoutError;
  }
});

// node_modules/.pnpm/p-queue@6.6.2/node_modules/p-queue/dist/lower-bound.js
var require_lower_bound = __commonJS({
  "node_modules/.pnpm/p-queue@6.6.2/node_modules/p-queue/dist/lower-bound.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function lowerBound(array, value, comparator) {
      let first = 0;
      let count = array.length;
      while (count > 0) {
        const step = count / 2 | 0;
        let it = first + step;
        if (comparator(array[it], value) <= 0) {
          first = ++it;
          count -= step + 1;
        } else {
          count = step;
        }
      }
      return first;
    }
    exports2.default = lowerBound;
  }
});

// node_modules/.pnpm/p-queue@6.6.2/node_modules/p-queue/dist/priority-queue.js
var require_priority_queue = __commonJS({
  "node_modules/.pnpm/p-queue@6.6.2/node_modules/p-queue/dist/priority-queue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var lower_bound_1 = require_lower_bound();
    var PriorityQueue = class {
      constructor() {
        this._queue = [];
      }
      enqueue(run, options) {
        options = Object.assign({ priority: 0 }, options);
        const element = {
          priority: options.priority,
          run
        };
        if (this.size && this._queue[this.size - 1].priority >= options.priority) {
          this._queue.push(element);
          return;
        }
        const index = lower_bound_1.default(this._queue, element, (a, b) => b.priority - a.priority);
        this._queue.splice(index, 0, element);
      }
      dequeue() {
        const item = this._queue.shift();
        return item === null || item === void 0 ? void 0 : item.run;
      }
      filter(options) {
        return this._queue.filter((element) => element.priority === options.priority).map((element) => element.run);
      }
      get size() {
        return this._queue.length;
      }
    };
    exports2.default = PriorityQueue;
  }
});

// node_modules/.pnpm/p-queue@6.6.2/node_modules/p-queue/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/.pnpm/p-queue@6.6.2/node_modules/p-queue/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var EventEmitter = require_eventemitter3();
    var p_timeout_1 = require_p_timeout();
    var priority_queue_1 = require_priority_queue();
    var empty = () => {
    };
    var timeoutError = new p_timeout_1.TimeoutError();
    var PQueue = class extends EventEmitter {
      constructor(options) {
        var _a, _b, _c, _d;
        super();
        this._intervalCount = 0;
        this._intervalEnd = 0;
        this._pendingCount = 0;
        this._resolveEmpty = empty;
        this._resolveIdle = empty;
        options = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options);
        if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
          throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options.intervalCap})`);
        }
        if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
          throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
        }
        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
        this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;
        this._intervalCap = options.intervalCap;
        this._interval = options.interval;
        this._queue = new options.queueClass();
        this._queueClass = options.queueClass;
        this.concurrency = options.concurrency;
        this._timeout = options.timeout;
        this._throwOnTimeout = options.throwOnTimeout === true;
        this._isPaused = options.autoStart === false;
      }
      get _doesIntervalAllowAnother() {
        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
      }
      get _doesConcurrentAllowAnother() {
        return this._pendingCount < this._concurrency;
      }
      _next() {
        this._pendingCount--;
        this._tryToStartAnother();
        this.emit("next");
      }
      _resolvePromises() {
        this._resolveEmpty();
        this._resolveEmpty = empty;
        if (this._pendingCount === 0) {
          this._resolveIdle();
          this._resolveIdle = empty;
          this.emit("idle");
        }
      }
      _onResumeInterval() {
        this._onInterval();
        this._initializeIntervalIfNeeded();
        this._timeoutId = void 0;
      }
      _isIntervalPaused() {
        const now = Date.now();
        if (this._intervalId === void 0) {
          const delay = this._intervalEnd - now;
          if (delay < 0) {
            this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
          } else {
            if (this._timeoutId === void 0) {
              this._timeoutId = setTimeout(() => {
                this._onResumeInterval();
              }, delay);
            }
            return true;
          }
        }
        return false;
      }
      _tryToStartAnother() {
        if (this._queue.size === 0) {
          if (this._intervalId) {
            clearInterval(this._intervalId);
          }
          this._intervalId = void 0;
          this._resolvePromises();
          return false;
        }
        if (!this._isPaused) {
          const canInitializeInterval = !this._isIntervalPaused();
          if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
            const job = this._queue.dequeue();
            if (!job) {
              return false;
            }
            this.emit("active");
            job();
            if (canInitializeInterval) {
              this._initializeIntervalIfNeeded();
            }
            return true;
          }
        }
        return false;
      }
      _initializeIntervalIfNeeded() {
        if (this._isIntervalIgnored || this._intervalId !== void 0) {
          return;
        }
        this._intervalId = setInterval(() => {
          this._onInterval();
        }, this._interval);
        this._intervalEnd = Date.now() + this._interval;
      }
      _onInterval() {
        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
          clearInterval(this._intervalId);
          this._intervalId = void 0;
        }
        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        this._processQueue();
      }
      /**
      Executes all queued functions until it reaches the limit.
      */
      _processQueue() {
        while (this._tryToStartAnother()) {
        }
      }
      get concurrency() {
        return this._concurrency;
      }
      set concurrency(newConcurrency) {
        if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
          throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
        }
        this._concurrency = newConcurrency;
        this._processQueue();
      }
      /**
      Adds a sync or async task to the queue. Always returns a promise.
      */
      async add(fn, options = {}) {
        return new Promise((resolve, reject) => {
          const run = async () => {
            this._pendingCount++;
            this._intervalCount++;
            try {
              const operation = this._timeout === void 0 && options.timeout === void 0 ? fn() : p_timeout_1.default(Promise.resolve(fn()), options.timeout === void 0 ? this._timeout : options.timeout, () => {
                if (options.throwOnTimeout === void 0 ? this._throwOnTimeout : options.throwOnTimeout) {
                  reject(timeoutError);
                }
                return void 0;
              });
              resolve(await operation);
            } catch (error) {
              reject(error);
            }
            this._next();
          };
          this._queue.enqueue(run, options);
          this._tryToStartAnother();
          this.emit("add");
        });
      }
      /**
          Same as `.add()`, but accepts an array of sync or async functions.
      
          @returns A promise that resolves when all functions are resolved.
          */
      async addAll(functions, options) {
        return Promise.all(functions.map(async (function_) => this.add(function_, options)));
      }
      /**
      Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
      */
      start() {
        if (!this._isPaused) {
          return this;
        }
        this._isPaused = false;
        this._processQueue();
        return this;
      }
      /**
      Put queue execution on hold.
      */
      pause() {
        this._isPaused = true;
      }
      /**
      Clear the queue.
      */
      clear() {
        this._queue = new this._queueClass();
      }
      /**
          Can be called multiple times. Useful if you for example add additional items at a later time.
      
          @returns A promise that settles when the queue becomes empty.
          */
      async onEmpty() {
        if (this._queue.size === 0) {
          return;
        }
        return new Promise((resolve) => {
          const existingResolve = this._resolveEmpty;
          this._resolveEmpty = () => {
            existingResolve();
            resolve();
          };
        });
      }
      /**
          The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
      
          @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
          */
      async onIdle() {
        if (this._pendingCount === 0 && this._queue.size === 0) {
          return;
        }
        return new Promise((resolve) => {
          const existingResolve = this._resolveIdle;
          this._resolveIdle = () => {
            existingResolve();
            resolve();
          };
        });
      }
      /**
      Size of the queue.
      */
      get size() {
        return this._queue.size;
      }
      /**
          Size of the queue, filtered by the given options.
      
          For example, this can be used to find the number of items remaining in the queue with a specific priority level.
          */
      sizeBy(options) {
        return this._queue.filter(options).length;
      }
      /**
      Number of pending promises.
      */
      get pending() {
        return this._pendingCount;
      }
      /**
      Whether the queue is currently paused.
      */
      get isPaused() {
        return this._isPaused;
      }
      get timeout() {
        return this._timeout;
      }
      /**
      Set the timeout for future operations.
      */
      set timeout(milliseconds) {
        this._timeout = milliseconds;
      }
    };
    exports2.default = PQueue;
  }
});

// node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/utils/async_caller.cjs
var require_async_caller = __commonJS({
  "node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/utils/async_caller.cjs"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncCaller = void 0;
    var p_retry_1 = __importDefault(require_p_retry());
    var p_queue_1 = __importDefault(require_dist2());
    var STATUS_RETRYABLE = [
      429,
      // Too Many Requests
      500,
      // Internal Server Error
      502,
      // Bad Gateway
      503,
      // Service Unavailable
      504
      // Gateway Timeout
    ];
    var AsyncCaller = class {
      constructor(params) {
        Object.defineProperty(this, "maxConcurrency", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "maxRetries", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "queue", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "onFailedResponseHook", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.maxConcurrency = params.maxConcurrency ?? Infinity;
        this.maxRetries = params.maxRetries ?? 6;
        if ("default" in p_queue_1.default) {
          this.queue = new p_queue_1.default.default({
            concurrency: this.maxConcurrency
          });
        } else {
          this.queue = new p_queue_1.default({ concurrency: this.maxConcurrency });
        }
        this.onFailedResponseHook = params?.onFailedResponseHook;
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      call(callable, ...args) {
        const onFailedResponseHook = this.onFailedResponseHook;
        return this.queue.add(() => (0, p_retry_1.default)(() => callable(...args).catch((error) => {
          if (error instanceof Error) {
            throw error;
          } else {
            throw new Error(error);
          }
        }), {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          async onFailedAttempt(error) {
            if (error.message.startsWith("Cancel") || error.message.startsWith("TimeoutError") || error.name === "TimeoutError" || error.message.startsWith("AbortError")) {
              throw error;
            }
            if (error?.code === "ECONNABORTED") {
              throw error;
            }
            const response = error?.response;
            if (onFailedResponseHook) {
              const handled = await onFailedResponseHook(response);
              if (handled) {
                return;
              }
            }
            const status = response?.status ?? error?.status;
            if (status) {
              if (!STATUS_RETRYABLE.includes(+status)) {
                throw error;
              }
            }
          },
          retries: this.maxRetries,
          randomize: true
        }), { throwOnTimeout: true });
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      callWithOptions(options, callable, ...args) {
        if (options.signal) {
          return Promise.race([
            this.call(callable, ...args),
            new Promise((_, reject) => {
              options.signal?.addEventListener("abort", () => {
                reject(new Error("AbortError"));
              });
            })
          ]);
        }
        return this.call(callable, ...args);
      }
    };
    exports2.AsyncCaller = AsyncCaller;
  }
});

// node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/utils/messages.cjs
var require_messages = __commonJS({
  "node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/utils/messages.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isLangChainMessage = isLangChainMessage;
    exports2.convertLangChainMessageToExample = convertLangChainMessageToExample;
    function isLangChainMessage(message) {
      return typeof message?._getType === "function";
    }
    function convertLangChainMessageToExample(message) {
      const converted = {
        type: message._getType(),
        data: { content: message.content }
      };
      if (message?.additional_kwargs && Object.keys(message.additional_kwargs).length > 0) {
        converted.data.additional_kwargs = { ...message.additional_kwargs };
      }
      return converted;
    }
  }
});

// node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/utils/_uuid.cjs
var require_uuid = __commonJS({
  "node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/utils/_uuid.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertUuid = assertUuid;
    var UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function assertUuid(str, which) {
      if (!UUID_REGEX.test(str)) {
        const msg = which !== void 0 ? `Invalid UUID for ${which}: ${str}` : `Invalid UUID: ${str}`;
        throw new Error(msg);
      }
      return str;
    }
  }
});

// node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/utils/warn.cjs
var require_warn = __commonJS({
  "node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/utils/warn.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.warnOnce = warnOnce;
    var warnedMessages = {};
    function warnOnce(message) {
      if (!warnedMessages[message]) {
        console.warn(message);
        warnedMessages[message] = true;
      }
    }
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/constants.js
var require_constants2 = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/constants.js"(exports2, module2) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/debug.js"(exports2, module2) {
    "use strict";
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/re.js"(exports2, module2) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants2();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var safeSrc = exports2.safeSrc = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/parse-options.js"(exports2, module2) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/identifiers.js"(exports2, module2) {
    "use strict";
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      if (typeof a === "number" && typeof b === "number") {
        return a === b ? 0 : a < b ? -1 : 1;
      }
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/semver.js"(exports2, module2) {
    "use strict";
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants2();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version2, options) {
        options = parseOptions(options);
        if (version2 instanceof _SemVer) {
          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version2, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.major < other.major) {
          return -1;
        }
        if (this.major > other.major) {
          return 1;
        }
        if (this.minor < other.minor) {
          return -1;
        }
        if (this.minor > other.minor) {
          return 1;
        }
        if (this.patch < other.patch) {
          return -1;
        }
        if (this.patch > other.patch) {
          return 1;
        }
        return 0;
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/parse.js
var require_parse3 = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/parse.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse2 = (version2, options, throwErrors = false) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse2;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/valid.js"(exports2, module2) {
    "use strict";
    var parse2 = require_parse3();
    var valid = (version2, options) => {
      const v = parse2(version2, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/clean.js"(exports2, module2) {
    "use strict";
    var parse2 = require_parse3();
    var clean = (version2, options) => {
      const s = parse2(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/inc.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var inc = (version2, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version2 instanceof SemVer ? version2.version : version2,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/diff.js"(exports2, module2) {
    "use strict";
    var parse2 = require_parse3();
    var diff = (version1, version2) => {
      const v12 = parse2(version1, null, true);
      const v2 = parse2(version2, null, true);
      const comparison = v12.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v12 : v2;
      const lowVersion = v1Higher ? v2 : v12;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v12.major !== v2.major) {
        return prefix + "major";
      }
      if (v12.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v12.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/major.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/minor.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/patch.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/prerelease.js"(exports2, module2) {
    "use strict";
    var parse2 = require_parse3();
    var prerelease = (version2, options) => {
      const parsed = parse2(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/rcompare.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/compare-build.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/sort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/rsort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/gt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/lt.js
var require_lt2 = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/lt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/eq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/neq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/gte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/lte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/cmp.js"(exports2, module2) {
    "use strict";
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt2();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/coerce.js
var require_coerce2 = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/coerce.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse2 = require_parse3();
    var { safeRe: re, t } = require_re();
    var coerce = (version2, options) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version2.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse2(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/internal/lrucache.js"(exports2, module2) {
    "use strict";
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/range.js"(exports2, module2) {
    "use strict";
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants2();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      comp = comp.replace(re[t.BUILD], "");
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version2, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/classes/comparator.js"(exports2, module2) {
    "use strict";
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/functions/satisfies.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var satisfies = (version2, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    };
    module2.exports = satisfies;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/min-version.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/valid.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/outside.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt2();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version2, range, hilo, options) => {
      version2 = new SemVer(version2, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/gtr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var gtr = (version2, range, options) => outside(version2, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/ltr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var ltr = (version2, range, options) => outside(version2, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/intersects.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/simplify.js"(exports2, module2) {
    "use strict";
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version2 of v) {
        const included = satisfies(version2, range, options);
        if (included) {
          prev = version2;
          if (!first) {
            first = version2;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/ranges/subset.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/.pnpm/semver@7.7.3/node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/.pnpm/semver@7.7.3/node_modules/semver/index.js"(exports2, module2) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants2();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse2 = require_parse3();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt2();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce2();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse: parse2,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/utils/prompts.cjs
var require_prompts = __commonJS({
  "node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/utils/prompts.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isVersionGreaterOrEqual = isVersionGreaterOrEqual;
    exports2.parsePromptIdentifier = parsePromptIdentifier;
    var semver_1 = require_semver2();
    function isVersionGreaterOrEqual(current_version, target_version) {
      const current = (0, semver_1.parse)(current_version);
      const target = (0, semver_1.parse)(target_version);
      if (!current || !target) {
        throw new Error("Invalid version format.");
      }
      return current.compare(target) >= 0;
    }
    function parsePromptIdentifier(identifier) {
      if (!identifier || identifier.split("/").length > 2 || identifier.startsWith("/") || identifier.endsWith("/") || identifier.split(":").length > 2) {
        throw new Error(`Invalid identifier format: ${identifier}`);
      }
      const [ownerNamePart, commitPart] = identifier.split(":");
      const commit = commitPart || "latest";
      if (ownerNamePart.includes("/")) {
        const [owner, name] = ownerNamePart.split("/", 2);
        if (!owner || !name) {
          throw new Error(`Invalid identifier format: ${identifier}`);
        }
        return [owner, name, commit];
      } else {
        if (!ownerNamePart) {
          throw new Error(`Invalid identifier format: ${identifier}`);
        }
        return ["-", ownerNamePart, commit];
      }
    }
  }
});

// node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/utils/error.cjs
var require_error = __commonJS({
  "node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/utils/error.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConflictingEndpointsError = exports2.LangSmithConflictError = void 0;
    exports2.printErrorStackTrace = printErrorStackTrace;
    exports2.raiseForStatus = raiseForStatus;
    exports2.isConflictingEndpointsError = isConflictingEndpointsError;
    function getErrorStackTrace(e) {
      if (typeof e !== "object" || e == null)
        return void 0;
      if (!("stack" in e) || typeof e.stack !== "string")
        return void 0;
      let stack = e.stack;
      const prevLine = `${e}`;
      if (stack.startsWith(prevLine)) {
        stack = stack.slice(prevLine.length);
      }
      if (stack.startsWith("\n")) {
        stack = stack.slice(1);
      }
      return stack;
    }
    function printErrorStackTrace(e) {
      const stack = getErrorStackTrace(e);
      if (stack == null)
        return;
      console.error(stack);
    }
    var LangSmithConflictError = class extends Error {
      constructor(message) {
        super(message);
        Object.defineProperty(this, "status", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.name = "LangSmithConflictError";
        this.status = 409;
      }
    };
    exports2.LangSmithConflictError = LangSmithConflictError;
    async function raiseForStatus(response, context, consumeOnSuccess) {
      let errorBody;
      if (response.ok) {
        if (consumeOnSuccess) {
          errorBody = await response.text();
        }
        return;
      }
      if (response.status === 403) {
        try {
          const errorData = await response.json();
          const errorCode = errorData?.error;
          if (errorCode === "org_scoped_key_requires_workspace") {
            errorBody = "This API key is org-scoped and requires workspace specification. Please provide 'workspaceId' parameter, or set LANGSMITH_WORKSPACE_ID environment variable.";
          }
        } catch (e) {
          const errorWithStatus = new Error(`${response.status} ${response.statusText}`);
          errorWithStatus.status = response?.status;
          throw errorWithStatus;
        }
      }
      if (errorBody === void 0) {
        try {
          errorBody = await response.text();
        } catch (e) {
          errorBody = "";
        }
      }
      const fullMessage = `Failed to ${context}. Received status [${response.status}]: ${response.statusText}. Message: ${errorBody}`;
      if (response.status === 409) {
        throw new LangSmithConflictError(fullMessage);
      }
      const err = new Error(fullMessage);
      err.status = response.status;
      throw err;
    }
    var ERR_CONFLICTING_ENDPOINTS = "ERR_CONFLICTING_ENDPOINTS";
    var ConflictingEndpointsError = class extends Error {
      constructor() {
        super("You cannot provide both LANGSMITH_ENDPOINT / LANGCHAIN_ENDPOINT and LANGSMITH_RUNS_ENDPOINTS.");
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: ERR_CONFLICTING_ENDPOINTS
        });
        this.name = "ConflictingEndpointsError";
      }
    };
    exports2.ConflictingEndpointsError = ConflictingEndpointsError;
    function isConflictingEndpointsError(err) {
      return typeof err === "object" && err !== null && err.code === ERR_CONFLICTING_ENDPOINTS;
    }
  }
});

// node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/utils/fast-safe-stringify/index.cjs
var require_fast_safe_stringify = __commonJS({
  "node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/utils/fast-safe-stringify/index.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serialize = serialize;
    var env_js_1 = require_env2();
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = { result: "[Circular]" };
    var arr = [];
    var replacerStack = [];
    var encoder = new TextEncoder();
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function encodeString(str) {
      return encoder.encode(str);
    }
    function serializeWellKnownTypes(val) {
      if (val && typeof val === "object" && val !== null) {
        if (val instanceof Map) {
          return Object.fromEntries(val);
        } else if (val instanceof Set) {
          return Array.from(val);
        } else if (val instanceof Date) {
          return val.toISOString();
        } else if (val instanceof RegExp) {
          return val.toString();
        } else if (val instanceof Error) {
          return {
            name: val.name,
            message: val.message
          };
        }
      } else if (typeof val === "bigint") {
        return val.toString();
      }
      return val;
    }
    function createDefaultReplacer(userReplacer) {
      return function(key, val) {
        if (userReplacer) {
          const userResult = userReplacer.call(this, key, val);
          if (userResult !== void 0) {
            return userResult;
          }
        }
        return serializeWellKnownTypes(val);
      };
    }
    function serialize(obj, errorContext, replacer, spacer, options) {
      try {
        const str = JSON.stringify(obj, createDefaultReplacer(replacer), spacer);
        return encodeString(str);
      } catch (e) {
        if (!e.message?.includes("Converting circular structure to JSON")) {
          console.warn(`[WARNING]: LangSmith received unserializable value.${errorContext ? `
Context: ${errorContext}` : ""}`);
          return encodeString("[Unserializable]");
        }
        (0, env_js_1.getLangSmithEnvironmentVariable)("SUPPRESS_CIRCULAR_JSON_WARNINGS") !== "true" && console.warn(`[WARNING]: LangSmith received circular JSON. This will decrease tracer performance. ${errorContext ? `
Context: ${errorContext}` : ""}`);
        if (typeof options === "undefined") {
          options = defaultOptions();
        }
        decirc(obj, "", 0, [], void 0, 0, options);
        let res;
        try {
          if (replacerStack.length === 0) {
            res = JSON.stringify(obj, replacer, spacer);
          } else {
            res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
          }
        } catch (_) {
          return encodeString("[unable to serialize, circular reference is too complex to analyze]");
        } finally {
          while (arr.length !== 0) {
            const part = arr.pop();
            if (part.length === 4) {
              Object.defineProperty(part[0], part[1], part[3]);
            } else {
              part[0][part[1]] = part[2];
            }
          }
        }
        return encodeString(res);
      }
    }
    function setReplace(replace, val, k, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k, { value: replace });
          arr.push([parent, k, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k, replace]);
        }
      } else {
        parent[k] = replace;
        arr.push([parent, k, val]);
      }
    }
    function decirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            decirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          val = serializeWellKnownTypes(val);
          var keys = Object.keys(val);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            decirc(val[key], key, i, stack, val, depth, options);
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
        return v;
      };
      return function(key, val) {
        if (replacerStack.length > 0) {
          for (var i = 0; i < replacerStack.length; i++) {
            var part = replacerStack[i];
            if (part[1] === key && part[0] === val) {
              val = part[2];
              replacerStack.splice(i, 1);
              break;
            }
          }
        }
        return replacer.call(this, key, val);
      };
    }
  }
});

// node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/client.cjs
var require_client = __commonJS({
  "node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/client.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Client = exports2.DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES = exports2.AutoBatchQueue = void 0;
    exports2.mergeRuntimeEnvIntoRun = mergeRuntimeEnvIntoRun;
    var uuid = __importStar((init_esm_node(), __toCommonJS(esm_node_exports)));
    var translator_js_1 = require_translator();
    var otel_js_1 = require_otel();
    var async_caller_js_1 = require_async_caller();
    var messages_js_1 = require_messages();
    var env_js_1 = require_env2();
    var index_js_1 = require_dist();
    var _uuid_js_1 = require_uuid();
    var warn_js_1 = require_warn();
    var prompts_js_1 = require_prompts();
    var error_js_1 = require_error();
    var fetch_js_1 = require_fetch();
    var index_js_2 = require_fast_safe_stringify();
    function mergeRuntimeEnvIntoRun(run, cachedEnvVars) {
      const runtimeEnv = (0, env_js_1.getRuntimeEnvironment)();
      const envVars = cachedEnvVars ?? (0, env_js_1.getLangSmithEnvVarsMetadata)();
      const extra = run.extra ?? {};
      const metadata = extra.metadata;
      run.extra = {
        ...extra,
        runtime: {
          ...runtimeEnv,
          ...extra?.runtime
        },
        metadata: {
          ...envVars,
          ...envVars.revision_id || "revision_id" in run && run.revision_id ? {
            revision_id: ("revision_id" in run ? run.revision_id : void 0) ?? envVars.revision_id
          } : {},
          ...metadata
        }
      };
      return run;
    }
    var getTracingSamplingRate = (configRate) => {
      const samplingRateStr = configRate?.toString() ?? (0, env_js_1.getLangSmithEnvironmentVariable)("TRACING_SAMPLING_RATE");
      if (samplingRateStr === void 0) {
        return void 0;
      }
      const samplingRate = parseFloat(samplingRateStr);
      if (samplingRate < 0 || samplingRate > 1) {
        throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);
      }
      return samplingRate;
    };
    var isLocalhost = (url) => {
      const strippedUrl = url.replace("http://", "").replace("https://", "");
      const hostname = strippedUrl.split("/")[0].split(":")[0];
      return hostname === "localhost" || hostname === "127.0.0.1" || hostname === "::1";
    };
    async function toArray(iterable) {
      const result = [];
      for await (const item of iterable) {
        result.push(item);
      }
      return result;
    }
    function trimQuotes(str) {
      if (str === void 0) {
        return void 0;
      }
      return str.trim().replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1");
    }
    var handle429 = async (response) => {
      if (response?.status === 429) {
        const retryAfter = parseInt(response.headers.get("retry-after") ?? "10", 10) * 1e3;
        if (retryAfter > 0) {
          await new Promise((resolve) => setTimeout(resolve, retryAfter));
          return true;
        }
      }
      return false;
    };
    function _formatFeedbackScore(score) {
      if (typeof score === "number") {
        return Number(score.toFixed(4));
      }
      return score;
    }
    var AutoBatchQueue = class {
      constructor() {
        Object.defineProperty(this, "items", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: []
        });
        Object.defineProperty(this, "sizeBytes", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: 0
        });
      }
      peek() {
        return this.items[0];
      }
      push(item) {
        let itemPromiseResolve;
        const itemPromise = new Promise((resolve) => {
          itemPromiseResolve = resolve;
        });
        const size = (0, index_js_2.serialize)(item.item, `Serializing run with id: ${item.item.id}`).length;
        this.items.push({
          action: item.action,
          payload: item.item,
          otelContext: item.otelContext,
          apiKey: item.apiKey,
          apiUrl: item.apiUrl,
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          itemPromiseResolve,
          itemPromise,
          size
        });
        this.sizeBytes += size;
        return itemPromise;
      }
      pop({ upToSizeBytes, upToSize }) {
        if (upToSizeBytes < 1) {
          throw new Error("Number of bytes to pop off may not be less than 1.");
        }
        const popped = [];
        let poppedSizeBytes = 0;
        while (poppedSizeBytes + (this.peek()?.size ?? 0) < upToSizeBytes && this.items.length > 0 && popped.length < upToSize) {
          const item = this.items.shift();
          if (item) {
            popped.push(item);
            poppedSizeBytes += item.size;
            this.sizeBytes -= item.size;
          }
        }
        if (popped.length === 0 && this.items.length > 0) {
          const item = this.items.shift();
          popped.push(item);
          poppedSizeBytes += item.size;
          this.sizeBytes -= item.size;
        }
        return [
          popped.map((it) => ({
            action: it.action,
            item: it.payload,
            otelContext: it.otelContext,
            apiKey: it.apiKey,
            apiUrl: it.apiUrl
          })),
          () => popped.forEach((it) => it.itemPromiseResolve())
        ];
      }
    };
    exports2.AutoBatchQueue = AutoBatchQueue;
    exports2.DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES = 24 * 1024 * 1024;
    var SERVER_INFO_REQUEST_TIMEOUT_MS = 1e4;
    var DEFAULT_BATCH_SIZE_LIMIT = 100;
    var DEFAULT_API_URL = "https://api.smith.langchain.com";
    var Client = class _Client {
      get _fetch() {
        return this.fetchImplementation || (0, fetch_js_1._getFetchImplementation)(this.debug);
      }
      constructor(config = {}) {
        Object.defineProperty(this, "apiKey", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "apiUrl", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "webUrl", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "workspaceId", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "caller", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "batchIngestCaller", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "timeout_ms", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "_tenantId", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: null
        });
        Object.defineProperty(this, "hideInputs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "hideOutputs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "tracingSampleRate", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "filteredPostUuids", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: /* @__PURE__ */ new Set()
        });
        Object.defineProperty(this, "autoBatchTracing", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: true
        });
        Object.defineProperty(this, "autoBatchQueue", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: new AutoBatchQueue()
        });
        Object.defineProperty(this, "autoBatchTimeout", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "autoBatchAggregationDelayMs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: 250
        });
        Object.defineProperty(this, "batchSizeBytesLimit", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "batchSizeLimit", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "fetchOptions", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "settings", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "blockOnRootRunFinalization", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (0, env_js_1.getEnvironmentVariable)("LANGSMITH_TRACING_BACKGROUND") === "false"
        });
        Object.defineProperty(this, "traceBatchConcurrency", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: 5
        });
        Object.defineProperty(this, "_serverInfo", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "_getServerInfoPromise", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "manualFlushMode", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: false
        });
        Object.defineProperty(this, "langSmithToOTELTranslator", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "fetchImplementation", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "cachedLSEnvVarsForMetadata", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "multipartStreamingDisabled", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: false
        });
        Object.defineProperty(this, "debug", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (0, env_js_1.getEnvironmentVariable)("LANGSMITH_DEBUG") === "true"
        });
        const defaultConfig2 = _Client.getDefaultClientConfig();
        this.tracingSampleRate = getTracingSamplingRate(config.tracingSamplingRate);
        this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig2.apiUrl) ?? "";
        if (this.apiUrl.endsWith("/")) {
          this.apiUrl = this.apiUrl.slice(0, -1);
        }
        this.apiKey = trimQuotes(config.apiKey ?? defaultConfig2.apiKey);
        this.webUrl = trimQuotes(config.webUrl ?? defaultConfig2.webUrl);
        if (this.webUrl?.endsWith("/")) {
          this.webUrl = this.webUrl.slice(0, -1);
        }
        this.workspaceId = trimQuotes(config.workspaceId ?? (0, env_js_1.getLangSmithEnvironmentVariable)("WORKSPACE_ID"));
        this.timeout_ms = config.timeout_ms ?? 9e4;
        this.caller = new async_caller_js_1.AsyncCaller({
          ...config.callerOptions ?? {},
          maxRetries: 4,
          debug: config.debug ?? this.debug
        });
        this.traceBatchConcurrency = config.traceBatchConcurrency ?? this.traceBatchConcurrency;
        if (this.traceBatchConcurrency < 1) {
          throw new Error("Trace batch concurrency must be positive.");
        }
        this.debug = config.debug ?? this.debug;
        this.fetchImplementation = config.fetchImplementation;
        this.batchIngestCaller = new async_caller_js_1.AsyncCaller({
          maxRetries: 2,
          maxConcurrency: this.traceBatchConcurrency,
          ...config.callerOptions ?? {},
          onFailedResponseHook: handle429,
          debug: config.debug ?? this.debug
        });
        this.hideInputs = config.hideInputs ?? config.anonymizer ?? defaultConfig2.hideInputs;
        this.hideOutputs = config.hideOutputs ?? config.anonymizer ?? defaultConfig2.hideOutputs;
        this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;
        this.blockOnRootRunFinalization = config.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization;
        this.batchSizeBytesLimit = config.batchSizeBytesLimit;
        this.batchSizeLimit = config.batchSizeLimit;
        this.fetchOptions = config.fetchOptions || {};
        this.manualFlushMode = config.manualFlushMode ?? this.manualFlushMode;
        if ((0, env_js_1.getOtelEnabled)()) {
          this.langSmithToOTELTranslator = new translator_js_1.LangSmithToOTELTranslator();
        }
        this.cachedLSEnvVarsForMetadata = (0, env_js_1.getLangSmithEnvVarsMetadata)();
      }
      static getDefaultClientConfig() {
        const apiKey = (0, env_js_1.getLangSmithEnvironmentVariable)("API_KEY");
        const apiUrl = (0, env_js_1.getLangSmithEnvironmentVariable)("ENDPOINT") ?? DEFAULT_API_URL;
        const hideInputs = (0, env_js_1.getLangSmithEnvironmentVariable)("HIDE_INPUTS") === "true";
        const hideOutputs = (0, env_js_1.getLangSmithEnvironmentVariable)("HIDE_OUTPUTS") === "true";
        return {
          apiUrl,
          apiKey,
          webUrl: void 0,
          hideInputs,
          hideOutputs
        };
      }
      getHostUrl() {
        if (this.webUrl) {
          return this.webUrl;
        } else if (isLocalhost(this.apiUrl)) {
          this.webUrl = "http://localhost:3000";
          return this.webUrl;
        } else if (this.apiUrl.endsWith("/api/v1")) {
          this.webUrl = this.apiUrl.replace("/api/v1", "");
          return this.webUrl;
        } else if (this.apiUrl.includes("/api") && !this.apiUrl.split(".", 1)[0].endsWith("api")) {
          this.webUrl = this.apiUrl.replace("/api", "");
          return this.webUrl;
        } else if (this.apiUrl.split(".", 1)[0].includes("dev")) {
          this.webUrl = "https://dev.smith.langchain.com";
          return this.webUrl;
        } else if (this.apiUrl.split(".", 1)[0].includes("eu")) {
          this.webUrl = "https://eu.smith.langchain.com";
          return this.webUrl;
        } else if (this.apiUrl.split(".", 1)[0].includes("beta")) {
          this.webUrl = "https://beta.smith.langchain.com";
          return this.webUrl;
        } else {
          this.webUrl = "https://smith.langchain.com";
          return this.webUrl;
        }
      }
      get headers() {
        const headers = {
          "User-Agent": `langsmith-js/${index_js_1.__version__}`
        };
        if (this.apiKey) {
          headers["x-api-key"] = `${this.apiKey}`;
        }
        if (this.workspaceId) {
          headers["x-tenant-id"] = this.workspaceId;
        }
        return headers;
      }
      _getPlatformEndpointPath(path) {
        const needsV1Prefix = this.apiUrl.slice(-3) !== "/v1" && this.apiUrl.slice(-4) !== "/v1/";
        return needsV1Prefix ? `/v1/platform/${path}` : `/platform/${path}`;
      }
      async processInputs(inputs) {
        if (this.hideInputs === false) {
          return inputs;
        }
        if (this.hideInputs === true) {
          return {};
        }
        if (typeof this.hideInputs === "function") {
          return this.hideInputs(inputs);
        }
        return inputs;
      }
      async processOutputs(outputs) {
        if (this.hideOutputs === false) {
          return outputs;
        }
        if (this.hideOutputs === true) {
          return {};
        }
        if (typeof this.hideOutputs === "function") {
          return this.hideOutputs(outputs);
        }
        return outputs;
      }
      async prepareRunCreateOrUpdateInputs(run) {
        const runParams = { ...run };
        if (runParams.inputs !== void 0) {
          runParams.inputs = await this.processInputs(runParams.inputs);
        }
        if (runParams.outputs !== void 0) {
          runParams.outputs = await this.processOutputs(runParams.outputs);
        }
        return runParams;
      }
      async _getResponse(path, queryParams) {
        const paramsString = queryParams?.toString() ?? "";
        const url = `${this.apiUrl}${path}?${paramsString}`;
        const response = await this.caller.call(async () => {
          const res = await this._fetch(url, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await (0, error_js_1.raiseForStatus)(res, `fetch ${path}`);
          return res;
        });
        return response;
      }
      async _get(path, queryParams) {
        const response = await this._getResponse(path, queryParams);
        return response.json();
      }
      async *_getPaginated(path, queryParams = new URLSearchParams(), transform) {
        let offset = Number(queryParams.get("offset")) || 0;
        const limit = Number(queryParams.get("limit")) || 100;
        while (true) {
          queryParams.set("offset", String(offset));
          queryParams.set("limit", String(limit));
          const url = `${this.apiUrl}${path}?${queryParams}`;
          const response = await this.caller.call(async () => {
            const res = await this._fetch(url, {
              method: "GET",
              headers: this.headers,
              signal: AbortSignal.timeout(this.timeout_ms),
              ...this.fetchOptions
            });
            await (0, error_js_1.raiseForStatus)(res, `fetch ${path}`);
            return res;
          });
          const items = transform ? transform(await response.json()) : await response.json();
          if (items.length === 0) {
            break;
          }
          yield items;
          if (items.length < limit) {
            break;
          }
          offset += items.length;
        }
      }
      async *_getCursorPaginatedList(path, body = null, requestMethod = "POST", dataKey = "runs") {
        const bodyParams = body ? { ...body } : {};
        while (true) {
          const body2 = JSON.stringify(bodyParams);
          const response = await this.caller.call(async () => {
            const res = await this._fetch(`${this.apiUrl}${path}`, {
              method: requestMethod,
              headers: { ...this.headers, "Content-Type": "application/json" },
              signal: AbortSignal.timeout(this.timeout_ms),
              ...this.fetchOptions,
              body: body2
            });
            await (0, error_js_1.raiseForStatus)(res, `fetch ${path}`);
            return res;
          });
          const responseBody = await response.json();
          if (!responseBody) {
            break;
          }
          if (!responseBody[dataKey]) {
            break;
          }
          yield responseBody[dataKey];
          const cursors = responseBody.cursors;
          if (!cursors) {
            break;
          }
          if (!cursors.next) {
            break;
          }
          bodyParams.cursor = cursors.next;
        }
      }
      // Allows mocking for tests
      _shouldSample() {
        if (this.tracingSampleRate === void 0) {
          return true;
        }
        return Math.random() < this.tracingSampleRate;
      }
      _filterForSampling(runs, patch = false) {
        if (this.tracingSampleRate === void 0) {
          return runs;
        }
        if (patch) {
          const sampled = [];
          for (const run of runs) {
            if (!this.filteredPostUuids.has(run.trace_id)) {
              sampled.push(run);
            } else if (run.id === run.trace_id) {
              this.filteredPostUuids.delete(run.trace_id);
            }
          }
          return sampled;
        } else {
          const sampled = [];
          for (const run of runs) {
            const traceId = run.trace_id ?? run.id;
            if (this.filteredPostUuids.has(traceId)) {
              continue;
            }
            if (run.id === traceId) {
              if (this._shouldSample()) {
                sampled.push(run);
              } else {
                this.filteredPostUuids.add(traceId);
              }
            } else {
              sampled.push(run);
            }
          }
          return sampled;
        }
      }
      async _getBatchSizeLimitBytes() {
        const serverInfo = await this._ensureServerInfo();
        return this.batchSizeBytesLimit ?? serverInfo.batch_ingest_config?.size_limit_bytes ?? exports2.DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES;
      }
      /**
       * Get the maximum number of operations to batch in a single request.
       */
      async _getBatchSizeLimit() {
        const serverInfo = await this._ensureServerInfo();
        return this.batchSizeLimit ?? serverInfo.batch_ingest_config?.size_limit ?? DEFAULT_BATCH_SIZE_LIMIT;
      }
      async _getDatasetExamplesMultiPartSupport() {
        const serverInfo = await this._ensureServerInfo();
        return serverInfo.instance_flags?.dataset_examples_multipart_enabled ?? false;
      }
      drainAutoBatchQueue({ batchSizeLimitBytes, batchSizeLimit }) {
        const promises = [];
        while (this.autoBatchQueue.items.length > 0) {
          const [batch, done] = this.autoBatchQueue.pop({
            upToSizeBytes: batchSizeLimitBytes,
            upToSize: batchSizeLimit
          });
          if (!batch.length) {
            done();
            break;
          }
          const batchesByDestination = batch.reduce((acc, item) => {
            const apiUrl = item.apiUrl ?? this.apiUrl;
            const apiKey = item.apiKey ?? this.apiKey;
            const isDefault = item.apiKey === this.apiKey && item.apiUrl === this.apiUrl;
            const batchKey = isDefault ? "default" : `${apiUrl}|${apiKey}`;
            if (!acc[batchKey]) {
              acc[batchKey] = [];
            }
            acc[batchKey].push(item);
            return acc;
          }, {});
          const batchPromises = [];
          for (const [batchKey, batch2] of Object.entries(batchesByDestination)) {
            const batchPromise = this._processBatch(batch2, {
              apiUrl: batchKey === "default" ? void 0 : batchKey.split("|")[0],
              apiKey: batchKey === "default" ? void 0 : batchKey.split("|")[1]
            });
            batchPromises.push(batchPromise);
          }
          const allBatchesPromise = Promise.all(batchPromises).finally(done);
          promises.push(allBatchesPromise);
        }
        return Promise.all(promises);
      }
      async _processBatch(batch, options) {
        if (!batch.length) {
          return;
        }
        try {
          if (this.langSmithToOTELTranslator !== void 0) {
            this._sendBatchToOTELTranslator(batch);
          } else {
            const ingestParams = {
              runCreates: batch.filter((item) => item.action === "create").map((item) => item.item),
              runUpdates: batch.filter((item) => item.action === "update").map((item) => item.item)
            };
            const serverInfo = await this._ensureServerInfo();
            if (serverInfo?.batch_ingest_config?.use_multipart_endpoint) {
              const useGzip = serverInfo?.instance_flags?.gzip_body_enabled;
              await this.multipartIngestRuns(ingestParams, { ...options, useGzip });
            } else {
              await this.batchIngestRuns(ingestParams, options);
            }
          }
        } catch (e) {
          console.error("Error exporting batch:", e);
        }
      }
      _sendBatchToOTELTranslator(batch) {
        if (this.langSmithToOTELTranslator !== void 0) {
          const otelContextMap = /* @__PURE__ */ new Map();
          const operations = [];
          for (const item of batch) {
            if (item.item.id && item.otelContext) {
              otelContextMap.set(item.item.id, item.otelContext);
              if (item.action === "create") {
                operations.push({
                  operation: "post",
                  id: item.item.id,
                  trace_id: item.item.trace_id ?? item.item.id,
                  run: item.item
                });
              } else {
                operations.push({
                  operation: "patch",
                  id: item.item.id,
                  trace_id: item.item.trace_id ?? item.item.id,
                  run: item.item
                });
              }
            }
          }
          this.langSmithToOTELTranslator.exportBatch(operations, otelContextMap);
        }
      }
      async processRunOperation(item) {
        clearTimeout(this.autoBatchTimeout);
        this.autoBatchTimeout = void 0;
        item.item = mergeRuntimeEnvIntoRun(item.item, this.cachedLSEnvVarsForMetadata);
        const itemPromise = this.autoBatchQueue.push(item);
        if (this.manualFlushMode) {
          return itemPromise;
        }
        const sizeLimitBytes = await this._getBatchSizeLimitBytes();
        const sizeLimit = await this._getBatchSizeLimit();
        if (this.autoBatchQueue.sizeBytes > sizeLimitBytes || this.autoBatchQueue.items.length > sizeLimit) {
          void this.drainAutoBatchQueue({
            batchSizeLimitBytes: sizeLimitBytes,
            batchSizeLimit: sizeLimit
          });
        }
        if (this.autoBatchQueue.items.length > 0) {
          this.autoBatchTimeout = setTimeout(() => {
            this.autoBatchTimeout = void 0;
            void this.drainAutoBatchQueue({
              batchSizeLimitBytes: sizeLimitBytes,
              batchSizeLimit: sizeLimit
            });
          }, this.autoBatchAggregationDelayMs);
        }
        return itemPromise;
      }
      async _getServerInfo() {
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/info`, {
            method: "GET",
            headers: { Accept: "application/json" },
            signal: AbortSignal.timeout(SERVER_INFO_REQUEST_TIMEOUT_MS),
            ...this.fetchOptions
          });
          await (0, error_js_1.raiseForStatus)(res, "get server info");
          return res;
        });
        const json = await response.json();
        if (this.debug) {
          console.log("\n=== LangSmith Server Configuration ===\n" + JSON.stringify(json, null, 2) + "\n");
        }
        return json;
      }
      async _ensureServerInfo() {
        if (this._getServerInfoPromise === void 0) {
          this._getServerInfoPromise = (async () => {
            if (this._serverInfo === void 0) {
              try {
                this._serverInfo = await this._getServerInfo();
              } catch (e) {
                console.warn(`[LANGSMITH]: Failed to fetch info on supported operations. Falling back to batch operations and default limits. Info: ${e.status ?? "Unspecified status code"} ${e.message}`);
              }
            }
            return this._serverInfo ?? {};
          })();
        }
        return this._getServerInfoPromise.then((serverInfo) => {
          if (this._serverInfo === void 0) {
            this._getServerInfoPromise = void 0;
          }
          return serverInfo;
        });
      }
      async _getSettings() {
        if (!this.settings) {
          this.settings = this._get("/settings");
        }
        return await this.settings;
      }
      /**
       * Flushes current queued traces.
       */
      async flush() {
        const sizeLimitBytes = await this._getBatchSizeLimitBytes();
        const sizeLimit = await this._getBatchSizeLimit();
        await this.drainAutoBatchQueue({
          batchSizeLimitBytes: sizeLimitBytes,
          batchSizeLimit: sizeLimit
        });
      }
      _cloneCurrentOTELContext() {
        const otel_trace = (0, otel_js_1.getOTELTrace)();
        const otel_context = (0, otel_js_1.getOTELContext)();
        if (this.langSmithToOTELTranslator !== void 0) {
          const currentSpan = otel_trace.getActiveSpan();
          if (currentSpan) {
            return otel_trace.setSpan(otel_context.active(), currentSpan);
          }
        }
        return void 0;
      }
      async createRun(run, options) {
        if (!this._filterForSampling([run]).length) {
          return;
        }
        const headers = {
          ...this.headers,
          "Content-Type": "application/json"
        };
        const session_name = run.project_name;
        delete run.project_name;
        const runCreate = await this.prepareRunCreateOrUpdateInputs({
          session_name,
          ...run,
          start_time: run.start_time ?? Date.now()
        });
        if (this.autoBatchTracing && runCreate.trace_id !== void 0 && runCreate.dotted_order !== void 0) {
          const otelContext = this._cloneCurrentOTELContext();
          void this.processRunOperation({
            action: "create",
            item: runCreate,
            otelContext,
            apiKey: options?.apiKey,
            apiUrl: options?.apiUrl
          }).catch(console.error);
          return;
        }
        const mergedRunCreateParam = mergeRuntimeEnvIntoRun(runCreate, this.cachedLSEnvVarsForMetadata);
        if (options?.apiKey !== void 0) {
          headers["x-api-key"] = options.apiKey;
        }
        if (options?.workspaceId !== void 0) {
          headers["x-tenant-id"] = options.workspaceId;
        }
        const body = (0, index_js_2.serialize)(mergedRunCreateParam, `Creating run with id: ${mergedRunCreateParam.id}`);
        await this.caller.call(async () => {
          const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs`, {
            method: "POST",
            headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await (0, error_js_1.raiseForStatus)(res, "create run", true);
          return res;
        });
      }
      /**
       * Batch ingest/upsert multiple runs in the Langsmith system.
       * @param runs
       */
      async batchIngestRuns({ runCreates, runUpdates }, options) {
        if (runCreates === void 0 && runUpdates === void 0) {
          return;
        }
        let preparedCreateParams = await Promise.all(runCreates?.map((create) => this.prepareRunCreateOrUpdateInputs(create)) ?? []);
        let preparedUpdateParams = await Promise.all(runUpdates?.map((update) => this.prepareRunCreateOrUpdateInputs(update)) ?? []);
        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {
          const createById = preparedCreateParams.reduce((params, run) => {
            if (!run.id) {
              return params;
            }
            params[run.id] = run;
            return params;
          }, {});
          const standaloneUpdates = [];
          for (const updateParam of preparedUpdateParams) {
            if (updateParam.id !== void 0 && createById[updateParam.id]) {
              createById[updateParam.id] = {
                ...createById[updateParam.id],
                ...updateParam
              };
            } else {
              standaloneUpdates.push(updateParam);
            }
          }
          preparedCreateParams = Object.values(createById);
          preparedUpdateParams = standaloneUpdates;
        }
        const rawBatch = {
          post: preparedCreateParams,
          patch: preparedUpdateParams
        };
        if (!rawBatch.post.length && !rawBatch.patch.length) {
          return;
        }
        const batchChunks = {
          post: [],
          patch: []
        };
        for (const k of ["post", "patch"]) {
          const key = k;
          const batchItems = rawBatch[key].reverse();
          let batchItem = batchItems.pop();
          while (batchItem !== void 0) {
            batchChunks[key].push(batchItem);
            batchItem = batchItems.pop();
          }
        }
        if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {
          const runIds = batchChunks.post.map((item) => item.id).concat(batchChunks.patch.map((item) => item.id)).join(",");
          await this._postBatchIngestRuns((0, index_js_2.serialize)(batchChunks, `Ingesting runs with ids: ${runIds}`), options);
        }
      }
      async _postBatchIngestRuns(body, options) {
        const headers = {
          ...this.headers,
          "Content-Type": "application/json",
          Accept: "application/json"
        };
        if (options?.apiKey !== void 0) {
          headers["x-api-key"] = options.apiKey;
        }
        await this.batchIngestCaller.call(async () => {
          const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/batch`, {
            method: "POST",
            headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await (0, error_js_1.raiseForStatus)(res, "batch create run", true);
          return res;
        });
      }
      /**
       * Batch ingest/upsert multiple runs in the Langsmith system.
       * @param runs
       */
      async multipartIngestRuns({ runCreates, runUpdates }, options) {
        if (runCreates === void 0 && runUpdates === void 0) {
          return;
        }
        const allAttachments = {};
        let preparedCreateParams = [];
        for (const create of runCreates ?? []) {
          const preparedCreate = await this.prepareRunCreateOrUpdateInputs(create);
          if (preparedCreate.id !== void 0 && preparedCreate.attachments !== void 0) {
            allAttachments[preparedCreate.id] = preparedCreate.attachments;
          }
          delete preparedCreate.attachments;
          preparedCreateParams.push(preparedCreate);
        }
        let preparedUpdateParams = [];
        for (const update of runUpdates ?? []) {
          preparedUpdateParams.push(await this.prepareRunCreateOrUpdateInputs(update));
        }
        const invalidRunCreate = preparedCreateParams.find((runCreate) => {
          return runCreate.trace_id === void 0 || runCreate.dotted_order === void 0;
        });
        if (invalidRunCreate !== void 0) {
          throw new Error(`Multipart ingest requires "trace_id" and "dotted_order" to be set when creating a run`);
        }
        const invalidRunUpdate = preparedUpdateParams.find((runUpdate) => {
          return runUpdate.trace_id === void 0 || runUpdate.dotted_order === void 0;
        });
        if (invalidRunUpdate !== void 0) {
          throw new Error(`Multipart ingest requires "trace_id" and "dotted_order" to be set when updating a run`);
        }
        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {
          const createById = preparedCreateParams.reduce((params, run) => {
            if (!run.id) {
              return params;
            }
            params[run.id] = run;
            return params;
          }, {});
          const standaloneUpdates = [];
          for (const updateParam of preparedUpdateParams) {
            if (updateParam.id !== void 0 && createById[updateParam.id]) {
              createById[updateParam.id] = {
                ...createById[updateParam.id],
                ...updateParam
              };
            } else {
              standaloneUpdates.push(updateParam);
            }
          }
          preparedCreateParams = Object.values(createById);
          preparedUpdateParams = standaloneUpdates;
        }
        if (preparedCreateParams.length === 0 && preparedUpdateParams.length === 0) {
          return;
        }
        const accumulatedContext = [];
        const accumulatedParts = [];
        for (const [method, payloads] of [
          ["post", preparedCreateParams],
          ["patch", preparedUpdateParams]
        ]) {
          for (const originalPayload of payloads) {
            const { inputs, outputs, events, extra, error, serialized, attachments, ...payload } = originalPayload;
            const fields = { inputs, outputs, events, extra, error, serialized };
            const stringifiedPayload = (0, index_js_2.serialize)(payload, `Serializing for multipart ingestion of run with id: ${payload.id}`);
            accumulatedParts.push({
              name: `${method}.${payload.id}`,
              payload: new Blob([stringifiedPayload], {
                type: `application/json; length=${stringifiedPayload.length}`
                // encoding=gzip
              })
            });
            for (const [key, value] of Object.entries(fields)) {
              if (value === void 0) {
                continue;
              }
              const stringifiedValue = (0, index_js_2.serialize)(value, `Serializing ${key} for multipart ingestion of run with id: ${payload.id}`);
              accumulatedParts.push({
                name: `${method}.${payload.id}.${key}`,
                payload: new Blob([stringifiedValue], {
                  type: `application/json; length=${stringifiedValue.length}`
                })
              });
            }
            if (payload.id !== void 0) {
              const attachments2 = allAttachments[payload.id];
              if (attachments2) {
                delete allAttachments[payload.id];
                for (const [name, attachment] of Object.entries(attachments2)) {
                  let contentType;
                  let content;
                  if (Array.isArray(attachment)) {
                    [contentType, content] = attachment;
                  } else {
                    contentType = attachment.mimeType;
                    content = attachment.data;
                  }
                  if (name.includes(".")) {
                    console.warn(`Skipping attachment '${name}' for run ${payload.id}: Invalid attachment name. Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);
                    continue;
                  }
                  accumulatedParts.push({
                    name: `attachment.${payload.id}.${name}`,
                    payload: new Blob([content], {
                      type: `${contentType}; length=${content.byteLength}`
                    })
                  });
                }
              }
            }
            accumulatedContext.push(`trace=${payload.trace_id},id=${payload.id}`);
          }
        }
        await this._sendMultipartRequest(accumulatedParts, accumulatedContext.join("; "), options);
      }
      async _createNodeFetchBody(parts, boundary) {
        const chunks = [];
        for (const part of parts) {
          chunks.push(new Blob([`--${boundary}\r
`]));
          chunks.push(new Blob([
            `Content-Disposition: form-data; name="${part.name}"\r
`,
            `Content-Type: ${part.payload.type}\r
\r
`
          ]));
          chunks.push(part.payload);
          chunks.push(new Blob(["\r\n"]));
        }
        chunks.push(new Blob([`--${boundary}--\r
`]));
        const body = new Blob(chunks);
        const arrayBuffer = await body.arrayBuffer();
        return arrayBuffer;
      }
      async _createMultipartStream(parts, boundary) {
        const encoder = new TextEncoder();
        const stream = new ReadableStream({
          async start(controller) {
            const writeChunk = async (chunk) => {
              if (typeof chunk === "string") {
                controller.enqueue(encoder.encode(chunk));
              } else {
                controller.enqueue(chunk);
              }
            };
            for (const part of parts) {
              await writeChunk(`--${boundary}\r
`);
              await writeChunk(`Content-Disposition: form-data; name="${part.name}"\r
`);
              await writeChunk(`Content-Type: ${part.payload.type}\r
\r
`);
              const payloadStream = part.payload.stream();
              const reader = payloadStream.getReader();
              try {
                let result;
                while (!(result = await reader.read()).done) {
                  controller.enqueue(result.value);
                }
              } finally {
                reader.releaseLock();
              }
              await writeChunk("\r\n");
            }
            await writeChunk(`--${boundary}--\r
`);
            controller.close();
          }
        });
        return stream;
      }
      async _sendMultipartRequest(parts, context, options) {
        const boundary = "----LangSmithFormBoundary" + Math.random().toString(36).slice(2);
        const isNodeFetch = (0, fetch_js_1._globalFetchImplementationIsNodeFetch)();
        const buildBuffered = () => this._createNodeFetchBody(parts, boundary);
        const buildStream = () => this._createMultipartStream(parts, boundary);
        const sendWithRetry = async (bodyFactory) => {
          return this.batchIngestCaller.call(async () => {
            const body = await bodyFactory();
            const headers = {
              ...this.headers,
              "Content-Type": `multipart/form-data; boundary=${boundary}`
            };
            if (options?.apiKey !== void 0) {
              headers["x-api-key"] = options.apiKey;
            }
            let transformedBody = body;
            if (options?.useGzip && typeof body === "object" && "pipeThrough" in body) {
              transformedBody = body.pipeThrough(new CompressionStream("gzip"));
              headers["Content-Encoding"] = "gzip";
            }
            const response = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/multipart`, {
              method: "POST",
              headers,
              body: transformedBody,
              duplex: "half",
              signal: AbortSignal.timeout(this.timeout_ms),
              ...this.fetchOptions
            });
            await (0, error_js_1.raiseForStatus)(response, `Failed to send multipart request`, true);
            return response;
          });
        };
        try {
          let res;
          let streamedAttempt = false;
          if (!isNodeFetch && !this.multipartStreamingDisabled && (0, env_js_1.getEnv)() !== "bun") {
            streamedAttempt = true;
            res = await sendWithRetry(buildStream);
          } else {
            res = await sendWithRetry(buildBuffered);
          }
          if ((!this.multipartStreamingDisabled || streamedAttempt) && res.status === 422 && (options?.apiUrl ?? this.apiUrl) !== DEFAULT_API_URL) {
            console.warn(`Streaming multipart upload to ${options?.apiUrl ?? this.apiUrl}/runs/multipart failed. This usually means the host does not support chunked uploads. Retrying with a buffered upload for operation "${context}".`);
            this.multipartStreamingDisabled = true;
            res = await sendWithRetry(buildBuffered);
          }
        } catch (e) {
          console.warn(`${e.message.trim()}

Context: ${context}`);
        }
      }
      async updateRun(runId, run, options) {
        (0, _uuid_js_1.assertUuid)(runId);
        if (run.inputs) {
          run.inputs = await this.processInputs(run.inputs);
        }
        if (run.outputs) {
          run.outputs = await this.processOutputs(run.outputs);
        }
        const data = { ...run, id: runId };
        if (!this._filterForSampling([data], true).length) {
          return;
        }
        if (this.autoBatchTracing && data.trace_id !== void 0 && data.dotted_order !== void 0) {
          const otelContext = this._cloneCurrentOTELContext();
          if (run.end_time !== void 0 && data.parent_run_id === void 0 && this.blockOnRootRunFinalization && !this.manualFlushMode) {
            await this.processRunOperation({
              action: "update",
              item: data,
              otelContext,
              apiKey: options?.apiKey,
              apiUrl: options?.apiUrl
            }).catch(console.error);
            return;
          } else {
            void this.processRunOperation({
              action: "update",
              item: data,
              otelContext,
              apiKey: options?.apiKey,
              apiUrl: options?.apiUrl
            }).catch(console.error);
          }
          return;
        }
        const headers = {
          ...this.headers,
          "Content-Type": "application/json"
        };
        if (options?.apiKey !== void 0) {
          headers["x-api-key"] = options.apiKey;
        }
        if (options?.workspaceId !== void 0) {
          headers["x-tenant-id"] = options.workspaceId;
        }
        const body = (0, index_js_2.serialize)(run, `Serializing payload to update run with id: ${runId}`);
        await this.caller.call(async () => {
          const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/${runId}`, {
            method: "PATCH",
            headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await (0, error_js_1.raiseForStatus)(res, "update run", true);
          return res;
        });
      }
      async readRun(runId, { loadChildRuns } = { loadChildRuns: false }) {
        (0, _uuid_js_1.assertUuid)(runId);
        let run = await this._get(`/runs/${runId}`);
        if (loadChildRuns) {
          run = await this._loadChildRuns(run);
        }
        return run;
      }
      async getRunUrl({ runId, run, projectOpts }) {
        if (run !== void 0) {
          let sessionId;
          if (run.session_id) {
            sessionId = run.session_id;
          } else if (projectOpts?.projectName) {
            sessionId = (await this.readProject({ projectName: projectOpts?.projectName })).id;
          } else if (projectOpts?.projectId) {
            sessionId = projectOpts?.projectId;
          } else {
            const project = await this.readProject({
              projectName: (0, env_js_1.getLangSmithEnvironmentVariable)("PROJECT") || "default"
            });
            sessionId = project.id;
          }
          const tenantId = await this._getTenantId();
          return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;
        } else if (runId !== void 0) {
          const run_ = await this.readRun(runId);
          if (!run_.app_path) {
            throw new Error(`Run ${runId} has no app_path`);
          }
          const baseUrl = this.getHostUrl();
          return `${baseUrl}${run_.app_path}`;
        } else {
          throw new Error("Must provide either runId or run");
        }
      }
      async _loadChildRuns(run) {
        const childRuns = await toArray(this.listRuns({
          isRoot: false,
          projectId: run.session_id,
          traceId: run.trace_id
        }));
        const treemap = {};
        const runs = {};
        childRuns.sort((a, b) => (a?.dotted_order ?? "").localeCompare(b?.dotted_order ?? ""));
        for (const childRun of childRuns) {
          if (childRun.parent_run_id === null || childRun.parent_run_id === void 0) {
            throw new Error(`Child run ${childRun.id} has no parent`);
          }
          if (childRun.dotted_order?.startsWith(run.dotted_order ?? "") && childRun.id !== run.id) {
            if (!(childRun.parent_run_id in treemap)) {
              treemap[childRun.parent_run_id] = [];
            }
            treemap[childRun.parent_run_id].push(childRun);
            runs[childRun.id] = childRun;
          }
        }
        run.child_runs = treemap[run.id] || [];
        for (const runId in treemap) {
          if (runId !== run.id) {
            runs[runId].child_runs = treemap[runId];
          }
        }
        return run;
      }
      /**
       * List runs from the LangSmith server.
       * @param projectId - The ID of the project to filter by.
       * @param projectName - The name of the project to filter by.
       * @param parentRunId - The ID of the parent run to filter by.
       * @param traceId - The ID of the trace to filter by.
       * @param referenceExampleId - The ID of the reference example to filter by.
       * @param startTime - The start time to filter by.
       * @param isRoot - Indicates whether to only return root runs.
       * @param runType - The run type to filter by.
       * @param error - Indicates whether to filter by error runs.
       * @param id - The ID of the run to filter by.
       * @param query - The query string to filter by.
       * @param filter - The filter string to apply to the run spans.
       * @param traceFilter - The filter string to apply on the root run of the trace.
       * @param treeFilter - The filter string to apply on other runs in the trace.
       * @param limit - The maximum number of runs to retrieve.
       * @returns {AsyncIterable<Run>} - The runs.
       *
       * @example
       * // List all runs in a project
       * const projectRuns = client.listRuns({ projectName: "<your_project>" });
       *
       * @example
       * // List LLM and Chat runs in the last 24 hours
       * const todaysLLMRuns = client.listRuns({
       *   projectName: "<your_project>",
       *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),
       *   run_type: "llm",
       * });
       *
       * @example
       * // List traces in a project
       * const rootRuns = client.listRuns({
       *   projectName: "<your_project>",
       *   execution_order: 1,
       * });
       *
       * @example
       * // List runs without errors
       * const correctRuns = client.listRuns({
       *   projectName: "<your_project>",
       *   error: false,
       * });
       *
       * @example
       * // List runs by run ID
       * const runIds = [
       *   "a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836",
       *   "9398e6be-964f-4aa4-8ae9-ad78cd4b7074",
       * ];
       * const selectedRuns = client.listRuns({ run_ids: runIds });
       *
       * @example
       * // List all "chain" type runs that took more than 10 seconds and had `total_tokens` greater than 5000
       * const chainRuns = client.listRuns({
       *   projectName: "<your_project>",
       *   filter: 'and(eq(run_type, "chain"), gt(latency, 10), gt(total_tokens, 5000))',
       * });
       *
       * @example
       * // List all runs called "extractor" whose root of the trace was assigned feedback "user_score" score of 1
       * const goodExtractorRuns = client.listRuns({
       *   projectName: "<your_project>",
       *   filter: 'eq(name, "extractor")',
       *   traceFilter: 'and(eq(feedback_key, "user_score"), eq(feedback_score, 1))',
       * });
       *
       * @example
       * // List all runs that started after a specific timestamp and either have "error" not equal to null or a "Correctness" feedback score equal to 0
       * const complexRuns = client.listRuns({
       *   projectName: "<your_project>",
       *   filter: 'and(gt(start_time, "2023-07-15T12:34:56Z"), or(neq(error, null), and(eq(feedback_key, "Correctness"), eq(feedback_score, 0.0))))',
       * });
       *
       * @example
       * // List all runs where `tags` include "experimental" or "beta" and `latency` is greater than 2 seconds
       * const taggedRuns = client.listRuns({
       *   projectName: "<your_project>",
       *   filter: 'and(or(has(tags, "experimental"), has(tags, "beta")), gt(latency, 2))',
       * });
       */
      async *listRuns(props) {
        const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, isRoot, runType, error, id, query, filter, traceFilter, treeFilter, limit, select, order } = props;
        let projectIds = [];
        if (projectId) {
          projectIds = Array.isArray(projectId) ? projectId : [projectId];
        }
        if (projectName) {
          const projectNames = Array.isArray(projectName) ? projectName : [projectName];
          const projectIds_ = await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)));
          projectIds.push(...projectIds_);
        }
        const default_select = [
          "app_path",
          "completion_cost",
          "completion_tokens",
          "dotted_order",
          "end_time",
          "error",
          "events",
          "extra",
          "feedback_stats",
          "first_token_time",
          "id",
          "inputs",
          "name",
          "outputs",
          "parent_run_id",
          "parent_run_ids",
          "prompt_cost",
          "prompt_tokens",
          "reference_example_id",
          "run_type",
          "session_id",
          "start_time",
          "status",
          "tags",
          "total_cost",
          "total_tokens",
          "trace_id"
        ];
        const body = {
          session: projectIds.length ? projectIds : null,
          run_type: runType,
          reference_example: referenceExampleId,
          query,
          filter,
          trace_filter: traceFilter,
          tree_filter: treeFilter,
          execution_order: executionOrder,
          parent_run: parentRunId,
          start_time: startTime ? startTime.toISOString() : null,
          error,
          id,
          limit,
          trace: traceId,
          select: select ? select : default_select,
          is_root: isRoot,
          order
        };
        if (body.select.includes("child_run_ids")) {
          (0, warn_js_1.warnOnce)("Deprecated: 'child_run_ids' in the listRuns select parameter is deprecated and will be removed in a future version.");
        }
        let runsYielded = 0;
        for await (const runs of this._getCursorPaginatedList("/runs/query", body)) {
          if (limit) {
            if (runsYielded >= limit) {
              break;
            }
            if (runs.length + runsYielded > limit) {
              const newRuns = runs.slice(0, limit - runsYielded);
              yield* newRuns;
              break;
            }
            runsYielded += runs.length;
            yield* runs;
          } else {
            yield* runs;
          }
        }
      }
      async *listGroupRuns(props) {
        const { projectId, projectName, groupBy, filter, startTime, endTime, limit, offset } = props;
        const sessionId = projectId || (await this.readProject({ projectName })).id;
        const baseBody = {
          session_id: sessionId,
          group_by: groupBy,
          filter,
          start_time: startTime ? startTime.toISOString() : null,
          end_time: endTime ? endTime.toISOString() : null,
          limit: Number(limit) || 100
        };
        let currentOffset = Number(offset) || 0;
        const path = "/runs/group";
        const url = `${this.apiUrl}${path}`;
        while (true) {
          const currentBody = {
            ...baseBody,
            offset: currentOffset
          };
          const filteredPayload = Object.fromEntries(Object.entries(currentBody).filter(([_, value]) => value !== void 0));
          const body = JSON.stringify(filteredPayload);
          const response = await this.caller.call(async () => {
            const res = await this._fetch(url, {
              method: "POST",
              headers: { ...this.headers, "Content-Type": "application/json" },
              signal: AbortSignal.timeout(this.timeout_ms),
              ...this.fetchOptions,
              body
            });
            await (0, error_js_1.raiseForStatus)(res, `Failed to fetch ${path}`);
            return res;
          });
          const items = await response.json();
          const { groups, total } = items;
          if (groups.length === 0) {
            break;
          }
          for (const thread of groups) {
            yield thread;
          }
          currentOffset += groups.length;
          if (currentOffset >= total) {
            break;
          }
        }
      }
      async getRunStats({ id, trace, parentRun, runType, projectNames, projectIds, referenceExampleIds, startTime, endTime, error, query, filter, traceFilter, treeFilter, isRoot, dataSourceType }) {
        let projectIds_ = projectIds || [];
        if (projectNames) {
          projectIds_ = [
            ...projectIds || [],
            ...await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)))
          ];
        }
        const payload = {
          id,
          trace,
          parent_run: parentRun,
          run_type: runType,
          session: projectIds_,
          reference_example: referenceExampleIds,
          start_time: startTime,
          end_time: endTime,
          error,
          query,
          filter,
          trace_filter: traceFilter,
          tree_filter: treeFilter,
          is_root: isRoot,
          data_source_type: dataSourceType
        };
        const filteredPayload = Object.fromEntries(Object.entries(payload).filter(([_, value]) => value !== void 0));
        const body = JSON.stringify(filteredPayload);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/runs/stats`, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await (0, error_js_1.raiseForStatus)(res, "get run stats");
          return res;
        });
        const result = await response.json();
        return result;
      }
      async shareRun(runId, { shareId } = {}) {
        const data = {
          run_id: runId,
          share_token: shareId || uuid.v4()
        };
        (0, _uuid_js_1.assertUuid)(runId);
        const body = JSON.stringify(data);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {
            method: "PUT",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await (0, error_js_1.raiseForStatus)(res, "share run");
          return res;
        });
        const result = await response.json();
        if (result === null || !("share_token" in result)) {
          throw new Error("Invalid response from server");
        }
        return `${this.getHostUrl()}/public/${result["share_token"]}/r`;
      }
      async unshareRun(runId) {
        (0, _uuid_js_1.assertUuid)(runId);
        await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {
            method: "DELETE",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await (0, error_js_1.raiseForStatus)(res, "unshare run", true);
          return res;
        });
      }
      async readRunSharedLink(runId) {
        (0, _uuid_js_1.assertUuid)(runId);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await (0, error_js_1.raiseForStatus)(res, "read run shared link");
          return res;
        });
        const result = await response.json();
        if (result === null || !("share_token" in result)) {
          return void 0;
        }
        return `${this.getHostUrl()}/public/${result["share_token"]}/r`;
      }
      async listSharedRuns(shareToken, { runIds } = {}) {
        const queryParams = new URLSearchParams({
          share_token: shareToken
        });
        if (runIds !== void 0) {
          for (const runId of runIds) {
            queryParams.append("id", runId);
          }
        }
        (0, _uuid_js_1.assertUuid)(shareToken);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await (0, error_js_1.raiseForStatus)(res, "list shared runs");
          return res;
        });
        const runs = await response.json();
        return runs;
      }
      async readDatasetSharedSchema(datasetId, datasetName) {
        if (!datasetId && !datasetName) {
          throw new Error("Either datasetId or datasetName must be given");
        }
        if (!datasetId) {
          const dataset = await this.readDataset({ datasetName });
          datasetId = dataset.id;
        }
        (0, _uuid_js_1.assertUuid)(datasetId);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await (0, error_js_1.raiseForStatus)(res, "read dataset shared schema");
          return res;
        });
        const shareSchema = await response.json();
        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;
        return shareSchema;
      }
      async shareDataset(datasetId, datasetName) {
        if (!datasetId && !datasetName) {
          throw new Error("Either datasetId or datasetName must be given");
        }
        if (!datasetId) {
          const dataset = await this.readDataset({ datasetName });
          datasetId = dataset.id;
        }
        const data = {
          dataset_id: datasetId
        };
        (0, _uuid_js_1.assertUuid)(datasetId);
        const body = JSON.stringify(data);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {
            method: "PUT",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await (0, error_js_1.raiseForStatus)(res, "share dataset");
          return res;
        });
        const shareSchema = await response.json();
        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;
        return shareSchema;
      }
      async unshareDataset(datasetId) {
        (0, _uuid_js_1.assertUuid)(datasetId);
        await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {
            method: "DELETE",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await (0, error_js_1.raiseForStatus)(res, "unshare dataset", true);
          return res;
        });
      }
      async readSharedDataset(shareToken) {
        (0, _uuid_js_1.assertUuid)(shareToken);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/datasets`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await (0, error_js_1.raiseForStatus)(res, "read shared dataset");
          return res;
        });
        const dataset = await response.json();
        return dataset;
      }
      /**
       * Get shared examples.
       *
       * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.
       * @param {Object} [options] Additional options for listing the examples.
       * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.
       * @returns {Promise<Example[]>} The shared examples.
       */
      async listSharedExamples(shareToken, options) {
        const params = {};
        if (options?.exampleIds) {
          params.id = options.exampleIds;
        }
        const urlParams = new URLSearchParams();
        Object.entries(params).forEach(([key, value]) => {
          if (Array.isArray(value)) {
            value.forEach((v) => urlParams.append(key, v));
          } else {
            urlParams.append(key, value);
          }
        });
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/examples?${urlParams.toString()}`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await (0, error_js_1.raiseForStatus)(res, "list shared examples");
          return res;
        });
        const result = await response.json();
        if (!response.ok) {
          if ("detail" in result) {
            throw new Error(`Failed to list shared examples.
Status: ${response.status}
Message: ${Array.isArray(result.detail) ? result.detail.join("\n") : "Unspecified error"}`);
          }
          throw new Error(`Failed to list shared examples: ${response.status} ${response.statusText}`);
        }
        return result.map((example) => ({
          ...example,
          _hostUrl: this.getHostUrl()
        }));
      }
      async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null }) {
        const upsert_ = upsert ? `?upsert=true` : "";
        const endpoint = `${this.apiUrl}/sessions${upsert_}`;
        const extra = projectExtra || {};
        if (metadata) {
          extra["metadata"] = metadata;
        }
        const body = {
          name: projectName,
          extra,
          description
        };
        if (referenceDatasetId !== null) {
          body["reference_dataset_id"] = referenceDatasetId;
        }
        const serializedBody = JSON.stringify(body);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(endpoint, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body: serializedBody
          });
          await (0, error_js_1.raiseForStatus)(res, "create project");
          return res;
        });
        const result = await response.json();
        return result;
      }
      async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null }) {
        const endpoint = `${this.apiUrl}/sessions/${projectId}`;
        let extra = projectExtra;
        if (metadata) {
          extra = { ...extra || {}, metadata };
        }
        const body = JSON.stringify({
          name,
          extra,
          description,
          end_time: endTime ? new Date(endTime).toISOString() : null
        });
        const response = await this.caller.call(async () => {
          const res = await this._fetch(endpoint, {
            method: "PATCH",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await (0, error_js_1.raiseForStatus)(res, "update project");
          return res;
        });
        const result = await response.json();
        return result;
      }
      async hasProject({ projectId, projectName }) {
        let path = "/sessions";
        const params = new URLSearchParams();
        if (projectId !== void 0 && projectName !== void 0) {
          throw new Error("Must provide either projectName or projectId, not both");
        } else if (projectId !== void 0) {
          (0, _uuid_js_1.assertUuid)(projectId);
          path += `/${projectId}`;
        } else if (projectName !== void 0) {
          params.append("name", projectName);
        } else {
          throw new Error("Must provide projectName or projectId");
        }
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}${path}?${params}`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await (0, error_js_1.raiseForStatus)(res, "has project");
          return res;
        });
        try {
          const result = await response.json();
          if (!response.ok) {
            return false;
          }
          if (Array.isArray(result)) {
            return result.length > 0;
          }
          return true;
        } catch (e) {
          return false;
        }
      }
      async readProject({ projectId, projectName, includeStats }) {
        let path = "/sessions";
        const params = new URLSearchParams();
        if (projectId !== void 0 && projectName !== void 0) {
          throw new Error("Must provide either projectName or projectId, not both");
        } else if (projectId !== void 0) {
          (0, _uuid_js_1.assertUuid)(projectId);
          path += `/${projectId}`;
        } else if (projectName !== void 0) {
          params.append("name", projectName);
        } else {
          throw new Error("Must provide projectName or projectId");
        }
        if (includeStats !== void 0) {
          params.append("include_stats", includeStats.toString());
        }
        const response = await this._get(path, params);
        let result;
        if (Array.isArray(response)) {
          if (response.length === 0) {
            throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);
          }
          result = response[0];
        } else {
          result = response;
        }
        return result;
      }
      async getProjectUrl({ projectId, projectName }) {
        if (projectId === void 0 && projectName === void 0) {
          throw new Error("Must provide either projectName or projectId");
        }
        const project = await this.readProject({ projectId, projectName });
        const tenantId = await this._getTenantId();
        return `${this.getHostUrl()}/o/${tenantId}/projects/p/${project.id}`;
      }
      async getDatasetUrl({ datasetId, datasetName }) {
        if (datasetId === void 0 && datasetName === void 0) {
          throw new Error("Must provide either datasetName or datasetId");
        }
        const dataset = await this.readDataset({ datasetId, datasetName });
        const tenantId = await this._getTenantId();
        return `${this.getHostUrl()}/o/${tenantId}/datasets/${dataset.id}`;
      }
      async _getTenantId() {
        if (this._tenantId !== null) {
          return this._tenantId;
        }
        const queryParams = new URLSearchParams({ limit: "1" });
        for await (const projects of this._getPaginated("/sessions", queryParams)) {
          this._tenantId = projects[0].tenant_id;
          return projects[0].tenant_id;
        }
        throw new Error("No projects found to resolve tenant.");
      }
      async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, includeStats, datasetVersion, referenceFree, metadata } = {}) {
        const params = new URLSearchParams();
        if (projectIds !== void 0) {
          for (const projectId of projectIds) {
            params.append("id", projectId);
          }
        }
        if (name !== void 0) {
          params.append("name", name);
        }
        if (nameContains !== void 0) {
          params.append("name_contains", nameContains);
        }
        if (referenceDatasetId !== void 0) {
          params.append("reference_dataset", referenceDatasetId);
        } else if (referenceDatasetName !== void 0) {
          const dataset = await this.readDataset({
            datasetName: referenceDatasetName
          });
          params.append("reference_dataset", dataset.id);
        }
        if (includeStats !== void 0) {
          params.append("include_stats", includeStats.toString());
        }
        if (datasetVersion !== void 0) {
          params.append("dataset_version", datasetVersion);
        }
        if (referenceFree !== void 0) {
          params.append("reference_free", referenceFree.toString());
        }
        if (metadata !== void 0) {
          params.append("metadata", JSON.stringify(metadata));
        }
        for await (const projects of this._getPaginated("/sessions", params)) {
          yield* projects;
        }
      }
      async deleteProject({ projectId, projectName }) {
        let projectId_;
        if (projectId === void 0 && projectName === void 0) {
          throw new Error("Must provide projectName or projectId");
        } else if (projectId !== void 0 && projectName !== void 0) {
          throw new Error("Must provide either projectName or projectId, not both");
        } else if (projectId === void 0) {
          projectId_ = (await this.readProject({ projectName })).id;
        } else {
          projectId_ = projectId;
        }
        (0, _uuid_js_1.assertUuid)(projectId_);
        await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/sessions/${projectId_}`, {
            method: "DELETE",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await (0, error_js_1.raiseForStatus)(res, `delete session ${projectId_} (${projectName})`, true);
          return res;
        });
      }
      async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name }) {
        const url = `${this.apiUrl}/datasets/upload`;
        const formData = new FormData();
        formData.append("file", csvFile, fileName);
        inputKeys.forEach((key) => {
          formData.append("input_keys", key);
        });
        outputKeys.forEach((key) => {
          formData.append("output_keys", key);
        });
        if (description) {
          formData.append("description", description);
        }
        if (dataType) {
          formData.append("data_type", dataType);
        }
        if (name) {
          formData.append("name", name);
        }
        const response = await this.caller.call(async () => {
          const res = await this._fetch(url, {
            method: "POST",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body: formData
          });
          await (0, error_js_1.raiseForStatus)(res, "upload CSV");
          return res;
        });
        const result = await response.json();
        return result;
      }
      async createDataset(name, { description, dataType, inputsSchema, outputsSchema, metadata } = {}) {
        const body = {
          name,
          description,
          extra: metadata ? { metadata } : void 0
        };
        if (dataType) {
          body.data_type = dataType;
        }
        if (inputsSchema) {
          body.inputs_schema_definition = inputsSchema;
        }
        if (outputsSchema) {
          body.outputs_schema_definition = outputsSchema;
        }
        const serializedBody = JSON.stringify(body);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/datasets`, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body: serializedBody
          });
          await (0, error_js_1.raiseForStatus)(res, "create dataset");
          return res;
        });
        const result = await response.json();
        return result;
      }
      async readDataset({ datasetId, datasetName }) {
        let path = "/datasets";
        const params = new URLSearchParams({ limit: "1" });
        if (datasetId && datasetName) {
          throw new Error("Must provide either datasetName or datasetId, not both");
        } else if (datasetId) {
          (0, _uuid_js_1.assertUuid)(datasetId);
          path += `/${datasetId}`;
        } else if (datasetName) {
          params.append("name", datasetName);
        } else {
          throw new Error("Must provide datasetName or datasetId");
        }
        const response = await this._get(path, params);
        let result;
        if (Array.isArray(response)) {
          if (response.length === 0) {
            throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);
          }
          result = response[0];
        } else {
          result = response;
        }
        return result;
      }
      async hasDataset({ datasetId, datasetName }) {
        try {
          await this.readDataset({ datasetId, datasetName });
          return true;
        } catch (e) {
          if (
            // eslint-disable-next-line no-instanceof/no-instanceof
            e instanceof Error && e.message.toLocaleLowerCase().includes("not found")
          ) {
            return false;
          }
          throw e;
        }
      }
      async diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion }) {
        let datasetId_ = datasetId;
        if (datasetId_ === void 0 && datasetName === void 0) {
          throw new Error("Must provide either datasetName or datasetId");
        } else if (datasetId_ !== void 0 && datasetName !== void 0) {
          throw new Error("Must provide either datasetName or datasetId, not both");
        } else if (datasetId_ === void 0) {
          const dataset = await this.readDataset({ datasetName });
          datasetId_ = dataset.id;
        }
        const urlParams = new URLSearchParams({
          from_version: typeof fromVersion === "string" ? fromVersion : fromVersion.toISOString(),
          to_version: typeof toVersion === "string" ? toVersion : toVersion.toISOString()
        });
        const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);
        return response;
      }
      async readDatasetOpenaiFinetuning({ datasetId, datasetName }) {
        const path = "/datasets";
        if (datasetId !== void 0) {
        } else if (datasetName !== void 0) {
          datasetId = (await this.readDataset({ datasetName })).id;
        } else {
          throw new Error("Must provide either datasetName or datasetId");
        }
        const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);
        const datasetText = await response.text();
        const dataset = datasetText.trim().split("\n").map((line) => JSON.parse(line));
        return dataset;
      }
      async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, metadata } = {}) {
        const path = "/datasets";
        const params = new URLSearchParams({
          limit: limit.toString(),
          offset: offset.toString()
        });
        if (datasetIds !== void 0) {
          for (const id_ of datasetIds) {
            params.append("id", id_);
          }
        }
        if (datasetName !== void 0) {
          params.append("name", datasetName);
        }
        if (datasetNameContains !== void 0) {
          params.append("name_contains", datasetNameContains);
        }
        if (metadata !== void 0) {
          params.append("metadata", JSON.stringify(metadata));
        }
        for await (const datasets of this._getPaginated(path, params)) {
          yield* datasets;
        }
      }
      /**
       * Update a dataset
       * @param props The dataset details to update
       * @returns The updated dataset
       */
      async updateDataset(props) {
        const { datasetId, datasetName, ...update } = props;
        if (!datasetId && !datasetName) {
          throw new Error("Must provide either datasetName or datasetId");
        }
        const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;
        (0, _uuid_js_1.assertUuid)(_datasetId);
        const body = JSON.stringify(update);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/datasets/${_datasetId}`, {
            method: "PATCH",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await (0, error_js_1.raiseForStatus)(res, "update dataset");
          return res;
        });
        return await response.json();
      }
      /**
       * Updates a tag on a dataset.
       *
       * If the tag is already assigned to a different version of this dataset,
       * the tag will be moved to the new version. The as_of parameter is used to
       * determine which version of the dataset to apply the new tags to.
       *
       * It must be an exact version of the dataset to succeed. You can
       * use the "readDatasetVersion" method to find the exact version
       * to apply the tags to.
       * @param params.datasetId The ID of the dataset to update. Must be provided if "datasetName" is not provided.
       * @param params.datasetName The name of the dataset to update. Must be provided if "datasetId" is not provided.
       * @param params.asOf The timestamp of the dataset to apply the new tags to.
       * @param params.tag The new tag to apply to the dataset.
       */
      async updateDatasetTag(props) {
        const { datasetId, datasetName, asOf, tag } = props;
        if (!datasetId && !datasetName) {
          throw new Error("Must provide either datasetName or datasetId");
        }
        const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;
        (0, _uuid_js_1.assertUuid)(_datasetId);
        const body = JSON.stringify({
          as_of: typeof asOf === "string" ? asOf : asOf.toISOString(),
          tag
        });
        await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/datasets/${_datasetId}/tags`, {
            method: "PUT",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await (0, error_js_1.raiseForStatus)(res, "update dataset tags", true);
          return res;
        });
      }
      async deleteDataset({ datasetId, datasetName }) {
        let path = "/datasets";
        let datasetId_ = datasetId;
        if (datasetId !== void 0 && datasetName !== void 0) {
          throw new Error("Must provide either datasetName or datasetId, not both");
        } else if (datasetName !== void 0) {
          const dataset = await this.readDataset({ datasetName });
          datasetId_ = dataset.id;
        }
        if (datasetId_ !== void 0) {
          (0, _uuid_js_1.assertUuid)(datasetId_);
          path += `/${datasetId_}`;
        } else {
          throw new Error("Must provide datasetName or datasetId");
        }
        await this.caller.call(async () => {
          const res = await this._fetch(this.apiUrl + path, {
            method: "DELETE",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await (0, error_js_1.raiseForStatus)(res, `delete ${path}`, true);
          return res;
        });
      }
      async indexDataset({ datasetId, datasetName, tag }) {
        let datasetId_ = datasetId;
        if (!datasetId_ && !datasetName) {
          throw new Error("Must provide either datasetName or datasetId");
        } else if (datasetId_ && datasetName) {
          throw new Error("Must provide either datasetName or datasetId, not both");
        } else if (!datasetId_) {
          const dataset = await this.readDataset({ datasetName });
          datasetId_ = dataset.id;
        }
        (0, _uuid_js_1.assertUuid)(datasetId_);
        const data = {
          tag
        };
        const body = JSON.stringify(data);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId_}/index`, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await (0, error_js_1.raiseForStatus)(res, "index dataset");
          return res;
        });
        await response.json();
      }
      /**
       * Lets you run a similarity search query on a dataset.
       *
       * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.
       *
       * @param inputs      The input on which to run the similarity search. Must have the
       *                    same schema as the dataset.
       *
       * @param datasetId   The dataset to search for similar examples.
       *
       * @param limit       The maximum number of examples to return. Will return the top `limit` most
       *                    similar examples in order of most similar to least similar. If no similar
       *                    examples are found, random examples will be returned.
       *
       * @param filter      A filter string to apply to the search. Only examples will be returned that
       *                    match the filter string. Some examples of filters
       *
       *                    - eq(metadata.mykey, "value")
       *                    - and(neq(metadata.my.nested.key, "value"), neq(metadata.mykey, "value"))
       *                    - or(eq(metadata.mykey, "value"), eq(metadata.mykey, "othervalue"))
       *
       * @returns           A list of similar examples.
       *
       *
       * @example
       * dataset_id = "123e4567-e89b-12d3-a456-426614174000"
       * inputs = {"text": "How many people live in Berlin?"}
       * limit = 5
       * examples = await client.similarExamples(inputs, dataset_id, limit)
       */
      async similarExamples(inputs, datasetId, limit, { filter } = {}) {
        const data = {
          limit,
          inputs
        };
        if (filter !== void 0) {
          data["filter"] = filter;
        }
        (0, _uuid_js_1.assertUuid)(datasetId);
        const body = JSON.stringify(data);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/search`, {
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            method: "POST",
            body
          });
          await (0, error_js_1.raiseForStatus)(res, "fetch similar examples");
          return res;
        });
        const result = await response.json();
        return result["examples"];
      }
      async createExample(inputsOrUpdate, outputs, options) {
        if (isExampleCreate(inputsOrUpdate)) {
          if (outputs !== void 0 || options !== void 0) {
            throw new Error("Cannot provide outputs or options when using ExampleCreate object");
          }
        }
        let datasetId_ = outputs ? options?.datasetId : inputsOrUpdate.dataset_id;
        const datasetName_ = outputs ? options?.datasetName : inputsOrUpdate.dataset_name;
        if (datasetId_ === void 0 && datasetName_ === void 0) {
          throw new Error("Must provide either datasetName or datasetId");
        } else if (datasetId_ !== void 0 && datasetName_ !== void 0) {
          throw new Error("Must provide either datasetName or datasetId, not both");
        } else if (datasetId_ === void 0) {
          const dataset = await this.readDataset({ datasetName: datasetName_ });
          datasetId_ = dataset.id;
        }
        const createdAt_ = (outputs ? options?.createdAt : inputsOrUpdate.created_at) || /* @__PURE__ */ new Date();
        let data;
        if (!isExampleCreate(inputsOrUpdate)) {
          data = {
            inputs: inputsOrUpdate,
            outputs,
            created_at: createdAt_?.toISOString(),
            id: options?.exampleId,
            metadata: options?.metadata,
            split: options?.split,
            source_run_id: options?.sourceRunId,
            use_source_run_io: options?.useSourceRunIO,
            use_source_run_attachments: options?.useSourceRunAttachments,
            attachments: options?.attachments
          };
        } else {
          data = inputsOrUpdate;
        }
        const response = await this._uploadExamplesMultipart(datasetId_, [data]);
        const example = await this.readExample(response.example_ids?.[0] ?? uuid.v4());
        return example;
      }
      async createExamples(propsOrUploads) {
        if (Array.isArray(propsOrUploads)) {
          if (propsOrUploads.length === 0) {
            return [];
          }
          const uploads = propsOrUploads;
          let datasetId_2 = uploads[0].dataset_id;
          const datasetName_2 = uploads[0].dataset_name;
          if (datasetId_2 === void 0 && datasetName_2 === void 0) {
            throw new Error("Must provide either datasetName or datasetId");
          } else if (datasetId_2 !== void 0 && datasetName_2 !== void 0) {
            throw new Error("Must provide either datasetName or datasetId, not both");
          } else if (datasetId_2 === void 0) {
            const dataset = await this.readDataset({ datasetName: datasetName_2 });
            datasetId_2 = dataset.id;
          }
          const response2 = await this._uploadExamplesMultipart(datasetId_2, uploads);
          const examples2 = await Promise.all(response2.example_ids.map((id) => this.readExample(id)));
          return examples2;
        }
        const { inputs, outputs, metadata, splits, sourceRunIds, useSourceRunIOs, useSourceRunAttachments, attachments, exampleIds, datasetId, datasetName } = propsOrUploads;
        if (inputs === void 0) {
          throw new Error("Must provide inputs when using legacy parameters");
        }
        let datasetId_ = datasetId;
        const datasetName_ = datasetName;
        if (datasetId_ === void 0 && datasetName_ === void 0) {
          throw new Error("Must provide either datasetName or datasetId");
        } else if (datasetId_ !== void 0 && datasetName_ !== void 0) {
          throw new Error("Must provide either datasetName or datasetId, not both");
        } else if (datasetId_ === void 0) {
          const dataset = await this.readDataset({ datasetName: datasetName_ });
          datasetId_ = dataset.id;
        }
        const formattedExamples = inputs.map((input, idx) => {
          return {
            dataset_id: datasetId_,
            inputs: input,
            outputs: outputs?.[idx],
            metadata: metadata?.[idx],
            split: splits?.[idx],
            id: exampleIds?.[idx],
            attachments: attachments?.[idx],
            source_run_id: sourceRunIds?.[idx],
            use_source_run_io: useSourceRunIOs?.[idx],
            use_source_run_attachments: useSourceRunAttachments?.[idx]
          };
        });
        const response = await this._uploadExamplesMultipart(datasetId_, formattedExamples);
        const examples = await Promise.all(response.example_ids.map((id) => this.readExample(id)));
        return examples;
      }
      async createLLMExample(input, generation, options) {
        return this.createExample({ input }, { output: generation }, options);
      }
      async createChatExample(input, generations, options) {
        const finalInput = input.map((message) => {
          if ((0, messages_js_1.isLangChainMessage)(message)) {
            return (0, messages_js_1.convertLangChainMessageToExample)(message);
          }
          return message;
        });
        const finalOutput = (0, messages_js_1.isLangChainMessage)(generations) ? (0, messages_js_1.convertLangChainMessageToExample)(generations) : generations;
        return this.createExample({ input: finalInput }, { output: finalOutput }, options);
      }
      async readExample(exampleId) {
        (0, _uuid_js_1.assertUuid)(exampleId);
        const path = `/examples/${exampleId}`;
        const rawExample = await this._get(path);
        const { attachment_urls, ...rest } = rawExample;
        const example = rest;
        if (attachment_urls) {
          example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {
            acc[key.slice("attachment.".length)] = {
              presigned_url: value.presigned_url,
              mime_type: value.mime_type
            };
            return acc;
          }, {});
        }
        return example;
      }
      async *listExamples({ datasetId, datasetName, exampleIds, asOf, splits, inlineS3Urls, metadata, limit, offset, filter, includeAttachments } = {}) {
        let datasetId_;
        if (datasetId !== void 0 && datasetName !== void 0) {
          throw new Error("Must provide either datasetName or datasetId, not both");
        } else if (datasetId !== void 0) {
          datasetId_ = datasetId;
        } else if (datasetName !== void 0) {
          const dataset = await this.readDataset({ datasetName });
          datasetId_ = dataset.id;
        } else {
          throw new Error("Must provide a datasetName or datasetId");
        }
        const params = new URLSearchParams({ dataset: datasetId_ });
        const dataset_version = asOf ? typeof asOf === "string" ? asOf : asOf?.toISOString() : void 0;
        if (dataset_version) {
          params.append("as_of", dataset_version);
        }
        const inlineS3Urls_ = inlineS3Urls ?? true;
        params.append("inline_s3_urls", inlineS3Urls_.toString());
        if (exampleIds !== void 0) {
          for (const id_ of exampleIds) {
            params.append("id", id_);
          }
        }
        if (splits !== void 0) {
          for (const split of splits) {
            params.append("splits", split);
          }
        }
        if (metadata !== void 0) {
          const serializedMetadata = JSON.stringify(metadata);
          params.append("metadata", serializedMetadata);
        }
        if (limit !== void 0) {
          params.append("limit", limit.toString());
        }
        if (offset !== void 0) {
          params.append("offset", offset.toString());
        }
        if (filter !== void 0) {
          params.append("filter", filter);
        }
        if (includeAttachments === true) {
          ["attachment_urls", "outputs", "metadata"].forEach((field) => params.append("select", field));
        }
        let i = 0;
        for await (const rawExamples of this._getPaginated("/examples", params)) {
          for (const rawExample of rawExamples) {
            const { attachment_urls, ...rest } = rawExample;
            const example = rest;
            if (attachment_urls) {
              example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {
                acc[key.slice("attachment.".length)] = {
                  presigned_url: value.presigned_url,
                  mime_type: value.mime_type || void 0
                };
                return acc;
              }, {});
            }
            yield example;
            i++;
          }
          if (limit !== void 0 && i >= limit) {
            break;
          }
        }
      }
      async deleteExample(exampleId) {
        (0, _uuid_js_1.assertUuid)(exampleId);
        const path = `/examples/${exampleId}`;
        await this.caller.call(async () => {
          const res = await this._fetch(this.apiUrl + path, {
            method: "DELETE",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await (0, error_js_1.raiseForStatus)(res, `delete ${path}`, true);
          return res;
        });
      }
      async updateExample(exampleIdOrUpdate, update) {
        let exampleId;
        if (update) {
          exampleId = exampleIdOrUpdate;
        } else {
          exampleId = exampleIdOrUpdate.id;
        }
        (0, _uuid_js_1.assertUuid)(exampleId);
        let updateToUse;
        if (update) {
          updateToUse = { id: exampleId, ...update };
        } else {
          updateToUse = exampleIdOrUpdate;
        }
        let datasetId;
        if (updateToUse.dataset_id !== void 0) {
          datasetId = updateToUse.dataset_id;
        } else {
          const example = await this.readExample(exampleId);
          datasetId = example.dataset_id;
        }
        return this._updateExamplesMultipart(datasetId, [updateToUse]);
      }
      async updateExamples(update) {
        let datasetId;
        if (update[0].dataset_id === void 0) {
          const example = await this.readExample(update[0].id);
          datasetId = example.dataset_id;
        } else {
          datasetId = update[0].dataset_id;
        }
        return this._updateExamplesMultipart(datasetId, update);
      }
      /**
       * Get dataset version by closest date or exact tag.
       *
       * Use this to resolve the nearest version to a given timestamp or for a given tag.
       *
       * @param options The options for getting the dataset version
       * @param options.datasetId The ID of the dataset
       * @param options.datasetName The name of the dataset
       * @param options.asOf The timestamp of the dataset to retrieve
       * @param options.tag The tag of the dataset to retrieve
       * @returns The dataset version
       */
      async readDatasetVersion({ datasetId, datasetName, asOf, tag }) {
        let resolvedDatasetId;
        if (!datasetId) {
          const dataset = await this.readDataset({ datasetName });
          resolvedDatasetId = dataset.id;
        } else {
          resolvedDatasetId = datasetId;
        }
        (0, _uuid_js_1.assertUuid)(resolvedDatasetId);
        if (asOf && tag || !asOf && !tag) {
          throw new Error("Exactly one of asOf and tag must be specified.");
        }
        const params = new URLSearchParams();
        if (asOf !== void 0) {
          params.append("as_of", typeof asOf === "string" ? asOf : asOf.toISOString());
        }
        if (tag !== void 0) {
          params.append("tag", tag);
        }
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/datasets/${resolvedDatasetId}/version?${params.toString()}`, {
            method: "GET",
            headers: { ...this.headers },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await (0, error_js_1.raiseForStatus)(res, "read dataset version");
          return res;
        });
        return await response.json();
      }
      async listDatasetSplits({ datasetId, datasetName, asOf }) {
        let datasetId_;
        if (datasetId === void 0 && datasetName === void 0) {
          throw new Error("Must provide dataset name or ID");
        } else if (datasetId !== void 0 && datasetName !== void 0) {
          throw new Error("Must provide either datasetName or datasetId, not both");
        } else if (datasetId === void 0) {
          const dataset = await this.readDataset({ datasetName });
          datasetId_ = dataset.id;
        } else {
          datasetId_ = datasetId;
        }
        (0, _uuid_js_1.assertUuid)(datasetId_);
        const params = new URLSearchParams();
        const dataset_version = asOf ? typeof asOf === "string" ? asOf : asOf?.toISOString() : void 0;
        if (dataset_version) {
          params.append("as_of", dataset_version);
        }
        const response = await this._get(`/datasets/${datasetId_}/splits`, params);
        return response;
      }
      async updateDatasetSplits({ datasetId, datasetName, splitName, exampleIds, remove = false }) {
        let datasetId_;
        if (datasetId === void 0 && datasetName === void 0) {
          throw new Error("Must provide dataset name or ID");
        } else if (datasetId !== void 0 && datasetName !== void 0) {
          throw new Error("Must provide either datasetName or datasetId, not both");
        } else if (datasetId === void 0) {
          const dataset = await this.readDataset({ datasetName });
          datasetId_ = dataset.id;
        } else {
          datasetId_ = datasetId;
        }
        (0, _uuid_js_1.assertUuid)(datasetId_);
        const data = {
          split_name: splitName,
          examples: exampleIds.map((id) => {
            (0, _uuid_js_1.assertUuid)(id);
            return id;
          }),
          remove
        };
        const body = JSON.stringify(data);
        await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId_}/splits`, {
            method: "PUT",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await (0, error_js_1.raiseForStatus)(res, "update dataset splits", true);
          return res;
        });
      }
      /**
       * @deprecated This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.
       */
      async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample } = { loadChildRuns: false }) {
        (0, warn_js_1.warnOnce)("This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.");
        let run_;
        if (typeof run === "string") {
          run_ = await this.readRun(run, { loadChildRuns });
        } else if (typeof run === "object" && "id" in run) {
          run_ = run;
        } else {
          throw new Error(`Invalid run type: ${typeof run}`);
        }
        if (run_.reference_example_id !== null && run_.reference_example_id !== void 0) {
          referenceExample = await this.readExample(run_.reference_example_id);
        }
        const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);
        const [_, feedbacks] = await this._logEvaluationFeedback(feedbackResult, run_, sourceInfo);
        return feedbacks[0];
      }
      async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = "api", sourceRunId, feedbackId, feedbackConfig, projectId, comparativeExperimentId }) {
        if (!runId && !projectId) {
          throw new Error("One of runId or projectId must be provided");
        }
        if (runId && projectId) {
          throw new Error("Only one of runId or projectId can be provided");
        }
        const feedback_source = {
          type: feedbackSourceType ?? "api",
          metadata: sourceInfo ?? {}
        };
        if (sourceRunId !== void 0 && feedback_source?.metadata !== void 0 && !feedback_source.metadata["__run"]) {
          feedback_source.metadata["__run"] = { run_id: sourceRunId };
        }
        if (feedback_source?.metadata !== void 0 && feedback_source.metadata["__run"]?.run_id !== void 0) {
          (0, _uuid_js_1.assertUuid)(feedback_source.metadata["__run"].run_id);
        }
        const feedback = {
          id: feedbackId ?? uuid.v4(),
          run_id: runId,
          key,
          score: _formatFeedbackScore(score),
          value,
          correction,
          comment,
          feedback_source,
          comparative_experiment_id: comparativeExperimentId,
          feedbackConfig,
          session_id: projectId
        };
        const body = JSON.stringify(feedback);
        const url = `${this.apiUrl}/feedback`;
        await this.caller.call(async () => {
          const res = await this._fetch(url, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await (0, error_js_1.raiseForStatus)(res, "create feedback", true);
          return res;
        });
        return feedback;
      }
      async updateFeedback(feedbackId, { score, value, correction, comment }) {
        const feedbackUpdate = {};
        if (score !== void 0 && score !== null) {
          feedbackUpdate["score"] = _formatFeedbackScore(score);
        }
        if (value !== void 0 && value !== null) {
          feedbackUpdate["value"] = value;
        }
        if (correction !== void 0 && correction !== null) {
          feedbackUpdate["correction"] = correction;
        }
        if (comment !== void 0 && comment !== null) {
          feedbackUpdate["comment"] = comment;
        }
        (0, _uuid_js_1.assertUuid)(feedbackId);
        const body = JSON.stringify(feedbackUpdate);
        await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/feedback/${feedbackId}`, {
            method: "PATCH",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await (0, error_js_1.raiseForStatus)(res, "update feedback", true);
          return res;
        });
      }
      async readFeedback(feedbackId) {
        (0, _uuid_js_1.assertUuid)(feedbackId);
        const path = `/feedback/${feedbackId}`;
        const response = await this._get(path);
        return response;
      }
      async deleteFeedback(feedbackId) {
        (0, _uuid_js_1.assertUuid)(feedbackId);
        const path = `/feedback/${feedbackId}`;
        await this.caller.call(async () => {
          const res = await this._fetch(this.apiUrl + path, {
            method: "DELETE",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await (0, error_js_1.raiseForStatus)(res, `delete ${path}`, true);
          return res;
        });
      }
      async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes } = {}) {
        const queryParams = new URLSearchParams();
        if (runIds) {
          for (const runId of runIds) {
            (0, _uuid_js_1.assertUuid)(runId);
            queryParams.append("run", runId);
          }
        }
        if (feedbackKeys) {
          for (const key of feedbackKeys) {
            queryParams.append("key", key);
          }
        }
        if (feedbackSourceTypes) {
          for (const type of feedbackSourceTypes) {
            queryParams.append("source", type);
          }
        }
        for await (const feedbacks of this._getPaginated("/feedback", queryParams)) {
          yield* feedbacks;
        }
      }
      /**
       * Creates a presigned feedback token and URL.
       *
       * The token can be used to authorize feedback metrics without
       * needing an API key. This is useful for giving browser-based
       * applications the ability to submit feedback without needing
       * to expose an API key.
       *
       * @param runId The ID of the run.
       * @param feedbackKey The feedback key.
       * @param options Additional options for the token.
       * @param options.expiration The expiration time for the token.
       *
       * @returns A promise that resolves to a FeedbackIngestToken.
       */
      async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig } = {}) {
        const body = {
          run_id: runId,
          feedback_key: feedbackKey,
          feedback_config: feedbackConfig
        };
        if (expiration) {
          if (typeof expiration === "string") {
            body["expires_at"] = expiration;
          } else if (expiration?.hours || expiration?.minutes || expiration?.days) {
            body["expires_in"] = expiration;
          }
        } else {
          body["expires_in"] = {
            hours: 3
          };
        }
        const serializedBody = JSON.stringify(body);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/feedback/tokens`, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body: serializedBody
          });
          await (0, error_js_1.raiseForStatus)(res, "create presigned feedback token");
          return res;
        });
        return await response.json();
      }
      async createComparativeExperiment({ name, experimentIds, referenceDatasetId, createdAt, description, metadata, id }) {
        if (experimentIds.length === 0) {
          throw new Error("At least one experiment is required");
        }
        if (!referenceDatasetId) {
          referenceDatasetId = (await this.readProject({
            projectId: experimentIds[0]
          })).reference_dataset_id;
        }
        if (!referenceDatasetId == null) {
          throw new Error("A reference dataset is required");
        }
        const body = {
          id,
          name,
          experiment_ids: experimentIds,
          reference_dataset_id: referenceDatasetId,
          description,
          created_at: (createdAt ?? /* @__PURE__ */ new Date())?.toISOString(),
          extra: {}
        };
        if (metadata)
          body.extra["metadata"] = metadata;
        const serializedBody = JSON.stringify(body);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/datasets/comparative`, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body: serializedBody
          });
          await (0, error_js_1.raiseForStatus)(res, "create comparative experiment");
          return res;
        });
        return response.json();
      }
      /**
       * Retrieves a list of presigned feedback tokens for a given run ID.
       * @param runId The ID of the run.
       * @returns An async iterable of FeedbackIngestToken objects.
       */
      async *listPresignedFeedbackTokens(runId) {
        (0, _uuid_js_1.assertUuid)(runId);
        const params = new URLSearchParams({ run_id: runId });
        for await (const tokens of this._getPaginated("/feedback/tokens", params)) {
          yield* tokens;
        }
      }
      _selectEvalResults(results) {
        let results_;
        if ("results" in results) {
          results_ = results.results;
        } else if (Array.isArray(results)) {
          results_ = results;
        } else {
          results_ = [results];
        }
        return results_;
      }
      async _logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {
        const evalResults = this._selectEvalResults(evaluatorResponse);
        const feedbacks = [];
        for (const res of evalResults) {
          let sourceInfo_ = sourceInfo || {};
          if (res.evaluatorInfo) {
            sourceInfo_ = { ...res.evaluatorInfo, ...sourceInfo_ };
          }
          let runId_ = null;
          if (res.targetRunId) {
            runId_ = res.targetRunId;
          } else if (run) {
            runId_ = run.id;
          }
          feedbacks.push(await this.createFeedback(runId_, res.key, {
            score: res.score,
            value: res.value,
            comment: res.comment,
            correction: res.correction,
            sourceInfo: sourceInfo_,
            sourceRunId: res.sourceRunId,
            feedbackConfig: res.feedbackConfig,
            feedbackSourceType: "model"
          }));
        }
        return [evalResults, feedbacks];
      }
      async logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {
        const [results] = await this._logEvaluationFeedback(evaluatorResponse, run, sourceInfo);
        return results;
      }
      /**
       * API for managing annotation queues
       */
      /**
       * List the annotation queues on the LangSmith API.
       * @param options - The options for listing annotation queues
       * @param options.queueIds - The IDs of the queues to filter by
       * @param options.name - The name of the queue to filter by
       * @param options.nameContains - The substring that the queue name should contain
       * @param options.limit - The maximum number of queues to return
       * @returns An iterator of AnnotationQueue objects
       */
      async *listAnnotationQueues(options = {}) {
        const { queueIds, name, nameContains, limit } = options;
        const params = new URLSearchParams();
        if (queueIds) {
          queueIds.forEach((id, i) => {
            (0, _uuid_js_1.assertUuid)(id, `queueIds[${i}]`);
            params.append("ids", id);
          });
        }
        if (name)
          params.append("name", name);
        if (nameContains)
          params.append("name_contains", nameContains);
        params.append("limit", (limit !== void 0 ? Math.min(limit, 100) : 100).toString());
        let count = 0;
        for await (const queues of this._getPaginated("/annotation-queues", params)) {
          yield* queues;
          count++;
          if (limit !== void 0 && count >= limit)
            break;
        }
      }
      /**
       * Create an annotation queue on the LangSmith API.
       * @param options - The options for creating an annotation queue
       * @param options.name - The name of the annotation queue
       * @param options.description - The description of the annotation queue
       * @param options.queueId - The ID of the annotation queue
       * @returns The created AnnotationQueue object
       */
      async createAnnotationQueue(options) {
        const { name, description, queueId, rubricInstructions } = options;
        const body = {
          name,
          description,
          id: queueId || uuid.v4(),
          rubric_instructions: rubricInstructions
        };
        const serializedBody = JSON.stringify(Object.fromEntries(Object.entries(body).filter(([_, v]) => v !== void 0)));
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/annotation-queues`, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body: serializedBody
          });
          await (0, error_js_1.raiseForStatus)(res, "create annotation queue");
          return res;
        });
        return response.json();
      }
      /**
       * Read an annotation queue with the specified queue ID.
       * @param queueId - The ID of the annotation queue to read
       * @returns The AnnotationQueueWithDetails object
       */
      async readAnnotationQueue(queueId) {
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0, _uuid_js_1.assertUuid)(queueId, "queueId")}`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await (0, error_js_1.raiseForStatus)(res, "read annotation queue");
          return res;
        });
        return response.json();
      }
      /**
       * Update an annotation queue with the specified queue ID.
       * @param queueId - The ID of the annotation queue to update
       * @param options - The options for updating the annotation queue
       * @param options.name - The new name for the annotation queue
       * @param options.description - The new description for the annotation queue
       */
      async updateAnnotationQueue(queueId, options) {
        const { name, description, rubricInstructions } = options;
        const body = JSON.stringify({
          name,
          description,
          rubric_instructions: rubricInstructions
        });
        await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0, _uuid_js_1.assertUuid)(queueId, "queueId")}`, {
            method: "PATCH",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await (0, error_js_1.raiseForStatus)(res, "update annotation queue", true);
          return res;
        });
      }
      /**
       * Delete an annotation queue with the specified queue ID.
       * @param queueId - The ID of the annotation queue to delete
       */
      async deleteAnnotationQueue(queueId) {
        await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0, _uuid_js_1.assertUuid)(queueId, "queueId")}`, {
            method: "DELETE",
            headers: { ...this.headers, Accept: "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await (0, error_js_1.raiseForStatus)(res, "delete annotation queue", true);
          return res;
        });
      }
      /**
       * Add runs to an annotation queue with the specified queue ID.
       * @param queueId - The ID of the annotation queue
       * @param runIds - The IDs of the runs to be added to the annotation queue
       */
      async addRunsToAnnotationQueue(queueId, runIds) {
        const body = JSON.stringify(runIds.map((id, i) => (0, _uuid_js_1.assertUuid)(id, `runIds[${i}]`).toString()));
        await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0, _uuid_js_1.assertUuid)(queueId, "queueId")}/runs`, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await (0, error_js_1.raiseForStatus)(res, "add runs to annotation queue", true);
          return res;
        });
      }
      /**
       * Get a run from an annotation queue at the specified index.
       * @param queueId - The ID of the annotation queue
       * @param index - The index of the run to retrieve
       * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object
       * @throws {Error} If the run is not found at the given index or for other API-related errors
       */
      async getRunFromAnnotationQueue(queueId, index) {
        const baseUrl = `/annotation-queues/${(0, _uuid_js_1.assertUuid)(queueId, "queueId")}/run`;
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}${baseUrl}/${index}`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await (0, error_js_1.raiseForStatus)(res, "get run from annotation queue");
          return res;
        });
        return response.json();
      }
      /**
       * Delete a run from an an annotation queue.
       * @param queueId - The ID of the annotation queue to delete the run from
       * @param queueRunId - The ID of the run to delete from the annotation queue
       */
      async deleteRunFromAnnotationQueue(queueId, queueRunId) {
        await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0, _uuid_js_1.assertUuid)(queueId, "queueId")}/runs/${(0, _uuid_js_1.assertUuid)(queueRunId, "queueRunId")}`, {
            method: "DELETE",
            headers: { ...this.headers, Accept: "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await (0, error_js_1.raiseForStatus)(res, "delete run from annotation queue", true);
          return res;
        });
      }
      /**
       * Get the size of an annotation queue.
       * @param queueId - The ID of the annotation queue
       */
      async getSizeFromAnnotationQueue(queueId) {
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0, _uuid_js_1.assertUuid)(queueId, "queueId")}/size`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await (0, error_js_1.raiseForStatus)(res, "get size from annotation queue");
          return res;
        });
        return response.json();
      }
      async _currentTenantIsOwner(owner) {
        const settings = await this._getSettings();
        return owner == "-" || settings.tenant_handle === owner;
      }
      async _ownerConflictError(action, owner) {
        const settings = await this._getSettings();
        return new Error(`Cannot ${action} for another tenant.

      Current tenant: ${settings.tenant_handle}

      Requested tenant: ${owner}`);
      }
      async _getLatestCommitHash(promptOwnerAndName) {
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/commits/${promptOwnerAndName}/?limit=${1}&offset=${0}`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await (0, error_js_1.raiseForStatus)(res, "get latest commit hash");
          return res;
        });
        const json = await response.json();
        if (json.commits.length === 0) {
          return void 0;
        }
        return json.commits[0].commit_hash;
      }
      async _likeOrUnlikePrompt(promptIdentifier, like) {
        const [owner, promptName, _] = (0, prompts_js_1.parsePromptIdentifier)(promptIdentifier);
        const body = JSON.stringify({ like });
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/likes/${owner}/${promptName}`, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await (0, error_js_1.raiseForStatus)(res, `${like ? "like" : "unlike"} prompt`);
          return res;
        });
        return response.json();
      }
      async _getPromptUrl(promptIdentifier) {
        const [owner, promptName, commitHash] = (0, prompts_js_1.parsePromptIdentifier)(promptIdentifier);
        if (!await this._currentTenantIsOwner(owner)) {
          if (commitHash !== "latest") {
            return `${this.getHostUrl()}/hub/${owner}/${promptName}/${commitHash.substring(0, 8)}`;
          } else {
            return `${this.getHostUrl()}/hub/${owner}/${promptName}`;
          }
        } else {
          const settings = await this._getSettings();
          if (commitHash !== "latest") {
            return `${this.getHostUrl()}/prompts/${promptName}/${commitHash.substring(0, 8)}?organizationId=${settings.id}`;
          } else {
            return `${this.getHostUrl()}/prompts/${promptName}?organizationId=${settings.id}`;
          }
        }
      }
      async promptExists(promptIdentifier) {
        const prompt = await this.getPrompt(promptIdentifier);
        return !!prompt;
      }
      async likePrompt(promptIdentifier) {
        return this._likeOrUnlikePrompt(promptIdentifier, true);
      }
      async unlikePrompt(promptIdentifier) {
        return this._likeOrUnlikePrompt(promptIdentifier, false);
      }
      async *listCommits(promptOwnerAndName) {
        for await (const commits of this._getPaginated(`/commits/${promptOwnerAndName}/`, new URLSearchParams(), (res) => res.commits)) {
          yield* commits;
        }
      }
      async *listPrompts(options) {
        const params = new URLSearchParams();
        params.append("sort_field", options?.sortField ?? "updated_at");
        params.append("sort_direction", "desc");
        params.append("is_archived", (!!options?.isArchived).toString());
        if (options?.isPublic !== void 0) {
          params.append("is_public", options.isPublic.toString());
        }
        if (options?.query) {
          params.append("query", options.query);
        }
        for await (const prompts of this._getPaginated("/repos", params, (res) => res.repos)) {
          yield* prompts;
        }
      }
      async getPrompt(promptIdentifier) {
        const [owner, promptName, _] = (0, prompts_js_1.parsePromptIdentifier)(promptIdentifier);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          if (res?.status === 404) {
            return null;
          }
          await (0, error_js_1.raiseForStatus)(res, "get prompt");
          return res;
        });
        const result = await response?.json();
        if (result?.repo) {
          return result.repo;
        } else {
          return null;
        }
      }
      async createPrompt(promptIdentifier, options) {
        const settings = await this._getSettings();
        if (options?.isPublic && !settings.tenant_handle) {
          throw new Error(`Cannot create a public prompt without first

        creating a LangChain Hub handle.
        You can add a handle by creating a public prompt at:

        https://smith.langchain.com/prompts`);
        }
        const [owner, promptName, _] = (0, prompts_js_1.parsePromptIdentifier)(promptIdentifier);
        if (!await this._currentTenantIsOwner(owner)) {
          throw await this._ownerConflictError("create a prompt", owner);
        }
        const data = {
          repo_handle: promptName,
          ...options?.description && { description: options.description },
          ...options?.readme && { readme: options.readme },
          ...options?.tags && { tags: options.tags },
          is_public: !!options?.isPublic
        };
        const body = JSON.stringify(data);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/repos/`, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await (0, error_js_1.raiseForStatus)(res, "create prompt");
          return res;
        });
        const { repo } = await response.json();
        return repo;
      }
      async createCommit(promptIdentifier, object, options) {
        if (!await this.promptExists(promptIdentifier)) {
          throw new Error("Prompt does not exist, you must create it first.");
        }
        const [owner, promptName, _] = (0, prompts_js_1.parsePromptIdentifier)(promptIdentifier);
        const resolvedParentCommitHash = options?.parentCommitHash === "latest" || !options?.parentCommitHash ? await this._getLatestCommitHash(`${owner}/${promptName}`) : options?.parentCommitHash;
        const payload = {
          manifest: JSON.parse(JSON.stringify(object)),
          parent_commit: resolvedParentCommitHash
        };
        const body = JSON.stringify(payload);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/commits/${owner}/${promptName}`, {
            method: "POST",
            headers: { ...this.headers, "Content-Type": "application/json" },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await (0, error_js_1.raiseForStatus)(res, "create commit");
          return res;
        });
        const result = await response.json();
        return this._getPromptUrl(`${owner}/${promptName}${result.commit_hash ? `:${result.commit_hash}` : ""}`);
      }
      /**
       * Update examples with attachments using multipart form data.
       * @param updates List of ExampleUpdateWithAttachments objects to upsert
       * @returns Promise with the update response
       */
      async updateExamplesMultipart(datasetId, updates = []) {
        return this._updateExamplesMultipart(datasetId, updates);
      }
      async _updateExamplesMultipart(datasetId, updates = []) {
        if (!await this._getDatasetExamplesMultiPartSupport()) {
          throw new Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
        }
        const formData = new FormData();
        for (const example of updates) {
          const exampleId = example.id;
          const exampleBody = {
            ...example.metadata && { metadata: example.metadata },
            ...example.split && { split: example.split }
          };
          const stringifiedExample = (0, index_js_2.serialize)(exampleBody, `Serializing body for example with id: ${exampleId}`);
          const exampleBlob = new Blob([stringifiedExample], {
            type: "application/json"
          });
          formData.append(exampleId, exampleBlob);
          if (example.inputs) {
            const stringifiedInputs = (0, index_js_2.serialize)(example.inputs, `Serializing inputs for example with id: ${exampleId}`);
            const inputsBlob = new Blob([stringifiedInputs], {
              type: "application/json"
            });
            formData.append(`${exampleId}.inputs`, inputsBlob);
          }
          if (example.outputs) {
            const stringifiedOutputs = (0, index_js_2.serialize)(example.outputs, `Serializing outputs whle updating example with id: ${exampleId}`);
            const outputsBlob = new Blob([stringifiedOutputs], {
              type: "application/json"
            });
            formData.append(`${exampleId}.outputs`, outputsBlob);
          }
          if (example.attachments) {
            for (const [name, attachment] of Object.entries(example.attachments)) {
              let mimeType;
              let data;
              if (Array.isArray(attachment)) {
                [mimeType, data] = attachment;
              } else {
                mimeType = attachment.mimeType;
                data = attachment.data;
              }
              const attachmentBlob = new Blob([data], {
                type: `${mimeType}; length=${data.byteLength}`
              });
              formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);
            }
          }
          if (example.attachments_operations) {
            const stringifiedAttachmentsOperations = (0, index_js_2.serialize)(example.attachments_operations, `Serializing attachments while updating example with id: ${exampleId}`);
            const attachmentsOperationsBlob = new Blob([stringifiedAttachmentsOperations], {
              type: "application/json"
            });
            formData.append(`${exampleId}.attachments_operations`, attachmentsOperationsBlob);
          }
        }
        const datasetIdToUse = datasetId ?? updates[0]?.dataset_id;
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetIdToUse}/examples`)}`, {
            method: "PATCH",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body: formData
          });
          await (0, error_js_1.raiseForStatus)(res, "update examples");
          return res;
        });
        return response.json();
      }
      /**
       * Upload examples with attachments using multipart form data.
       * @param uploads List of ExampleUploadWithAttachments objects to upload
       * @returns Promise with the upload response
       * @deprecated This method is deprecated and will be removed in future LangSmith versions, please use `createExamples` instead
       */
      async uploadExamplesMultipart(datasetId, uploads = []) {
        return this._uploadExamplesMultipart(datasetId, uploads);
      }
      async _uploadExamplesMultipart(datasetId, uploads = []) {
        if (!await this._getDatasetExamplesMultiPartSupport()) {
          throw new Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
        }
        const formData = new FormData();
        for (const example of uploads) {
          const exampleId = (example.id ?? uuid.v4()).toString();
          const exampleBody = {
            created_at: example.created_at,
            ...example.metadata && { metadata: example.metadata },
            ...example.split && { split: example.split },
            ...example.source_run_id && { source_run_id: example.source_run_id },
            ...example.use_source_run_io && {
              use_source_run_io: example.use_source_run_io
            },
            ...example.use_source_run_attachments && {
              use_source_run_attachments: example.use_source_run_attachments
            }
          };
          const stringifiedExample = (0, index_js_2.serialize)(exampleBody, `Serializing body for uploaded example with id: ${exampleId}`);
          const exampleBlob = new Blob([stringifiedExample], {
            type: "application/json"
          });
          formData.append(exampleId, exampleBlob);
          if (example.inputs) {
            const stringifiedInputs = (0, index_js_2.serialize)(example.inputs, `Serializing inputs for uploaded example with id: ${exampleId}`);
            const inputsBlob = new Blob([stringifiedInputs], {
              type: "application/json"
            });
            formData.append(`${exampleId}.inputs`, inputsBlob);
          }
          if (example.outputs) {
            const stringifiedOutputs = (0, index_js_2.serialize)(example.outputs, `Serializing outputs for uploaded example with id: ${exampleId}`);
            const outputsBlob = new Blob([stringifiedOutputs], {
              type: "application/json"
            });
            formData.append(`${exampleId}.outputs`, outputsBlob);
          }
          if (example.attachments) {
            for (const [name, attachment] of Object.entries(example.attachments)) {
              let mimeType;
              let data;
              if (Array.isArray(attachment)) {
                [mimeType, data] = attachment;
              } else {
                mimeType = attachment.mimeType;
                data = attachment.data;
              }
              const attachmentBlob = new Blob([data], {
                type: `${mimeType}; length=${data.byteLength}`
              });
              formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);
            }
          }
        }
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetId}/examples`)}`, {
            method: "POST",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body: formData
          });
          await (0, error_js_1.raiseForStatus)(res, "upload examples");
          return res;
        });
        return response.json();
      }
      async updatePrompt(promptIdentifier, options) {
        if (!await this.promptExists(promptIdentifier)) {
          throw new Error("Prompt does not exist, you must create it first.");
        }
        const [owner, promptName] = (0, prompts_js_1.parsePromptIdentifier)(promptIdentifier);
        if (!await this._currentTenantIsOwner(owner)) {
          throw await this._ownerConflictError("update a prompt", owner);
        }
        const payload = {};
        if (options?.description !== void 0)
          payload.description = options.description;
        if (options?.readme !== void 0)
          payload.readme = options.readme;
        if (options?.tags !== void 0)
          payload.tags = options.tags;
        if (options?.isPublic !== void 0)
          payload.is_public = options.isPublic;
        if (options?.isArchived !== void 0)
          payload.is_archived = options.isArchived;
        if (Object.keys(payload).length === 0) {
          throw new Error("No valid update options provided");
        }
        const body = JSON.stringify(payload);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {
            method: "PATCH",
            headers: {
              ...this.headers,
              "Content-Type": "application/json"
            },
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions,
            body
          });
          await (0, error_js_1.raiseForStatus)(res, "update prompt");
          return res;
        });
        return response.json();
      }
      async deletePrompt(promptIdentifier) {
        if (!await this.promptExists(promptIdentifier)) {
          throw new Error("Prompt does not exist, you must create it first.");
        }
        const [owner, promptName, _] = (0, prompts_js_1.parsePromptIdentifier)(promptIdentifier);
        if (!await this._currentTenantIsOwner(owner)) {
          throw await this._ownerConflictError("delete a prompt", owner);
        }
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {
            method: "DELETE",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await (0, error_js_1.raiseForStatus)(res, "delete prompt");
          return res;
        });
        return response.json();
      }
      async pullPromptCommit(promptIdentifier, options) {
        const [owner, promptName, commitHash] = (0, prompts_js_1.parsePromptIdentifier)(promptIdentifier);
        const response = await this.caller.call(async () => {
          const res = await this._fetch(`${this.apiUrl}/commits/${owner}/${promptName}/${commitHash}${options?.includeModel ? "?include_model=true" : ""}`, {
            method: "GET",
            headers: this.headers,
            signal: AbortSignal.timeout(this.timeout_ms),
            ...this.fetchOptions
          });
          await (0, error_js_1.raiseForStatus)(res, "pull prompt commit");
          return res;
        });
        const result = await response.json();
        return {
          owner,
          repo: promptName,
          commit_hash: result.commit_hash,
          manifest: result.manifest,
          examples: result.examples
        };
      }
      /**
       * This method should not be used directly, use `import { pull } from "langchain/hub"` instead.
       * Using this method directly returns the JSON string of the prompt rather than a LangChain object.
       * @private
       */
      async _pullPrompt(promptIdentifier, options) {
        const promptObject = await this.pullPromptCommit(promptIdentifier, {
          includeModel: options?.includeModel
        });
        const prompt = JSON.stringify(promptObject.manifest);
        return prompt;
      }
      async pushPrompt(promptIdentifier, options) {
        if (await this.promptExists(promptIdentifier)) {
          if (options && Object.keys(options).some((key) => key !== "object")) {
            await this.updatePrompt(promptIdentifier, {
              description: options?.description,
              readme: options?.readme,
              tags: options?.tags,
              isPublic: options?.isPublic
            });
          }
        } else {
          await this.createPrompt(promptIdentifier, {
            description: options?.description,
            readme: options?.readme,
            tags: options?.tags,
            isPublic: options?.isPublic
          });
        }
        if (!options?.object) {
          return await this._getPromptUrl(promptIdentifier);
        }
        const url = await this.createCommit(promptIdentifier, options?.object, {
          parentCommitHash: options?.parentCommitHash
        });
        return url;
      }
      /**
         * Clone a public dataset to your own langsmith tenant.
         * This operation is idempotent. If you already have a dataset with the given name,
         * this function will do nothing.
      
         * @param {string} tokenOrUrl The token of the public dataset to clone.
         * @param {Object} [options] Additional options for cloning the dataset.
         * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.
         * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.
         * @returns {Promise<void>}
         */
      async clonePublicDataset(tokenOrUrl, options = {}) {
        const { sourceApiUrl = this.apiUrl, datasetName } = options;
        const [parsedApiUrl, tokenUuid] = this.parseTokenOrUrl(tokenOrUrl, sourceApiUrl);
        const sourceClient = new _Client({
          apiUrl: parsedApiUrl,
          // Placeholder API key not needed anymore in most cases, but
          // some private deployments may have API key-based rate limiting
          // that would cause this to fail if we provide no value.
          apiKey: "placeholder"
        });
        const ds = await sourceClient.readSharedDataset(tokenUuid);
        const finalDatasetName = datasetName || ds.name;
        try {
          if (await this.hasDataset({ datasetId: finalDatasetName })) {
            console.log(`Dataset ${finalDatasetName} already exists in your tenant. Skipping.`);
            return;
          }
        } catch (_) {
        }
        const examples = await sourceClient.listSharedExamples(tokenUuid);
        const dataset = await this.createDataset(finalDatasetName, {
          description: ds.description,
          dataType: ds.data_type || "kv",
          inputsSchema: ds.inputs_schema_definition ?? void 0,
          outputsSchema: ds.outputs_schema_definition ?? void 0
        });
        try {
          await this.createExamples({
            inputs: examples.map((e) => e.inputs),
            outputs: examples.flatMap((e) => e.outputs ? [e.outputs] : []),
            datasetId: dataset.id
          });
        } catch (e) {
          console.error(`An error occurred while creating dataset ${finalDatasetName}. You should delete it manually.`);
          throw e;
        }
      }
      parseTokenOrUrl(urlOrToken, apiUrl, numParts = 2, kind = "dataset") {
        try {
          (0, _uuid_js_1.assertUuid)(urlOrToken);
          return [apiUrl, urlOrToken];
        } catch (_) {
        }
        try {
          const parsedUrl = new URL(urlOrToken);
          const pathParts = parsedUrl.pathname.split("/").filter((part) => part !== "");
          if (pathParts.length >= numParts) {
            const tokenUuid = pathParts[pathParts.length - numParts];
            return [apiUrl, tokenUuid];
          } else {
            throw new Error(`Invalid public ${kind} URL: ${urlOrToken}`);
          }
        } catch (error) {
          throw new Error(`Invalid public ${kind} URL or token: ${urlOrToken}`);
        }
      }
      /**
       * Awaits all pending trace batches. Useful for environments where
       * you need to be sure that all tracing requests finish before execution ends,
       * such as serverless environments.
       *
       * @example
       * ```
       * import { Client } from "langsmith";
       *
       * const client = new Client();
       *
       * try {
       *   // Tracing happens here
       *   ...
       * } finally {
       *   await client.awaitPendingTraceBatches();
       * }
       * ```
       *
       * @returns A promise that resolves once all currently pending traces have sent.
       */
      async awaitPendingTraceBatches() {
        if (this.manualFlushMode) {
          console.warn("[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches.");
          return Promise.resolve();
        }
        await Promise.all([
          ...this.autoBatchQueue.items.map(({ itemPromise }) => itemPromise),
          this.batchIngestCaller.queue.onIdle()
        ]);
        if (this.langSmithToOTELTranslator !== void 0) {
          await (0, otel_js_1.getDefaultOTLPTracerComponents)()?.DEFAULT_LANGSMITH_SPAN_PROCESSOR?.forceFlush();
        }
      }
    };
    exports2.Client = Client;
    function isExampleCreate(input) {
      return "dataset_id" in input || "dataset_name" in input;
    }
  }
});

// node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/env.cjs
var require_env3 = __commonJS({
  "node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/env.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTracingEnabled = void 0;
    var env_js_1 = require_env2();
    var isTracingEnabled = (tracingEnabled) => {
      if (tracingEnabled !== void 0) {
        return tracingEnabled;
      }
      const envVars = ["TRACING_V2", "TRACING"];
      return !!envVars.find((envVar) => (0, env_js_1.getLangSmithEnvironmentVariable)(envVar) === "true");
    };
    exports2.isTracingEnabled = isTracingEnabled;
  }
});

// node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/singletons/constants.cjs
var require_constants3 = __commonJS({
  "node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/singletons/constants.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._LC_CONTEXT_VARIABLES_KEY = void 0;
    exports2._LC_CONTEXT_VARIABLES_KEY = Symbol.for("lc:context_variables");
  }
});

// node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/run_trees.cjs
var require_run_trees = __commonJS({
  "node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/run_trees.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RunTree = void 0;
    exports2.convertToDottedOrderFormat = convertToDottedOrderFormat;
    exports2.isRunTree = isRunTree;
    exports2.isRunnableConfigLike = isRunnableConfigLike;
    var uuid = __importStar((init_esm_node(), __toCommonJS(esm_node_exports)));
    var client_js_1 = require_client();
    var env_js_1 = require_env3();
    var error_js_1 = require_error();
    var constants_js_1 = require_constants3();
    var env_js_2 = require_env2();
    var project_js_1 = require_project();
    var env_js_3 = require_env2();
    var warn_js_1 = require_warn();
    function stripNonAlphanumeric(input) {
      return input.replace(/[-:.]/g, "");
    }
    function convertToDottedOrderFormat(epoch, runId, executionOrder = 1) {
      const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, "0");
      const microsecondPrecisionDatestring = `${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`;
      return {
        dottedOrder: stripNonAlphanumeric(microsecondPrecisionDatestring) + runId,
        microsecondPrecisionDatestring
      };
    }
    var Baggage = class _Baggage {
      constructor(metadata, tags, project_name, replicas) {
        Object.defineProperty(this, "metadata", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "tags", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "project_name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "replicas", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.metadata = metadata;
        this.tags = tags;
        this.project_name = project_name;
        this.replicas = replicas;
      }
      static fromHeader(value) {
        const items = value.split(",");
        let metadata = {};
        let tags = [];
        let project_name;
        let replicas;
        for (const item of items) {
          const [key, uriValue] = item.split("=");
          const value2 = decodeURIComponent(uriValue);
          if (key === "langsmith-metadata") {
            metadata = JSON.parse(value2);
          } else if (key === "langsmith-tags") {
            tags = value2.split(",");
          } else if (key === "langsmith-project") {
            project_name = value2;
          } else if (key === "langsmith-replicas") {
            replicas = JSON.parse(value2);
          }
        }
        return new _Baggage(metadata, tags, project_name, replicas);
      }
      toHeader() {
        const items = [];
        if (this.metadata && Object.keys(this.metadata).length > 0) {
          items.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`);
        }
        if (this.tags && this.tags.length > 0) {
          items.push(`langsmith-tags=${encodeURIComponent(this.tags.join(","))}`);
        }
        if (this.project_name) {
          items.push(`langsmith-project=${encodeURIComponent(this.project_name)}`);
        }
        return items.join(",");
      }
    };
    var RunTree = class _RunTree {
      constructor(originalConfig) {
        Object.defineProperty(this, "id", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "run_type", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "project_name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "parent_run", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "parent_run_id", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "child_runs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "start_time", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "end_time", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "extra", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "tags", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "error", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "serialized", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "inputs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "outputs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "reference_example_id", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "events", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "trace_id", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "dotted_order", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "tracingEnabled", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "execution_order", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "child_execution_order", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "attachments", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "replicas", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "_serialized_start_time", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        if (isRunTree(originalConfig)) {
          Object.assign(this, { ...originalConfig });
          return;
        }
        const defaultConfig2 = _RunTree.getDefaultConfig();
        const { metadata, ...config } = originalConfig;
        const client = config.client ?? _RunTree.getSharedClient();
        const dedupedMetadata = {
          ...metadata,
          ...config?.extra?.metadata
        };
        config.extra = { ...config.extra, metadata: dedupedMetadata };
        Object.assign(this, { ...defaultConfig2, ...config, client });
        if (!this.trace_id) {
          if (this.parent_run) {
            this.trace_id = this.parent_run.trace_id ?? this.id;
          } else {
            this.trace_id = this.id;
          }
        }
        this.replicas = _ensureWriteReplicas(this.replicas);
        this.execution_order ??= 1;
        this.child_execution_order ??= 1;
        if (!this.dotted_order) {
          const { dottedOrder, microsecondPrecisionDatestring } = convertToDottedOrderFormat(this.start_time, this.id, this.execution_order);
          if (this.parent_run) {
            this.dotted_order = this.parent_run.dotted_order + "." + dottedOrder;
          } else {
            this.dotted_order = dottedOrder;
          }
          this._serialized_start_time = microsecondPrecisionDatestring;
        }
      }
      set metadata(metadata) {
        this.extra = {
          ...this.extra,
          metadata: {
            ...this.extra?.metadata,
            ...metadata
          }
        };
      }
      get metadata() {
        return this.extra?.metadata;
      }
      static getDefaultConfig() {
        return {
          id: uuid.v4(),
          run_type: "chain",
          project_name: (0, project_js_1.getDefaultProjectName)(),
          child_runs: [],
          api_url: (0, env_js_2.getEnvironmentVariable)("LANGCHAIN_ENDPOINT") ?? "http://localhost:1984",
          api_key: (0, env_js_2.getEnvironmentVariable)("LANGCHAIN_API_KEY"),
          caller_options: {},
          start_time: Date.now(),
          serialized: {},
          inputs: {},
          extra: {}
        };
      }
      static getSharedClient() {
        if (!_RunTree.sharedClient) {
          _RunTree.sharedClient = new client_js_1.Client();
        }
        return _RunTree.sharedClient;
      }
      createChild(config) {
        const child_execution_order = this.child_execution_order + 1;
        const child = new _RunTree({
          ...config,
          parent_run: this,
          project_name: this.project_name,
          replicas: this.replicas,
          client: this.client,
          tracingEnabled: this.tracingEnabled,
          execution_order: child_execution_order,
          child_execution_order
        });
        if (constants_js_1._LC_CONTEXT_VARIABLES_KEY in this) {
          child[constants_js_1._LC_CONTEXT_VARIABLES_KEY] = this[constants_js_1._LC_CONTEXT_VARIABLES_KEY];
        }
        const LC_CHILD = Symbol.for("lc:child_config");
        const presentConfig = config.extra?.[LC_CHILD] ?? this.extra[LC_CHILD];
        if (isRunnableConfigLike(presentConfig)) {
          const newConfig = { ...presentConfig };
          const callbacks = isCallbackManagerLike(newConfig.callbacks) ? newConfig.callbacks.copy?.() : void 0;
          if (callbacks) {
            Object.assign(callbacks, { _parentRunId: child.id });
            callbacks.handlers?.find(isLangChainTracerLike)?.updateFromRunTree?.(child);
            newConfig.callbacks = callbacks;
          }
          child.extra[LC_CHILD] = newConfig;
        }
        const visited = /* @__PURE__ */ new Set();
        let current = this;
        while (current != null && !visited.has(current.id)) {
          visited.add(current.id);
          current.child_execution_order = Math.max(current.child_execution_order, child_execution_order);
          current = current.parent_run;
        }
        this.child_runs.push(child);
        return child;
      }
      async end(outputs, error, endTime = Date.now(), metadata) {
        this.outputs = this.outputs ?? outputs;
        this.error = this.error ?? error;
        this.end_time = this.end_time ?? endTime;
        if (metadata && Object.keys(metadata).length > 0) {
          this.extra = this.extra ? { ...this.extra, metadata: { ...this.extra.metadata, ...metadata } } : { metadata };
        }
      }
      _convertToCreate(run, runtimeEnv, excludeChildRuns = true) {
        const runExtra = run.extra ?? {};
        if (runExtra?.runtime?.library === void 0) {
          if (!runExtra.runtime) {
            runExtra.runtime = {};
          }
          if (runtimeEnv) {
            for (const [k, v] of Object.entries(runtimeEnv)) {
              if (!runExtra.runtime[k]) {
                runExtra.runtime[k] = v;
              }
            }
          }
        }
        let child_runs;
        let parent_run_id;
        if (!excludeChildRuns) {
          child_runs = run.child_runs.map((child_run) => this._convertToCreate(child_run, runtimeEnv, excludeChildRuns));
          parent_run_id = void 0;
        } else {
          parent_run_id = run.parent_run?.id ?? run.parent_run_id;
          child_runs = [];
        }
        return {
          id: run.id,
          name: run.name,
          start_time: run._serialized_start_time ?? run.start_time,
          end_time: run.end_time,
          run_type: run.run_type,
          reference_example_id: run.reference_example_id,
          extra: runExtra,
          serialized: run.serialized,
          error: run.error,
          inputs: run.inputs,
          outputs: run.outputs,
          session_name: run.project_name,
          child_runs,
          parent_run_id,
          trace_id: run.trace_id,
          dotted_order: run.dotted_order,
          tags: run.tags,
          attachments: run.attachments,
          events: run.events
        };
      }
      _remapForProject(projectName, runtimeEnv, excludeChildRuns = true) {
        const baseRun = this._convertToCreate(this, runtimeEnv, excludeChildRuns);
        if (projectName === this.project_name) {
          return baseRun;
        }
        const createRemappedId = (originalId) => {
          return uuid.v5(`${originalId}:${projectName}`, uuid.v5.DNS);
        };
        const newId = createRemappedId(baseRun.id);
        const newTraceId = baseRun.trace_id ? createRemappedId(baseRun.trace_id) : void 0;
        const newParentRunId = baseRun.parent_run_id ? createRemappedId(baseRun.parent_run_id) : void 0;
        let newDottedOrder;
        if (baseRun.dotted_order) {
          const segments = _parseDottedOrder(baseRun.dotted_order);
          const rebuilt = [];
          for (let i = 0; i < segments.length - 1; i++) {
            const [timestamp, segmentId] = segments[i];
            const remappedId = createRemappedId(segmentId);
            rebuilt.push(timestamp.toISOString().replace(/[-:]/g, "").replace(".", "") + remappedId);
          }
          const [lastTimestamp] = segments[segments.length - 1];
          rebuilt.push(lastTimestamp.toISOString().replace(/[-:]/g, "").replace(".", "") + newId);
          newDottedOrder = rebuilt.join(".");
        } else {
          newDottedOrder = void 0;
        }
        const remappedRun = {
          ...baseRun,
          id: newId,
          trace_id: newTraceId,
          parent_run_id: newParentRunId,
          dotted_order: newDottedOrder,
          session_name: projectName
        };
        return remappedRun;
      }
      async postRun(excludeChildRuns = true) {
        try {
          const runtimeEnv = (0, env_js_2.getRuntimeEnvironment)();
          if (this.replicas && this.replicas.length > 0) {
            for (const { projectName, apiKey, apiUrl, workspaceId } of this.replicas) {
              const runCreate = this._remapForProject(projectName ?? this.project_name, runtimeEnv, true);
              await this.client.createRun(runCreate, {
                apiKey,
                apiUrl,
                workspaceId
              });
            }
          } else {
            const runCreate = this._convertToCreate(this, runtimeEnv, excludeChildRuns);
            await this.client.createRun(runCreate);
          }
          if (!excludeChildRuns) {
            (0, warn_js_1.warnOnce)("Posting with excludeChildRuns=false is deprecated and will be removed in a future version.");
            for (const childRun of this.child_runs) {
              await childRun.postRun(false);
            }
          }
        } catch (error) {
          console.error(`Error in postRun for run ${this.id}:`, error);
        }
      }
      async patchRun(options) {
        if (this.replicas && this.replicas.length > 0) {
          for (const { projectName, apiKey, apiUrl, workspaceId, updates } of this.replicas) {
            const runData = this._remapForProject(projectName ?? this.project_name);
            const updatePayload = {
              id: runData.id,
              outputs: runData.outputs,
              error: runData.error,
              parent_run_id: runData.parent_run_id,
              session_name: runData.session_name,
              reference_example_id: runData.reference_example_id,
              end_time: runData.end_time,
              dotted_order: runData.dotted_order,
              trace_id: runData.trace_id,
              events: runData.events,
              tags: runData.tags,
              extra: runData.extra,
              attachments: this.attachments,
              ...updates
            };
            if (!options?.excludeInputs) {
              updatePayload.inputs = runData.inputs;
            }
            await this.client.updateRun(runData.id, updatePayload, {
              apiKey,
              apiUrl,
              workspaceId
            });
          }
        } else {
          try {
            const runUpdate = {
              end_time: this.end_time,
              error: this.error,
              outputs: this.outputs,
              parent_run_id: this.parent_run?.id ?? this.parent_run_id,
              reference_example_id: this.reference_example_id,
              extra: this.extra,
              events: this.events,
              dotted_order: this.dotted_order,
              trace_id: this.trace_id,
              tags: this.tags,
              attachments: this.attachments,
              session_name: this.project_name
            };
            if (!options?.excludeInputs) {
              runUpdate.inputs = this.inputs;
            }
            await this.client.updateRun(this.id, runUpdate);
          } catch (error) {
            console.error(`Error in patchRun for run ${this.id}`, error);
          }
        }
      }
      toJSON() {
        return this._convertToCreate(this, void 0, false);
      }
      /**
       * Add an event to the run tree.
       * @param event - A single event or string to add
       */
      addEvent(event) {
        if (!this.events) {
          this.events = [];
        }
        if (typeof event === "string") {
          this.events.push({
            name: "event",
            time: (/* @__PURE__ */ new Date()).toISOString(),
            message: event
          });
        } else {
          this.events.push({
            ...event,
            time: event.time ?? (/* @__PURE__ */ new Date()).toISOString()
          });
        }
      }
      static fromRunnableConfig(parentConfig, props) {
        const callbackManager = parentConfig?.callbacks;
        let parentRun;
        let projectName;
        let client;
        let tracingEnabled = (0, env_js_1.isTracingEnabled)();
        if (callbackManager) {
          const parentRunId = callbackManager?.getParentRunId?.() ?? "";
          const langChainTracer = callbackManager?.handlers?.find((handler) => handler?.name == "langchain_tracer");
          parentRun = langChainTracer?.getRun?.(parentRunId);
          projectName = langChainTracer?.projectName;
          client = langChainTracer?.client;
          tracingEnabled = tracingEnabled || !!langChainTracer;
        }
        if (!parentRun) {
          return new _RunTree({
            ...props,
            client,
            tracingEnabled,
            project_name: projectName
          });
        }
        const parentRunTree = new _RunTree({
          name: parentRun.name,
          id: parentRun.id,
          trace_id: parentRun.trace_id,
          dotted_order: parentRun.dotted_order,
          client,
          tracingEnabled,
          project_name: projectName,
          tags: [
            ...new Set((parentRun?.tags ?? []).concat(parentConfig?.tags ?? []))
          ],
          extra: {
            metadata: {
              ...parentRun?.extra?.metadata,
              ...parentConfig?.metadata
            }
          }
        });
        return parentRunTree.createChild(props);
      }
      static fromDottedOrder(dottedOrder) {
        return this.fromHeaders({ "langsmith-trace": dottedOrder });
      }
      static fromHeaders(headers, inheritArgs) {
        const rawHeaders = "get" in headers && typeof headers.get === "function" ? {
          "langsmith-trace": headers.get("langsmith-trace"),
          baggage: headers.get("baggage")
        } : headers;
        const headerTrace = rawHeaders["langsmith-trace"];
        if (!headerTrace || typeof headerTrace !== "string")
          return void 0;
        const parentDottedOrder = headerTrace.trim();
        const parsedDottedOrder = parentDottedOrder.split(".").map((part) => {
          const [strTime, uuid2] = part.split("Z");
          return { strTime, time: Date.parse(strTime + "Z"), uuid: uuid2 };
        });
        const traceId = parsedDottedOrder[0].uuid;
        const config = {
          ...inheritArgs,
          name: inheritArgs?.["name"] ?? "parent",
          run_type: inheritArgs?.["run_type"] ?? "chain",
          start_time: inheritArgs?.["start_time"] ?? Date.now(),
          id: parsedDottedOrder.at(-1)?.uuid,
          trace_id: traceId,
          dotted_order: parentDottedOrder
        };
        if (rawHeaders["baggage"] && typeof rawHeaders["baggage"] === "string") {
          const baggage = Baggage.fromHeader(rawHeaders["baggage"]);
          config.metadata = baggage.metadata;
          config.tags = baggage.tags;
          config.project_name = baggage.project_name;
          config.replicas = baggage.replicas;
        }
        return new _RunTree(config);
      }
      toHeaders(headers) {
        const result = {
          "langsmith-trace": this.dotted_order,
          baggage: new Baggage(this.extra?.metadata, this.tags, this.project_name, this.replicas).toHeader()
        };
        if (headers) {
          for (const [key, value] of Object.entries(result)) {
            headers.set(key, value);
          }
        }
        return result;
      }
    };
    exports2.RunTree = RunTree;
    Object.defineProperty(RunTree, "sharedClient", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: null
    });
    function isRunTree(x) {
      return x != null && typeof x.createChild === "function" && typeof x.postRun === "function";
    }
    function isLangChainTracerLike(x) {
      return typeof x === "object" && x != null && typeof x.name === "string" && x.name === "langchain_tracer";
    }
    function containsLangChainTracerLike(x) {
      return Array.isArray(x) && x.some((callback) => isLangChainTracerLike(callback));
    }
    function isCallbackManagerLike(x) {
      return typeof x === "object" && x != null && Array.isArray(x.handlers);
    }
    function isRunnableConfigLike(x) {
      return x != null && typeof x.callbacks === "object" && // Callback manager with a langchain tracer
      (containsLangChainTracerLike(x.callbacks?.handlers) || // Or it's an array with a LangChainTracerLike object within it
      containsLangChainTracerLike(x.callbacks));
    }
    function _parseDottedOrder(dottedOrder) {
      const parts = dottedOrder.split(".");
      return parts.map((part) => {
        const timestampStr = part.slice(0, -36);
        const uuidStr = part.slice(-36);
        const year = parseInt(timestampStr.slice(0, 4));
        const month = parseInt(timestampStr.slice(4, 6)) - 1;
        const day = parseInt(timestampStr.slice(6, 8));
        const hour = parseInt(timestampStr.slice(9, 11));
        const minute = parseInt(timestampStr.slice(11, 13));
        const second = parseInt(timestampStr.slice(13, 15));
        const microsecond = parseInt(timestampStr.slice(15, 21));
        const timestamp = new Date(year, month, day, hour, minute, second, microsecond / 1e3);
        return [timestamp, uuidStr];
      });
    }
    function _getWriteReplicasFromEnv() {
      const envVar = (0, env_js_2.getEnvironmentVariable)("LANGSMITH_RUNS_ENDPOINTS");
      if (!envVar)
        return [];
      try {
        const parsed = JSON.parse(envVar);
        if (Array.isArray(parsed)) {
          const replicas = [];
          for (const item of parsed) {
            if (typeof item !== "object" || item === null) {
              console.warn(`Invalid item type in LANGSMITH_RUNS_ENDPOINTS: expected object, got ${typeof item}`);
              continue;
            }
            if (typeof item.api_url !== "string") {
              console.warn(`Invalid api_url type in LANGSMITH_RUNS_ENDPOINTS: expected string, got ${typeof item.api_url}`);
              continue;
            }
            if (typeof item.api_key !== "string") {
              console.warn(`Invalid api_key type in LANGSMITH_RUNS_ENDPOINTS: expected string, got ${typeof item.api_key}`);
              continue;
            }
            replicas.push({
              apiUrl: item.api_url.replace(/\/$/, ""),
              apiKey: item.api_key
            });
          }
          return replicas;
        } else if (typeof parsed === "object" && parsed !== null) {
          _checkEndpointEnvUnset(parsed);
          const replicas = [];
          for (const [url, key] of Object.entries(parsed)) {
            const cleanUrl = url.replace(/\/$/, "");
            if (typeof key === "string") {
              replicas.push({
                apiUrl: cleanUrl,
                apiKey: key
              });
            } else {
              console.warn(`Invalid value type in LANGSMITH_RUNS_ENDPOINTS for URL ${url}: expected string, got ${typeof key}`);
              continue;
            }
          }
          return replicas;
        } else {
          console.warn(`Invalid LANGSMITH_RUNS_ENDPOINTS \u2013 must be valid JSON array of objects with api_url and api_key properties, or object mapping url->apiKey, got ${typeof parsed}`);
          return [];
        }
      } catch (e) {
        if ((0, error_js_1.isConflictingEndpointsError)(e)) {
          throw e;
        }
        console.warn("Invalid LANGSMITH_RUNS_ENDPOINTS \u2013 must be valid JSON array of objects with api_url and api_key properties, or object mapping url->apiKey");
        return [];
      }
    }
    function _ensureWriteReplicas(replicas) {
      if (replicas) {
        return replicas.map((replica) => {
          if (Array.isArray(replica)) {
            return {
              projectName: replica[0],
              updates: replica[1]
            };
          }
          return replica;
        });
      }
      return _getWriteReplicasFromEnv();
    }
    function _checkEndpointEnvUnset(parsed) {
      if (Object.keys(parsed).length > 0 && (0, env_js_3.getLangSmithEnvironmentVariable)("ENDPOINT")) {
        throw new error_js_1.ConflictingEndpointsError();
      }
    }
  }
});

// node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/run_trees.cjs
var require_run_trees2 = __commonJS({
  "node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/run_trees.cjs"(exports2, module2) {
    module2.exports = require_run_trees();
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/tracers/base.cjs
var require_base3 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/tracers/base.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_utils_env = require_env();
    var require_callbacks_base = require_base2();
    var langsmith_run_trees = require_rolldown_runtime5.__toESM(require_run_trees2());
    var base_exports = {};
    require_rolldown_runtime5.__export(base_exports, {
      BaseTracer: () => BaseTracer,
      isBaseTracer: () => isBaseTracer
    });
    var convertRunTreeToRun = (runTree) => {
      if (!runTree) return void 0;
      runTree.events = runTree.events ?? [];
      runTree.child_runs = runTree.child_runs ?? [];
      return runTree;
    };
    function convertRunToRunTree(run, parentRun) {
      if (!run) return void 0;
      return new langsmith_run_trees.RunTree({
        ...run,
        start_time: run._serialized_start_time ?? run.start_time,
        parent_run: convertRunToRunTree(parentRun),
        child_runs: run.child_runs.map((r) => convertRunToRunTree(r)).filter((r) => r !== void 0),
        extra: {
          ...run.extra,
          runtime: require_utils_env.getRuntimeEnvironment()
        },
        tracingEnabled: false
      });
    }
    function _coerceToDict(value, defaultKey) {
      return value && !Array.isArray(value) && typeof value === "object" ? value : { [defaultKey]: value };
    }
    function isBaseTracer(x) {
      return typeof x._addRunToRunMap === "function";
    }
    var BaseTracer = class extends require_callbacks_base.BaseCallbackHandler {
      /** @deprecated Use `runTreeMap` instead. */
      runMap = /* @__PURE__ */ new Map();
      runTreeMap = /* @__PURE__ */ new Map();
      usesRunTreeMap = false;
      constructor(_fields) {
        super(...arguments);
      }
      copy() {
        return this;
      }
      getRunById(runId) {
        if (runId === void 0) return void 0;
        return this.usesRunTreeMap ? convertRunTreeToRun(this.runTreeMap.get(runId)) : this.runMap.get(runId);
      }
      stringifyError(error) {
        if (error instanceof Error) return error.message + (error?.stack ? `

${error.stack}` : "");
        if (typeof error === "string") return error;
        return `${error}`;
      }
      _addChildRun(parentRun, childRun) {
        parentRun.child_runs.push(childRun);
      }
      _addRunToRunMap(run) {
        const { dottedOrder: currentDottedOrder, microsecondPrecisionDatestring } = (0, langsmith_run_trees.convertToDottedOrderFormat)(new Date(run.start_time).getTime(), run.id, run.execution_order);
        const storedRun = { ...run };
        const parentRun = this.getRunById(storedRun.parent_run_id);
        if (storedRun.parent_run_id !== void 0) {
          if (parentRun) {
            this._addChildRun(parentRun, storedRun);
            parentRun.child_execution_order = Math.max(parentRun.child_execution_order, storedRun.child_execution_order);
            storedRun.trace_id = parentRun.trace_id;
            if (parentRun.dotted_order !== void 0) {
              storedRun.dotted_order = [parentRun.dotted_order, currentDottedOrder].join(".");
              storedRun._serialized_start_time = microsecondPrecisionDatestring;
            }
          }
        } else {
          storedRun.trace_id = storedRun.id;
          storedRun.dotted_order = currentDottedOrder;
          storedRun._serialized_start_time = microsecondPrecisionDatestring;
        }
        if (this.usesRunTreeMap) {
          const runTree = convertRunToRunTree(storedRun, parentRun);
          if (runTree !== void 0) this.runTreeMap.set(storedRun.id, runTree);
        } else this.runMap.set(storedRun.id, storedRun);
        return storedRun;
      }
      async _endTrace(run) {
        const parentRun = run.parent_run_id !== void 0 && this.getRunById(run.parent_run_id);
        if (parentRun) parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order);
        else await this.persistRun(run);
        await this.onRunUpdate?.(run);
        if (this.usesRunTreeMap) this.runTreeMap.delete(run.id);
        else this.runMap.delete(run.id);
      }
      _getExecutionOrder(parentRunId) {
        const parentRun = parentRunId !== void 0 && this.getRunById(parentRunId);
        if (!parentRun) return 1;
        return parentRun.child_execution_order + 1;
      }
      /**
      * Create and add a run to the run map for LLM start events.
      * This must sometimes be done synchronously to avoid race conditions
      * when callbacks are backgrounded, so we expose it as a separate method here.
      */
      _createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
        const execution_order = this._getExecutionOrder(parentRunId);
        const start_time = Date.now();
        const finalExtraParams = metadata ? {
          ...extraParams,
          metadata
        } : extraParams;
        const run = {
          id: runId,
          name: name ?? llm.id[llm.id.length - 1],
          parent_run_id: parentRunId,
          start_time,
          serialized: llm,
          events: [{
            name: "start",
            time: new Date(start_time).toISOString()
          }],
          inputs: { prompts },
          execution_order,
          child_runs: [],
          child_execution_order: execution_order,
          run_type: "llm",
          extra: finalExtraParams ?? {},
          tags: tags || []
        };
        return this._addRunToRunMap(run);
      }
      async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
        const run = this.getRunById(runId) ?? this._createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name);
        await this.onRunCreate?.(run);
        await this.onLLMStart?.(run);
        return run;
      }
      /**
      * Create and add a run to the run map for chat model start events.
      * This must sometimes be done synchronously to avoid race conditions
      * when callbacks are backgrounded, so we expose it as a separate method here.
      */
      _createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
        const execution_order = this._getExecutionOrder(parentRunId);
        const start_time = Date.now();
        const finalExtraParams = metadata ? {
          ...extraParams,
          metadata
        } : extraParams;
        const run = {
          id: runId,
          name: name ?? llm.id[llm.id.length - 1],
          parent_run_id: parentRunId,
          start_time,
          serialized: llm,
          events: [{
            name: "start",
            time: new Date(start_time).toISOString()
          }],
          inputs: { messages },
          execution_order,
          child_runs: [],
          child_execution_order: execution_order,
          run_type: "llm",
          extra: finalExtraParams ?? {},
          tags: tags || []
        };
        return this._addRunToRunMap(run);
      }
      async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
        const run = this.getRunById(runId) ?? this._createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name);
        await this.onRunCreate?.(run);
        await this.onLLMStart?.(run);
        return run;
      }
      async handleLLMEnd(output, runId, _parentRunId, _tags, extraParams) {
        const run = this.getRunById(runId);
        if (!run || run?.run_type !== "llm") throw new Error("No LLM run to end.");
        run.end_time = Date.now();
        run.outputs = output;
        run.events.push({
          name: "end",
          time: new Date(run.end_time).toISOString()
        });
        run.extra = {
          ...run.extra,
          ...extraParams
        };
        await this.onLLMEnd?.(run);
        await this._endTrace(run);
        return run;
      }
      async handleLLMError(error, runId, _parentRunId, _tags, extraParams) {
        const run = this.getRunById(runId);
        if (!run || run?.run_type !== "llm") throw new Error("No LLM run to end.");
        run.end_time = Date.now();
        run.error = this.stringifyError(error);
        run.events.push({
          name: "error",
          time: new Date(run.end_time).toISOString()
        });
        run.extra = {
          ...run.extra,
          ...extraParams
        };
        await this.onLLMError?.(run);
        await this._endTrace(run);
        return run;
      }
      /**
      * Create and add a run to the run map for chain start events.
      * This must sometimes be done synchronously to avoid race conditions
      * when callbacks are backgrounded, so we expose it as a separate method here.
      */
      _createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {
        const execution_order = this._getExecutionOrder(parentRunId);
        const start_time = Date.now();
        const run = {
          id: runId,
          name: name ?? chain.id[chain.id.length - 1],
          parent_run_id: parentRunId,
          start_time,
          serialized: chain,
          events: [{
            name: "start",
            time: new Date(start_time).toISOString()
          }],
          inputs,
          execution_order,
          child_execution_order: execution_order,
          run_type: runType ?? "chain",
          child_runs: [],
          extra: metadata ? { metadata } : {},
          tags: tags || []
        };
        return this._addRunToRunMap(run);
      }
      async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {
        const run = this.getRunById(runId) ?? this._createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name);
        await this.onRunCreate?.(run);
        await this.onChainStart?.(run);
        return run;
      }
      async handleChainEnd(outputs, runId, _parentRunId, _tags, kwargs) {
        const run = this.getRunById(runId);
        if (!run) throw new Error("No chain run to end.");
        run.end_time = Date.now();
        run.outputs = _coerceToDict(outputs, "output");
        run.events.push({
          name: "end",
          time: new Date(run.end_time).toISOString()
        });
        if (kwargs?.inputs !== void 0) run.inputs = _coerceToDict(kwargs.inputs, "input");
        await this.onChainEnd?.(run);
        await this._endTrace(run);
        return run;
      }
      async handleChainError(error, runId, _parentRunId, _tags, kwargs) {
        const run = this.getRunById(runId);
        if (!run) throw new Error("No chain run to end.");
        run.end_time = Date.now();
        run.error = this.stringifyError(error);
        run.events.push({
          name: "error",
          time: new Date(run.end_time).toISOString()
        });
        if (kwargs?.inputs !== void 0) run.inputs = _coerceToDict(kwargs.inputs, "input");
        await this.onChainError?.(run);
        await this._endTrace(run);
        return run;
      }
      /**
      * Create and add a run to the run map for tool start events.
      * This must sometimes be done synchronously to avoid race conditions
      * when callbacks are backgrounded, so we expose it as a separate method here.
      */
      _createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name) {
        const execution_order = this._getExecutionOrder(parentRunId);
        const start_time = Date.now();
        const run = {
          id: runId,
          name: name ?? tool.id[tool.id.length - 1],
          parent_run_id: parentRunId,
          start_time,
          serialized: tool,
          events: [{
            name: "start",
            time: new Date(start_time).toISOString()
          }],
          inputs: { input },
          execution_order,
          child_execution_order: execution_order,
          run_type: "tool",
          child_runs: [],
          extra: metadata ? { metadata } : {},
          tags: tags || []
        };
        return this._addRunToRunMap(run);
      }
      async handleToolStart(tool, input, runId, parentRunId, tags, metadata, name) {
        const run = this.getRunById(runId) ?? this._createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name);
        await this.onRunCreate?.(run);
        await this.onToolStart?.(run);
        return run;
      }
      async handleToolEnd(output, runId) {
        const run = this.getRunById(runId);
        if (!run || run?.run_type !== "tool") throw new Error("No tool run to end");
        run.end_time = Date.now();
        run.outputs = { output };
        run.events.push({
          name: "end",
          time: new Date(run.end_time).toISOString()
        });
        await this.onToolEnd?.(run);
        await this._endTrace(run);
        return run;
      }
      async handleToolError(error, runId) {
        const run = this.getRunById(runId);
        if (!run || run?.run_type !== "tool") throw new Error("No tool run to end");
        run.end_time = Date.now();
        run.error = this.stringifyError(error);
        run.events.push({
          name: "error",
          time: new Date(run.end_time).toISOString()
        });
        await this.onToolError?.(run);
        await this._endTrace(run);
        return run;
      }
      async handleAgentAction(action, runId) {
        const run = this.getRunById(runId);
        if (!run || run?.run_type !== "chain") return;
        const agentRun = run;
        agentRun.actions = agentRun.actions || [];
        agentRun.actions.push(action);
        agentRun.events.push({
          name: "agent_action",
          time: (/* @__PURE__ */ new Date()).toISOString(),
          kwargs: { action }
        });
        await this.onAgentAction?.(run);
      }
      async handleAgentEnd(action, runId) {
        const run = this.getRunById(runId);
        if (!run || run?.run_type !== "chain") return;
        run.events.push({
          name: "agent_end",
          time: (/* @__PURE__ */ new Date()).toISOString(),
          kwargs: { action }
        });
        await this.onAgentEnd?.(run);
      }
      /**
      * Create and add a run to the run map for retriever start events.
      * This must sometimes be done synchronously to avoid race conditions
      * when callbacks are backgrounded, so we expose it as a separate method here.
      */
      _createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
        const execution_order = this._getExecutionOrder(parentRunId);
        const start_time = Date.now();
        const run = {
          id: runId,
          name: name ?? retriever.id[retriever.id.length - 1],
          parent_run_id: parentRunId,
          start_time,
          serialized: retriever,
          events: [{
            name: "start",
            time: new Date(start_time).toISOString()
          }],
          inputs: { query },
          execution_order,
          child_execution_order: execution_order,
          run_type: "retriever",
          child_runs: [],
          extra: metadata ? { metadata } : {},
          tags: tags || []
        };
        return this._addRunToRunMap(run);
      }
      async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
        const run = this.getRunById(runId) ?? this._createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name);
        await this.onRunCreate?.(run);
        await this.onRetrieverStart?.(run);
        return run;
      }
      async handleRetrieverEnd(documents, runId) {
        const run = this.getRunById(runId);
        if (!run || run?.run_type !== "retriever") throw new Error("No retriever run to end");
        run.end_time = Date.now();
        run.outputs = { documents };
        run.events.push({
          name: "end",
          time: new Date(run.end_time).toISOString()
        });
        await this.onRetrieverEnd?.(run);
        await this._endTrace(run);
        return run;
      }
      async handleRetrieverError(error, runId) {
        const run = this.getRunById(runId);
        if (!run || run?.run_type !== "retriever") throw new Error("No retriever run to end");
        run.end_time = Date.now();
        run.error = this.stringifyError(error);
        run.events.push({
          name: "error",
          time: new Date(run.end_time).toISOString()
        });
        await this.onRetrieverError?.(run);
        await this._endTrace(run);
        return run;
      }
      async handleText(text, runId) {
        const run = this.getRunById(runId);
        if (!run || run?.run_type !== "chain") return;
        run.events.push({
          name: "text",
          time: (/* @__PURE__ */ new Date()).toISOString(),
          kwargs: { text }
        });
        await this.onText?.(run);
      }
      async handleLLMNewToken(token, idx, runId, _parentRunId, _tags, fields) {
        const run = this.getRunById(runId);
        if (!run || run?.run_type !== "llm") throw new Error(`Invalid "runId" provided to "handleLLMNewToken" callback.`);
        run.events.push({
          name: "new_token",
          time: (/* @__PURE__ */ new Date()).toISOString(),
          kwargs: {
            token,
            idx,
            chunk: fields?.chunk
          }
        });
        await this.onLLMNewToken?.(run, token, { chunk: fields?.chunk });
        return run;
      }
    };
    exports2.BaseTracer = BaseTracer;
    Object.defineProperty(exports2, "base_exports", {
      enumerable: true,
      get: function() {
        return base_exports;
      }
    });
    exports2.isBaseTracer = isBaseTracer;
  }
});

// node_modules/.pnpm/ansi-styles@5.2.0/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/.pnpm/ansi-styles@5.2.0/node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var ANSI_BACKGROUND_OFFSET = 10;
    var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
    var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          overline: [53, 55],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      styles.color.ansi256 = wrapAnsi256();
      styles.color.ansi16m = wrapAnsi16m();
      styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
      styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
      Object.defineProperties(styles, {
        rgbToAnsi256: {
          value: (red, green, blue) => {
            if (red === green && green === blue) {
              if (red < 8) {
                return 16;
              }
              if (red > 248) {
                return 231;
              }
              return Math.round((red - 8) / 247 * 24) + 232;
            }
            return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
          },
          enumerable: false
        },
        hexToRgb: {
          value: (hex) => {
            const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
            if (!matches) {
              return [0, 0, 0];
            }
            let { colorString } = matches.groups;
            if (colorString.length === 3) {
              colorString = colorString.split("").map((character) => character + character).join("");
            }
            const integer = Number.parseInt(colorString, 16);
            return [
              integer >> 16 & 255,
              integer >> 8 & 255,
              integer & 255
            ];
          },
          enumerable: false
        },
        hexToAnsi256: {
          value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
          enumerable: false
        }
      });
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/tracers/console.cjs
var require_console = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/tracers/console.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_tracers_base = require_base3();
    var ansi_styles = require_rolldown_runtime5.__toESM(require_ansi_styles());
    var console_exports = {};
    require_rolldown_runtime5.__export(console_exports, { ConsoleCallbackHandler: () => ConsoleCallbackHandler });
    function wrap(style, text) {
      return `${style.open}${text}${style.close}`;
    }
    function tryJsonStringify(obj, fallback) {
      try {
        return JSON.stringify(obj, null, 2);
      } catch {
        return fallback;
      }
    }
    function formatKVMapItem(value) {
      if (typeof value === "string") return value.trim();
      if (value === null || value === void 0) return value;
      return tryJsonStringify(value, value.toString());
    }
    function elapsed(run) {
      if (!run.end_time) return "";
      const elapsed$1 = run.end_time - run.start_time;
      if (elapsed$1 < 1e3) return `${elapsed$1}ms`;
      return `${(elapsed$1 / 1e3).toFixed(2)}s`;
    }
    var { color } = ansi_styles.default;
    var ConsoleCallbackHandler = class extends require_tracers_base.BaseTracer {
      name = "console_callback_handler";
      /**
      * Method used to persist the run. In this case, it simply returns a
      * resolved promise as there's no persistence logic.
      * @param _run The run to persist.
      * @returns A resolved promise.
      */
      persistRun(_run) {
        return Promise.resolve();
      }
      /**
      * Method used to get all the parent runs of a given run.
      * @param run The run whose parents are to be retrieved.
      * @returns An array of parent runs.
      */
      getParents(run) {
        const parents = [];
        let currentRun = run;
        while (currentRun.parent_run_id) {
          const parent = this.runMap.get(currentRun.parent_run_id);
          if (parent) {
            parents.push(parent);
            currentRun = parent;
          } else break;
        }
        return parents;
      }
      /**
      * Method used to get a string representation of the run's lineage, which
      * is used in logging.
      * @param run The run whose lineage is to be retrieved.
      * @returns A string representation of the run's lineage.
      */
      getBreadcrumbs(run) {
        const parents = this.getParents(run).reverse();
        const string = [...parents, run].map((parent, i, arr) => {
          const name = `${parent.execution_order}:${parent.run_type}:${parent.name}`;
          return i === arr.length - 1 ? wrap(ansi_styles.default.bold, name) : name;
        }).join(" > ");
        return wrap(color.grey, string);
      }
      /**
      * Method used to log the start of a chain run.
      * @param run The chain run that has started.
      * @returns void
      */
      onChainStart(run) {
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.green, "[chain/start]")} [${crumbs}] Entering Chain run with input: ${tryJsonStringify(run.inputs, "[inputs]")}`);
      }
      /**
      * Method used to log the end of a chain run.
      * @param run The chain run that has ended.
      * @returns void
      */
      onChainEnd(run) {
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.cyan, "[chain/end]")} [${crumbs}] [${elapsed(run)}] Exiting Chain run with output: ${tryJsonStringify(run.outputs, "[outputs]")}`);
      }
      /**
      * Method used to log any errors of a chain run.
      * @param run The chain run that has errored.
      * @returns void
      */
      onChainError(run) {
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.red, "[chain/error]")} [${crumbs}] [${elapsed(run)}] Chain run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
      }
      /**
      * Method used to log the start of an LLM run.
      * @param run The LLM run that has started.
      * @returns void
      */
      onLLMStart(run) {
        const crumbs = this.getBreadcrumbs(run);
        const inputs = "prompts" in run.inputs ? { prompts: run.inputs.prompts.map((p) => p.trim()) } : run.inputs;
        console.log(`${wrap(color.green, "[llm/start]")} [${crumbs}] Entering LLM run with input: ${tryJsonStringify(inputs, "[inputs]")}`);
      }
      /**
      * Method used to log the end of an LLM run.
      * @param run The LLM run that has ended.
      * @returns void
      */
      onLLMEnd(run) {
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.cyan, "[llm/end]")} [${crumbs}] [${elapsed(run)}] Exiting LLM run with output: ${tryJsonStringify(run.outputs, "[response]")}`);
      }
      /**
      * Method used to log any errors of an LLM run.
      * @param run The LLM run that has errored.
      * @returns void
      */
      onLLMError(run) {
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.red, "[llm/error]")} [${crumbs}] [${elapsed(run)}] LLM run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
      }
      /**
      * Method used to log the start of a tool run.
      * @param run The tool run that has started.
      * @returns void
      */
      onToolStart(run) {
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.green, "[tool/start]")} [${crumbs}] Entering Tool run with input: "${formatKVMapItem(run.inputs.input)}"`);
      }
      /**
      * Method used to log the end of a tool run.
      * @param run The tool run that has ended.
      * @returns void
      */
      onToolEnd(run) {
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.cyan, "[tool/end]")} [${crumbs}] [${elapsed(run)}] Exiting Tool run with output: "${formatKVMapItem(run.outputs?.output)}"`);
      }
      /**
      * Method used to log any errors of a tool run.
      * @param run The tool run that has errored.
      * @returns void
      */
      onToolError(run) {
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.red, "[tool/error]")} [${crumbs}] [${elapsed(run)}] Tool run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
      }
      /**
      * Method used to log the start of a retriever run.
      * @param run The retriever run that has started.
      * @returns void
      */
      onRetrieverStart(run) {
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.green, "[retriever/start]")} [${crumbs}] Entering Retriever run with input: ${tryJsonStringify(run.inputs, "[inputs]")}`);
      }
      /**
      * Method used to log the end of a retriever run.
      * @param run The retriever run that has ended.
      * @returns void
      */
      onRetrieverEnd(run) {
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.cyan, "[retriever/end]")} [${crumbs}] [${elapsed(run)}] Exiting Retriever run with output: ${tryJsonStringify(run.outputs, "[outputs]")}`);
      }
      /**
      * Method used to log any errors of a retriever run.
      * @param run The retriever run that has errored.
      * @returns void
      */
      onRetrieverError(run) {
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.red, "[retriever/error]")} [${crumbs}] [${elapsed(run)}] Retriever run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
      }
      /**
      * Method used to log the action selected by the agent.
      * @param run The run in which the agent action occurred.
      * @returns void
      */
      onAgentAction(run) {
        const agentRun = run;
        const crumbs = this.getBreadcrumbs(run);
        console.log(`${wrap(color.blue, "[agent/action]")} [${crumbs}] Agent selected action: ${tryJsonStringify(agentRun.actions[agentRun.actions.length - 1], "[action]")}`);
      }
    };
    exports2.ConsoleCallbackHandler = ConsoleCallbackHandler;
    Object.defineProperty(exports2, "console_exports", {
      enumerable: true,
      get: function() {
        return console_exports;
      }
    });
  }
});

// node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/index.cjs
var require_langsmith = __commonJS({
  "node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/index.cjs"(exports2, module2) {
    module2.exports = require_dist();
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/singletons/tracer.cjs
var require_tracer = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/singletons/tracer.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_utils_env = require_env();
    var langsmith = require_rolldown_runtime5.__toESM(require_langsmith());
    var client;
    var getDefaultLangChainClientSingleton = () => {
      if (client === void 0) {
        const clientParams = require_utils_env.getEnvironmentVariable("LANGCHAIN_CALLBACKS_BACKGROUND") === "false" ? { blockOnRootRunFinalization: true } : {};
        client = new langsmith.Client(clientParams);
      }
      return client;
    };
    exports2.getDefaultLangChainClientSingleton = getDefaultLangChainClientSingleton;
  }
});

// node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/singletons/traceable.cjs
var require_traceable = __commonJS({
  "node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/dist/singletons/traceable.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ROOT = exports2.AsyncLocalStorageProviderSingleton = void 0;
    exports2.getCurrentRunTree = getCurrentRunTree;
    exports2.withRunTree = withRunTree;
    exports2.isTraceableFunction = isTraceableFunction;
    var MockAsyncLocalStorage = class {
      getStore() {
        return void 0;
      }
      run(_, callback) {
        return callback();
      }
    };
    var TRACING_ALS_KEY = Symbol.for("ls:tracing_async_local_storage");
    var mockAsyncLocalStorage = new MockAsyncLocalStorage();
    var AsyncLocalStorageProvider = class {
      getInstance() {
        return globalThis[TRACING_ALS_KEY] ?? mockAsyncLocalStorage;
      }
      initializeGlobalInstance(instance) {
        if (globalThis[TRACING_ALS_KEY] === void 0) {
          globalThis[TRACING_ALS_KEY] = instance;
        }
      }
    };
    exports2.AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();
    function getCurrentRunTree(permitAbsentRunTree = false) {
      const runTree = exports2.AsyncLocalStorageProviderSingleton.getInstance().getStore();
      if (!permitAbsentRunTree && runTree === void 0) {
        throw new Error("Could not get the current run tree.\n\nPlease make sure you are calling this method within a traceable function and that tracing is enabled.");
      }
      return runTree;
    }
    function withRunTree(runTree, fn) {
      const storage = exports2.AsyncLocalStorageProviderSingleton.getInstance();
      return new Promise((resolve, reject) => {
        storage.run(runTree, () => void Promise.resolve(fn()).then(resolve).catch(reject));
      });
    }
    exports2.ROOT = Symbol.for("langsmith:traceable:root");
    function isTraceableFunction(x) {
      return typeof x === "function" && "langsmith:traceable" in x;
    }
  }
});

// node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/singletons/traceable.cjs
var require_traceable2 = __commonJS({
  "node_modules/.pnpm/langsmith@0.3.76/node_modules/langsmith/singletons/traceable.cjs"(exports2, module2) {
    module2.exports = require_traceable();
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/tracers/tracer_langchain.cjs
var require_tracer_langchain = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/tracers/tracer_langchain.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_tracers_base = require_base3();
    var require_tracer2 = require_tracer();
    var langsmith_singletons_traceable = require_rolldown_runtime5.__toESM(require_traceable2());
    var langsmith_run_trees = require_rolldown_runtime5.__toESM(require_run_trees2());
    var langsmith = require_rolldown_runtime5.__toESM(require_langsmith());
    var tracer_langchain_exports = {};
    require_rolldown_runtime5.__export(tracer_langchain_exports, { LangChainTracer: () => LangChainTracer });
    var LangChainTracer = class LangChainTracer2 extends require_tracers_base.BaseTracer {
      name = "langchain_tracer";
      projectName;
      exampleId;
      client;
      replicas;
      usesRunTreeMap = true;
      constructor(fields = {}) {
        super(fields);
        const { exampleId, projectName, client, replicas } = fields;
        this.projectName = projectName ?? (0, langsmith.getDefaultProjectName)();
        this.replicas = replicas;
        this.exampleId = exampleId;
        this.client = client ?? require_tracer2.getDefaultLangChainClientSingleton();
        const traceableTree = LangChainTracer2.getTraceableRunTree();
        if (traceableTree) this.updateFromRunTree(traceableTree);
      }
      async persistRun(_run) {
      }
      async onRunCreate(run) {
        const runTree = this.getRunTreeWithTracingConfig(run.id);
        await runTree?.postRun();
      }
      async onRunUpdate(run) {
        const runTree = this.getRunTreeWithTracingConfig(run.id);
        await runTree?.patchRun();
      }
      getRun(id) {
        return this.runTreeMap.get(id);
      }
      updateFromRunTree(runTree) {
        this.runTreeMap.set(runTree.id, runTree);
        let rootRun = runTree;
        const visited = /* @__PURE__ */ new Set();
        while (rootRun.parent_run) {
          if (visited.has(rootRun.id)) break;
          visited.add(rootRun.id);
          if (!rootRun.parent_run) break;
          rootRun = rootRun.parent_run;
        }
        visited.clear();
        const queue = [rootRun];
        while (queue.length > 0) {
          const current = queue.shift();
          if (!current || visited.has(current.id)) continue;
          visited.add(current.id);
          this.runTreeMap.set(current.id, current);
          if (current.child_runs) queue.push(...current.child_runs);
        }
        this.client = runTree.client ?? this.client;
        this.replicas = runTree.replicas ?? this.replicas;
        this.projectName = runTree.project_name ?? this.projectName;
        this.exampleId = runTree.reference_example_id ?? this.exampleId;
      }
      getRunTreeWithTracingConfig(id) {
        const runTree = this.runTreeMap.get(id);
        if (!runTree) return void 0;
        return new langsmith_run_trees.RunTree({
          ...runTree,
          client: this.client,
          project_name: this.projectName,
          replicas: this.replicas,
          reference_example_id: this.exampleId,
          tracingEnabled: true
        });
      }
      static getTraceableRunTree() {
        try {
          return (0, langsmith_singletons_traceable.getCurrentRunTree)(true);
        } catch {
          return void 0;
        }
      }
    };
    exports2.LangChainTracer = LangChainTracer;
    Object.defineProperty(exports2, "tracer_langchain_exports", {
      enumerable: true,
      get: function() {
        return tracer_langchain_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/singletons/async_local_storage/globals.cjs
var require_globals = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/singletons/async_local_storage/globals.cjs"(exports2) {
    var TRACING_ALS_KEY = Symbol.for("ls:tracing_async_local_storage");
    var _CONTEXT_VARIABLES_KEY = Symbol.for("lc:context_variables");
    var setGlobalAsyncLocalStorageInstance = (instance) => {
      globalThis[TRACING_ALS_KEY] = instance;
    };
    var getGlobalAsyncLocalStorageInstance = () => {
      return globalThis[TRACING_ALS_KEY];
    };
    exports2._CONTEXT_VARIABLES_KEY = _CONTEXT_VARIABLES_KEY;
    exports2.getGlobalAsyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance;
    exports2.setGlobalAsyncLocalStorageInstance = setGlobalAsyncLocalStorageInstance;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/singletons/callbacks.cjs
var require_callbacks = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/singletons/callbacks.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_tracer2 = require_tracer();
    var require_globals2 = require_globals();
    var p_queue = require_rolldown_runtime5.__toESM(require_dist2());
    var queue;
    function createQueue() {
      const PQueue = "default" in p_queue.default ? p_queue.default.default : p_queue.default;
      return new PQueue({
        autoStart: true,
        concurrency: 1
      });
    }
    function getQueue() {
      if (typeof queue === "undefined") queue = createQueue();
      return queue;
    }
    async function consumeCallback(promiseFn, wait) {
      if (wait === true) {
        const asyncLocalStorageInstance = require_globals2.getGlobalAsyncLocalStorageInstance();
        if (asyncLocalStorageInstance !== void 0) await asyncLocalStorageInstance.run(void 0, async () => promiseFn());
        else await promiseFn();
      } else {
        queue = getQueue();
        queue.add(async () => {
          const asyncLocalStorageInstance = require_globals2.getGlobalAsyncLocalStorageInstance();
          if (asyncLocalStorageInstance !== void 0) await asyncLocalStorageInstance.run(void 0, async () => promiseFn());
          else await promiseFn();
        });
      }
    }
    async function awaitAllCallbacks() {
      const defaultClient = require_tracer2.getDefaultLangChainClientSingleton();
      await Promise.allSettled([typeof queue !== "undefined" ? queue.onIdle() : Promise.resolve(), defaultClient.awaitPendingTraceBatches()]);
    }
    exports2.awaitAllCallbacks = awaitAllCallbacks;
    exports2.consumeCallback = consumeCallback;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/callbacks/promises.cjs
var require_promises = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/callbacks/promises.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_callbacks3 = require_callbacks();
    var promises_exports = {};
    require_rolldown_runtime5.__export(promises_exports, {
      awaitAllCallbacks: () => require_callbacks3.awaitAllCallbacks,
      consumeCallback: () => require_callbacks3.consumeCallback
    });
    exports2.awaitAllCallbacks = require_callbacks3.awaitAllCallbacks;
    exports2.consumeCallback = require_callbacks3.consumeCallback;
    Object.defineProperty(exports2, "promises_exports", {
      enumerable: true,
      get: function() {
        return promises_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/callbacks.cjs
var require_callbacks2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/callbacks.cjs"(exports2) {
    var require_utils_env = require_env();
    var isTracingEnabled = (tracingEnabled) => {
      if (tracingEnabled !== void 0) return tracingEnabled;
      const envVars = [
        "LANGSMITH_TRACING_V2",
        "LANGCHAIN_TRACING_V2",
        "LANGSMITH_TRACING",
        "LANGCHAIN_TRACING"
      ];
      return !!envVars.find((envVar) => require_utils_env.getEnvironmentVariable(envVar) === "true");
    };
    exports2.isTracingEnabled = isTracingEnabled;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/singletons/async_local_storage/context.cjs
var require_context = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/singletons/async_local_storage/context.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_globals2 = require_globals();
    var langsmith_run_trees = require_rolldown_runtime5.__toESM(require_run_trees2());
    function setContextVariable(name, value) {
      const asyncLocalStorageInstance = require_globals2.getGlobalAsyncLocalStorageInstance();
      if (asyncLocalStorageInstance === void 0) throw new Error(`Internal error: Global shared async local storage instance has not been initialized.`);
      const runTree = asyncLocalStorageInstance.getStore();
      const contextVars = { ...runTree?.[require_globals2._CONTEXT_VARIABLES_KEY] };
      contextVars[name] = value;
      let newValue = {};
      if ((0, langsmith_run_trees.isRunTree)(runTree)) newValue = new langsmith_run_trees.RunTree(runTree);
      newValue[require_globals2._CONTEXT_VARIABLES_KEY] = contextVars;
      asyncLocalStorageInstance.enterWith(newValue);
    }
    function getContextVariable(name) {
      const asyncLocalStorageInstance = require_globals2.getGlobalAsyncLocalStorageInstance();
      if (asyncLocalStorageInstance === void 0) return void 0;
      const runTree = asyncLocalStorageInstance.getStore();
      return runTree?.[require_globals2._CONTEXT_VARIABLES_KEY]?.[name];
    }
    var LC_CONFIGURE_HOOKS_KEY = Symbol("lc:configure_hooks");
    var _getConfigureHooks = () => getContextVariable(LC_CONFIGURE_HOOKS_KEY) || [];
    var registerConfigureHook = (config) => {
      if (config.envVar && !config.handlerClass) throw new Error("If envVar is set, handlerClass must also be set to a non-None value.");
      setContextVariable(LC_CONFIGURE_HOOKS_KEY, [..._getConfigureHooks(), config]);
    };
    exports2._getConfigureHooks = _getConfigureHooks;
    exports2.getContextVariable = getContextVariable;
    exports2.registerConfigureHook = registerConfigureHook;
    exports2.setContextVariable = setContextVariable;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/callbacks/manager.cjs
var require_manager = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/callbacks/manager.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_utils10 = require_utils3();
    var require_utils_env = require_env();
    var require_callbacks_base = require_base2();
    var require_tracers_base = require_base3();
    var require_tracers_console = require_console();
    var require_tracers_tracer_langchain = require_tracer_langchain();
    var require_callbacks3 = require_callbacks();
    require_promises();
    var require_callbacks$1 = require_callbacks2();
    var require_context2 = require_context();
    var uuid = require_rolldown_runtime5.__toESM((init_esm_node(), __toCommonJS(esm_node_exports)));
    var manager_exports = {};
    require_rolldown_runtime5.__export(manager_exports, {
      BaseCallbackManager: () => BaseCallbackManager,
      BaseRunManager: () => BaseRunManager,
      CallbackManager: () => CallbackManager,
      CallbackManagerForChainRun: () => CallbackManagerForChainRun,
      CallbackManagerForLLMRun: () => CallbackManagerForLLMRun,
      CallbackManagerForRetrieverRun: () => CallbackManagerForRetrieverRun,
      CallbackManagerForToolRun: () => CallbackManagerForToolRun,
      ensureHandler: () => ensureHandler,
      parseCallbackConfigArg: () => parseCallbackConfigArg
    });
    function parseCallbackConfigArg(arg) {
      if (!arg) return {};
      else if (Array.isArray(arg) || "name" in arg) return { callbacks: arg };
      else return arg;
    }
    var BaseCallbackManager = class {
      setHandler(handler) {
        return this.setHandlers([handler]);
      }
    };
    var BaseRunManager = class {
      constructor(runId, handlers, inheritableHandlers, tags, inheritableTags, metadata, inheritableMetadata, _parentRunId) {
        this.runId = runId;
        this.handlers = handlers;
        this.inheritableHandlers = inheritableHandlers;
        this.tags = tags;
        this.inheritableTags = inheritableTags;
        this.metadata = metadata;
        this.inheritableMetadata = inheritableMetadata;
        this._parentRunId = _parentRunId;
      }
      get parentRunId() {
        return this._parentRunId;
      }
      async handleText(text) {
        await Promise.all(this.handlers.map((handler) => require_callbacks3.consumeCallback(async () => {
          try {
            await handler.handleText?.(text, this.runId, this._parentRunId, this.tags);
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleText: ${err}`);
            if (handler.raiseError) throw err;
          }
        }, handler.awaitHandlers)));
      }
      async handleCustomEvent(eventName, data, _runId, _tags, _metadata) {
        await Promise.all(this.handlers.map((handler) => require_callbacks3.consumeCallback(async () => {
          try {
            await handler.handleCustomEvent?.(eventName, data, this.runId, this.tags, this.metadata);
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);
            if (handler.raiseError) throw err;
          }
        }, handler.awaitHandlers)));
      }
    };
    var CallbackManagerForRetrieverRun = class extends BaseRunManager {
      getChild(tag) {
        const manager = new CallbackManager(this.runId);
        manager.setHandlers(this.inheritableHandlers);
        manager.addTags(this.inheritableTags);
        manager.addMetadata(this.inheritableMetadata);
        if (tag) manager.addTags([tag], false);
        return manager;
      }
      async handleRetrieverEnd(documents) {
        await Promise.all(this.handlers.map((handler) => require_callbacks3.consumeCallback(async () => {
          if (!handler.ignoreRetriever) try {
            await handler.handleRetrieverEnd?.(documents, this.runId, this._parentRunId, this.tags);
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleRetriever`);
            if (handler.raiseError) throw err;
          }
        }, handler.awaitHandlers)));
      }
      async handleRetrieverError(err) {
        await Promise.all(this.handlers.map((handler) => require_callbacks3.consumeCallback(async () => {
          if (!handler.ignoreRetriever) try {
            await handler.handleRetrieverError?.(err, this.runId, this._parentRunId, this.tags);
          } catch (error) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`);
            if (handler.raiseError) throw err;
          }
        }, handler.awaitHandlers)));
      }
    };
    var CallbackManagerForLLMRun = class extends BaseRunManager {
      async handleLLMNewToken(token, idx, _runId, _parentRunId, _tags, fields) {
        await Promise.all(this.handlers.map((handler) => require_callbacks3.consumeCallback(async () => {
          if (!handler.ignoreLLM) try {
            await handler.handleLLMNewToken?.(token, idx ?? {
              prompt: 0,
              completion: 0
            }, this.runId, this._parentRunId, this.tags, fields);
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`);
            if (handler.raiseError) throw err;
          }
        }, handler.awaitHandlers)));
      }
      async handleLLMError(err, _runId, _parentRunId, _tags, extraParams) {
        await Promise.all(this.handlers.map((handler) => require_callbacks3.consumeCallback(async () => {
          if (!handler.ignoreLLM) try {
            await handler.handleLLMError?.(err, this.runId, this._parentRunId, this.tags, extraParams);
          } catch (err$1) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleLLMError: ${err$1}`);
            if (handler.raiseError) throw err$1;
          }
        }, handler.awaitHandlers)));
      }
      async handleLLMEnd(output, _runId, _parentRunId, _tags, extraParams) {
        await Promise.all(this.handlers.map((handler) => require_callbacks3.consumeCallback(async () => {
          if (!handler.ignoreLLM) try {
            await handler.handleLLMEnd?.(output, this.runId, this._parentRunId, this.tags, extraParams);
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`);
            if (handler.raiseError) throw err;
          }
        }, handler.awaitHandlers)));
      }
    };
    var CallbackManagerForChainRun = class extends BaseRunManager {
      getChild(tag) {
        const manager = new CallbackManager(this.runId);
        manager.setHandlers(this.inheritableHandlers);
        manager.addTags(this.inheritableTags);
        manager.addMetadata(this.inheritableMetadata);
        if (tag) manager.addTags([tag], false);
        return manager;
      }
      async handleChainError(err, _runId, _parentRunId, _tags, kwargs) {
        await Promise.all(this.handlers.map((handler) => require_callbacks3.consumeCallback(async () => {
          if (!handler.ignoreChain) try {
            await handler.handleChainError?.(err, this.runId, this._parentRunId, this.tags, kwargs);
          } catch (err$1) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleChainError: ${err$1}`);
            if (handler.raiseError) throw err$1;
          }
        }, handler.awaitHandlers)));
      }
      async handleChainEnd(output, _runId, _parentRunId, _tags, kwargs) {
        await Promise.all(this.handlers.map((handler) => require_callbacks3.consumeCallback(async () => {
          if (!handler.ignoreChain) try {
            await handler.handleChainEnd?.(output, this.runId, this._parentRunId, this.tags, kwargs);
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`);
            if (handler.raiseError) throw err;
          }
        }, handler.awaitHandlers)));
      }
      async handleAgentAction(action) {
        await Promise.all(this.handlers.map((handler) => require_callbacks3.consumeCallback(async () => {
          if (!handler.ignoreAgent) try {
            await handler.handleAgentAction?.(action, this.runId, this._parentRunId, this.tags);
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`);
            if (handler.raiseError) throw err;
          }
        }, handler.awaitHandlers)));
      }
      async handleAgentEnd(action) {
        await Promise.all(this.handlers.map((handler) => require_callbacks3.consumeCallback(async () => {
          if (!handler.ignoreAgent) try {
            await handler.handleAgentEnd?.(action, this.runId, this._parentRunId, this.tags);
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`);
            if (handler.raiseError) throw err;
          }
        }, handler.awaitHandlers)));
      }
    };
    var CallbackManagerForToolRun = class extends BaseRunManager {
      getChild(tag) {
        const manager = new CallbackManager(this.runId);
        manager.setHandlers(this.inheritableHandlers);
        manager.addTags(this.inheritableTags);
        manager.addMetadata(this.inheritableMetadata);
        if (tag) manager.addTags([tag], false);
        return manager;
      }
      async handleToolError(err) {
        await Promise.all(this.handlers.map((handler) => require_callbacks3.consumeCallback(async () => {
          if (!handler.ignoreAgent) try {
            await handler.handleToolError?.(err, this.runId, this._parentRunId, this.tags);
          } catch (err$1) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleToolError: ${err$1}`);
            if (handler.raiseError) throw err$1;
          }
        }, handler.awaitHandlers)));
      }
      async handleToolEnd(output) {
        await Promise.all(this.handlers.map((handler) => require_callbacks3.consumeCallback(async () => {
          if (!handler.ignoreAgent) try {
            await handler.handleToolEnd?.(output, this.runId, this._parentRunId, this.tags);
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`);
            if (handler.raiseError) throw err;
          }
        }, handler.awaitHandlers)));
      }
    };
    var CallbackManager = class CallbackManager2 extends BaseCallbackManager {
      handlers = [];
      inheritableHandlers = [];
      tags = [];
      inheritableTags = [];
      metadata = {};
      inheritableMetadata = {};
      name = "callback_manager";
      _parentRunId;
      constructor(parentRunId, options) {
        super();
        this.handlers = options?.handlers ?? this.handlers;
        this.inheritableHandlers = options?.inheritableHandlers ?? this.inheritableHandlers;
        this.tags = options?.tags ?? this.tags;
        this.inheritableTags = options?.inheritableTags ?? this.inheritableTags;
        this.metadata = options?.metadata ?? this.metadata;
        this.inheritableMetadata = options?.inheritableMetadata ?? this.inheritableMetadata;
        this._parentRunId = parentRunId;
      }
      /**
      * Gets the parent run ID, if any.
      *
      * @returns The parent run ID.
      */
      getParentRunId() {
        return this._parentRunId;
      }
      async handleLLMStart(llm, prompts, runId = void 0, _parentRunId = void 0, extraParams = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
        return Promise.all(prompts.map(async (prompt, idx) => {
          const runId_ = idx === 0 && runId ? runId : (0, uuid.v4)();
          await Promise.all(this.handlers.map((handler) => {
            if (handler.ignoreLLM) return;
            if (require_tracers_base.isBaseTracer(handler)) handler._createRunForLLMStart(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
            return require_callbacks3.consumeCallback(async () => {
              try {
                await handler.handleLLMStart?.(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
              } catch (err) {
                const logFunction = handler.raiseError ? console.error : console.warn;
                logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);
                if (handler.raiseError) throw err;
              }
            }, handler.awaitHandlers);
          }));
          return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
        }));
      }
      async handleChatModelStart(llm, messages, runId = void 0, _parentRunId = void 0, extraParams = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
        return Promise.all(messages.map(async (messageGroup, idx) => {
          const runId_ = idx === 0 && runId ? runId : (0, uuid.v4)();
          await Promise.all(this.handlers.map((handler) => {
            if (handler.ignoreLLM) return;
            if (require_tracers_base.isBaseTracer(handler)) handler._createRunForChatModelStart(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
            return require_callbacks3.consumeCallback(async () => {
              try {
                if (handler.handleChatModelStart) await handler.handleChatModelStart?.(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
                else if (handler.handleLLMStart) {
                  const messageString = require_utils10.getBufferString(messageGroup);
                  await handler.handleLLMStart?.(llm, [messageString], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
                }
              } catch (err) {
                const logFunction = handler.raiseError ? console.error : console.warn;
                logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);
                if (handler.raiseError) throw err;
              }
            }, handler.awaitHandlers);
          }));
          return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
        }));
      }
      async handleChainStart(chain, inputs, runId = (0, uuid.v4)(), runType = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
        await Promise.all(this.handlers.map((handler) => {
          if (handler.ignoreChain) return;
          if (require_tracers_base.isBaseTracer(handler)) handler._createRunForChainStart(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);
          return require_callbacks3.consumeCallback(async () => {
            try {
              await handler.handleChainStart?.(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);
            } catch (err) {
              const logFunction = handler.raiseError ? console.error : console.warn;
              logFunction(`Error in handler ${handler.constructor.name}, handleChainStart: ${err}`);
              if (handler.raiseError) throw err;
            }
          }, handler.awaitHandlers);
        }));
        return new CallbackManagerForChainRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
      }
      async handleToolStart(tool, input, runId = (0, uuid.v4)(), _parentRunId = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
        await Promise.all(this.handlers.map((handler) => {
          if (handler.ignoreAgent) return;
          if (require_tracers_base.isBaseTracer(handler)) handler._createRunForToolStart(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);
          return require_callbacks3.consumeCallback(async () => {
            try {
              await handler.handleToolStart?.(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);
            } catch (err) {
              const logFunction = handler.raiseError ? console.error : console.warn;
              logFunction(`Error in handler ${handler.constructor.name}, handleToolStart: ${err}`);
              if (handler.raiseError) throw err;
            }
          }, handler.awaitHandlers);
        }));
        return new CallbackManagerForToolRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
      }
      async handleRetrieverStart(retriever, query, runId = (0, uuid.v4)(), _parentRunId = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
        await Promise.all(this.handlers.map((handler) => {
          if (handler.ignoreRetriever) return;
          if (require_tracers_base.isBaseTracer(handler)) handler._createRunForRetrieverStart(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);
          return require_callbacks3.consumeCallback(async () => {
            try {
              await handler.handleRetrieverStart?.(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);
            } catch (err) {
              const logFunction = handler.raiseError ? console.error : console.warn;
              logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`);
              if (handler.raiseError) throw err;
            }
          }, handler.awaitHandlers);
        }));
        return new CallbackManagerForRetrieverRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
      }
      async handleCustomEvent(eventName, data, runId, _tags, _metadata) {
        await Promise.all(this.handlers.map((handler) => require_callbacks3.consumeCallback(async () => {
          if (!handler.ignoreCustomEvent) try {
            await handler.handleCustomEvent?.(eventName, data, runId, this.tags, this.metadata);
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);
            if (handler.raiseError) throw err;
          }
        }, handler.awaitHandlers)));
      }
      addHandler(handler, inherit = true) {
        this.handlers.push(handler);
        if (inherit) this.inheritableHandlers.push(handler);
      }
      removeHandler(handler) {
        this.handlers = this.handlers.filter((_handler) => _handler !== handler);
        this.inheritableHandlers = this.inheritableHandlers.filter((_handler) => _handler !== handler);
      }
      setHandlers(handlers, inherit = true) {
        this.handlers = [];
        this.inheritableHandlers = [];
        for (const handler of handlers) this.addHandler(handler, inherit);
      }
      addTags(tags, inherit = true) {
        this.removeTags(tags);
        this.tags.push(...tags);
        if (inherit) this.inheritableTags.push(...tags);
      }
      removeTags(tags) {
        this.tags = this.tags.filter((tag) => !tags.includes(tag));
        this.inheritableTags = this.inheritableTags.filter((tag) => !tags.includes(tag));
      }
      addMetadata(metadata, inherit = true) {
        this.metadata = {
          ...this.metadata,
          ...metadata
        };
        if (inherit) this.inheritableMetadata = {
          ...this.inheritableMetadata,
          ...metadata
        };
      }
      removeMetadata(metadata) {
        for (const key of Object.keys(metadata)) {
          delete this.metadata[key];
          delete this.inheritableMetadata[key];
        }
      }
      copy(additionalHandlers = [], inherit = true) {
        const manager = new CallbackManager2(this._parentRunId);
        for (const handler of this.handlers) {
          const inheritable = this.inheritableHandlers.includes(handler);
          manager.addHandler(handler, inheritable);
        }
        for (const tag of this.tags) {
          const inheritable = this.inheritableTags.includes(tag);
          manager.addTags([tag], inheritable);
        }
        for (const key of Object.keys(this.metadata)) {
          const inheritable = Object.keys(this.inheritableMetadata).includes(key);
          manager.addMetadata({ [key]: this.metadata[key] }, inheritable);
        }
        for (const handler of additionalHandlers) {
          if (manager.handlers.filter((h) => h.name === "console_callback_handler").some((h) => h.name === handler.name)) continue;
          manager.addHandler(handler, inherit);
        }
        return manager;
      }
      static fromHandlers(handlers) {
        class Handler extends require_callbacks_base.BaseCallbackHandler {
          name = (0, uuid.v4)();
          constructor() {
            super();
            Object.assign(this, handlers);
          }
        }
        const manager = new this();
        manager.addHandler(new Handler());
        return manager;
      }
      static configure(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {
        return this._configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options);
      }
      static _configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {
        let callbackManager;
        if (inheritableHandlers || localHandlers) {
          if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {
            callbackManager = new CallbackManager2();
            callbackManager.setHandlers(inheritableHandlers?.map(ensureHandler) ?? [], true);
          } else callbackManager = inheritableHandlers;
          callbackManager = callbackManager.copy(Array.isArray(localHandlers) ? localHandlers.map(ensureHandler) : localHandlers?.handlers, false);
        }
        const verboseEnabled = require_utils_env.getEnvironmentVariable("LANGCHAIN_VERBOSE") === "true" || options?.verbose;
        const tracingV2Enabled = require_tracers_tracer_langchain.LangChainTracer.getTraceableRunTree()?.tracingEnabled || require_callbacks$1.isTracingEnabled();
        const tracingEnabled = tracingV2Enabled || (require_utils_env.getEnvironmentVariable("LANGCHAIN_TRACING") ?? false);
        if (verboseEnabled || tracingEnabled) {
          if (!callbackManager) callbackManager = new CallbackManager2();
          if (verboseEnabled && !callbackManager.handlers.some((handler) => handler.name === require_tracers_console.ConsoleCallbackHandler.prototype.name)) {
            const consoleHandler = new require_tracers_console.ConsoleCallbackHandler();
            callbackManager.addHandler(consoleHandler, true);
          }
          if (tracingEnabled && !callbackManager.handlers.some((handler) => handler.name === "langchain_tracer")) {
            if (tracingV2Enabled) {
              const tracerV2 = new require_tracers_tracer_langchain.LangChainTracer();
              callbackManager.addHandler(tracerV2, true);
            }
          }
          if (tracingV2Enabled) {
            const implicitRunTree = require_tracers_tracer_langchain.LangChainTracer.getTraceableRunTree();
            if (implicitRunTree && callbackManager._parentRunId === void 0) {
              callbackManager._parentRunId = implicitRunTree.id;
              const tracerV2 = callbackManager.handlers.find((handler) => handler.name === "langchain_tracer");
              tracerV2?.updateFromRunTree(implicitRunTree);
            }
          }
        }
        for (const { contextVar, inheritable = true, handlerClass, envVar } of require_context2._getConfigureHooks()) {
          const createIfNotInContext = envVar && require_utils_env.getEnvironmentVariable(envVar) === "true" && handlerClass;
          let handler;
          const contextVarValue = contextVar !== void 0 ? require_context2.getContextVariable(contextVar) : void 0;
          if (contextVarValue && require_callbacks_base.isBaseCallbackHandler(contextVarValue)) handler = contextVarValue;
          else if (createIfNotInContext) handler = new handlerClass({});
          if (handler !== void 0) {
            if (!callbackManager) callbackManager = new CallbackManager2();
            if (!callbackManager.handlers.some((h) => h.name === handler.name)) callbackManager.addHandler(handler, inheritable);
          }
        }
        if (inheritableTags || localTags) {
          if (callbackManager) {
            callbackManager.addTags(inheritableTags ?? []);
            callbackManager.addTags(localTags ?? [], false);
          }
        }
        if (inheritableMetadata || localMetadata) {
          if (callbackManager) {
            callbackManager.addMetadata(inheritableMetadata ?? {});
            callbackManager.addMetadata(localMetadata ?? {}, false);
          }
        }
        return callbackManager;
      }
    };
    function ensureHandler(handler) {
      if ("name" in handler) return handler;
      return require_callbacks_base.BaseCallbackHandler.fromMethods(handler);
    }
    exports2.BaseCallbackManager = BaseCallbackManager;
    exports2.BaseRunManager = BaseRunManager;
    exports2.CallbackManager = CallbackManager;
    exports2.CallbackManagerForChainRun = CallbackManagerForChainRun;
    exports2.CallbackManagerForLLMRun = CallbackManagerForLLMRun;
    exports2.CallbackManagerForRetrieverRun = CallbackManagerForRetrieverRun;
    exports2.CallbackManagerForToolRun = CallbackManagerForToolRun;
    exports2.ensureHandler = ensureHandler;
    Object.defineProperty(exports2, "manager_exports", {
      enumerable: true,
      get: function() {
        return manager_exports;
      }
    });
    exports2.parseCallbackConfigArg = parseCallbackConfigArg;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/singletons/async_local_storage/index.cjs
var require_async_local_storage = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/singletons/async_local_storage/index.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_globals2 = require_globals();
    var require_callbacks_manager = require_manager();
    var langsmith = require_rolldown_runtime5.__toESM(require_langsmith());
    var MockAsyncLocalStorage = class {
      getStore() {
        return void 0;
      }
      run(_store, callback) {
        return callback();
      }
      enterWith(_store) {
        return void 0;
      }
    };
    var mockAsyncLocalStorage = new MockAsyncLocalStorage();
    var LC_CHILD_KEY = Symbol.for("lc:child_config");
    var AsyncLocalStorageProvider = class {
      getInstance() {
        return require_globals2.getGlobalAsyncLocalStorageInstance() ?? mockAsyncLocalStorage;
      }
      getRunnableConfig() {
        const storage = this.getInstance();
        return storage.getStore()?.extra?.[LC_CHILD_KEY];
      }
      runWithConfig(config, callback, avoidCreatingRootRunTree) {
        const callbackManager = require_callbacks_manager.CallbackManager._configureSync(config?.callbacks, void 0, config?.tags, void 0, config?.metadata);
        const storage = this.getInstance();
        const previousValue = storage.getStore();
        const parentRunId = callbackManager?.getParentRunId();
        const langChainTracer = callbackManager?.handlers?.find((handler) => handler?.name === "langchain_tracer");
        let runTree;
        if (langChainTracer && parentRunId) runTree = langChainTracer.getRunTreeWithTracingConfig(parentRunId);
        else if (!avoidCreatingRootRunTree) runTree = new langsmith.RunTree({
          name: "<runnable_lambda>",
          tracingEnabled: false
        });
        if (runTree) runTree.extra = {
          ...runTree.extra,
          [LC_CHILD_KEY]: config
        };
        if (previousValue !== void 0 && previousValue[require_globals2._CONTEXT_VARIABLES_KEY] !== void 0) {
          if (runTree === void 0) runTree = {};
          runTree[require_globals2._CONTEXT_VARIABLES_KEY] = previousValue[require_globals2._CONTEXT_VARIABLES_KEY];
        }
        return storage.run(runTree, callback);
      }
      initializeGlobalInstance(instance) {
        if (require_globals2.getGlobalAsyncLocalStorageInstance() === void 0) require_globals2.setGlobalAsyncLocalStorageInstance(instance);
      }
    };
    var AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();
    exports2.AsyncLocalStorageProviderSingleton = AsyncLocalStorageProviderSingleton;
    exports2.MockAsyncLocalStorage = MockAsyncLocalStorage;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/singletons/index.cjs
var require_singletons = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/singletons/index.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_globals2 = require_globals();
    var require_index = require_async_local_storage();
    var singletons_exports = {};
    require_rolldown_runtime5.__export(singletons_exports, {
      AsyncLocalStorageProviderSingleton: () => require_index.AsyncLocalStorageProviderSingleton,
      MockAsyncLocalStorage: () => require_index.MockAsyncLocalStorage,
      _CONTEXT_VARIABLES_KEY: () => require_globals2._CONTEXT_VARIABLES_KEY
    });
    exports2.AsyncLocalStorageProviderSingleton = require_index.AsyncLocalStorageProviderSingleton;
    exports2.MockAsyncLocalStorage = require_index.MockAsyncLocalStorage;
    exports2._CONTEXT_VARIABLES_KEY = require_globals2._CONTEXT_VARIABLES_KEY;
    Object.defineProperty(exports2, "singletons_exports", {
      enumerable: true,
      get: function() {
        return singletons_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/config.cjs
var require_config = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/config.cjs"(exports2) {
    var require_callbacks_manager = require_manager();
    var require_index = require_async_local_storage();
    require_singletons();
    var DEFAULT_RECURSION_LIMIT = 25;
    async function getCallbackManagerForConfig(config) {
      return require_callbacks_manager.CallbackManager._configureSync(config?.callbacks, void 0, config?.tags, void 0, config?.metadata);
    }
    function mergeConfigs(...configs) {
      const copy = {};
      for (const options of configs.filter((c) => !!c)) for (const key of Object.keys(options)) if (key === "metadata") copy[key] = {
        ...copy[key],
        ...options[key]
      };
      else if (key === "tags") {
        const baseKeys = copy[key] ?? [];
        copy[key] = [...new Set(baseKeys.concat(options[key] ?? []))];
      } else if (key === "configurable") copy[key] = {
        ...copy[key],
        ...options[key]
      };
      else if (key === "timeout") {
        if (copy.timeout === void 0) copy.timeout = options.timeout;
        else if (options.timeout !== void 0) copy.timeout = Math.min(copy.timeout, options.timeout);
      } else if (key === "signal") {
        if (copy.signal === void 0) copy.signal = options.signal;
        else if (options.signal !== void 0) if ("any" in AbortSignal) copy.signal = AbortSignal.any([copy.signal, options.signal]);
        else copy.signal = options.signal;
      } else if (key === "callbacks") {
        const baseCallbacks = copy.callbacks;
        const providedCallbacks = options.callbacks;
        if (Array.isArray(providedCallbacks)) if (!baseCallbacks) copy.callbacks = providedCallbacks;
        else if (Array.isArray(baseCallbacks)) copy.callbacks = baseCallbacks.concat(providedCallbacks);
        else {
          const manager = baseCallbacks.copy();
          for (const callback of providedCallbacks) manager.addHandler(require_callbacks_manager.ensureHandler(callback), true);
          copy.callbacks = manager;
        }
        else if (providedCallbacks) if (!baseCallbacks) copy.callbacks = providedCallbacks;
        else if (Array.isArray(baseCallbacks)) {
          const manager = providedCallbacks.copy();
          for (const callback of baseCallbacks) manager.addHandler(require_callbacks_manager.ensureHandler(callback), true);
          copy.callbacks = manager;
        } else copy.callbacks = new require_callbacks_manager.CallbackManager(providedCallbacks._parentRunId, {
          handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),
          inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),
          tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),
          inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),
          metadata: {
            ...baseCallbacks.metadata,
            ...providedCallbacks.metadata
          }
        });
      } else {
        const typedKey = key;
        copy[typedKey] = options[typedKey] ?? copy[typedKey];
      }
      return copy;
    }
    var PRIMITIVES = /* @__PURE__ */ new Set([
      "string",
      "number",
      "boolean"
    ]);
    function ensureConfig(config) {
      const implicitConfig = require_index.AsyncLocalStorageProviderSingleton.getRunnableConfig();
      let empty = {
        tags: [],
        metadata: {},
        recursionLimit: 25,
        runId: void 0
      };
      if (implicitConfig) {
        const { runId, runName, ...rest } = implicitConfig;
        empty = Object.entries(rest).reduce((currentConfig, [key, value]) => {
          if (value !== void 0) currentConfig[key] = value;
          return currentConfig;
        }, empty);
      }
      if (config) empty = Object.entries(config).reduce((currentConfig, [key, value]) => {
        if (value !== void 0) currentConfig[key] = value;
        return currentConfig;
      }, empty);
      if (empty?.configurable) {
        for (const key of Object.keys(empty.configurable)) if (PRIMITIVES.has(typeof empty.configurable[key]) && !empty.metadata?.[key]) {
          if (!empty.metadata) empty.metadata = {};
          empty.metadata[key] = empty.configurable[key];
        }
      }
      if (empty.timeout !== void 0) {
        if (empty.timeout <= 0) throw new Error("Timeout must be a positive number");
        const timeoutSignal = AbortSignal.timeout(empty.timeout);
        if (empty.signal !== void 0) {
          if ("any" in AbortSignal) empty.signal = AbortSignal.any([empty.signal, timeoutSignal]);
        } else empty.signal = timeoutSignal;
        delete empty.timeout;
      }
      return empty;
    }
    function patchConfig(config = {}, { callbacks, maxConcurrency, recursionLimit, runName, configurable, runId } = {}) {
      const newConfig = ensureConfig(config);
      if (callbacks !== void 0) {
        delete newConfig.runName;
        newConfig.callbacks = callbacks;
      }
      if (recursionLimit !== void 0) newConfig.recursionLimit = recursionLimit;
      if (maxConcurrency !== void 0) newConfig.maxConcurrency = maxConcurrency;
      if (runName !== void 0) newConfig.runName = runName;
      if (configurable !== void 0) newConfig.configurable = {
        ...newConfig.configurable,
        ...configurable
      };
      if (runId !== void 0) delete newConfig.runId;
      return newConfig;
    }
    function pickRunnableConfigKeys(config) {
      return config ? {
        configurable: config.configurable,
        recursionLimit: config.recursionLimit,
        callbacks: config.callbacks,
        tags: config.tags,
        metadata: config.metadata,
        maxConcurrency: config.maxConcurrency,
        timeout: config.timeout,
        signal: config.signal
      } : void 0;
    }
    exports2.DEFAULT_RECURSION_LIMIT = DEFAULT_RECURSION_LIMIT;
    exports2.ensureConfig = ensureConfig;
    exports2.getCallbackManagerForConfig = getCallbackManagerForConfig;
    exports2.mergeConfigs = mergeConfigs;
    exports2.patchConfig = patchConfig;
    exports2.pickRunnableConfigKeys = pickRunnableConfigKeys;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/signal.cjs
var require_signal = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/signal.cjs"(exports2) {
    async function raceWithSignal(promise, signal) {
      if (signal === void 0) return promise;
      let listener;
      return Promise.race([promise.catch((err) => {
        if (!signal?.aborted) throw err;
        else return void 0;
      }), new Promise((_, reject) => {
        listener = () => {
          reject(getAbortSignalError(signal));
        };
        signal.addEventListener("abort", listener);
        if (signal.aborted) reject(getAbortSignalError(signal));
      })]).finally(() => signal.removeEventListener("abort", listener));
    }
    function getAbortSignalError(signal) {
      if (signal?.reason instanceof Error) return signal.reason;
      if (typeof signal?.reason === "string") return new Error(signal.reason);
      return /* @__PURE__ */ new Error("Aborted");
    }
    exports2.getAbortSignalError = getAbortSignalError;
    exports2.raceWithSignal = raceWithSignal;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/types/zod.cjs
var require_zod = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/types/zod.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var zod_v4_core = require_rolldown_runtime5.__toESM(require_core2());
    function isZodSchemaV4(schema) {
      if (typeof schema !== "object" || schema === null) return false;
      const obj = schema;
      if (!("_zod" in obj)) return false;
      const zod = obj._zod;
      return typeof zod === "object" && zod !== null && "def" in zod;
    }
    function isZodSchemaV3(schema) {
      if (typeof schema !== "object" || schema === null) return false;
      const obj = schema;
      if (!("_def" in obj) || "_zod" in obj) return false;
      const def = obj._def;
      return typeof def === "object" && def != null && "typeName" in def;
    }
    function isZodSchema(schema) {
      if (isZodSchemaV4(schema)) console.warn("[WARNING] Attempting to use Zod 4 schema in a context where Zod 3 schema is expected. This may cause unexpected behavior.");
      return isZodSchemaV3(schema);
    }
    function isInteropZodSchema(input) {
      if (!input) return false;
      if (typeof input !== "object") return false;
      if (Array.isArray(input)) return false;
      if (isZodSchemaV4(input) || isZodSchemaV3(input)) return true;
      return false;
    }
    function isZodLiteralV3(obj) {
      if (typeof obj === "object" && obj !== null && "_def" in obj && typeof obj._def === "object" && obj._def !== null && "typeName" in obj._def && obj._def.typeName === "ZodLiteral") return true;
      return false;
    }
    function isZodLiteralV4(obj) {
      if (!isZodSchemaV4(obj)) return false;
      if (typeof obj === "object" && obj !== null && "_zod" in obj && typeof obj._zod === "object" && obj._zod !== null && "def" in obj._zod && typeof obj._zod.def === "object" && obj._zod.def !== null && "type" in obj._zod.def && obj._zod.def.type === "literal") return true;
      return false;
    }
    function isInteropZodLiteral(obj) {
      if (isZodLiteralV3(obj)) return true;
      if (isZodLiteralV4(obj)) return true;
      return false;
    }
    async function interopSafeParseAsync(schema, input) {
      if (isZodSchemaV4(schema)) try {
        const data = await (0, zod_v4_core.parseAsync)(schema, input);
        return {
          success: true,
          data
        };
      } catch (error) {
        return {
          success: false,
          error
        };
      }
      if (isZodSchemaV3(schema)) return await schema.safeParseAsync(input);
      throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
    }
    async function interopParseAsync(schema, input) {
      if (isZodSchemaV4(schema)) return await (0, zod_v4_core.parseAsync)(schema, input);
      if (isZodSchemaV3(schema)) return await schema.parseAsync(input);
      throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
    }
    function interopSafeParse(schema, input) {
      if (isZodSchemaV4(schema)) try {
        const data = (0, zod_v4_core.parse)(schema, input);
        return {
          success: true,
          data
        };
      } catch (error) {
        return {
          success: false,
          error
        };
      }
      if (isZodSchemaV3(schema)) return schema.safeParse(input);
      throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
    }
    function interopParse(schema, input) {
      if (isZodSchemaV4(schema)) return (0, zod_v4_core.parse)(schema, input);
      if (isZodSchemaV3(schema)) return schema.parse(input);
      throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
    }
    function getSchemaDescription(schema) {
      if (isZodSchemaV4(schema)) return zod_v4_core.globalRegistry.get(schema)?.description;
      if (isZodSchemaV3(schema)) return schema.description;
      if ("description" in schema && typeof schema.description === "string") return schema.description;
      return void 0;
    }
    function isShapelessZodSchema(schema) {
      if (!isInteropZodSchema(schema)) return false;
      if (isZodSchemaV3(schema)) {
        const def = schema._def;
        if (def.typeName === "ZodObject") {
          const obj = schema;
          return !obj.shape || Object.keys(obj.shape).length === 0;
        }
        if (def.typeName === "ZodRecord") return true;
      }
      if (isZodSchemaV4(schema)) {
        const def = schema._zod.def;
        if (def.type === "object") {
          const obj = schema;
          return !obj.shape || Object.keys(obj.shape).length === 0;
        }
        if (def.type === "record") return true;
      }
      if (typeof schema === "object" && schema !== null && !("shape" in schema)) return true;
      return false;
    }
    function isSimpleStringZodSchema(schema) {
      if (!isInteropZodSchema(schema)) return false;
      if (isZodSchemaV3(schema)) {
        const def = schema._def;
        return def.typeName === "ZodString";
      }
      if (isZodSchemaV4(schema)) {
        const def = schema._zod.def;
        return def.type === "string";
      }
      return false;
    }
    function isZodObjectV3(obj) {
      if (typeof obj === "object" && obj !== null && "_def" in obj && typeof obj._def === "object" && obj._def !== null && "typeName" in obj._def && obj._def.typeName === "ZodObject") return true;
      return false;
    }
    function isZodObjectV4(obj) {
      if (!isZodSchemaV4(obj)) return false;
      if (typeof obj === "object" && obj !== null && "_zod" in obj && typeof obj._zod === "object" && obj._zod !== null && "def" in obj._zod && typeof obj._zod.def === "object" && obj._zod.def !== null && "type" in obj._zod.def && obj._zod.def.type === "object") return true;
      return false;
    }
    function isZodArrayV4(obj) {
      if (!isZodSchemaV4(obj)) return false;
      if (typeof obj === "object" && obj !== null && "_zod" in obj && typeof obj._zod === "object" && obj._zod !== null && "def" in obj._zod && typeof obj._zod.def === "object" && obj._zod.def !== null && "type" in obj._zod.def && obj._zod.def.type === "array") return true;
      return false;
    }
    function isInteropZodObject(obj) {
      if (isZodObjectV3(obj)) return true;
      if (isZodObjectV4(obj)) return true;
      return false;
    }
    function getInteropZodObjectShape(schema) {
      if (isZodSchemaV3(schema)) return schema.shape;
      if (isZodSchemaV4(schema)) return schema._zod.def.shape;
      throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
    }
    function extendInteropZodObject(schema, extension) {
      if (isZodSchemaV3(schema)) return schema.extend(extension);
      if (isZodSchemaV4(schema)) return zod_v4_core.util.extend(schema, extension);
      throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
    }
    function interopZodObjectPartial(schema) {
      if (isZodSchemaV3(schema)) return schema.partial();
      if (isZodSchemaV4(schema)) return zod_v4_core.util.partial(zod_v4_core.$ZodOptional, schema, void 0);
      throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
    }
    function interopZodObjectStrict(schema, recursive = false) {
      if (isZodSchemaV3(schema)) return schema.strict();
      if (isZodObjectV4(schema)) {
        const outputShape = schema._zod.def.shape;
        if (recursive) for (const [key, keySchema] of Object.entries(schema._zod.def.shape)) {
          if (isZodObjectV4(keySchema)) {
            const outputSchema = interopZodObjectStrict(keySchema, recursive);
            outputShape[key] = outputSchema;
          } else if (isZodArrayV4(keySchema)) {
            let elementSchema = keySchema._zod.def.element;
            if (isZodObjectV4(elementSchema)) elementSchema = interopZodObjectStrict(elementSchema, recursive);
            outputShape[key] = (0, zod_v4_core.clone)(keySchema, {
              ...keySchema._zod.def,
              element: elementSchema
            });
          } else outputShape[key] = keySchema;
          const meta$1 = zod_v4_core.globalRegistry.get(keySchema);
          if (meta$1) zod_v4_core.globalRegistry.add(outputShape[key], meta$1);
        }
        const modifiedSchema = (0, zod_v4_core.clone)(schema, {
          ...schema._zod.def,
          shape: outputShape,
          catchall: (0, zod_v4_core._never)(zod_v4_core.$ZodNever)
        });
        const meta = zod_v4_core.globalRegistry.get(schema);
        if (meta) zod_v4_core.globalRegistry.add(modifiedSchema, meta);
        return modifiedSchema;
      }
      throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
    }
    function interopZodObjectPassthrough(schema, recursive = false) {
      if (isZodObjectV3(schema)) return schema.passthrough();
      if (isZodObjectV4(schema)) {
        const outputShape = schema._zod.def.shape;
        if (recursive) for (const [key, keySchema] of Object.entries(schema._zod.def.shape)) {
          if (isZodObjectV4(keySchema)) {
            const outputSchema = interopZodObjectPassthrough(keySchema, recursive);
            outputShape[key] = outputSchema;
          } else if (isZodArrayV4(keySchema)) {
            let elementSchema = keySchema._zod.def.element;
            if (isZodObjectV4(elementSchema)) elementSchema = interopZodObjectPassthrough(elementSchema, recursive);
            outputShape[key] = (0, zod_v4_core.clone)(keySchema, {
              ...keySchema._zod.def,
              element: elementSchema
            });
          } else outputShape[key] = keySchema;
          const meta$1 = zod_v4_core.globalRegistry.get(keySchema);
          if (meta$1) zod_v4_core.globalRegistry.add(outputShape[key], meta$1);
        }
        const modifiedSchema = (0, zod_v4_core.clone)(schema, {
          ...schema._zod.def,
          shape: outputShape,
          catchall: (0, zod_v4_core._unknown)(zod_v4_core.$ZodUnknown)
        });
        const meta = zod_v4_core.globalRegistry.get(schema);
        if (meta) zod_v4_core.globalRegistry.add(modifiedSchema, meta);
        return modifiedSchema;
      }
      throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
    }
    function getInteropZodDefaultGetter(schema) {
      if (isZodSchemaV3(schema)) try {
        const defaultValue = schema.parse(void 0);
        return () => defaultValue;
      } catch {
        return void 0;
      }
      if (isZodSchemaV4(schema)) try {
        const defaultValue = (0, zod_v4_core.parse)(schema, void 0);
        return () => defaultValue;
      } catch {
        return void 0;
      }
      return void 0;
    }
    function isZodTransformV3(schema) {
      return isZodSchemaV3(schema) && "typeName" in schema._def && schema._def.typeName === "ZodEffects";
    }
    function isZodTransformV4(schema) {
      return isZodSchemaV4(schema) && schema._zod.def.type === "pipe";
    }
    function interopZodTransformInputSchema(schema, recursive = false) {
      if (isZodSchemaV3(schema)) {
        if (isZodTransformV3(schema)) return interopZodTransformInputSchema(schema._def.schema, recursive);
        return schema;
      }
      if (isZodSchemaV4(schema)) {
        let outputSchema = schema;
        if (isZodTransformV4(schema)) outputSchema = interopZodTransformInputSchema(schema._zod.def.in, recursive);
        if (recursive) {
          if (isZodObjectV4(outputSchema)) {
            const outputShape = outputSchema._zod.def.shape;
            for (const [key, keySchema] of Object.entries(outputSchema._zod.def.shape)) outputShape[key] = interopZodTransformInputSchema(keySchema, recursive);
            outputSchema = (0, zod_v4_core.clone)(outputSchema, {
              ...outputSchema._zod.def,
              shape: outputShape
            });
          } else if (isZodArrayV4(outputSchema)) {
            const elementSchema = interopZodTransformInputSchema(outputSchema._zod.def.element, recursive);
            outputSchema = (0, zod_v4_core.clone)(outputSchema, {
              ...outputSchema._zod.def,
              element: elementSchema
            });
          }
        }
        const meta = zod_v4_core.globalRegistry.get(schema);
        if (meta) zod_v4_core.globalRegistry.add(outputSchema, meta);
        return outputSchema;
      }
      throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
    }
    function interopZodObjectMakeFieldsOptional(schema, predicate) {
      if (isZodSchemaV3(schema)) {
        const shape = getInteropZodObjectShape(schema);
        const modifiedShape = {};
        for (const [key, value] of Object.entries(shape)) if (predicate(key, value)) modifiedShape[key] = value.optional();
        else modifiedShape[key] = value;
        return schema.extend(modifiedShape);
      }
      if (isZodSchemaV4(schema)) {
        const shape = getInteropZodObjectShape(schema);
        const outputShape = { ...schema._zod.def.shape };
        for (const [key, value] of Object.entries(shape)) if (predicate(key, value)) outputShape[key] = new zod_v4_core.$ZodOptional({
          type: "optional",
          innerType: value
        });
        const modifiedSchema = (0, zod_v4_core.clone)(schema, {
          ...schema._zod.def,
          shape: outputShape
        });
        const meta = zod_v4_core.globalRegistry.get(schema);
        if (meta) zod_v4_core.globalRegistry.add(modifiedSchema, meta);
        return modifiedSchema;
      }
      throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
    }
    exports2.extendInteropZodObject = extendInteropZodObject;
    exports2.getInteropZodDefaultGetter = getInteropZodDefaultGetter;
    exports2.getInteropZodObjectShape = getInteropZodObjectShape;
    exports2.getSchemaDescription = getSchemaDescription;
    exports2.interopParse = interopParse;
    exports2.interopParseAsync = interopParseAsync;
    exports2.interopSafeParse = interopSafeParse;
    exports2.interopSafeParseAsync = interopSafeParseAsync;
    exports2.interopZodObjectMakeFieldsOptional = interopZodObjectMakeFieldsOptional;
    exports2.interopZodObjectPartial = interopZodObjectPartial;
    exports2.interopZodObjectPassthrough = interopZodObjectPassthrough;
    exports2.interopZodObjectStrict = interopZodObjectStrict;
    exports2.interopZodTransformInputSchema = interopZodTransformInputSchema;
    exports2.isInteropZodLiteral = isInteropZodLiteral;
    exports2.isInteropZodObject = isInteropZodObject;
    exports2.isInteropZodSchema = isInteropZodSchema;
    exports2.isShapelessZodSchema = isShapelessZodSchema;
    exports2.isSimpleStringZodSchema = isSimpleStringZodSchema;
    exports2.isZodArrayV4 = isZodArrayV4;
    exports2.isZodLiteralV3 = isZodLiteralV3;
    exports2.isZodLiteralV4 = isZodLiteralV4;
    exports2.isZodObjectV3 = isZodObjectV3;
    exports2.isZodObjectV4 = isZodObjectV4;
    exports2.isZodSchema = isZodSchema;
    exports2.isZodSchemaV3 = isZodSchemaV3;
    exports2.isZodSchemaV4 = isZodSchemaV4;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/Options.cjs
var require_Options = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/Options.cjs"(exports2) {
    var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
    var defaultOptions = {
      name: void 0,
      $refStrategy: "root",
      basePath: ["#"],
      effectStrategy: "input",
      pipeStrategy: "all",
      dateStrategy: "format:date-time",
      mapStrategy: "entries",
      removeAdditionalStrategy: "passthrough",
      allowedAdditionalProperties: true,
      rejectedAdditionalProperties: false,
      definitionPath: "definitions",
      target: "jsonSchema7",
      strictUnions: false,
      definitions: {},
      errorMessages: false,
      markdownDescription: false,
      patternStrategy: "escape",
      applyRegexFlags: false,
      emailStrategy: "format:email",
      base64Strategy: "contentEncoding:base64",
      nameStrategy: "ref",
      openAiAnyTypeName: "OpenAiAnyType"
    };
    var getDefaultOptions = (options) => typeof options === "string" ? {
      ...defaultOptions,
      name: options
    } : {
      ...defaultOptions,
      ...options
    };
    exports2.defaultOptions = defaultOptions;
    exports2.getDefaultOptions = getDefaultOptions;
    exports2.ignoreOverride = ignoreOverride;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/Refs.cjs
var require_Refs = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/Refs.cjs"(exports2) {
    var require_Options2 = require_Options();
    var getRefs = (options) => {
      const _options = require_Options2.getDefaultOptions(options);
      const currentPath = _options.name !== void 0 ? [
        ..._options.basePath,
        _options.definitionPath,
        _options.name
      ] : _options.basePath;
      return {
        ..._options,
        flags: { hasReferencedOpenAiAnyType: false },
        currentPath,
        propertyPath: void 0,
        seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [def._def, {
          def: def._def,
          path: [
            ..._options.basePath,
            _options.definitionPath,
            name
          ],
          jsonSchema: void 0
        }]))
      };
    };
    exports2.getRefs = getRefs;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/getRelativePath.cjs
var require_getRelativePath = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/getRelativePath.cjs"(exports2) {
    var getRelativePath = (pathA, pathB) => {
      let i = 0;
      for (; i < pathA.length && i < pathB.length; i++) if (pathA[i] !== pathB[i]) break;
      return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
    };
    exports2.getRelativePath = getRelativePath;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/any.cjs
var require_any = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/any.cjs"(exports2) {
    var require_getRelativePath2 = require_getRelativePath();
    function parseAnyDef(refs) {
      if (refs.target !== "openAi") return {};
      const anyDefinitionPath = [
        ...refs.basePath,
        refs.definitionPath,
        refs.openAiAnyTypeName
      ];
      refs.flags.hasReferencedOpenAiAnyType = true;
      return { $ref: refs.$refStrategy === "relative" ? require_getRelativePath2.getRelativePath(anyDefinitionPath, refs.currentPath) : anyDefinitionPath.join("/") };
    }
    exports2.parseAnyDef = parseAnyDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/errorMessages.cjs
var require_errorMessages = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/errorMessages.cjs"(exports2) {
    function addErrorMessage(res, key, errorMessage, refs) {
      if (!refs?.errorMessages) return;
      if (errorMessage) res.errorMessage = {
        ...res.errorMessage,
        [key]: errorMessage
      };
    }
    function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
      res[key] = value;
      addErrorMessage(res, key, errorMessage, refs);
    }
    exports2.addErrorMessage = addErrorMessage;
    exports2.setResponseValueAndErrors = setResponseValueAndErrors;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/array.cjs
var require_array = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/array.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_errorMessages2 = require_errorMessages();
    var require_parseDef2 = require_parseDef();
    var zod_v3 = require_rolldown_runtime5.__toESM(require_v3());
    function parseArrayDef(def, refs) {
      const res = { type: "array" };
      if (def.type?._def && def.type?._def?.typeName !== zod_v3.ZodFirstPartyTypeKind.ZodAny) res.items = require_parseDef2.parseDef(def.type._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items"]
      });
      if (def.minLength) require_errorMessages2.setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
      if (def.maxLength) require_errorMessages2.setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
      if (def.exactLength) {
        require_errorMessages2.setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
        require_errorMessages2.setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
      }
      return res;
    }
    exports2.parseArrayDef = parseArrayDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/bigint.cjs
var require_bigint = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/bigint.cjs"(exports2) {
    var require_errorMessages2 = require_errorMessages();
    function parseBigintDef(def, refs) {
      const res = {
        type: "integer",
        format: "int64"
      };
      if (!def.checks) return res;
      for (const check of def.checks) switch (check.kind) {
        case "min":
          if (refs.target === "jsonSchema7") if (check.inclusive) require_errorMessages2.setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          else require_errorMessages2.setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          else {
            if (!check.inclusive) res.exclusiveMinimum = true;
            require_errorMessages2.setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          }
          break;
        case "max":
          if (refs.target === "jsonSchema7") if (check.inclusive) require_errorMessages2.setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          else require_errorMessages2.setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          else {
            if (!check.inclusive) res.exclusiveMaximum = true;
            require_errorMessages2.setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          }
          break;
        case "multipleOf":
          require_errorMessages2.setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
          break;
      }
      return res;
    }
    exports2.parseBigintDef = parseBigintDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/boolean.cjs
var require_boolean = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/boolean.cjs"(exports2) {
    function parseBooleanDef() {
      return { type: "boolean" };
    }
    exports2.parseBooleanDef = parseBooleanDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/branded.cjs
var require_branded = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/branded.cjs"(exports2) {
    var require_parseDef2 = require_parseDef();
    function parseBrandedDef(_def, refs) {
      return require_parseDef2.parseDef(_def.type._def, refs);
    }
    exports2.parseBrandedDef = parseBrandedDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/catch.cjs
var require_catch = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/catch.cjs"(exports2) {
    var require_parseDef2 = require_parseDef();
    var parseCatchDef = (def, refs) => {
      return require_parseDef2.parseDef(def.innerType._def, refs);
    };
    exports2.parseCatchDef = parseCatchDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/date.cjs
var require_date = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/date.cjs"(exports2) {
    var require_errorMessages2 = require_errorMessages();
    function parseDateDef(def, refs, overrideDateStrategy) {
      const strategy = overrideDateStrategy ?? refs.dateStrategy;
      if (Array.isArray(strategy)) return { anyOf: strategy.map((item) => parseDateDef(def, refs, item)) };
      switch (strategy) {
        case "string":
        case "format:date-time":
          return {
            type: "string",
            format: "date-time"
          };
        case "format:date":
          return {
            type: "string",
            format: "date"
          };
        case "integer":
          return integerDateParser(def, refs);
      }
    }
    var integerDateParser = (def, refs) => {
      const res = {
        type: "integer",
        format: "unix-time"
      };
      if (refs.target === "openApi3") return res;
      for (const check of def.checks) switch (check.kind) {
        case "min":
          require_errorMessages2.setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          break;
        case "max":
          require_errorMessages2.setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          break;
      }
      return res;
    };
    exports2.parseDateDef = parseDateDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/default.cjs
var require_default = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/default.cjs"(exports2) {
    var require_parseDef2 = require_parseDef();
    function parseDefaultDef(_def, refs) {
      return {
        ...require_parseDef2.parseDef(_def.innerType._def, refs),
        default: _def.defaultValue()
      };
    }
    exports2.parseDefaultDef = parseDefaultDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/effects.cjs
var require_effects = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/effects.cjs"(exports2) {
    var require_any2 = require_any();
    var require_parseDef2 = require_parseDef();
    function parseEffectsDef(_def, refs) {
      return refs.effectStrategy === "input" ? require_parseDef2.parseDef(_def.schema._def, refs) : require_any2.parseAnyDef(refs);
    }
    exports2.parseEffectsDef = parseEffectsDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/enum.cjs
var require_enum = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/enum.cjs"(exports2) {
    function parseEnumDef(def) {
      return {
        type: "string",
        enum: Array.from(def.values)
      };
    }
    exports2.parseEnumDef = parseEnumDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/intersection.cjs
var require_intersection = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/intersection.cjs"(exports2) {
    var require_parseDef2 = require_parseDef();
    var isJsonSchema7AllOfType = (type) => {
      if ("type" in type && type.type === "string") return false;
      return "allOf" in type;
    };
    function parseIntersectionDef(def, refs) {
      const allOf = [require_parseDef2.parseDef(def.left._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath,
          "allOf",
          "0"
        ]
      }), require_parseDef2.parseDef(def.right._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath,
          "allOf",
          "1"
        ]
      })].filter((x) => !!x);
      let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
      const mergedAllOf = [];
      allOf.forEach((schema) => {
        if (isJsonSchema7AllOfType(schema)) {
          mergedAllOf.push(...schema.allOf);
          if (schema.unevaluatedProperties === void 0) unevaluatedProperties = void 0;
        } else {
          let nestedSchema = schema;
          if ("additionalProperties" in schema && schema.additionalProperties === false) {
            const { additionalProperties, ...rest } = schema;
            nestedSchema = rest;
          } else unevaluatedProperties = void 0;
          mergedAllOf.push(nestedSchema);
        }
      });
      return mergedAllOf.length ? {
        allOf: mergedAllOf,
        ...unevaluatedProperties
      } : void 0;
    }
    exports2.parseIntersectionDef = parseIntersectionDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/literal.cjs
var require_literal = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/literal.cjs"(exports2) {
    function parseLiteralDef(def, refs) {
      const parsedType = typeof def.value;
      if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") return { type: Array.isArray(def.value) ? "array" : "object" };
      if (refs.target === "openApi3") return {
        type: parsedType === "bigint" ? "integer" : parsedType,
        enum: [def.value]
      };
      return {
        type: parsedType === "bigint" ? "integer" : parsedType,
        const: def.value
      };
    }
    exports2.parseLiteralDef = parseLiteralDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/string.cjs
var require_string = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/string.cjs"(exports2) {
    var require_errorMessages2 = require_errorMessages();
    var emojiRegex = void 0;
    var zodPatterns = {
      cuid: /^[cC][^\s-]{8,}$/,
      cuid2: /^[0-9a-z]+$/,
      ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
      email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
      emoji: () => {
        if (emojiRegex === void 0) emojiRegex = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
        return emojiRegex;
      },
      uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
      ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
      ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
      ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
      ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
      base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
      base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
      nanoid: /^[a-zA-Z0-9_-]{21}$/,
      jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
    };
    function parseStringDef(def, refs) {
      const res = { type: "string" };
      if (def.checks) for (const check of def.checks) switch (check.kind) {
        case "min":
          require_errorMessages2.setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          break;
        case "max":
          require_errorMessages2.setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
          break;
        case "endsWith":
          addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat(res, "date", check.message, refs);
          break;
        case "time":
          addFormat(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check.message, refs);
          break;
        case "length":
          require_errorMessages2.setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          require_errorMessages2.setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "includes":
          addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
          break;
        case "ip":
          if (check.version !== "v6") addFormat(res, "ipv4", check.message, refs);
          if (check.version !== "v4") addFormat(res, "ipv6", check.message, refs);
          break;
        case "base64url":
          addPattern(res, zodPatterns.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern(res, zodPatterns.jwt, check.message, refs);
          break;
        case "cidr":
          if (check.version !== "v6") addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
          if (check.version !== "v4") addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
          break;
        case "emoji":
          addPattern(res, zodPatterns.emoji(), check.message, refs);
          break;
        case "ulid":
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        case "base64":
          switch (refs.base64Strategy) {
            case "format:binary":
              addFormat(res, "binary", check.message, refs);
              break;
            case "contentEncoding:base64":
              require_errorMessages2.setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.base64, check.message, refs);
              break;
          }
          break;
        case "nanoid":
          addPattern(res, zodPatterns.nanoid, check.message, refs);
          break;
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_) => {
          })(check);
      }
      return res;
    }
    function escapeLiteralCheckValue(literal, refs) {
      return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal) : literal;
    }
    var ALPHA_NUMERIC = /* @__PURE__ */ new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
    function escapeNonAlphaNumeric(source) {
      let result = "";
      for (let i = 0; i < source.length; i++) {
        if (!ALPHA_NUMERIC.has(source[i])) result += "\\";
        result += source[i];
      }
      return result;
    }
    function addFormat(schema, value, message, refs) {
      if (schema.format || schema.anyOf?.some((x) => x.format)) {
        if (!schema.anyOf) schema.anyOf = [];
        if (schema.format) {
          schema.anyOf.push({
            format: schema.format,
            ...schema.errorMessage && refs.errorMessages && { errorMessage: { format: schema.errorMessage.format } }
          });
          delete schema.format;
          if (schema.errorMessage) {
            delete schema.errorMessage.format;
            if (Object.keys(schema.errorMessage).length === 0) delete schema.errorMessage;
          }
        }
        schema.anyOf.push({
          format: value,
          ...message && refs.errorMessages && { errorMessage: { format: message } }
        });
      } else require_errorMessages2.setResponseValueAndErrors(schema, "format", value, message, refs);
    }
    function addPattern(schema, regex, message, refs) {
      if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
        if (!schema.allOf) schema.allOf = [];
        if (schema.pattern) {
          schema.allOf.push({
            pattern: schema.pattern,
            ...schema.errorMessage && refs.errorMessages && { errorMessage: { pattern: schema.errorMessage.pattern } }
          });
          delete schema.pattern;
          if (schema.errorMessage) {
            delete schema.errorMessage.pattern;
            if (Object.keys(schema.errorMessage).length === 0) delete schema.errorMessage;
          }
        }
        schema.allOf.push({
          pattern: stringifyRegExpWithFlags(regex, refs),
          ...message && refs.errorMessages && { errorMessage: { pattern: message } }
        });
      } else require_errorMessages2.setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex, refs), message, refs);
    }
    function stringifyRegExpWithFlags(regex, refs) {
      if (!refs.applyRegexFlags || !regex.flags) return regex.source;
      const flags = {
        i: regex.flags.includes("i"),
        m: regex.flags.includes("m"),
        s: regex.flags.includes("s")
      };
      const source = flags.i ? regex.source.toLowerCase() : regex.source;
      let pattern = "";
      let isEscaped = false;
      let inCharGroup = false;
      let inCharRange = false;
      for (let i = 0; i < source.length; i++) {
        if (isEscaped) {
          pattern += source[i];
          isEscaped = false;
          continue;
        }
        if (flags.i) {
          if (inCharGroup) {
            if (source[i].match(/[a-z]/)) {
              if (inCharRange) {
                pattern += source[i];
                pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
                inCharRange = false;
              } else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
                pattern += source[i];
                inCharRange = true;
              } else pattern += `${source[i]}${source[i].toUpperCase()}`;
              continue;
            }
          } else if (source[i].match(/[a-z]/)) {
            pattern += `[${source[i]}${source[i].toUpperCase()}]`;
            continue;
          }
        }
        if (flags.m) {
          if (source[i] === "^") {
            pattern += `(^|(?<=[\r
]))`;
            continue;
          } else if (source[i] === "$") {
            pattern += `($|(?=[\r
]))`;
            continue;
          }
        }
        if (flags.s && source[i] === ".") {
          pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
          continue;
        }
        pattern += source[i];
        if (source[i] === "\\") isEscaped = true;
        else if (inCharGroup && source[i] === "]") inCharGroup = false;
        else if (!inCharGroup && source[i] === "[") inCharGroup = true;
      }
      try {
        new RegExp(pattern);
      } catch {
        console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
        return regex.source;
      }
      return pattern;
    }
    exports2.parseStringDef = parseStringDef;
    exports2.zodPatterns = zodPatterns;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/record.cjs
var require_record = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/record.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_any2 = require_any();
    var require_branded2 = require_branded();
    var require_string4 = require_string();
    var require_parseDef2 = require_parseDef();
    var zod_v3 = require_rolldown_runtime5.__toESM(require_v3());
    function parseRecordDef(def, refs) {
      if (refs.target === "openAi") console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
      if (refs.target === "openApi3" && def.keyType?._def.typeName === zod_v3.ZodFirstPartyTypeKind.ZodEnum) return {
        type: "object",
        required: def.keyType._def.values,
        properties: def.keyType._def.values.reduce((acc, key) => ({
          ...acc,
          [key]: require_parseDef2.parseDef(def.valueType._def, {
            ...refs,
            currentPath: [
              ...refs.currentPath,
              "properties",
              key
            ]
          }) ?? require_any2.parseAnyDef(refs)
        }), {}),
        additionalProperties: refs.rejectedAdditionalProperties
      };
      const schema = {
        type: "object",
        additionalProperties: require_parseDef2.parseDef(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "additionalProperties"]
        }) ?? refs.allowedAdditionalProperties
      };
      if (refs.target === "openApi3") return schema;
      if (def.keyType?._def.typeName === zod_v3.ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
        const { type, ...keyType } = require_string4.parseStringDef(def.keyType._def, refs);
        return {
          ...schema,
          propertyNames: keyType
        };
      } else if (def.keyType?._def.typeName === zod_v3.ZodFirstPartyTypeKind.ZodEnum) return {
        ...schema,
        propertyNames: { enum: def.keyType._def.values }
      };
      else if (def.keyType?._def.typeName === zod_v3.ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === zod_v3.ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {
        const { type, ...keyType } = require_branded2.parseBrandedDef(def.keyType._def, refs);
        return {
          ...schema,
          propertyNames: keyType
        };
      }
      return schema;
    }
    exports2.parseRecordDef = parseRecordDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/map.cjs
var require_map = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/map.cjs"(exports2) {
    var require_any2 = require_any();
    var require_record2 = require_record();
    var require_parseDef2 = require_parseDef();
    function parseMapDef(def, refs) {
      if (refs.mapStrategy === "record") return require_record2.parseRecordDef(def, refs);
      const keys = require_parseDef2.parseDef(def.keyType._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath,
          "items",
          "items",
          "0"
        ]
      }) || require_any2.parseAnyDef(refs);
      const values = require_parseDef2.parseDef(def.valueType._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath,
          "items",
          "items",
          "1"
        ]
      }) || require_any2.parseAnyDef(refs);
      return {
        type: "array",
        maxItems: 125,
        items: {
          type: "array",
          items: [keys, values],
          minItems: 2,
          maxItems: 2
        }
      };
    }
    exports2.parseMapDef = parseMapDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/nativeEnum.cjs
var require_nativeEnum = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/nativeEnum.cjs"(exports2) {
    function parseNativeEnumDef(def) {
      const object = def.values;
      const actualKeys = Object.keys(def.values).filter((key) => {
        return typeof object[object[key]] !== "number";
      });
      const actualValues = actualKeys.map((key) => object[key]);
      const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
      return {
        type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
        enum: actualValues
      };
    }
    exports2.parseNativeEnumDef = parseNativeEnumDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/never.cjs
var require_never = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/never.cjs"(exports2) {
    var require_any2 = require_any();
    function parseNeverDef(refs) {
      return refs.target === "openAi" ? void 0 : { not: require_any2.parseAnyDef({
        ...refs,
        currentPath: [...refs.currentPath, "not"]
      }) };
    }
    exports2.parseNeverDef = parseNeverDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/null.cjs
var require_null = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/null.cjs"(exports2) {
    function parseNullDef(refs) {
      return refs.target === "openApi3" ? {
        enum: ["null"],
        nullable: true
      } : { type: "null" };
    }
    exports2.parseNullDef = parseNullDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/union.cjs
var require_union = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/union.cjs"(exports2) {
    var require_parseDef2 = require_parseDef();
    var primitiveMappings = {
      ZodString: "string",
      ZodNumber: "number",
      ZodBigInt: "integer",
      ZodBoolean: "boolean",
      ZodNull: "null"
    };
    function parseUnionDef(def, refs) {
      if (refs.target === "openApi3") return asAnyOf(def, refs);
      const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
      if (options.every((x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
        const types = options.reduce((types$1, x) => {
          const type = primitiveMappings[x._def.typeName];
          return type && !types$1.includes(type) ? [...types$1, type] : types$1;
        }, []);
        return { type: types.length > 1 ? types : types[0] };
      } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
        const types = options.reduce((acc, x) => {
          const type = typeof x._def.value;
          switch (type) {
            case "string":
            case "number":
            case "boolean":
              return [...acc, type];
            case "bigint":
              return [...acc, "integer"];
            case "object":
              if (x._def.value === null) return [...acc, "null"];
              return acc;
            case "symbol":
            case "undefined":
            case "function":
            default:
              return acc;
          }
        }, []);
        if (types.length === options.length) {
          const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
          return {
            type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
            enum: options.reduce((acc, x) => {
              return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
            }, [])
          };
        }
      } else if (options.every((x) => x._def.typeName === "ZodEnum")) return {
        type: "string",
        enum: options.reduce((acc, x) => [...acc, ...x._def.values.filter((x$1) => !acc.includes(x$1))], [])
      };
      return asAnyOf(def, refs);
    }
    var asAnyOf = (def, refs) => {
      const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => require_parseDef2.parseDef(x._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath,
          "anyOf",
          `${i}`
        ]
      })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
      return anyOf.length ? { anyOf } : void 0;
    };
    exports2.parseUnionDef = parseUnionDef;
    exports2.primitiveMappings = primitiveMappings;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/nullable.cjs
var require_nullable = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/nullable.cjs"(exports2) {
    var require_union2 = require_union();
    var require_parseDef2 = require_parseDef();
    function parseNullableDef(def, refs) {
      if ([
        "ZodString",
        "ZodNumber",
        "ZodBigInt",
        "ZodBoolean",
        "ZodNull"
      ].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
        if (refs.target === "openApi3") return {
          type: require_union2.primitiveMappings[def.innerType._def.typeName],
          nullable: true
        };
        return { type: [require_union2.primitiveMappings[def.innerType._def.typeName], "null"] };
      }
      if (refs.target === "openApi3") {
        const base$1 = require_parseDef2.parseDef(def.innerType._def, {
          ...refs,
          currentPath: [...refs.currentPath]
        });
        if (base$1 && "$ref" in base$1) return {
          allOf: [base$1],
          nullable: true
        };
        return base$1 && {
          ...base$1,
          nullable: true
        };
      }
      const base = require_parseDef2.parseDef(def.innerType._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath,
          "anyOf",
          "0"
        ]
      });
      return base && { anyOf: [base, { type: "null" }] };
    }
    exports2.parseNullableDef = parseNullableDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/number.cjs
var require_number = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/number.cjs"(exports2) {
    var require_errorMessages2 = require_errorMessages();
    function parseNumberDef(def, refs) {
      const res = { type: "number" };
      if (!def.checks) return res;
      for (const check of def.checks) switch (check.kind) {
        case "int":
          res.type = "integer";
          require_errorMessages2.addErrorMessage(res, "type", check.message, refs);
          break;
        case "min":
          if (refs.target === "jsonSchema7") if (check.inclusive) require_errorMessages2.setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          else require_errorMessages2.setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          else {
            if (!check.inclusive) res.exclusiveMinimum = true;
            require_errorMessages2.setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          }
          break;
        case "max":
          if (refs.target === "jsonSchema7") if (check.inclusive) require_errorMessages2.setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          else require_errorMessages2.setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          else {
            if (!check.inclusive) res.exclusiveMaximum = true;
            require_errorMessages2.setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          }
          break;
        case "multipleOf":
          require_errorMessages2.setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
          break;
      }
      return res;
    }
    exports2.parseNumberDef = parseNumberDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/object.cjs
var require_object = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/object.cjs"(exports2) {
    var require_parseDef2 = require_parseDef();
    function parseObjectDef(def, refs) {
      const forceOptionalIntoNullable = refs.target === "openAi";
      const result = {
        type: "object",
        properties: {}
      };
      const required = [];
      const shape = def.shape();
      for (const propName in shape) {
        let propDef = shape[propName];
        if (propDef === void 0 || propDef._def === void 0) continue;
        let propOptional = safeIsOptional(propDef);
        if (propOptional && forceOptionalIntoNullable) {
          if (propDef._def.typeName === "ZodOptional") propDef = propDef._def.innerType;
          if (!propDef.isNullable()) propDef = propDef.nullable();
          propOptional = false;
        }
        const parsedDef = require_parseDef2.parseDef(propDef._def, {
          ...refs,
          currentPath: [
            ...refs.currentPath,
            "properties",
            propName
          ],
          propertyPath: [
            ...refs.currentPath,
            "properties",
            propName
          ]
        });
        if (parsedDef === void 0) continue;
        result.properties[propName] = parsedDef;
        if (!propOptional) required.push(propName);
      }
      if (required.length) result.required = required;
      const additionalProperties = decideAdditionalProperties(def, refs);
      if (additionalProperties !== void 0) result.additionalProperties = additionalProperties;
      return result;
    }
    function decideAdditionalProperties(def, refs) {
      if (def.catchall._def.typeName !== "ZodNever") return require_parseDef2.parseDef(def.catchall._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalProperties"]
      });
      switch (def.unknownKeys) {
        case "passthrough":
          return refs.allowedAdditionalProperties;
        case "strict":
          return refs.rejectedAdditionalProperties;
        case "strip":
          return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
      }
    }
    function safeIsOptional(schema) {
      try {
        return schema.isOptional();
      } catch {
        return true;
      }
    }
    exports2.parseObjectDef = parseObjectDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/optional.cjs
var require_optional = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/optional.cjs"(exports2) {
    var require_any2 = require_any();
    var require_parseDef2 = require_parseDef();
    var parseOptionalDef = (def, refs) => {
      if (refs.currentPath.toString() === refs.propertyPath?.toString()) return require_parseDef2.parseDef(def.innerType._def, refs);
      const innerSchema = require_parseDef2.parseDef(def.innerType._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath,
          "anyOf",
          "1"
        ]
      });
      return innerSchema ? { anyOf: [{ not: require_any2.parseAnyDef(refs) }, innerSchema] } : require_any2.parseAnyDef(refs);
    };
    exports2.parseOptionalDef = parseOptionalDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/pipeline.cjs
var require_pipeline = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/pipeline.cjs"(exports2) {
    var require_parseDef2 = require_parseDef();
    var parsePipelineDef = (def, refs) => {
      if (refs.pipeStrategy === "input") return require_parseDef2.parseDef(def.in._def, refs);
      else if (refs.pipeStrategy === "output") return require_parseDef2.parseDef(def.out._def, refs);
      const a = require_parseDef2.parseDef(def.in._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath,
          "allOf",
          "0"
        ]
      });
      const b = require_parseDef2.parseDef(def.out._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath,
          "allOf",
          a ? "1" : "0"
        ]
      });
      return { allOf: [a, b].filter((x) => x !== void 0) };
    };
    exports2.parsePipelineDef = parsePipelineDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/promise.cjs
var require_promise = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/promise.cjs"(exports2) {
    var require_parseDef2 = require_parseDef();
    function parsePromiseDef(def, refs) {
      return require_parseDef2.parseDef(def.type._def, refs);
    }
    exports2.parsePromiseDef = parsePromiseDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/set.cjs
var require_set = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/set.cjs"(exports2) {
    var require_errorMessages2 = require_errorMessages();
    var require_parseDef2 = require_parseDef();
    function parseSetDef(def, refs) {
      const items = require_parseDef2.parseDef(def.valueType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items"]
      });
      const schema = {
        type: "array",
        uniqueItems: true,
        items
      };
      if (def.minSize) require_errorMessages2.setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
      if (def.maxSize) require_errorMessages2.setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
      return schema;
    }
    exports2.parseSetDef = parseSetDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/tuple.cjs
var require_tuple = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/tuple.cjs"(exports2) {
    var require_parseDef2 = require_parseDef();
    function parseTupleDef(def, refs) {
      if (def.rest) return {
        type: "array",
        minItems: def.items.length,
        items: def.items.map((x, i) => require_parseDef2.parseDef(x._def, {
          ...refs,
          currentPath: [
            ...refs.currentPath,
            "items",
            `${i}`
          ]
        })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
        additionalItems: require_parseDef2.parseDef(def.rest._def, {
          ...refs,
          currentPath: [...refs.currentPath, "additionalItems"]
        })
      };
      else return {
        type: "array",
        minItems: def.items.length,
        maxItems: def.items.length,
        items: def.items.map((x, i) => require_parseDef2.parseDef(x._def, {
          ...refs,
          currentPath: [
            ...refs.currentPath,
            "items",
            `${i}`
          ]
        })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
      };
    }
    exports2.parseTupleDef = parseTupleDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/undefined.cjs
var require_undefined = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/undefined.cjs"(exports2) {
    var require_any2 = require_any();
    function parseUndefinedDef(refs) {
      return { not: require_any2.parseAnyDef(refs) };
    }
    exports2.parseUndefinedDef = parseUndefinedDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/unknown.cjs
var require_unknown = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/unknown.cjs"(exports2) {
    var require_any2 = require_any();
    function parseUnknownDef(refs) {
      return require_any2.parseAnyDef(refs);
    }
    exports2.parseUnknownDef = parseUnknownDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/readonly.cjs
var require_readonly = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/readonly.cjs"(exports2) {
    var require_parseDef2 = require_parseDef();
    var parseReadonlyDef = (def, refs) => {
      return require_parseDef2.parseDef(def.innerType._def, refs);
    };
    exports2.parseReadonlyDef = parseReadonlyDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/selectParser.cjs
var require_selectParser = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/selectParser.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_any2 = require_any();
    var require_array2 = require_array();
    var require_bigint2 = require_bigint();
    var require_boolean2 = require_boolean();
    var require_branded2 = require_branded();
    var require_catch2 = require_catch();
    var require_date2 = require_date();
    var require_default2 = require_default();
    var require_effects2 = require_effects();
    var require_enum3 = require_enum();
    var require_intersection2 = require_intersection();
    var require_literal2 = require_literal();
    var require_string4 = require_string();
    var require_record2 = require_record();
    var require_map2 = require_map();
    var require_nativeEnum2 = require_nativeEnum();
    var require_never2 = require_never();
    var require_null2 = require_null();
    var require_union2 = require_union();
    var require_nullable2 = require_nullable();
    var require_number2 = require_number();
    var require_object2 = require_object();
    var require_optional2 = require_optional();
    var require_pipeline3 = require_pipeline();
    var require_promise2 = require_promise();
    var require_set2 = require_set();
    var require_tuple2 = require_tuple();
    var require_undefined2 = require_undefined();
    var require_unknown2 = require_unknown();
    var require_readonly2 = require_readonly();
    var zod_v3 = require_rolldown_runtime5.__toESM(require_v3());
    var selectParser = (def, typeName, refs) => {
      switch (typeName) {
        case zod_v3.ZodFirstPartyTypeKind.ZodString:
          return require_string4.parseStringDef(def, refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodNumber:
          return require_number2.parseNumberDef(def, refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodObject:
          return require_object2.parseObjectDef(def, refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodBigInt:
          return require_bigint2.parseBigintDef(def, refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodBoolean:
          return require_boolean2.parseBooleanDef();
        case zod_v3.ZodFirstPartyTypeKind.ZodDate:
          return require_date2.parseDateDef(def, refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodUndefined:
          return require_undefined2.parseUndefinedDef(refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodNull:
          return require_null2.parseNullDef(refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodArray:
          return require_array2.parseArrayDef(def, refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodUnion:
        case zod_v3.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
          return require_union2.parseUnionDef(def, refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodIntersection:
          return require_intersection2.parseIntersectionDef(def, refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodTuple:
          return require_tuple2.parseTupleDef(def, refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodRecord:
          return require_record2.parseRecordDef(def, refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodLiteral:
          return require_literal2.parseLiteralDef(def, refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodEnum:
          return require_enum3.parseEnumDef(def);
        case zod_v3.ZodFirstPartyTypeKind.ZodNativeEnum:
          return require_nativeEnum2.parseNativeEnumDef(def);
        case zod_v3.ZodFirstPartyTypeKind.ZodNullable:
          return require_nullable2.parseNullableDef(def, refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodOptional:
          return require_optional2.parseOptionalDef(def, refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodMap:
          return require_map2.parseMapDef(def, refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodSet:
          return require_set2.parseSetDef(def, refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodLazy:
          return () => def.getter()._def;
        case zod_v3.ZodFirstPartyTypeKind.ZodPromise:
          return require_promise2.parsePromiseDef(def, refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodNaN:
        case zod_v3.ZodFirstPartyTypeKind.ZodNever:
          return require_never2.parseNeverDef(refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodEffects:
          return require_effects2.parseEffectsDef(def, refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodAny:
          return require_any2.parseAnyDef(refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodUnknown:
          return require_unknown2.parseUnknownDef(refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodDefault:
          return require_default2.parseDefaultDef(def, refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodBranded:
          return require_branded2.parseBrandedDef(def, refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodReadonly:
          return require_readonly2.parseReadonlyDef(def, refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodCatch:
          return require_catch2.parseCatchDef(def, refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodPipeline:
          return require_pipeline3.parsePipelineDef(def, refs);
        case zod_v3.ZodFirstPartyTypeKind.ZodFunction:
        case zod_v3.ZodFirstPartyTypeKind.ZodVoid:
        case zod_v3.ZodFirstPartyTypeKind.ZodSymbol:
          return void 0;
        default:
          return /* @__PURE__ */ ((_) => void 0)(typeName);
      }
    };
    exports2.selectParser = selectParser;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parseDef.cjs
var require_parseDef = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/parseDef.cjs"(exports2) {
    var require_Options2 = require_Options();
    var require_getRelativePath2 = require_getRelativePath();
    var require_any2 = require_any();
    var require_selectParser2 = require_selectParser();
    function parseDef(def, refs, forceResolution = false) {
      const seenItem = refs.seen.get(def);
      if (refs.override) {
        const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
        if (overrideResult !== require_Options2.ignoreOverride) return overrideResult;
      }
      if (seenItem && !forceResolution) {
        const seenSchema = get$ref(seenItem, refs);
        if (seenSchema !== void 0) return seenSchema;
      }
      const newItem = {
        def,
        path: refs.currentPath,
        jsonSchema: void 0
      };
      refs.seen.set(def, newItem);
      const jsonSchemaOrGetter = require_selectParser2.selectParser(def, def.typeName, refs);
      const jsonSchema = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
      if (jsonSchema) addMeta(def, refs, jsonSchema);
      if (refs.postProcess) {
        const postProcessResult = refs.postProcess(jsonSchema, def, refs);
        newItem.jsonSchema = jsonSchema;
        return postProcessResult;
      }
      newItem.jsonSchema = jsonSchema;
      return jsonSchema;
    }
    var get$ref = (item, refs) => {
      switch (refs.$refStrategy) {
        case "root":
          return { $ref: item.path.join("/") };
        case "relative":
          return { $ref: require_getRelativePath2.getRelativePath(refs.currentPath, item.path) };
        case "none":
        case "seen":
          if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
            console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
            return require_any2.parseAnyDef(refs);
          }
          return refs.$refStrategy === "seen" ? require_any2.parseAnyDef(refs) : void 0;
      }
    };
    var addMeta = (def, refs, jsonSchema) => {
      if (def.description) {
        jsonSchema.description = def.description;
        if (refs.markdownDescription) jsonSchema.markdownDescription = def.description;
      }
      return jsonSchema;
    };
    exports2.parseDef = parseDef;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/zodToJsonSchema.cjs
var require_zodToJsonSchema = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/zodToJsonSchema.cjs"(exports2) {
    var require_Refs2 = require_Refs();
    var require_any2 = require_any();
    var require_parseDef2 = require_parseDef();
    var zodToJsonSchema = (schema, options) => {
      const refs = require_Refs2.getRefs(options);
      let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name$1, schema$1]) => ({
        ...acc,
        [name$1]: require_parseDef2.parseDef(schema$1._def, {
          ...refs,
          currentPath: [
            ...refs.basePath,
            refs.definitionPath,
            name$1
          ]
        }, true) ?? require_any2.parseAnyDef(refs)
      }), {}) : void 0;
      const name = typeof options === "string" ? options : options?.nameStrategy === "title" ? void 0 : options?.name;
      const main = require_parseDef2.parseDef(schema._def, name === void 0 ? refs : {
        ...refs,
        currentPath: [
          ...refs.basePath,
          refs.definitionPath,
          name
        ]
      }, false) ?? require_any2.parseAnyDef(refs);
      const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
      if (title !== void 0) main.title = title;
      if (refs.flags.hasReferencedOpenAiAnyType) {
        if (!definitions) definitions = {};
        if (!definitions[refs.openAiAnyTypeName]) definitions[refs.openAiAnyTypeName] = {
          type: [
            "string",
            "number",
            "integer",
            "boolean",
            "array",
            "null"
          ],
          items: { $ref: refs.$refStrategy === "relative" ? "1" : [
            ...refs.basePath,
            refs.definitionPath,
            refs.openAiAnyTypeName
          ].join("/") }
        };
      }
      const combined = name === void 0 ? definitions ? {
        ...main,
        [refs.definitionPath]: definitions
      } : main : {
        $ref: [
          ...refs.$refStrategy === "relative" ? [] : refs.basePath,
          refs.definitionPath,
          name
        ].join("/"),
        [refs.definitionPath]: {
          ...definitions,
          [name]: main
        }
      };
      if (refs.target === "jsonSchema7") combined.$schema = "http://json-schema.org/draft-07/schema#";
      else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
      if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
      return combined;
    };
    exports2.zodToJsonSchema = zodToJsonSchema;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/index.cjs
var require_zod_to_json_schema = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/zod-to-json-schema/index.cjs"() {
    var require_Options2 = require_Options();
    var require_Refs2 = require_Refs();
    var require_errorMessages2 = require_errorMessages();
    var require_getRelativePath2 = require_getRelativePath();
    var require_any2 = require_any();
    var require_array2 = require_array();
    var require_bigint2 = require_bigint();
    var require_boolean2 = require_boolean();
    var require_branded2 = require_branded();
    var require_catch2 = require_catch();
    var require_date2 = require_date();
    var require_default2 = require_default();
    var require_effects2 = require_effects();
    var require_enum3 = require_enum();
    var require_intersection2 = require_intersection();
    var require_literal2 = require_literal();
    var require_string4 = require_string();
    var require_record2 = require_record();
    var require_map2 = require_map();
    var require_nativeEnum2 = require_nativeEnum();
    var require_never2 = require_never();
    var require_null2 = require_null();
    var require_union2 = require_union();
    var require_nullable2 = require_nullable();
    var require_number2 = require_number();
    var require_object2 = require_object();
    var require_optional2 = require_optional();
    var require_pipeline3 = require_pipeline();
    var require_promise2 = require_promise();
    var require_set2 = require_set();
    var require_tuple2 = require_tuple();
    var require_undefined2 = require_undefined();
    var require_unknown2 = require_unknown();
    var require_readonly2 = require_readonly();
    var require_selectParser2 = require_selectParser();
    var require_parseDef2 = require_parseDef();
    var require_zodToJsonSchema2 = require_zodToJsonSchema();
  }
});

// node_modules/.pnpm/@cfworker+json-schema@4.1.1/node_modules/@cfworker/json-schema/dist/commonjs/deep-compare-strict.js
var require_deep_compare_strict = __commonJS({
  "node_modules/.pnpm/@cfworker+json-schema@4.1.1/node_modules/@cfworker/json-schema/dist/commonjs/deep-compare-strict.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deepCompareStrict = deepCompareStrict;
    function deepCompareStrict(a, b) {
      const typeofa = typeof a;
      if (typeofa !== typeof b) {
        return false;
      }
      if (Array.isArray(a)) {
        if (!Array.isArray(b)) {
          return false;
        }
        const length = a.length;
        if (length !== b.length) {
          return false;
        }
        for (let i = 0; i < length; i++) {
          if (!deepCompareStrict(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
      if (typeofa === "object") {
        if (!a || !b) {
          return a === b;
        }
        const aKeys = Object.keys(a);
        const bKeys = Object.keys(b);
        const length = aKeys.length;
        if (length !== bKeys.length) {
          return false;
        }
        for (const k of aKeys) {
          if (!deepCompareStrict(a[k], b[k])) {
            return false;
          }
        }
        return true;
      }
      return a === b;
    }
  }
});

// node_modules/.pnpm/@cfworker+json-schema@4.1.1/node_modules/@cfworker/json-schema/dist/commonjs/pointer.js
var require_pointer = __commonJS({
  "node_modules/.pnpm/@cfworker+json-schema@4.1.1/node_modules/@cfworker/json-schema/dist/commonjs/pointer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodePointer = encodePointer;
    exports2.escapePointer = escapePointer;
    function encodePointer(p) {
      return encodeURI(escapePointer(p));
    }
    function escapePointer(p) {
      return p.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/.pnpm/@cfworker+json-schema@4.1.1/node_modules/@cfworker/json-schema/dist/commonjs/dereference.js
var require_dereference = __commonJS({
  "node_modules/.pnpm/@cfworker+json-schema@4.1.1/node_modules/@cfworker/json-schema/dist/commonjs/dereference.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initialBaseURI = exports2.ignoredKeyword = exports2.schemaMapKeyword = exports2.schemaArrayKeyword = exports2.schemaKeyword = void 0;
    exports2.dereference = dereference;
    var pointer_js_1 = require_pointer();
    exports2.schemaKeyword = {
      additionalItems: true,
      unevaluatedItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      unevaluatedProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    exports2.schemaArrayKeyword = {
      prefixItems: true,
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    exports2.schemaMapKeyword = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependentSchemas: true
    };
    exports2.ignoredKeyword = {
      id: true,
      $id: true,
      $ref: true,
      $schema: true,
      $anchor: true,
      $vocabulary: true,
      $comment: true,
      default: true,
      enum: true,
      const: true,
      required: true,
      type: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    exports2.initialBaseURI = typeof self !== "undefined" && self.location && self.location.origin !== "null" ? new URL(self.location.origin + self.location.pathname + location.search) : new URL("https://github.com/cfworker");
    function dereference(schema, lookup = /* @__PURE__ */ Object.create(null), baseURI = exports2.initialBaseURI, basePointer = "") {
      if (schema && typeof schema === "object" && !Array.isArray(schema)) {
        const id = schema.$id || schema.id;
        if (id) {
          const url = new URL(id, baseURI.href);
          if (url.hash.length > 1) {
            lookup[url.href] = schema;
          } else {
            url.hash = "";
            if (basePointer === "") {
              baseURI = url;
            } else {
              dereference(schema, lookup, baseURI);
            }
          }
        }
      } else if (schema !== true && schema !== false) {
        return lookup;
      }
      const schemaURI = baseURI.href + (basePointer ? "#" + basePointer : "");
      if (lookup[schemaURI] !== void 0) {
        throw new Error(`Duplicate schema URI "${schemaURI}".`);
      }
      lookup[schemaURI] = schema;
      if (schema === true || schema === false) {
        return lookup;
      }
      if (schema.__absolute_uri__ === void 0) {
        Object.defineProperty(schema, "__absolute_uri__", {
          enumerable: false,
          value: schemaURI
        });
      }
      if (schema.$ref && schema.__absolute_ref__ === void 0) {
        const url = new URL(schema.$ref, baseURI.href);
        url.hash = url.hash;
        Object.defineProperty(schema, "__absolute_ref__", {
          enumerable: false,
          value: url.href
        });
      }
      if (schema.$recursiveRef && schema.__absolute_recursive_ref__ === void 0) {
        const url = new URL(schema.$recursiveRef, baseURI.href);
        url.hash = url.hash;
        Object.defineProperty(schema, "__absolute_recursive_ref__", {
          enumerable: false,
          value: url.href
        });
      }
      if (schema.$anchor) {
        const url = new URL("#" + schema.$anchor, baseURI.href);
        lookup[url.href] = schema;
      }
      for (let key in schema) {
        if (exports2.ignoredKeyword[key]) {
          continue;
        }
        const keyBase = `${basePointer}/${(0, pointer_js_1.encodePointer)(key)}`;
        const subSchema = schema[key];
        if (Array.isArray(subSchema)) {
          if (exports2.schemaArrayKeyword[key]) {
            const length = subSchema.length;
            for (let i = 0; i < length; i++) {
              dereference(subSchema[i], lookup, baseURI, `${keyBase}/${i}`);
            }
          }
        } else if (exports2.schemaMapKeyword[key]) {
          for (let subKey in subSchema) {
            dereference(subSchema[subKey], lookup, baseURI, `${keyBase}/${(0, pointer_js_1.encodePointer)(subKey)}`);
          }
        } else {
          dereference(subSchema, lookup, baseURI, keyBase);
        }
      }
      return lookup;
    }
  }
});

// node_modules/.pnpm/@cfworker+json-schema@4.1.1/node_modules/@cfworker/json-schema/dist/commonjs/format.js
var require_format2 = __commonJS({
  "node_modules/.pnpm/@cfworker+json-schema@4.1.1/node_modules/@cfworker/json-schema/dist/commonjs/format.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.format = void 0;
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
    var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
    var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
    var URL_ = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
    var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
    var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
    var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
    var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
    var EMAIL = (input) => {
      if (input[0] === '"')
        return false;
      const [name, host, ...rest] = input.split("@");
      if (!name || !host || rest.length !== 0 || name.length > 64 || host.length > 253)
        return false;
      if (name[0] === "." || name.endsWith(".") || name.includes(".."))
        return false;
      if (!/^[a-z0-9.-]+$/i.test(host) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name))
        return false;
      return host.split(".").every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part));
    };
    var IPV4 = /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/;
    var IPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i;
    var DURATION = (input) => input.length > 1 && input.length < 80 && (/^P\d+([.,]\d+)?W$/.test(input) || /^P[\dYMDTHS]*(\d[.,]\d+)?[YMDHS]$/.test(input) && /^P([.,\d]+Y)?([.,\d]+M)?([.,\d]+D)?(T([.,\d]+H)?([.,\d]+M)?([.,\d]+S)?)?$/.test(input));
    function bind(r) {
      return r.test.bind(r);
    }
    exports2.format = {
      date,
      time: time.bind(void 0, false),
      "date-time": date_time,
      duration: DURATION,
      uri,
      "uri-reference": bind(URIREF),
      "uri-template": bind(URITEMPLATE),
      url: bind(URL_),
      email: EMAIL,
      hostname: bind(HOSTNAME),
      ipv4: bind(IPV4),
      ipv6: bind(IPV6),
      regex,
      uuid: bind(UUID),
      "json-pointer": bind(JSON_POINTER),
      "json-pointer-uri-fragment": bind(JSON_POINTER_URI_FRAGMENT),
      "relative-json-pointer": bind(RELATIVE_JSON_POINTER)
    };
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function date(str) {
      const matches = str.match(DATE);
      if (!matches)
        return false;
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function time(full, str) {
      const matches = str.match(TIME);
      if (!matches)
        return false;
      const hour = +matches[1];
      const minute = +matches[2];
      const second = +matches[3];
      const timeZone = !!matches[5];
      return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function date_time(str) {
      const dateTime = str.split(DATE_TIME_SEPARATOR);
      return dateTime.length == 2 && date(dateTime[0]) && time(true, dateTime[1]);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    var URI_PATTERN = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI_PATTERN.test(str);
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str, "u");
        return true;
      } catch (e) {
        return false;
      }
    }
  }
});

// node_modules/.pnpm/@cfworker+json-schema@4.1.1/node_modules/@cfworker/json-schema/dist/commonjs/types.js
var require_types3 = __commonJS({
  "node_modules/.pnpm/@cfworker+json-schema@4.1.1/node_modules/@cfworker/json-schema/dist/commonjs/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OutputFormat = void 0;
    var OutputFormat;
    (function(OutputFormat2) {
      OutputFormat2[OutputFormat2["Flag"] = 1] = "Flag";
      OutputFormat2[OutputFormat2["Basic"] = 2] = "Basic";
      OutputFormat2[OutputFormat2["Detailed"] = 4] = "Detailed";
    })(OutputFormat || (exports2.OutputFormat = OutputFormat = {}));
  }
});

// node_modules/.pnpm/@cfworker+json-schema@4.1.1/node_modules/@cfworker/json-schema/dist/commonjs/ucs2-length.js
var require_ucs2_length = __commonJS({
  "node_modules/.pnpm/@cfworker+json-schema@4.1.1/node_modules/@cfworker/json-schema/dist/commonjs/ucs2-length.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ucs2length = ucs2length;
    function ucs2length(s) {
      let result = 0;
      let length = s.length;
      let index = 0;
      let charCode;
      while (index < length) {
        result++;
        charCode = s.charCodeAt(index++);
        if (charCode >= 55296 && charCode <= 56319 && index < length) {
          charCode = s.charCodeAt(index);
          if ((charCode & 64512) == 56320) {
            index++;
          }
        }
      }
      return result;
    }
  }
});

// node_modules/.pnpm/@cfworker+json-schema@4.1.1/node_modules/@cfworker/json-schema/dist/commonjs/validate.js
var require_validate = __commonJS({
  "node_modules/.pnpm/@cfworker+json-schema@4.1.1/node_modules/@cfworker/json-schema/dist/commonjs/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validate = validate2;
    var deep_compare_strict_js_1 = require_deep_compare_strict();
    var dereference_js_1 = require_dereference();
    var format_js_1 = require_format2();
    var pointer_js_1 = require_pointer();
    var ucs2_length_js_1 = require_ucs2_length();
    function validate2(instance, schema, draft = "2019-09", lookup = (0, dereference_js_1.dereference)(schema), shortCircuit = true, recursiveAnchor = null, instanceLocation = "#", schemaLocation = "#", evaluated = /* @__PURE__ */ Object.create(null)) {
      if (schema === true) {
        return { valid: true, errors: [] };
      }
      if (schema === false) {
        return {
          valid: false,
          errors: [
            {
              instanceLocation,
              keyword: "false",
              keywordLocation: instanceLocation,
              error: "False boolean schema."
            }
          ]
        };
      }
      const rawInstanceType = typeof instance;
      let instanceType;
      switch (rawInstanceType) {
        case "boolean":
        case "number":
        case "string":
          instanceType = rawInstanceType;
          break;
        case "object":
          if (instance === null) {
            instanceType = "null";
          } else if (Array.isArray(instance)) {
            instanceType = "array";
          } else {
            instanceType = "object";
          }
          break;
        default:
          throw new Error(`Instances of "${rawInstanceType}" type are not supported.`);
      }
      const { $ref, $recursiveRef, $recursiveAnchor, type: $type, const: $const, enum: $enum, required: $required, not: $not, anyOf: $anyOf, allOf: $allOf, oneOf: $oneOf, if: $if, then: $then, else: $else, format: $format, properties: $properties, patternProperties: $patternProperties, additionalProperties: $additionalProperties, unevaluatedProperties: $unevaluatedProperties, minProperties: $minProperties, maxProperties: $maxProperties, propertyNames: $propertyNames, dependentRequired: $dependentRequired, dependentSchemas: $dependentSchemas, dependencies: $dependencies, prefixItems: $prefixItems, items: $items, additionalItems: $additionalItems, unevaluatedItems: $unevaluatedItems, contains: $contains, minContains: $minContains, maxContains: $maxContains, minItems: $minItems, maxItems: $maxItems, uniqueItems: $uniqueItems, minimum: $minimum, maximum: $maximum, exclusiveMinimum: $exclusiveMinimum, exclusiveMaximum: $exclusiveMaximum, multipleOf: $multipleOf, minLength: $minLength, maxLength: $maxLength, pattern: $pattern, __absolute_ref__, __absolute_recursive_ref__ } = schema;
      const errors = [];
      if ($recursiveAnchor === true && recursiveAnchor === null) {
        recursiveAnchor = schema;
      }
      if ($recursiveRef === "#") {
        const refSchema = recursiveAnchor === null ? lookup[__absolute_recursive_ref__] : recursiveAnchor;
        const keywordLocation = `${schemaLocation}/$recursiveRef`;
        const result = validate2(instance, recursiveAnchor === null ? schema : recursiveAnchor, draft, lookup, shortCircuit, refSchema, instanceLocation, keywordLocation, evaluated);
        if (!result.valid) {
          errors.push({
            instanceLocation,
            keyword: "$recursiveRef",
            keywordLocation,
            error: "A subschema had errors."
          }, ...result.errors);
        }
      }
      if ($ref !== void 0) {
        const uri = __absolute_ref__ || $ref;
        const refSchema = lookup[uri];
        if (refSchema === void 0) {
          let message = `Unresolved $ref "${$ref}".`;
          if (__absolute_ref__ && __absolute_ref__ !== $ref) {
            message += `  Absolute URI "${__absolute_ref__}".`;
          }
          message += `
Known schemas:
- ${Object.keys(lookup).join("\n- ")}`;
          throw new Error(message);
        }
        const keywordLocation = `${schemaLocation}/$ref`;
        const result = validate2(instance, refSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated);
        if (!result.valid) {
          errors.push({
            instanceLocation,
            keyword: "$ref",
            keywordLocation,
            error: "A subschema had errors."
          }, ...result.errors);
        }
        if (draft === "4" || draft === "7") {
          return { valid: errors.length === 0, errors };
        }
      }
      if (Array.isArray($type)) {
        let length = $type.length;
        let valid = false;
        for (let i = 0; i < length; i++) {
          if (instanceType === $type[i] || $type[i] === "integer" && instanceType === "number" && instance % 1 === 0 && instance === instance) {
            valid = true;
            break;
          }
        }
        if (!valid) {
          errors.push({
            instanceLocation,
            keyword: "type",
            keywordLocation: `${schemaLocation}/type`,
            error: `Instance type "${instanceType}" is invalid. Expected "${$type.join('", "')}".`
          });
        }
      } else if ($type === "integer") {
        if (instanceType !== "number" || instance % 1 || instance !== instance) {
          errors.push({
            instanceLocation,
            keyword: "type",
            keywordLocation: `${schemaLocation}/type`,
            error: `Instance type "${instanceType}" is invalid. Expected "${$type}".`
          });
        }
      } else if ($type !== void 0 && instanceType !== $type) {
        errors.push({
          instanceLocation,
          keyword: "type",
          keywordLocation: `${schemaLocation}/type`,
          error: `Instance type "${instanceType}" is invalid. Expected "${$type}".`
        });
      }
      if ($const !== void 0) {
        if (instanceType === "object" || instanceType === "array") {
          if (!(0, deep_compare_strict_js_1.deepCompareStrict)(instance, $const)) {
            errors.push({
              instanceLocation,
              keyword: "const",
              keywordLocation: `${schemaLocation}/const`,
              error: `Instance does not match ${JSON.stringify($const)}.`
            });
          }
        } else if (instance !== $const) {
          errors.push({
            instanceLocation,
            keyword: "const",
            keywordLocation: `${schemaLocation}/const`,
            error: `Instance does not match ${JSON.stringify($const)}.`
          });
        }
      }
      if ($enum !== void 0) {
        if (instanceType === "object" || instanceType === "array") {
          if (!$enum.some((value) => (0, deep_compare_strict_js_1.deepCompareStrict)(instance, value))) {
            errors.push({
              instanceLocation,
              keyword: "enum",
              keywordLocation: `${schemaLocation}/enum`,
              error: `Instance does not match any of ${JSON.stringify($enum)}.`
            });
          }
        } else if (!$enum.some((value) => instance === value)) {
          errors.push({
            instanceLocation,
            keyword: "enum",
            keywordLocation: `${schemaLocation}/enum`,
            error: `Instance does not match any of ${JSON.stringify($enum)}.`
          });
        }
      }
      if ($not !== void 0) {
        const keywordLocation = `${schemaLocation}/not`;
        const result = validate2(instance, $not, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation);
        if (result.valid) {
          errors.push({
            instanceLocation,
            keyword: "not",
            keywordLocation,
            error: 'Instance matched "not" schema.'
          });
        }
      }
      let subEvaluateds = [];
      if ($anyOf !== void 0) {
        const keywordLocation = `${schemaLocation}/anyOf`;
        const errorsLength = errors.length;
        let anyValid = false;
        for (let i = 0; i < $anyOf.length; i++) {
          const subSchema = $anyOf[i];
          const subEvaluated = Object.create(evaluated);
          const result = validate2(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);
          errors.push(...result.errors);
          anyValid = anyValid || result.valid;
          if (result.valid) {
            subEvaluateds.push(subEvaluated);
          }
        }
        if (anyValid) {
          errors.length = errorsLength;
        } else {
          errors.splice(errorsLength, 0, {
            instanceLocation,
            keyword: "anyOf",
            keywordLocation,
            error: "Instance does not match any subschemas."
          });
        }
      }
      if ($allOf !== void 0) {
        const keywordLocation = `${schemaLocation}/allOf`;
        const errorsLength = errors.length;
        let allValid = true;
        for (let i = 0; i < $allOf.length; i++) {
          const subSchema = $allOf[i];
          const subEvaluated = Object.create(evaluated);
          const result = validate2(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);
          errors.push(...result.errors);
          allValid = allValid && result.valid;
          if (result.valid) {
            subEvaluateds.push(subEvaluated);
          }
        }
        if (allValid) {
          errors.length = errorsLength;
        } else {
          errors.splice(errorsLength, 0, {
            instanceLocation,
            keyword: "allOf",
            keywordLocation,
            error: `Instance does not match every subschema.`
          });
        }
      }
      if ($oneOf !== void 0) {
        const keywordLocation = `${schemaLocation}/oneOf`;
        const errorsLength = errors.length;
        const matches = $oneOf.filter((subSchema, i) => {
          const subEvaluated = Object.create(evaluated);
          const result = validate2(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);
          errors.push(...result.errors);
          if (result.valid) {
            subEvaluateds.push(subEvaluated);
          }
          return result.valid;
        }).length;
        if (matches === 1) {
          errors.length = errorsLength;
        } else {
          errors.splice(errorsLength, 0, {
            instanceLocation,
            keyword: "oneOf",
            keywordLocation,
            error: `Instance does not match exactly one subschema (${matches} matches).`
          });
        }
      }
      if (instanceType === "object" || instanceType === "array") {
        Object.assign(evaluated, ...subEvaluateds);
      }
      if ($if !== void 0) {
        const keywordLocation = `${schemaLocation}/if`;
        const conditionResult = validate2(instance, $if, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated).valid;
        if (conditionResult) {
          if ($then !== void 0) {
            const thenResult = validate2(instance, $then, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/then`, evaluated);
            if (!thenResult.valid) {
              errors.push({
                instanceLocation,
                keyword: "if",
                keywordLocation,
                error: `Instance does not match "then" schema.`
              }, ...thenResult.errors);
            }
          }
        } else if ($else !== void 0) {
          const elseResult = validate2(instance, $else, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/else`, evaluated);
          if (!elseResult.valid) {
            errors.push({
              instanceLocation,
              keyword: "if",
              keywordLocation,
              error: `Instance does not match "else" schema.`
            }, ...elseResult.errors);
          }
        }
      }
      if (instanceType === "object") {
        if ($required !== void 0) {
          for (const key of $required) {
            if (!(key in instance)) {
              errors.push({
                instanceLocation,
                keyword: "required",
                keywordLocation: `${schemaLocation}/required`,
                error: `Instance does not have required property "${key}".`
              });
            }
          }
        }
        const keys = Object.keys(instance);
        if ($minProperties !== void 0 && keys.length < $minProperties) {
          errors.push({
            instanceLocation,
            keyword: "minProperties",
            keywordLocation: `${schemaLocation}/minProperties`,
            error: `Instance does not have at least ${$minProperties} properties.`
          });
        }
        if ($maxProperties !== void 0 && keys.length > $maxProperties) {
          errors.push({
            instanceLocation,
            keyword: "maxProperties",
            keywordLocation: `${schemaLocation}/maxProperties`,
            error: `Instance does not have at least ${$maxProperties} properties.`
          });
        }
        if ($propertyNames !== void 0) {
          const keywordLocation = `${schemaLocation}/propertyNames`;
          for (const key in instance) {
            const subInstancePointer = `${instanceLocation}/${(0, pointer_js_1.encodePointer)(key)}`;
            const result = validate2(key, $propertyNames, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);
            if (!result.valid) {
              errors.push({
                instanceLocation,
                keyword: "propertyNames",
                keywordLocation,
                error: `Property name "${key}" does not match schema.`
              }, ...result.errors);
            }
          }
        }
        if ($dependentRequired !== void 0) {
          const keywordLocation = `${schemaLocation}/dependantRequired`;
          for (const key in $dependentRequired) {
            if (key in instance) {
              const required = $dependentRequired[key];
              for (const dependantKey of required) {
                if (!(dependantKey in instance)) {
                  errors.push({
                    instanceLocation,
                    keyword: "dependentRequired",
                    keywordLocation,
                    error: `Instance has "${key}" but does not have "${dependantKey}".`
                  });
                }
              }
            }
          }
        }
        if ($dependentSchemas !== void 0) {
          for (const key in $dependentSchemas) {
            const keywordLocation = `${schemaLocation}/dependentSchemas`;
            if (key in instance) {
              const result = validate2(instance, $dependentSchemas[key], draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${(0, pointer_js_1.encodePointer)(key)}`, evaluated);
              if (!result.valid) {
                errors.push({
                  instanceLocation,
                  keyword: "dependentSchemas",
                  keywordLocation,
                  error: `Instance has "${key}" but does not match dependant schema.`
                }, ...result.errors);
              }
            }
          }
        }
        if ($dependencies !== void 0) {
          const keywordLocation = `${schemaLocation}/dependencies`;
          for (const key in $dependencies) {
            if (key in instance) {
              const propsOrSchema = $dependencies[key];
              if (Array.isArray(propsOrSchema)) {
                for (const dependantKey of propsOrSchema) {
                  if (!(dependantKey in instance)) {
                    errors.push({
                      instanceLocation,
                      keyword: "dependencies",
                      keywordLocation,
                      error: `Instance has "${key}" but does not have "${dependantKey}".`
                    });
                  }
                }
              } else {
                const result = validate2(instance, propsOrSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${(0, pointer_js_1.encodePointer)(key)}`);
                if (!result.valid) {
                  errors.push({
                    instanceLocation,
                    keyword: "dependencies",
                    keywordLocation,
                    error: `Instance has "${key}" but does not match dependant schema.`
                  }, ...result.errors);
                }
              }
            }
          }
        }
        const thisEvaluated = /* @__PURE__ */ Object.create(null);
        let stop = false;
        if ($properties !== void 0) {
          const keywordLocation = `${schemaLocation}/properties`;
          for (const key in $properties) {
            if (!(key in instance)) {
              continue;
            }
            const subInstancePointer = `${instanceLocation}/${(0, pointer_js_1.encodePointer)(key)}`;
            const result = validate2(instance[key], $properties[key], draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${(0, pointer_js_1.encodePointer)(key)}`);
            if (result.valid) {
              evaluated[key] = thisEvaluated[key] = true;
            } else {
              stop = shortCircuit;
              errors.push({
                instanceLocation,
                keyword: "properties",
                keywordLocation,
                error: `Property "${key}" does not match schema.`
              }, ...result.errors);
              if (stop)
                break;
            }
          }
        }
        if (!stop && $patternProperties !== void 0) {
          const keywordLocation = `${schemaLocation}/patternProperties`;
          for (const pattern in $patternProperties) {
            const regex = new RegExp(pattern, "u");
            const subSchema = $patternProperties[pattern];
            for (const key in instance) {
              if (!regex.test(key)) {
                continue;
              }
              const subInstancePointer = `${instanceLocation}/${(0, pointer_js_1.encodePointer)(key)}`;
              const result = validate2(instance[key], subSchema, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${(0, pointer_js_1.encodePointer)(pattern)}`);
              if (result.valid) {
                evaluated[key] = thisEvaluated[key] = true;
              } else {
                stop = shortCircuit;
                errors.push({
                  instanceLocation,
                  keyword: "patternProperties",
                  keywordLocation,
                  error: `Property "${key}" matches pattern "${pattern}" but does not match associated schema.`
                }, ...result.errors);
              }
            }
          }
        }
        if (!stop && $additionalProperties !== void 0) {
          const keywordLocation = `${schemaLocation}/additionalProperties`;
          for (const key in instance) {
            if (thisEvaluated[key]) {
              continue;
            }
            const subInstancePointer = `${instanceLocation}/${(0, pointer_js_1.encodePointer)(key)}`;
            const result = validate2(instance[key], $additionalProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);
            if (result.valid) {
              evaluated[key] = true;
            } else {
              stop = shortCircuit;
              errors.push({
                instanceLocation,
                keyword: "additionalProperties",
                keywordLocation,
                error: `Property "${key}" does not match additional properties schema.`
              }, ...result.errors);
            }
          }
        } else if (!stop && $unevaluatedProperties !== void 0) {
          const keywordLocation = `${schemaLocation}/unevaluatedProperties`;
          for (const key in instance) {
            if (!evaluated[key]) {
              const subInstancePointer = `${instanceLocation}/${(0, pointer_js_1.encodePointer)(key)}`;
              const result = validate2(instance[key], $unevaluatedProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);
              if (result.valid) {
                evaluated[key] = true;
              } else {
                errors.push({
                  instanceLocation,
                  keyword: "unevaluatedProperties",
                  keywordLocation,
                  error: `Property "${key}" does not match unevaluated properties schema.`
                }, ...result.errors);
              }
            }
          }
        }
      } else if (instanceType === "array") {
        if ($maxItems !== void 0 && instance.length > $maxItems) {
          errors.push({
            instanceLocation,
            keyword: "maxItems",
            keywordLocation: `${schemaLocation}/maxItems`,
            error: `Array has too many items (${instance.length} > ${$maxItems}).`
          });
        }
        if ($minItems !== void 0 && instance.length < $minItems) {
          errors.push({
            instanceLocation,
            keyword: "minItems",
            keywordLocation: `${schemaLocation}/minItems`,
            error: `Array has too few items (${instance.length} < ${$minItems}).`
          });
        }
        const length = instance.length;
        let i = 0;
        let stop = false;
        if ($prefixItems !== void 0) {
          const keywordLocation = `${schemaLocation}/prefixItems`;
          const length2 = Math.min($prefixItems.length, length);
          for (; i < length2; i++) {
            const result = validate2(instance[i], $prefixItems[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);
            evaluated[i] = true;
            if (!result.valid) {
              stop = shortCircuit;
              errors.push({
                instanceLocation,
                keyword: "prefixItems",
                keywordLocation,
                error: `Items did not match schema.`
              }, ...result.errors);
              if (stop)
                break;
            }
          }
        }
        if ($items !== void 0) {
          const keywordLocation = `${schemaLocation}/items`;
          if (Array.isArray($items)) {
            const length2 = Math.min($items.length, length);
            for (; i < length2; i++) {
              const result = validate2(instance[i], $items[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);
              evaluated[i] = true;
              if (!result.valid) {
                stop = shortCircuit;
                errors.push({
                  instanceLocation,
                  keyword: "items",
                  keywordLocation,
                  error: `Items did not match schema.`
                }, ...result.errors);
                if (stop)
                  break;
              }
            }
          } else {
            for (; i < length; i++) {
              const result = validate2(instance[i], $items, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);
              evaluated[i] = true;
              if (!result.valid) {
                stop = shortCircuit;
                errors.push({
                  instanceLocation,
                  keyword: "items",
                  keywordLocation,
                  error: `Items did not match schema.`
                }, ...result.errors);
                if (stop)
                  break;
              }
            }
          }
          if (!stop && $additionalItems !== void 0) {
            const keywordLocation2 = `${schemaLocation}/additionalItems`;
            for (; i < length; i++) {
              const result = validate2(instance[i], $additionalItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation2);
              evaluated[i] = true;
              if (!result.valid) {
                stop = shortCircuit;
                errors.push({
                  instanceLocation,
                  keyword: "additionalItems",
                  keywordLocation: keywordLocation2,
                  error: `Items did not match additional items schema.`
                }, ...result.errors);
              }
            }
          }
        }
        if ($contains !== void 0) {
          if (length === 0 && $minContains === void 0) {
            errors.push({
              instanceLocation,
              keyword: "contains",
              keywordLocation: `${schemaLocation}/contains`,
              error: `Array is empty. It must contain at least one item matching the schema.`
            });
          } else if ($minContains !== void 0 && length < $minContains) {
            errors.push({
              instanceLocation,
              keyword: "minContains",
              keywordLocation: `${schemaLocation}/minContains`,
              error: `Array has less items (${length}) than minContains (${$minContains}).`
            });
          } else {
            const keywordLocation = `${schemaLocation}/contains`;
            const errorsLength = errors.length;
            let contained = 0;
            for (let j = 0; j < length; j++) {
              const result = validate2(instance[j], $contains, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${j}`, keywordLocation);
              if (result.valid) {
                evaluated[j] = true;
                contained++;
              } else {
                errors.push(...result.errors);
              }
            }
            if (contained >= ($minContains || 0)) {
              errors.length = errorsLength;
            }
            if ($minContains === void 0 && $maxContains === void 0 && contained === 0) {
              errors.splice(errorsLength, 0, {
                instanceLocation,
                keyword: "contains",
                keywordLocation,
                error: `Array does not contain item matching schema.`
              });
            } else if ($minContains !== void 0 && contained < $minContains) {
              errors.push({
                instanceLocation,
                keyword: "minContains",
                keywordLocation: `${schemaLocation}/minContains`,
                error: `Array must contain at least ${$minContains} items matching schema. Only ${contained} items were found.`
              });
            } else if ($maxContains !== void 0 && contained > $maxContains) {
              errors.push({
                instanceLocation,
                keyword: "maxContains",
                keywordLocation: `${schemaLocation}/maxContains`,
                error: `Array may contain at most ${$maxContains} items matching schema. ${contained} items were found.`
              });
            }
          }
        }
        if (!stop && $unevaluatedItems !== void 0) {
          const keywordLocation = `${schemaLocation}/unevaluatedItems`;
          for (i; i < length; i++) {
            if (evaluated[i]) {
              continue;
            }
            const result = validate2(instance[i], $unevaluatedItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);
            evaluated[i] = true;
            if (!result.valid) {
              errors.push({
                instanceLocation,
                keyword: "unevaluatedItems",
                keywordLocation,
                error: `Items did not match unevaluated items schema.`
              }, ...result.errors);
            }
          }
        }
        if ($uniqueItems) {
          for (let j = 0; j < length; j++) {
            const a = instance[j];
            const ao = typeof a === "object" && a !== null;
            for (let k = 0; k < length; k++) {
              if (j === k) {
                continue;
              }
              const b = instance[k];
              const bo = typeof b === "object" && b !== null;
              if (a === b || ao && bo && (0, deep_compare_strict_js_1.deepCompareStrict)(a, b)) {
                errors.push({
                  instanceLocation,
                  keyword: "uniqueItems",
                  keywordLocation: `${schemaLocation}/uniqueItems`,
                  error: `Duplicate items at indexes ${j} and ${k}.`
                });
                j = Number.MAX_SAFE_INTEGER;
                k = Number.MAX_SAFE_INTEGER;
              }
            }
          }
        }
      } else if (instanceType === "number") {
        if (draft === "4") {
          if ($minimum !== void 0 && ($exclusiveMinimum === true && instance <= $minimum || instance < $minimum)) {
            errors.push({
              instanceLocation,
              keyword: "minimum",
              keywordLocation: `${schemaLocation}/minimum`,
              error: `${instance} is less than ${$exclusiveMinimum ? "or equal to " : ""} ${$minimum}.`
            });
          }
          if ($maximum !== void 0 && ($exclusiveMaximum === true && instance >= $maximum || instance > $maximum)) {
            errors.push({
              instanceLocation,
              keyword: "maximum",
              keywordLocation: `${schemaLocation}/maximum`,
              error: `${instance} is greater than ${$exclusiveMaximum ? "or equal to " : ""} ${$maximum}.`
            });
          }
        } else {
          if ($minimum !== void 0 && instance < $minimum) {
            errors.push({
              instanceLocation,
              keyword: "minimum",
              keywordLocation: `${schemaLocation}/minimum`,
              error: `${instance} is less than ${$minimum}.`
            });
          }
          if ($maximum !== void 0 && instance > $maximum) {
            errors.push({
              instanceLocation,
              keyword: "maximum",
              keywordLocation: `${schemaLocation}/maximum`,
              error: `${instance} is greater than ${$maximum}.`
            });
          }
          if ($exclusiveMinimum !== void 0 && instance <= $exclusiveMinimum) {
            errors.push({
              instanceLocation,
              keyword: "exclusiveMinimum",
              keywordLocation: `${schemaLocation}/exclusiveMinimum`,
              error: `${instance} is less than ${$exclusiveMinimum}.`
            });
          }
          if ($exclusiveMaximum !== void 0 && instance >= $exclusiveMaximum) {
            errors.push({
              instanceLocation,
              keyword: "exclusiveMaximum",
              keywordLocation: `${schemaLocation}/exclusiveMaximum`,
              error: `${instance} is greater than or equal to ${$exclusiveMaximum}.`
            });
          }
        }
        if ($multipleOf !== void 0) {
          const remainder = instance % $multipleOf;
          if (Math.abs(0 - remainder) >= 11920929e-14 && Math.abs($multipleOf - remainder) >= 11920929e-14) {
            errors.push({
              instanceLocation,
              keyword: "multipleOf",
              keywordLocation: `${schemaLocation}/multipleOf`,
              error: `${instance} is not a multiple of ${$multipleOf}.`
            });
          }
        }
      } else if (instanceType === "string") {
        const length = $minLength === void 0 && $maxLength === void 0 ? 0 : (0, ucs2_length_js_1.ucs2length)(instance);
        if ($minLength !== void 0 && length < $minLength) {
          errors.push({
            instanceLocation,
            keyword: "minLength",
            keywordLocation: `${schemaLocation}/minLength`,
            error: `String is too short (${length} < ${$minLength}).`
          });
        }
        if ($maxLength !== void 0 && length > $maxLength) {
          errors.push({
            instanceLocation,
            keyword: "maxLength",
            keywordLocation: `${schemaLocation}/maxLength`,
            error: `String is too long (${length} > ${$maxLength}).`
          });
        }
        if ($pattern !== void 0 && !new RegExp($pattern, "u").test(instance)) {
          errors.push({
            instanceLocation,
            keyword: "pattern",
            keywordLocation: `${schemaLocation}/pattern`,
            error: `String does not match pattern.`
          });
        }
        if ($format !== void 0 && format_js_1.format[$format] && !format_js_1.format[$format](instance)) {
          errors.push({
            instanceLocation,
            keyword: "format",
            keywordLocation: `${schemaLocation}/format`,
            error: `String does not match format "${$format}".`
          });
        }
      }
      return { valid: errors.length === 0, errors };
    }
  }
});

// node_modules/.pnpm/@cfworker+json-schema@4.1.1/node_modules/@cfworker/json-schema/dist/commonjs/validator.js
var require_validator = __commonJS({
  "node_modules/.pnpm/@cfworker+json-schema@4.1.1/node_modules/@cfworker/json-schema/dist/commonjs/validator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Validator = void 0;
    var dereference_js_1 = require_dereference();
    var validate_js_1 = require_validate();
    var Validator = class {
      schema;
      draft;
      shortCircuit;
      lookup;
      constructor(schema, draft = "2019-09", shortCircuit = true) {
        this.schema = schema;
        this.draft = draft;
        this.shortCircuit = shortCircuit;
        this.lookup = (0, dereference_js_1.dereference)(schema);
      }
      validate(instance) {
        return (0, validate_js_1.validate)(instance, this.schema, this.draft, this.lookup, this.shortCircuit);
      }
      addSchema(schema, id) {
        if (id) {
          schema = { ...schema, $id: id };
        }
        (0, dereference_js_1.dereference)(schema, this.lookup);
      }
    };
    exports2.Validator = Validator;
  }
});

// node_modules/.pnpm/@cfworker+json-schema@4.1.1/node_modules/@cfworker/json-schema/dist/commonjs/index.js
var require_commonjs = __commonJS({
  "node_modules/.pnpm/@cfworker+json-schema@4.1.1/node_modules/@cfworker/json-schema/dist/commonjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_deep_compare_strict(), exports2);
    __exportStar(require_dereference(), exports2);
    __exportStar(require_format2(), exports2);
    __exportStar(require_pointer(), exports2);
    __exportStar(require_types3(), exports2);
    __exportStar(require_ucs2_length(), exports2);
    __exportStar(require_validate(), exports2);
    __exportStar(require_validator(), exports2);
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/json_schema.cjs
var require_json_schema2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/json_schema.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_zod3 = require_zod();
    var require_zodToJsonSchema2 = require_zodToJsonSchema();
    require_zod_to_json_schema();
    var zod_v4_core = require_rolldown_runtime5.__toESM(require_core2());
    var __cfworker_json_schema = require_rolldown_runtime5.__toESM(require_commonjs());
    var json_schema_exports = {};
    require_rolldown_runtime5.__export(json_schema_exports, {
      Validator: () => __cfworker_json_schema.Validator,
      deepCompareStrict: () => __cfworker_json_schema.deepCompareStrict,
      toJsonSchema: () => toJsonSchema,
      validatesOnlyStrings: () => validatesOnlyStrings
    });
    function toJsonSchema(schema) {
      if (require_zod3.isZodSchemaV4(schema)) {
        const inputSchema = require_zod3.interopZodTransformInputSchema(schema, true);
        if (require_zod3.isZodObjectV4(inputSchema)) {
          const strictSchema = require_zod3.interopZodObjectStrict(inputSchema, true);
          return (0, zod_v4_core.toJSONSchema)(strictSchema);
        } else return (0, zod_v4_core.toJSONSchema)(schema);
      }
      if (require_zod3.isZodSchemaV3(schema)) return require_zodToJsonSchema2.zodToJsonSchema(schema);
      return schema;
    }
    function validatesOnlyStrings(schema) {
      if (!schema || typeof schema !== "object" || Object.keys(schema).length === 0 || Array.isArray(schema)) return false;
      if ("type" in schema) {
        if (typeof schema.type === "string") return schema.type === "string";
        if (Array.isArray(schema.type)) return schema.type.every((t) => t === "string");
        return false;
      }
      if ("enum" in schema) return Array.isArray(schema.enum) && schema.enum.length > 0 && schema.enum.every((val) => typeof val === "string");
      if ("const" in schema) return typeof schema.const === "string";
      if ("allOf" in schema && Array.isArray(schema.allOf)) return schema.allOf.some((subschema) => validatesOnlyStrings(subschema));
      if ("anyOf" in schema && Array.isArray(schema.anyOf) || "oneOf" in schema && Array.isArray(schema.oneOf)) {
        const subschemas = "anyOf" in schema ? schema.anyOf : schema.oneOf;
        return subschemas.length > 0 && subschemas.every((subschema) => validatesOnlyStrings(subschema));
      }
      if ("not" in schema) return false;
      if ("$ref" in schema && typeof schema.$ref === "string") {
        const ref = schema.$ref;
        const resolved = (0, __cfworker_json_schema.dereference)(schema);
        if (resolved[ref]) return validatesOnlyStrings(resolved[ref]);
        return false;
      }
      return false;
    }
    Object.defineProperty(exports2, "Validator", {
      enumerable: true,
      get: function() {
        return __cfworker_json_schema.Validator;
      }
    });
    Object.defineProperty(exports2, "deepCompareStrict", {
      enumerable: true,
      get: function() {
        return __cfworker_json_schema.deepCompareStrict;
      }
    });
    Object.defineProperty(exports2, "json_schema_exports", {
      enumerable: true,
      get: function() {
        return json_schema_exports;
      }
    });
    exports2.toJsonSchema = toJsonSchema;
    exports2.validatesOnlyStrings = validatesOnlyStrings;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/async_caller.cjs
var require_async_caller2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/async_caller.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_signal2 = require_signal();
    var p_retry = require_rolldown_runtime5.__toESM(require_p_retry());
    var p_queue = require_rolldown_runtime5.__toESM(require_dist2());
    var async_caller_exports = {};
    require_rolldown_runtime5.__export(async_caller_exports, { AsyncCaller: () => AsyncCaller });
    var STATUS_NO_RETRY = [
      400,
      401,
      402,
      403,
      404,
      405,
      406,
      407,
      409
    ];
    var defaultFailedAttemptHandler = (error) => {
      if (error.message.startsWith("Cancel") || error.message.startsWith("AbortError") || error.name === "AbortError") throw error;
      if (error?.code === "ECONNABORTED") throw error;
      const status = error?.response?.status ?? error?.status;
      if (status && STATUS_NO_RETRY.includes(+status)) throw error;
      if (error?.error?.code === "insufficient_quota") {
        const err = new Error(error?.message);
        err.name = "InsufficientQuotaError";
        throw err;
      }
    };
    var AsyncCaller = class {
      maxConcurrency;
      maxRetries;
      onFailedAttempt;
      queue;
      constructor(params) {
        this.maxConcurrency = params.maxConcurrency ?? Infinity;
        this.maxRetries = params.maxRetries ?? 6;
        this.onFailedAttempt = params.onFailedAttempt ?? defaultFailedAttemptHandler;
        const PQueue = "default" in p_queue.default ? p_queue.default.default : p_queue.default;
        this.queue = new PQueue({ concurrency: this.maxConcurrency });
      }
      call(callable, ...args) {
        return this.queue.add(() => (0, p_retry.default)(() => callable(...args).catch((error) => {
          if (error instanceof Error) throw error;
          else throw new Error(error);
        }), {
          onFailedAttempt: this.onFailedAttempt,
          retries: this.maxRetries,
          randomize: true
        }), { throwOnTimeout: true });
      }
      callWithOptions(options, callable, ...args) {
        if (options.signal) return Promise.race([this.call(callable, ...args), new Promise((_, reject) => {
          options.signal?.addEventListener("abort", () => {
            reject(require_signal2.getAbortSignalError(options.signal));
          });
        })]);
        return this.call(callable, ...args);
      }
      fetch(...args) {
        return this.call(() => fetch(...args).then((res) => res.ok ? res : Promise.reject(res)));
      }
    };
    exports2.AsyncCaller = AsyncCaller;
    Object.defineProperty(exports2, "async_caller_exports", {
      enumerable: true,
      get: function() {
        return async_caller_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/stream.cjs
var require_stream = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/stream.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_index = require_async_local_storage();
    require_singletons();
    var require_config3 = require_config();
    var require_signal2 = require_signal();
    var stream_exports = {};
    require_rolldown_runtime5.__export(stream_exports, {
      AsyncGeneratorWithSetup: () => AsyncGeneratorWithSetup,
      IterableReadableStream: () => IterableReadableStream,
      atee: () => atee,
      concat: () => concat,
      pipeGeneratorWithSetup: () => pipeGeneratorWithSetup
    });
    var IterableReadableStream = class IterableReadableStream2 extends ReadableStream {
      reader;
      ensureReader() {
        if (!this.reader) this.reader = this.getReader();
      }
      async next() {
        this.ensureReader();
        try {
          const result = await this.reader.read();
          if (result.done) {
            this.reader.releaseLock();
            return {
              done: true,
              value: void 0
            };
          } else return {
            done: false,
            value: result.value
          };
        } catch (e) {
          this.reader.releaseLock();
          throw e;
        }
      }
      async return() {
        this.ensureReader();
        if (this.locked) {
          const cancelPromise = this.reader.cancel();
          this.reader.releaseLock();
          await cancelPromise;
        }
        return {
          done: true,
          value: void 0
        };
      }
      async throw(e) {
        this.ensureReader();
        if (this.locked) {
          const cancelPromise = this.reader.cancel();
          this.reader.releaseLock();
          await cancelPromise;
        }
        throw e;
      }
      [Symbol.asyncIterator]() {
        return this;
      }
      async [Symbol.asyncDispose]() {
        await this.return();
      }
      static fromReadableStream(stream) {
        const reader = stream.getReader();
        return new IterableReadableStream2({
          start(controller) {
            return pump();
            function pump() {
              return reader.read().then(({ done, value }) => {
                if (done) {
                  controller.close();
                  return;
                }
                controller.enqueue(value);
                return pump();
              });
            }
          },
          cancel() {
            reader.releaseLock();
          }
        });
      }
      static fromAsyncGenerator(generator) {
        return new IterableReadableStream2({
          async pull(controller) {
            const { value, done } = await generator.next();
            if (done) controller.close();
            controller.enqueue(value);
          },
          async cancel(reason) {
            await generator.return(reason);
          }
        });
      }
    };
    function atee(iter, length = 2) {
      const buffers = Array.from({ length }, () => []);
      return buffers.map(async function* makeIter(buffer) {
        while (true) if (buffer.length === 0) {
          const result = await iter.next();
          for (const buffer$1 of buffers) buffer$1.push(result);
        } else if (buffer[0].done) return;
        else yield buffer.shift().value;
      });
    }
    function concat(first, second) {
      if (Array.isArray(first) && Array.isArray(second)) return first.concat(second);
      else if (typeof first === "string" && typeof second === "string") return first + second;
      else if (typeof first === "number" && typeof second === "number") return first + second;
      else if ("concat" in first && typeof first.concat === "function") return first.concat(second);
      else if (typeof first === "object" && typeof second === "object") {
        const chunk = { ...first };
        for (const [key, value] of Object.entries(second)) if (key in chunk && !Array.isArray(chunk[key])) chunk[key] = concat(chunk[key], value);
        else chunk[key] = value;
        return chunk;
      } else throw new Error(`Cannot concat ${typeof first} and ${typeof second}`);
    }
    var AsyncGeneratorWithSetup = class {
      generator;
      setup;
      config;
      signal;
      firstResult;
      firstResultUsed = false;
      constructor(params) {
        this.generator = params.generator;
        this.config = params.config;
        this.signal = params.signal ?? this.config?.signal;
        this.setup = new Promise((resolve, reject) => {
          require_index.AsyncLocalStorageProviderSingleton.runWithConfig(require_config3.pickRunnableConfigKeys(params.config), async () => {
            this.firstResult = params.generator.next();
            if (params.startSetup) this.firstResult.then(params.startSetup).then(resolve, reject);
            else this.firstResult.then((_result) => resolve(void 0), reject);
          }, true);
        });
      }
      async next(...args) {
        this.signal?.throwIfAborted();
        if (!this.firstResultUsed) {
          this.firstResultUsed = true;
          return this.firstResult;
        }
        return require_index.AsyncLocalStorageProviderSingleton.runWithConfig(require_config3.pickRunnableConfigKeys(this.config), this.signal ? async () => {
          return require_signal2.raceWithSignal(this.generator.next(...args), this.signal);
        } : async () => {
          return this.generator.next(...args);
        }, true);
      }
      async return(value) {
        return this.generator.return(value);
      }
      async throw(e) {
        return this.generator.throw(e);
      }
      [Symbol.asyncIterator]() {
        return this;
      }
      async [Symbol.asyncDispose]() {
        await this.return();
      }
    };
    async function pipeGeneratorWithSetup(to, generator, startSetup, signal, ...args) {
      const gen = new AsyncGeneratorWithSetup({
        generator,
        startSetup,
        signal
      });
      const setup = await gen.setup;
      return {
        output: to(gen, setup, ...args),
        setup
      };
    }
    exports2.AsyncGeneratorWithSetup = AsyncGeneratorWithSetup;
    exports2.IterableReadableStream = IterableReadableStream;
    exports2.atee = atee;
    exports2.concat = concat;
    exports2.pipeGeneratorWithSetup = pipeGeneratorWithSetup;
    Object.defineProperty(exports2, "stream_exports", {
      enumerable: true,
      get: function() {
        return stream_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs
var require_helpers = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs"(exports2) {
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function hasOwnProperty(obj, key) {
      return _hasOwnProperty.call(obj, key);
    }
    function _objectKeys(obj) {
      if (Array.isArray(obj)) {
        const keys$1 = new Array(obj.length);
        for (let k = 0; k < keys$1.length; k++) keys$1[k] = "" + k;
        return keys$1;
      }
      if (Object.keys) return Object.keys(obj);
      let keys = [];
      for (let i in obj) if (hasOwnProperty(obj, i)) keys.push(i);
      return keys;
    }
    function _deepClone(obj) {
      switch (typeof obj) {
        case "object":
          return JSON.parse(JSON.stringify(obj));
        case "undefined":
          return null;
        default:
          return obj;
      }
    }
    function isInteger(str) {
      let i = 0;
      const len = str.length;
      let charCode;
      while (i < len) {
        charCode = str.charCodeAt(i);
        if (charCode >= 48 && charCode <= 57) {
          i++;
          continue;
        }
        return false;
      }
      return true;
    }
    function escapePathComponent(path) {
      if (path.indexOf("/") === -1 && path.indexOf("~") === -1) return path;
      return path.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    function unescapePathComponent(path) {
      return path.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    function hasUndefined(obj) {
      if (obj === void 0) return true;
      if (obj) {
        if (Array.isArray(obj)) {
          for (let i$1 = 0, len = obj.length; i$1 < len; i$1++) if (hasUndefined(obj[i$1])) return true;
        } else if (typeof obj === "object") {
          const objKeys = _objectKeys(obj);
          const objKeysLength = objKeys.length;
          for (var i = 0; i < objKeysLength; i++) if (hasUndefined(obj[objKeys[i]])) return true;
        }
      }
      return false;
    }
    function patchErrorMessageFormatter(message, args) {
      const messageParts = [message];
      for (const key in args) {
        const value = typeof args[key] === "object" ? JSON.stringify(args[key], null, 2) : args[key];
        if (typeof value !== "undefined") messageParts.push(`${key}: ${value}`);
      }
      return messageParts.join("\n");
    }
    var PatchError = class extends Error {
      constructor(message, name, index, operation, tree) {
        super(patchErrorMessageFormatter(message, {
          name,
          index,
          operation,
          tree
        }));
        this.name = name;
        this.index = index;
        this.operation = operation;
        this.tree = tree;
        Object.setPrototypeOf(this, new.target.prototype);
        this.message = patchErrorMessageFormatter(message, {
          name,
          index,
          operation,
          tree
        });
      }
    };
    exports2.PatchError = PatchError;
    exports2._deepClone = _deepClone;
    exports2._objectKeys = _objectKeys;
    exports2.escapePathComponent = escapePathComponent;
    exports2.hasOwnProperty = hasOwnProperty;
    exports2.hasUndefined = hasUndefined;
    exports2.isInteger = isInteger;
    exports2.unescapePathComponent = unescapePathComponent;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.cjs
var require_core3 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_helpers2 = require_helpers();
    var core_exports = {};
    require_rolldown_runtime5.__export(core_exports, {
      JsonPatchError: () => JsonPatchError,
      _areEquals: () => _areEquals,
      applyOperation: () => applyOperation,
      applyPatch: () => applyPatch,
      applyReducer: () => applyReducer,
      deepClone: () => deepClone,
      getValueByPointer: () => getValueByPointer,
      validate: () => validate2,
      validator: () => validator
    });
    var JsonPatchError = require_helpers2.PatchError;
    var deepClone = require_helpers2._deepClone;
    var objOps = {
      add: function(obj, key, document2) {
        obj[key] = this.value;
        return { newDocument: document2 };
      },
      remove: function(obj, key, document2) {
        var removed = obj[key];
        delete obj[key];
        return {
          newDocument: document2,
          removed
        };
      },
      replace: function(obj, key, document2) {
        var removed = obj[key];
        obj[key] = this.value;
        return {
          newDocument: document2,
          removed
        };
      },
      move: function(obj, key, document2) {
        let removed = getValueByPointer(document2, this.path);
        if (removed) removed = require_helpers2._deepClone(removed);
        const originalValue = applyOperation(document2, {
          op: "remove",
          path: this.from
        }).removed;
        applyOperation(document2, {
          op: "add",
          path: this.path,
          value: originalValue
        });
        return {
          newDocument: document2,
          removed
        };
      },
      copy: function(obj, key, document2) {
        const valueToCopy = getValueByPointer(document2, this.from);
        applyOperation(document2, {
          op: "add",
          path: this.path,
          value: require_helpers2._deepClone(valueToCopy)
        });
        return { newDocument: document2 };
      },
      test: function(obj, key, document2) {
        return {
          newDocument: document2,
          test: _areEquals(obj[key], this.value)
        };
      },
      _get: function(obj, key, document2) {
        this.value = obj[key];
        return { newDocument: document2 };
      }
    };
    var arrOps = {
      add: function(arr, i, document2) {
        if (require_helpers2.isInteger(i)) arr.splice(i, 0, this.value);
        else arr[i] = this.value;
        return {
          newDocument: document2,
          index: i
        };
      },
      remove: function(arr, i, document2) {
        var removedList = arr.splice(i, 1);
        return {
          newDocument: document2,
          removed: removedList[0]
        };
      },
      replace: function(arr, i, document2) {
        var removed = arr[i];
        arr[i] = this.value;
        return {
          newDocument: document2,
          removed
        };
      },
      move: objOps.move,
      copy: objOps.copy,
      test: objOps.test,
      _get: objOps._get
    };
    function getValueByPointer(document2, pointer) {
      if (pointer == "") return document2;
      var getOriginalDestination = {
        op: "_get",
        path: pointer
      };
      applyOperation(document2, getOriginalDestination);
      return getOriginalDestination.value;
    }
    function applyOperation(document2, operation, validateOperation = false, mutateDocument = true, banPrototypeModifications = true, index = 0) {
      if (validateOperation) if (typeof validateOperation == "function") validateOperation(operation, 0, document2, operation.path);
      else validator(operation, 0);
      if (operation.path === "") {
        let returnValue = { newDocument: document2 };
        if (operation.op === "add") {
          returnValue.newDocument = operation.value;
          return returnValue;
        } else if (operation.op === "replace") {
          returnValue.newDocument = operation.value;
          returnValue.removed = document2;
          return returnValue;
        } else if (operation.op === "move" || operation.op === "copy") {
          returnValue.newDocument = getValueByPointer(document2, operation.from);
          if (operation.op === "move") returnValue.removed = document2;
          return returnValue;
        } else if (operation.op === "test") {
          returnValue.test = _areEquals(document2, operation.value);
          if (returnValue.test === false) throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
          returnValue.newDocument = document2;
          return returnValue;
        } else if (operation.op === "remove") {
          returnValue.removed = document2;
          returnValue.newDocument = null;
          return returnValue;
        } else if (operation.op === "_get") {
          operation.value = document2;
          return returnValue;
        } else if (validateOperation) throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document2);
        else return returnValue;
      } else {
        if (!mutateDocument) document2 = require_helpers2._deepClone(document2);
        const path = operation.path || "";
        const keys = path.split("/");
        let obj = document2;
        let t = 1;
        let len = keys.length;
        let existingPathFragment = void 0;
        let key;
        let validateFunction;
        if (typeof validateOperation == "function") validateFunction = validateOperation;
        else validateFunction = validator;
        while (true) {
          key = keys[t];
          if (key && key.indexOf("~") != -1) key = require_helpers2.unescapePathComponent(key);
          if (banPrototypeModifications && (key == "__proto__" || key == "prototype" && t > 0 && keys[t - 1] == "constructor")) throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
          if (validateOperation) {
            if (existingPathFragment === void 0) {
              if (obj[key] === void 0) existingPathFragment = keys.slice(0, t).join("/");
              else if (t == len - 1) existingPathFragment = operation.path;
              if (existingPathFragment !== void 0) validateFunction(operation, 0, document2, existingPathFragment);
            }
          }
          t++;
          if (Array.isArray(obj)) {
            if (key === "-") key = obj.length;
            else if (validateOperation && !require_helpers2.isInteger(key)) throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document2);
            else if (require_helpers2.isInteger(key)) key = ~~key;
            if (t >= len) {
              if (validateOperation && operation.op === "add" && key > obj.length) throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document2);
              const returnValue = arrOps[operation.op].call(operation, obj, key, document2);
              if (returnValue.test === false) throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
              return returnValue;
            }
          } else if (t >= len) {
            const returnValue = objOps[operation.op].call(operation, obj, key, document2);
            if (returnValue.test === false) throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
            return returnValue;
          }
          obj = obj[key];
          if (validateOperation && t < len && (!obj || typeof obj !== "object")) throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index, operation, document2);
        }
      }
    }
    function applyPatch(document2, patch, validateOperation, mutateDocument = true, banPrototypeModifications = true) {
      if (validateOperation) {
        if (!Array.isArray(patch)) throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
      }
      if (!mutateDocument) document2 = require_helpers2._deepClone(document2);
      const results = new Array(patch.length);
      for (let i = 0, length = patch.length; i < length; i++) {
        results[i] = applyOperation(document2, patch[i], validateOperation, true, banPrototypeModifications, i);
        document2 = results[i].newDocument;
      }
      results.newDocument = document2;
      return results;
    }
    function applyReducer(document2, operation, index) {
      const operationResult = applyOperation(document2, operation);
      if (operationResult.test === false) throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
      return operationResult.newDocument;
    }
    function validator(operation, index, document2, existingPathFragment) {
      if (typeof operation !== "object" || operation === null || Array.isArray(operation)) throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index, operation, document2);
      else if (!objOps[operation.op]) throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document2);
      else if (typeof operation.path !== "string") throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index, operation, document2);
      else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index, operation, document2);
      else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string") throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index, operation, document2);
      else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === void 0) throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index, operation, document2);
      else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && require_helpers2.hasUndefined(operation.value)) throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index, operation, document2);
      else if (document2) {
        if (operation.op == "add") {
          var pathLen = operation.path.split("/").length;
          var existingPathLen = existingPathFragment.split("/").length;
          if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index, operation, document2);
        } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
          if (operation.path !== existingPathFragment) throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index, operation, document2);
        } else if (operation.op === "move" || operation.op === "copy") {
          var existingValue = {
            op: "_get",
            path: operation.from,
            value: void 0
          };
          var error = validate2([existingValue], document2);
          if (error && error.name === "OPERATION_PATH_UNRESOLVABLE") throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index, operation, document2);
        }
      }
    }
    function validate2(sequence, document2, externalValidator) {
      try {
        if (!Array.isArray(sequence)) throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
        if (document2) applyPatch(require_helpers2._deepClone(document2), require_helpers2._deepClone(sequence), externalValidator || true);
        else {
          externalValidator = externalValidator || validator;
          for (var i = 0; i < sequence.length; i++) externalValidator(sequence[i], i, document2, void 0);
        }
      } catch (e) {
        if (e instanceof JsonPatchError) return e;
        else throw e;
      }
    }
    function _areEquals(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;
        if (arrA && arrB) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; ) if (!_areEquals(a[i], b[i])) return false;
          return true;
        }
        if (arrA != arrB) return false;
        var keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; ) if (!b.hasOwnProperty(keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          key = keys[i];
          if (!_areEquals(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    }
    exports2._areEquals = _areEquals;
    exports2.applyOperation = applyOperation;
    exports2.applyPatch = applyPatch;
    exports2.applyReducer = applyReducer;
    Object.defineProperty(exports2, "core_exports", {
      enumerable: true,
      get: function() {
        return core_exports;
      }
    });
    exports2.getValueByPointer = getValueByPointer;
    exports2.validate = validate2;
    exports2.validator = validator;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.cjs
var require_duplex = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.cjs"(exports2) {
    var require_helpers2 = require_helpers();
    require_core3();
    function _generate(mirror, obj, patches, path, invertible) {
      if (obj === mirror) return;
      if (typeof obj.toJSON === "function") obj = obj.toJSON();
      var newKeys = require_helpers2._objectKeys(obj);
      var oldKeys = require_helpers2._objectKeys(mirror);
      var changed = false;
      var deleted = false;
      for (var t = oldKeys.length - 1; t >= 0; t--) {
        var key = oldKeys[t];
        var oldVal = mirror[key];
        if (require_helpers2.hasOwnProperty(obj, key) && !(obj[key] === void 0 && oldVal !== void 0 && Array.isArray(obj) === false)) {
          var newVal = obj[key];
          if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) _generate(oldVal, newVal, patches, path + "/" + require_helpers2.escapePathComponent(key), invertible);
          else if (oldVal !== newVal) {
            changed = true;
            if (invertible) patches.push({
              op: "test",
              path: path + "/" + require_helpers2.escapePathComponent(key),
              value: require_helpers2._deepClone(oldVal)
            });
            patches.push({
              op: "replace",
              path: path + "/" + require_helpers2.escapePathComponent(key),
              value: require_helpers2._deepClone(newVal)
            });
          }
        } else if (Array.isArray(mirror) === Array.isArray(obj)) {
          if (invertible) patches.push({
            op: "test",
            path: path + "/" + require_helpers2.escapePathComponent(key),
            value: require_helpers2._deepClone(oldVal)
          });
          patches.push({
            op: "remove",
            path: path + "/" + require_helpers2.escapePathComponent(key)
          });
          deleted = true;
        } else {
          if (invertible) patches.push({
            op: "test",
            path,
            value: mirror
          });
          patches.push({
            op: "replace",
            path,
            value: obj
          });
          changed = true;
        }
      }
      if (!deleted && newKeys.length == oldKeys.length) return;
      for (var t = 0; t < newKeys.length; t++) {
        var key = newKeys[t];
        if (!require_helpers2.hasOwnProperty(mirror, key) && obj[key] !== void 0) patches.push({
          op: "add",
          path: path + "/" + require_helpers2.escapePathComponent(key),
          value: require_helpers2._deepClone(obj[key])
        });
      }
    }
    function compare(tree1, tree2, invertible = false) {
      var patches = [];
      _generate(tree1, tree2, patches, "", invertible);
      return patches;
    }
    exports2.compare = compare;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/fast-json-patch/index.cjs
var require_fast_json_patch = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/fast-json-patch/index.cjs"() {
    var require_helpers2 = require_helpers();
    var require_core6 = require_core3();
    var require_duplex2 = require_duplex();
    var fast_json_patch_default = {
      ...require_core6.core_exports,
      JsonPatchError: require_helpers2.PatchError,
      deepClone: require_helpers2._deepClone,
      escapePathComponent: require_helpers2.escapePathComponent,
      unescapePathComponent: require_helpers2.unescapePathComponent
    };
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/tracers/log_stream.cjs
var require_log_stream = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/tracers/log_stream.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_ai2 = require_ai();
    var require_core6 = require_core3();
    require_fast_json_patch();
    var require_tracers_base = require_base3();
    var require_utils_stream = require_stream();
    var log_stream_exports = {};
    require_rolldown_runtime5.__export(log_stream_exports, {
      LogStreamCallbackHandler: () => LogStreamCallbackHandler,
      RunLog: () => RunLog,
      RunLogPatch: () => RunLogPatch,
      isLogStreamHandler: () => isLogStreamHandler
    });
    var RunLogPatch = class {
      ops;
      constructor(fields) {
        this.ops = fields.ops ?? [];
      }
      concat(other) {
        const ops = this.ops.concat(other.ops);
        const states = require_core6.applyPatch({}, ops);
        return new RunLog({
          ops,
          state: states[states.length - 1].newDocument
        });
      }
    };
    var RunLog = class RunLog2 extends RunLogPatch {
      state;
      constructor(fields) {
        super(fields);
        this.state = fields.state;
      }
      concat(other) {
        const ops = this.ops.concat(other.ops);
        const states = require_core6.applyPatch(this.state, other.ops);
        return new RunLog2({
          ops,
          state: states[states.length - 1].newDocument
        });
      }
      static fromRunLogPatch(patch) {
        const states = require_core6.applyPatch({}, patch.ops);
        return new RunLog2({
          ops: patch.ops,
          state: states[states.length - 1].newDocument
        });
      }
    };
    var isLogStreamHandler = (handler) => handler.name === "log_stream_tracer";
    async function _getStandardizedInputs(run, schemaFormat) {
      if (schemaFormat === "original") throw new Error("Do not assign inputs with original schema drop the key for now. When inputs are added to streamLog they should be added with standardized schema for streaming events.");
      const { inputs } = run;
      if ([
        "retriever",
        "llm",
        "prompt"
      ].includes(run.run_type)) return inputs;
      if (Object.keys(inputs).length === 1 && inputs?.input === "") return void 0;
      return inputs.input;
    }
    async function _getStandardizedOutputs(run, schemaFormat) {
      const { outputs } = run;
      if (schemaFormat === "original") return outputs;
      if ([
        "retriever",
        "llm",
        "prompt"
      ].includes(run.run_type)) return outputs;
      if (outputs !== void 0 && Object.keys(outputs).length === 1 && outputs?.output !== void 0) return outputs.output;
      return outputs;
    }
    function isChatGenerationChunk(x) {
      return x !== void 0 && x.message !== void 0;
    }
    var LogStreamCallbackHandler = class extends require_tracers_base.BaseTracer {
      autoClose = true;
      includeNames;
      includeTypes;
      includeTags;
      excludeNames;
      excludeTypes;
      excludeTags;
      _schemaFormat = "original";
      rootId;
      keyMapByRunId = {};
      counterMapByRunName = {};
      transformStream;
      writer;
      receiveStream;
      name = "log_stream_tracer";
      lc_prefer_streaming = true;
      constructor(fields) {
        super({
          _awaitHandler: true,
          ...fields
        });
        this.autoClose = fields?.autoClose ?? true;
        this.includeNames = fields?.includeNames;
        this.includeTypes = fields?.includeTypes;
        this.includeTags = fields?.includeTags;
        this.excludeNames = fields?.excludeNames;
        this.excludeTypes = fields?.excludeTypes;
        this.excludeTags = fields?.excludeTags;
        this._schemaFormat = fields?._schemaFormat ?? this._schemaFormat;
        this.transformStream = new TransformStream();
        this.writer = this.transformStream.writable.getWriter();
        this.receiveStream = require_utils_stream.IterableReadableStream.fromReadableStream(this.transformStream.readable);
      }
      [Symbol.asyncIterator]() {
        return this.receiveStream;
      }
      async persistRun(_run) {
      }
      _includeRun(run) {
        if (run.id === this.rootId) return false;
        const runTags = run.tags ?? [];
        let include = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
        if (this.includeNames !== void 0) include = include || this.includeNames.includes(run.name);
        if (this.includeTypes !== void 0) include = include || this.includeTypes.includes(run.run_type);
        if (this.includeTags !== void 0) include = include || runTags.find((tag) => this.includeTags?.includes(tag)) !== void 0;
        if (this.excludeNames !== void 0) include = include && !this.excludeNames.includes(run.name);
        if (this.excludeTypes !== void 0) include = include && !this.excludeTypes.includes(run.run_type);
        if (this.excludeTags !== void 0) include = include && runTags.every((tag) => !this.excludeTags?.includes(tag));
        return include;
      }
      async *tapOutputIterable(runId, output) {
        for await (const chunk of output) {
          if (runId !== this.rootId) {
            const key = this.keyMapByRunId[runId];
            if (key) await this.writer.write(new RunLogPatch({ ops: [{
              op: "add",
              path: `/logs/${key}/streamed_output/-`,
              value: chunk
            }] }));
          }
          yield chunk;
        }
      }
      async onRunCreate(run) {
        if (this.rootId === void 0) {
          this.rootId = run.id;
          await this.writer.write(new RunLogPatch({ ops: [{
            op: "replace",
            path: "",
            value: {
              id: run.id,
              name: run.name,
              type: run.run_type,
              streamed_output: [],
              final_output: void 0,
              logs: {}
            }
          }] }));
        }
        if (!this._includeRun(run)) return;
        if (this.counterMapByRunName[run.name] === void 0) this.counterMapByRunName[run.name] = 0;
        this.counterMapByRunName[run.name] += 1;
        const count = this.counterMapByRunName[run.name];
        this.keyMapByRunId[run.id] = count === 1 ? run.name : `${run.name}:${count}`;
        const logEntry = {
          id: run.id,
          name: run.name,
          type: run.run_type,
          tags: run.tags ?? [],
          metadata: run.extra?.metadata ?? {},
          start_time: new Date(run.start_time).toISOString(),
          streamed_output: [],
          streamed_output_str: [],
          final_output: void 0,
          end_time: void 0
        };
        if (this._schemaFormat === "streaming_events") logEntry.inputs = await _getStandardizedInputs(run, this._schemaFormat);
        await this.writer.write(new RunLogPatch({ ops: [{
          op: "add",
          path: `/logs/${this.keyMapByRunId[run.id]}`,
          value: logEntry
        }] }));
      }
      async onRunUpdate(run) {
        try {
          const runName = this.keyMapByRunId[run.id];
          if (runName === void 0) return;
          const ops = [];
          if (this._schemaFormat === "streaming_events") ops.push({
            op: "replace",
            path: `/logs/${runName}/inputs`,
            value: await _getStandardizedInputs(run, this._schemaFormat)
          });
          ops.push({
            op: "add",
            path: `/logs/${runName}/final_output`,
            value: await _getStandardizedOutputs(run, this._schemaFormat)
          });
          if (run.end_time !== void 0) ops.push({
            op: "add",
            path: `/logs/${runName}/end_time`,
            value: new Date(run.end_time).toISOString()
          });
          const patch = new RunLogPatch({ ops });
          await this.writer.write(patch);
        } finally {
          if (run.id === this.rootId) {
            const patch = new RunLogPatch({ ops: [{
              op: "replace",
              path: "/final_output",
              value: await _getStandardizedOutputs(run, this._schemaFormat)
            }] });
            await this.writer.write(patch);
            if (this.autoClose) await this.writer.close();
          }
        }
      }
      async onLLMNewToken(run, token, kwargs) {
        const runName = this.keyMapByRunId[run.id];
        if (runName === void 0) return;
        const isChatModel = run.inputs.messages !== void 0;
        let streamedOutputValue;
        if (isChatModel) if (isChatGenerationChunk(kwargs?.chunk)) streamedOutputValue = kwargs?.chunk;
        else streamedOutputValue = new require_ai2.AIMessageChunk({
          id: `run-${run.id}`,
          content: token
        });
        else streamedOutputValue = token;
        const patch = new RunLogPatch({ ops: [{
          op: "add",
          path: `/logs/${runName}/streamed_output_str/-`,
          value: token
        }, {
          op: "add",
          path: `/logs/${runName}/streamed_output/-`,
          value: streamedOutputValue
        }] });
        await this.writer.write(patch);
      }
    };
    exports2.LogStreamCallbackHandler = LogStreamCallbackHandler;
    exports2.RunLog = RunLog;
    exports2.RunLogPatch = RunLogPatch;
    exports2.isLogStreamHandler = isLogStreamHandler;
    Object.defineProperty(exports2, "log_stream_exports", {
      enumerable: true,
      get: function() {
        return log_stream_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/outputs.cjs
var require_outputs = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/outputs.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var outputs_exports = {};
    require_rolldown_runtime5.__export(outputs_exports, {
      ChatGenerationChunk: () => ChatGenerationChunk,
      GenerationChunk: () => GenerationChunk,
      RUN_KEY: () => RUN_KEY
    });
    var RUN_KEY = "__run";
    var GenerationChunk = class GenerationChunk2 {
      text;
      generationInfo;
      constructor(fields) {
        this.text = fields.text;
        this.generationInfo = fields.generationInfo;
      }
      concat(chunk) {
        return new GenerationChunk2({
          text: this.text + chunk.text,
          generationInfo: {
            ...this.generationInfo,
            ...chunk.generationInfo
          }
        });
      }
    };
    var ChatGenerationChunk = class ChatGenerationChunk2 extends GenerationChunk {
      message;
      constructor(fields) {
        super(fields);
        this.message = fields.message;
      }
      concat(chunk) {
        return new ChatGenerationChunk2({
          text: this.text + chunk.text,
          generationInfo: {
            ...this.generationInfo,
            ...chunk.generationInfo
          },
          message: this.message.concat(chunk.message)
        });
      }
    };
    exports2.ChatGenerationChunk = ChatGenerationChunk;
    exports2.GenerationChunk = GenerationChunk;
    exports2.RUN_KEY = RUN_KEY;
    Object.defineProperty(exports2, "outputs_exports", {
      enumerable: true,
      get: function() {
        return outputs_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/tracers/event_stream.cjs
var require_event_stream = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/tracers/event_stream.cjs"(exports2) {
    var require_ai2 = require_ai();
    var require_tracers_base = require_base3();
    var require_utils_stream = require_stream();
    var require_outputs2 = require_outputs();
    function assignName({ name, serialized }) {
      if (name !== void 0) return name;
      if (serialized?.name !== void 0) return serialized.name;
      else if (serialized?.id !== void 0 && Array.isArray(serialized?.id)) return serialized.id[serialized.id.length - 1];
      return "Unnamed";
    }
    var isStreamEventsHandler = (handler) => handler.name === "event_stream_tracer";
    var EventStreamCallbackHandler = class extends require_tracers_base.BaseTracer {
      autoClose = true;
      includeNames;
      includeTypes;
      includeTags;
      excludeNames;
      excludeTypes;
      excludeTags;
      runInfoMap = /* @__PURE__ */ new Map();
      tappedPromises = /* @__PURE__ */ new Map();
      transformStream;
      writer;
      receiveStream;
      name = "event_stream_tracer";
      lc_prefer_streaming = true;
      constructor(fields) {
        super({
          _awaitHandler: true,
          ...fields
        });
        this.autoClose = fields?.autoClose ?? true;
        this.includeNames = fields?.includeNames;
        this.includeTypes = fields?.includeTypes;
        this.includeTags = fields?.includeTags;
        this.excludeNames = fields?.excludeNames;
        this.excludeTypes = fields?.excludeTypes;
        this.excludeTags = fields?.excludeTags;
        this.transformStream = new TransformStream();
        this.writer = this.transformStream.writable.getWriter();
        this.receiveStream = require_utils_stream.IterableReadableStream.fromReadableStream(this.transformStream.readable);
      }
      [Symbol.asyncIterator]() {
        return this.receiveStream;
      }
      async persistRun(_run) {
      }
      _includeRun(run) {
        const runTags = run.tags ?? [];
        let include = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
        if (this.includeNames !== void 0) include = include || this.includeNames.includes(run.name);
        if (this.includeTypes !== void 0) include = include || this.includeTypes.includes(run.runType);
        if (this.includeTags !== void 0) include = include || runTags.find((tag) => this.includeTags?.includes(tag)) !== void 0;
        if (this.excludeNames !== void 0) include = include && !this.excludeNames.includes(run.name);
        if (this.excludeTypes !== void 0) include = include && !this.excludeTypes.includes(run.runType);
        if (this.excludeTags !== void 0) include = include && runTags.every((tag) => !this.excludeTags?.includes(tag));
        return include;
      }
      async *tapOutputIterable(runId, outputStream) {
        const firstChunk = await outputStream.next();
        if (firstChunk.done) return;
        const runInfo = this.runInfoMap.get(runId);
        if (runInfo === void 0) {
          yield firstChunk.value;
          return;
        }
        function _formatOutputChunk(eventType, data) {
          if (eventType === "llm" && typeof data === "string") return new require_outputs2.GenerationChunk({ text: data });
          return data;
        }
        let tappedPromise = this.tappedPromises.get(runId);
        if (tappedPromise === void 0) {
          let tappedPromiseResolver;
          tappedPromise = new Promise((resolve) => {
            tappedPromiseResolver = resolve;
          });
          this.tappedPromises.set(runId, tappedPromise);
          try {
            const event = {
              event: `on_${runInfo.runType}_stream`,
              run_id: runId,
              name: runInfo.name,
              tags: runInfo.tags,
              metadata: runInfo.metadata,
              data: {}
            };
            await this.send({
              ...event,
              data: { chunk: _formatOutputChunk(runInfo.runType, firstChunk.value) }
            }, runInfo);
            yield firstChunk.value;
            for await (const chunk of outputStream) {
              if (runInfo.runType !== "tool" && runInfo.runType !== "retriever") await this.send({
                ...event,
                data: { chunk: _formatOutputChunk(runInfo.runType, chunk) }
              }, runInfo);
              yield chunk;
            }
          } finally {
            tappedPromiseResolver?.();
          }
        } else {
          yield firstChunk.value;
          for await (const chunk of outputStream) yield chunk;
        }
      }
      async send(payload, run) {
        if (this._includeRun(run)) await this.writer.write(payload);
      }
      async sendEndEvent(payload, run) {
        const tappedPromise = this.tappedPromises.get(payload.run_id);
        if (tappedPromise !== void 0) tappedPromise.then(() => {
          this.send(payload, run);
        });
        else await this.send(payload, run);
      }
      async onLLMStart(run) {
        const runName = assignName(run);
        const runType = run.inputs.messages !== void 0 ? "chat_model" : "llm";
        const runInfo = {
          tags: run.tags ?? [],
          metadata: run.extra?.metadata ?? {},
          name: runName,
          runType,
          inputs: run.inputs
        };
        this.runInfoMap.set(run.id, runInfo);
        const eventName = `on_${runType}_start`;
        await this.send({
          event: eventName,
          data: { input: run.inputs },
          name: runName,
          tags: run.tags ?? [],
          run_id: run.id,
          metadata: run.extra?.metadata ?? {}
        }, runInfo);
      }
      async onLLMNewToken(run, token, kwargs) {
        const runInfo = this.runInfoMap.get(run.id);
        let chunk;
        let eventName;
        if (runInfo === void 0) throw new Error(`onLLMNewToken: Run ID ${run.id} not found in run map.`);
        if (this.runInfoMap.size === 1) return;
        if (runInfo.runType === "chat_model") {
          eventName = "on_chat_model_stream";
          if (kwargs?.chunk === void 0) chunk = new require_ai2.AIMessageChunk({
            content: token,
            id: `run-${run.id}`
          });
          else chunk = kwargs.chunk.message;
        } else if (runInfo.runType === "llm") {
          eventName = "on_llm_stream";
          if (kwargs?.chunk === void 0) chunk = new require_outputs2.GenerationChunk({ text: token });
          else chunk = kwargs.chunk;
        } else throw new Error(`Unexpected run type ${runInfo.runType}`);
        await this.send({
          event: eventName,
          data: { chunk },
          run_id: run.id,
          name: runInfo.name,
          tags: runInfo.tags,
          metadata: runInfo.metadata
        }, runInfo);
      }
      async onLLMEnd(run) {
        const runInfo = this.runInfoMap.get(run.id);
        this.runInfoMap.delete(run.id);
        let eventName;
        if (runInfo === void 0) throw new Error(`onLLMEnd: Run ID ${run.id} not found in run map.`);
        const generations = run.outputs?.generations;
        let output;
        if (runInfo.runType === "chat_model") {
          for (const generation of generations ?? []) {
            if (output !== void 0) break;
            output = generation[0]?.message;
          }
          eventName = "on_chat_model_end";
        } else if (runInfo.runType === "llm") {
          output = {
            generations: generations?.map((generation) => {
              return generation.map((chunk) => {
                return {
                  text: chunk.text,
                  generationInfo: chunk.generationInfo
                };
              });
            }),
            llmOutput: run.outputs?.llmOutput ?? {}
          };
          eventName = "on_llm_end";
        } else throw new Error(`onLLMEnd: Unexpected run type: ${runInfo.runType}`);
        await this.sendEndEvent({
          event: eventName,
          data: {
            output,
            input: runInfo.inputs
          },
          run_id: run.id,
          name: runInfo.name,
          tags: runInfo.tags,
          metadata: runInfo.metadata
        }, runInfo);
      }
      async onChainStart(run) {
        const runName = assignName(run);
        const runType = run.run_type ?? "chain";
        const runInfo = {
          tags: run.tags ?? [],
          metadata: run.extra?.metadata ?? {},
          name: runName,
          runType: run.run_type
        };
        let eventData = {};
        if (run.inputs.input === "" && Object.keys(run.inputs).length === 1) {
          eventData = {};
          runInfo.inputs = {};
        } else if (run.inputs.input !== void 0) {
          eventData.input = run.inputs.input;
          runInfo.inputs = run.inputs.input;
        } else {
          eventData.input = run.inputs;
          runInfo.inputs = run.inputs;
        }
        this.runInfoMap.set(run.id, runInfo);
        await this.send({
          event: `on_${runType}_start`,
          data: eventData,
          name: runName,
          tags: run.tags ?? [],
          run_id: run.id,
          metadata: run.extra?.metadata ?? {}
        }, runInfo);
      }
      async onChainEnd(run) {
        const runInfo = this.runInfoMap.get(run.id);
        this.runInfoMap.delete(run.id);
        if (runInfo === void 0) throw new Error(`onChainEnd: Run ID ${run.id} not found in run map.`);
        const eventName = `on_${run.run_type}_end`;
        const inputs = run.inputs ?? runInfo.inputs ?? {};
        const outputs = run.outputs?.output ?? run.outputs;
        const data = {
          output: outputs,
          input: inputs
        };
        if (inputs.input && Object.keys(inputs).length === 1) {
          data.input = inputs.input;
          runInfo.inputs = inputs.input;
        }
        await this.sendEndEvent({
          event: eventName,
          data,
          run_id: run.id,
          name: runInfo.name,
          tags: runInfo.tags,
          metadata: runInfo.metadata ?? {}
        }, runInfo);
      }
      async onToolStart(run) {
        const runName = assignName(run);
        const runInfo = {
          tags: run.tags ?? [],
          metadata: run.extra?.metadata ?? {},
          name: runName,
          runType: "tool",
          inputs: run.inputs ?? {}
        };
        this.runInfoMap.set(run.id, runInfo);
        await this.send({
          event: "on_tool_start",
          data: { input: run.inputs ?? {} },
          name: runName,
          run_id: run.id,
          tags: run.tags ?? [],
          metadata: run.extra?.metadata ?? {}
        }, runInfo);
      }
      async onToolEnd(run) {
        const runInfo = this.runInfoMap.get(run.id);
        this.runInfoMap.delete(run.id);
        if (runInfo === void 0) throw new Error(`onToolEnd: Run ID ${run.id} not found in run map.`);
        if (runInfo.inputs === void 0) throw new Error(`onToolEnd: Run ID ${run.id} is a tool call, and is expected to have traced inputs.`);
        const output = run.outputs?.output === void 0 ? run.outputs : run.outputs.output;
        await this.sendEndEvent({
          event: "on_tool_end",
          data: {
            output,
            input: runInfo.inputs
          },
          run_id: run.id,
          name: runInfo.name,
          tags: runInfo.tags,
          metadata: runInfo.metadata
        }, runInfo);
      }
      async onRetrieverStart(run) {
        const runName = assignName(run);
        const runType = "retriever";
        const runInfo = {
          tags: run.tags ?? [],
          metadata: run.extra?.metadata ?? {},
          name: runName,
          runType,
          inputs: { query: run.inputs.query }
        };
        this.runInfoMap.set(run.id, runInfo);
        await this.send({
          event: "on_retriever_start",
          data: { input: { query: run.inputs.query } },
          name: runName,
          tags: run.tags ?? [],
          run_id: run.id,
          metadata: run.extra?.metadata ?? {}
        }, runInfo);
      }
      async onRetrieverEnd(run) {
        const runInfo = this.runInfoMap.get(run.id);
        this.runInfoMap.delete(run.id);
        if (runInfo === void 0) throw new Error(`onRetrieverEnd: Run ID ${run.id} not found in run map.`);
        await this.sendEndEvent({
          event: "on_retriever_end",
          data: {
            output: run.outputs?.documents ?? run.outputs,
            input: runInfo.inputs
          },
          run_id: run.id,
          name: runInfo.name,
          tags: runInfo.tags,
          metadata: runInfo.metadata
        }, runInfo);
      }
      async handleCustomEvent(eventName, data, runId) {
        const runInfo = this.runInfoMap.get(runId);
        if (runInfo === void 0) throw new Error(`handleCustomEvent: Run ID ${runId} not found in run map.`);
        await this.send({
          event: "on_custom_event",
          run_id: runId,
          name: eventName,
          tags: runInfo.tags,
          metadata: runInfo.metadata,
          data
        }, runInfo);
      }
      async finish() {
        const pendingPromises = [...this.tappedPromises.values()];
        Promise.all(pendingPromises).finally(() => {
          this.writer.close();
        });
      }
    };
    exports2.EventStreamCallbackHandler = EventStreamCallbackHandler;
    exports2.isStreamEventsHandler = isStreamEventsHandler;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/tracers/root_listener.cjs
var require_root_listener = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/tracers/root_listener.cjs"(exports2) {
    var require_tracers_base = require_base3();
    var RootListenersTracer = class extends require_tracers_base.BaseTracer {
      name = "RootListenersTracer";
      /** The Run's ID. Type UUID */
      rootId;
      config;
      argOnStart;
      argOnEnd;
      argOnError;
      constructor({ config, onStart, onEnd, onError }) {
        super({ _awaitHandler: true });
        this.config = config;
        this.argOnStart = onStart;
        this.argOnEnd = onEnd;
        this.argOnError = onError;
      }
      /**
      * This is a legacy method only called once for an entire run tree
      * therefore not useful here
      * @param {Run} _ Not used
      */
      persistRun(_) {
        return Promise.resolve();
      }
      async onRunCreate(run) {
        if (this.rootId) return;
        this.rootId = run.id;
        if (this.argOnStart) await this.argOnStart(run, this.config);
      }
      async onRunUpdate(run) {
        if (run.id !== this.rootId) return;
        if (!run.error) {
          if (this.argOnEnd) await this.argOnEnd(run, this.config);
        } else if (this.argOnError) await this.argOnError(run, this.config);
      }
    };
    exports2.RootListenersTracer = RootListenersTracer;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/utils.cjs
var require_utils4 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/utils.cjs"(exports2) {
    function isRunnableInterface(thing) {
      return thing ? thing.lc_runnable : false;
    }
    var _RootEventFilter = class {
      includeNames;
      includeTypes;
      includeTags;
      excludeNames;
      excludeTypes;
      excludeTags;
      constructor(fields) {
        this.includeNames = fields.includeNames;
        this.includeTypes = fields.includeTypes;
        this.includeTags = fields.includeTags;
        this.excludeNames = fields.excludeNames;
        this.excludeTypes = fields.excludeTypes;
        this.excludeTags = fields.excludeTags;
      }
      includeEvent(event, rootType) {
        let include = this.includeNames === void 0 && this.includeTypes === void 0 && this.includeTags === void 0;
        const eventTags = event.tags ?? [];
        if (this.includeNames !== void 0) include = include || this.includeNames.includes(event.name);
        if (this.includeTypes !== void 0) include = include || this.includeTypes.includes(rootType);
        if (this.includeTags !== void 0) include = include || eventTags.some((tag) => this.includeTags?.includes(tag));
        if (this.excludeNames !== void 0) include = include && !this.excludeNames.includes(event.name);
        if (this.excludeTypes !== void 0) include = include && !this.excludeTypes.includes(rootType);
        if (this.excludeTags !== void 0) include = include && eventTags.every((tag) => !this.excludeTags?.includes(tag));
        return include;
      }
    };
    exports2._RootEventFilter = _RootEventFilter;
    exports2.isRunnableInterface = isRunnableInterface;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/graph_mermaid.cjs
var require_graph_mermaid = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/graph_mermaid.cjs"(exports2) {
    function _escapeNodeLabel(nodeLabel) {
      return nodeLabel.replace(/[^a-zA-Z-_0-9]/g, "_");
    }
    var MARKDOWN_SPECIAL_CHARS = [
      "*",
      "_",
      "`"
    ];
    function _generateMermaidGraphStyles(nodeColors) {
      let styles = "";
      for (const [className, color] of Object.entries(nodeColors)) styles += `	classDef ${className} ${color};
`;
      return styles;
    }
    function drawMermaid(nodes, edges, config) {
      const { firstNode, lastNode, nodeColors, withStyles = true, curveStyle = "linear", wrapLabelNWords = 9 } = config ?? {};
      let mermaidGraph = withStyles ? `%%{init: {'flowchart': {'curve': '${curveStyle}'}}}%%
graph TD;
` : "graph TD;\n";
      if (withStyles) {
        const defaultClassLabel = "default";
        const formatDict = { [defaultClassLabel]: "{0}({1})" };
        if (firstNode !== void 0) formatDict[firstNode] = "{0}([{1}]):::first";
        if (lastNode !== void 0) formatDict[lastNode] = "{0}([{1}]):::last";
        for (const [key, node] of Object.entries(nodes)) {
          const nodeName = node.name.split(":").pop() ?? "";
          const label = MARKDOWN_SPECIAL_CHARS.some((char) => nodeName.startsWith(char) && nodeName.endsWith(char)) ? `<p>${nodeName}</p>` : nodeName;
          let finalLabel = label;
          if (Object.keys(node.metadata ?? {}).length) finalLabel += `<hr/><small><em>${Object.entries(node.metadata ?? {}).map(([k, v]) => `${k} = ${v}`).join("\n")}</em></small>`;
          const nodeLabel = (formatDict[key] ?? formatDict[defaultClassLabel]).replace("{0}", _escapeNodeLabel(key)).replace("{1}", finalLabel);
          mermaidGraph += `	${nodeLabel}
`;
        }
      }
      const edgeGroups = {};
      for (const edge of edges) {
        const srcParts = edge.source.split(":");
        const tgtParts = edge.target.split(":");
        const commonPrefix = srcParts.filter((src, i) => src === tgtParts[i]).join(":");
        if (!edgeGroups[commonPrefix]) edgeGroups[commonPrefix] = [];
        edgeGroups[commonPrefix].push(edge);
      }
      const seenSubgraphs = /* @__PURE__ */ new Set();
      function addSubgraph(edges$1, prefix) {
        const selfLoop = edges$1.length === 1 && edges$1[0].source === edges$1[0].target;
        if (prefix && !selfLoop) {
          const subgraph = prefix.split(":").pop();
          if (seenSubgraphs.has(subgraph)) throw new Error(`Found duplicate subgraph '${subgraph}' -- this likely means that you're reusing a subgraph node with the same name. Please adjust your graph to have subgraph nodes with unique names.`);
          seenSubgraphs.add(subgraph);
          mermaidGraph += `	subgraph ${subgraph}
`;
        }
        for (const edge of edges$1) {
          const { source, target, data, conditional } = edge;
          let edgeLabel = "";
          if (data !== void 0) {
            let edgeData = data;
            const words = edgeData.split(" ");
            if (words.length > wrapLabelNWords) edgeData = Array.from({ length: Math.ceil(words.length / wrapLabelNWords) }, (_, i) => words.slice(i * wrapLabelNWords, (i + 1) * wrapLabelNWords).join(" ")).join("&nbsp;<br>&nbsp;");
            edgeLabel = conditional ? ` -. &nbsp;${edgeData}&nbsp; .-> ` : ` -- &nbsp;${edgeData}&nbsp; --> `;
          } else edgeLabel = conditional ? " -.-> " : " --> ";
          mermaidGraph += `	${_escapeNodeLabel(source)}${edgeLabel}${_escapeNodeLabel(target)};
`;
        }
        for (const nestedPrefix in edgeGroups) if (nestedPrefix.startsWith(`${prefix}:`) && nestedPrefix !== prefix) addSubgraph(edgeGroups[nestedPrefix], nestedPrefix);
        if (prefix && !selfLoop) mermaidGraph += "	end\n";
      }
      addSubgraph(edgeGroups[""] ?? [], "");
      for (const prefix in edgeGroups) if (!prefix.includes(":") && prefix !== "") addSubgraph(edgeGroups[prefix], prefix);
      if (withStyles) mermaidGraph += _generateMermaidGraphStyles(nodeColors ?? {});
      return mermaidGraph;
    }
    async function drawMermaidImage(mermaidSyntax, config) {
      let backgroundColor = config?.backgroundColor ?? "white";
      const imageType = config?.imageType ?? "png";
      const mermaidSyntaxEncoded = btoa(mermaidSyntax);
      if (backgroundColor !== void 0) {
        const hexColorPattern = /^#(?:[0-9a-fA-F]{3}){1,2}$/;
        if (!hexColorPattern.test(backgroundColor)) backgroundColor = `!${backgroundColor}`;
      }
      const imageUrl = `https://mermaid.ink/img/${mermaidSyntaxEncoded}?bgColor=${backgroundColor}&type=${imageType}`;
      const res = await fetch(imageUrl);
      if (!res.ok) throw new Error([
        `Failed to render the graph using the Mermaid.INK API.`,
        `Status code: ${res.status}`,
        `Status text: ${res.statusText}`
      ].join("\n"));
      const content = await res.blob();
      return content;
    }
    exports2.drawMermaid = drawMermaid;
    exports2.drawMermaidImage = drawMermaidImage;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/graph.cjs
var require_graph = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/graph.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_utils10 = require_utils4();
    var require_graph_mermaid2 = require_graph_mermaid();
    var require_utils_json_schema = require_json_schema2();
    var uuid = require_rolldown_runtime5.__toESM((init_esm_node(), __toCommonJS(esm_node_exports)));
    var graph_exports = {};
    require_rolldown_runtime5.__export(graph_exports, { Graph: () => Graph });
    function nodeDataStr(id, data) {
      if (id !== void 0 && !(0, uuid.validate)(id)) return id;
      else if (require_utils10.isRunnableInterface(data)) try {
        let dataStr = data.getName();
        dataStr = dataStr.startsWith("Runnable") ? dataStr.slice(8) : dataStr;
        return dataStr;
      } catch {
        return data.getName();
      }
      else return data.name ?? "UnknownSchema";
    }
    function nodeDataJson(node) {
      if (require_utils10.isRunnableInterface(node.data)) return {
        type: "runnable",
        data: {
          id: node.data.lc_id,
          name: node.data.getName()
        }
      };
      else return {
        type: "schema",
        data: {
          ...require_utils_json_schema.toJsonSchema(node.data.schema),
          title: node.data.name
        }
      };
    }
    var Graph = class Graph2 {
      nodes = {};
      edges = [];
      constructor(params) {
        this.nodes = params?.nodes ?? this.nodes;
        this.edges = params?.edges ?? this.edges;
      }
      toJSON() {
        const stableNodeIds = {};
        Object.values(this.nodes).forEach((node, i) => {
          stableNodeIds[node.id] = (0, uuid.validate)(node.id) ? i : node.id;
        });
        return {
          nodes: Object.values(this.nodes).map((node) => ({
            id: stableNodeIds[node.id],
            ...nodeDataJson(node)
          })),
          edges: this.edges.map((edge) => {
            const item = {
              source: stableNodeIds[edge.source],
              target: stableNodeIds[edge.target]
            };
            if (typeof edge.data !== "undefined") item.data = edge.data;
            if (typeof edge.conditional !== "undefined") item.conditional = edge.conditional;
            return item;
          })
        };
      }
      addNode(data, id, metadata) {
        if (id !== void 0 && this.nodes[id] !== void 0) throw new Error(`Node with id ${id} already exists`);
        const nodeId = id ?? (0, uuid.v4)();
        const node = {
          id: nodeId,
          data,
          name: nodeDataStr(id, data),
          metadata
        };
        this.nodes[nodeId] = node;
        return node;
      }
      removeNode(node) {
        delete this.nodes[node.id];
        this.edges = this.edges.filter((edge) => edge.source !== node.id && edge.target !== node.id);
      }
      addEdge(source, target, data, conditional) {
        if (this.nodes[source.id] === void 0) throw new Error(`Source node ${source.id} not in graph`);
        if (this.nodes[target.id] === void 0) throw new Error(`Target node ${target.id} not in graph`);
        const edge = {
          source: source.id,
          target: target.id,
          data,
          conditional
        };
        this.edges.push(edge);
        return edge;
      }
      firstNode() {
        return _firstNode(this);
      }
      lastNode() {
        return _lastNode(this);
      }
      /**
      * Add all nodes and edges from another graph.
      * Note this doesn't check for duplicates, nor does it connect the graphs.
      */
      extend(graph, prefix = "") {
        let finalPrefix = prefix;
        const nodeIds = Object.values(graph.nodes).map((node) => node.id);
        if (nodeIds.every(uuid.validate)) finalPrefix = "";
        const prefixed = (id) => {
          return finalPrefix ? `${finalPrefix}:${id}` : id;
        };
        Object.entries(graph.nodes).forEach(([key, value]) => {
          this.nodes[prefixed(key)] = {
            ...value,
            id: prefixed(key)
          };
        });
        const newEdges = graph.edges.map((edge) => {
          return {
            ...edge,
            source: prefixed(edge.source),
            target: prefixed(edge.target)
          };
        });
        this.edges = [...this.edges, ...newEdges];
        const first = graph.firstNode();
        const last = graph.lastNode();
        return [first ? {
          id: prefixed(first.id),
          data: first.data
        } : void 0, last ? {
          id: prefixed(last.id),
          data: last.data
        } : void 0];
      }
      trimFirstNode() {
        const firstNode = this.firstNode();
        if (firstNode && _firstNode(this, [firstNode.id])) this.removeNode(firstNode);
      }
      trimLastNode() {
        const lastNode = this.lastNode();
        if (lastNode && _lastNode(this, [lastNode.id])) this.removeNode(lastNode);
      }
      /**
      * Return a new graph with all nodes re-identified,
      * using their unique, readable names where possible.
      */
      reid() {
        const nodeLabels = Object.fromEntries(Object.values(this.nodes).map((node) => [node.id, node.name]));
        const nodeLabelCounts = /* @__PURE__ */ new Map();
        Object.values(nodeLabels).forEach((label) => {
          nodeLabelCounts.set(label, (nodeLabelCounts.get(label) || 0) + 1);
        });
        const getNodeId = (nodeId) => {
          const label = nodeLabels[nodeId];
          if ((0, uuid.validate)(nodeId) && nodeLabelCounts.get(label) === 1) return label;
          else return nodeId;
        };
        return new Graph2({
          nodes: Object.fromEntries(Object.entries(this.nodes).map(([id, node]) => [getNodeId(id), {
            ...node,
            id: getNodeId(id)
          }])),
          edges: this.edges.map((edge) => ({
            ...edge,
            source: getNodeId(edge.source),
            target: getNodeId(edge.target)
          }))
        });
      }
      drawMermaid(params) {
        const { withStyles, curveStyle, nodeColors = {
          default: "fill:#f2f0ff,line-height:1.2",
          first: "fill-opacity:0",
          last: "fill:#bfb6fc"
        }, wrapLabelNWords } = params ?? {};
        const graph = this.reid();
        const firstNode = graph.firstNode();
        const lastNode = graph.lastNode();
        return require_graph_mermaid2.drawMermaid(graph.nodes, graph.edges, {
          firstNode: firstNode?.id,
          lastNode: lastNode?.id,
          withStyles,
          curveStyle,
          nodeColors,
          wrapLabelNWords
        });
      }
      async drawMermaidPng(params) {
        const mermaidSyntax = this.drawMermaid(params);
        return require_graph_mermaid2.drawMermaidImage(mermaidSyntax, { backgroundColor: params?.backgroundColor });
      }
    };
    function _firstNode(graph, exclude = []) {
      const targets = new Set(graph.edges.filter((edge) => !exclude.includes(edge.source)).map((edge) => edge.target));
      const found = [];
      for (const node of Object.values(graph.nodes)) if (!exclude.includes(node.id) && !targets.has(node.id)) found.push(node);
      return found.length === 1 ? found[0] : void 0;
    }
    function _lastNode(graph, exclude = []) {
      const sources = new Set(graph.edges.filter((edge) => !exclude.includes(edge.target)).map((edge) => edge.source));
      const found = [];
      for (const node of Object.values(graph.nodes)) if (!exclude.includes(node.id) && !sources.has(node.id)) found.push(node);
      return found.length === 1 ? found[0] : void 0;
    }
    exports2.Graph = Graph;
    Object.defineProperty(exports2, "graph_exports", {
      enumerable: true,
      get: function() {
        return graph_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/wrappers.cjs
var require_wrappers = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/wrappers.cjs"(exports2) {
    var require_utils_stream = require_stream();
    function convertToHttpEventStream(stream) {
      const encoder = new TextEncoder();
      const finalStream = new ReadableStream({ async start(controller) {
        for await (const chunk of stream) controller.enqueue(encoder.encode(`event: data
data: ${JSON.stringify(chunk)}

`));
        controller.enqueue(encoder.encode("event: end\n\n"));
        controller.close();
      } });
      return require_utils_stream.IterableReadableStream.fromReadableStream(finalStream);
    }
    exports2.convertToHttpEventStream = convertToHttpEventStream;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/iter.cjs
var require_iter = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/iter.cjs"(exports2) {
    var require_index = require_async_local_storage();
    require_singletons();
    var require_config3 = require_config();
    function isIterableIterator(thing) {
      return typeof thing === "object" && thing !== null && typeof thing[Symbol.iterator] === "function" && typeof thing.next === "function";
    }
    var isIterator = (x) => x != null && typeof x === "object" && "next" in x && typeof x.next === "function";
    function isAsyncIterable(thing) {
      return typeof thing === "object" && thing !== null && typeof thing[Symbol.asyncIterator] === "function";
    }
    function* consumeIteratorInContext(context, iter) {
      while (true) {
        const { value, done } = require_index.AsyncLocalStorageProviderSingleton.runWithConfig(require_config3.pickRunnableConfigKeys(context), iter.next.bind(iter), true);
        if (done) break;
        else yield value;
      }
    }
    async function* consumeAsyncIterableInContext(context, iter) {
      const iterator = iter[Symbol.asyncIterator]();
      while (true) {
        const { value, done } = await require_index.AsyncLocalStorageProviderSingleton.runWithConfig(require_config3.pickRunnableConfigKeys(context), iterator.next.bind(iter), true);
        if (done) break;
        else yield value;
      }
    }
    exports2.consumeAsyncIterableInContext = consumeAsyncIterableInContext;
    exports2.consumeIteratorInContext = consumeIteratorInContext;
    exports2.isAsyncIterable = isAsyncIterable;
    exports2.isIterableIterator = isIterableIterator;
    exports2.isIterator = isIterator;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/base.cjs
var require_base4 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/base.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_load_serializable = require_serializable();
    var require_utils10 = require_utils2();
    var require_index = require_async_local_storage();
    require_singletons();
    var require_config3 = require_config();
    var require_signal2 = require_signal();
    var require_utils_stream = require_stream();
    var require_tracers_log_stream = require_log_stream();
    var require_event_stream2 = require_event_stream();
    var require_utils_async_caller = require_async_caller2();
    var require_root_listener2 = require_root_listener();
    var require_utils$1 = require_utils4();
    var require_zod3 = require_zod();
    var require_runnables_graph = require_graph();
    var require_wrappers2 = require_wrappers();
    var require_iter2 = require_iter();
    var zod_v3 = require_rolldown_runtime5.__toESM(require_v3());
    var p_retry = require_rolldown_runtime5.__toESM(require_p_retry());
    var uuid = require_rolldown_runtime5.__toESM((init_esm_node(), __toCommonJS(esm_node_exports)));
    var langsmith_singletons_traceable = require_rolldown_runtime5.__toESM(require_traceable2());
    function _coerceToDict(value, defaultKey) {
      return value && !Array.isArray(value) && !(value instanceof Date) && typeof value === "object" ? value : { [defaultKey]: value };
    }
    var Runnable = class extends require_load_serializable.Serializable {
      lc_runnable = true;
      name;
      getName(suffix) {
        const name = this.name ?? this.constructor.lc_name() ?? this.constructor.name;
        return suffix ? `${name}${suffix}` : name;
      }
      /**
      * Add retry logic to an existing runnable.
      * @param fields.stopAfterAttempt The number of attempts to retry.
      * @param fields.onFailedAttempt A function that is called when a retry fails.
      * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.
      */
      withRetry(fields) {
        return new RunnableRetry({
          bound: this,
          kwargs: {},
          config: {},
          maxAttemptNumber: fields?.stopAfterAttempt,
          ...fields
        });
      }
      /**
      * Bind config to a Runnable, returning a new Runnable.
      * @param config New configuration parameters to attach to the new runnable.
      * @returns A new RunnableBinding with a config matching what's passed.
      */
      withConfig(config) {
        return new RunnableBinding({
          bound: this,
          config,
          kwargs: {}
        });
      }
      /**
      * Create a new runnable from the current one that will try invoking
      * other passed fallback runnables if the initial invocation fails.
      * @param fields.fallbacks Other runnables to call if the runnable errors.
      * @returns A new RunnableWithFallbacks.
      */
      withFallbacks(fields) {
        const fallbacks = Array.isArray(fields) ? fields : fields.fallbacks;
        return new RunnableWithFallbacks({
          runnable: this,
          fallbacks
        });
      }
      _getOptionsList(options, length = 0) {
        if (Array.isArray(options) && options.length !== length) throw new Error(`Passed "options" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);
        if (Array.isArray(options)) return options.map(require_config3.ensureConfig);
        if (length > 1 && !Array.isArray(options) && options.runId) {
          console.warn("Provided runId will be used only for the first element of the batch.");
          const subsequent = Object.fromEntries(Object.entries(options).filter(([key]) => key !== "runId"));
          return Array.from({ length }, (_, i) => require_config3.ensureConfig(i === 0 ? options : subsequent));
        }
        return Array.from({ length }, () => require_config3.ensureConfig(options));
      }
      async batch(inputs, options, batchOptions) {
        const configList = this._getOptionsList(options ?? {}, inputs.length);
        const maxConcurrency = configList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;
        const caller = new require_utils_async_caller.AsyncCaller({
          maxConcurrency,
          onFailedAttempt: (e) => {
            throw e;
          }
        });
        const batchCalls = inputs.map((input, i) => caller.call(async () => {
          try {
            const result = await this.invoke(input, configList[i]);
            return result;
          } catch (e) {
            if (batchOptions?.returnExceptions) return e;
            throw e;
          }
        }));
        return Promise.all(batchCalls);
      }
      /**
      * Default streaming implementation.
      * Subclasses should override this method if they support streaming output.
      * @param input
      * @param options
      */
      async *_streamIterator(input, options) {
        yield this.invoke(input, options);
      }
      /**
      * Stream output in chunks.
      * @param input
      * @param options
      * @returns A readable stream that is also an iterable.
      */
      async stream(input, options) {
        const config = require_config3.ensureConfig(options);
        const wrappedGenerator = new require_utils_stream.AsyncGeneratorWithSetup({
          generator: this._streamIterator(input, config),
          config
        });
        await wrappedGenerator.setup;
        return require_utils_stream.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
      }
      _separateRunnableConfigFromCallOptions(options) {
        let runnableConfig;
        if (options === void 0) runnableConfig = require_config3.ensureConfig(options);
        else runnableConfig = require_config3.ensureConfig({
          callbacks: options.callbacks,
          tags: options.tags,
          metadata: options.metadata,
          runName: options.runName,
          configurable: options.configurable,
          recursionLimit: options.recursionLimit,
          maxConcurrency: options.maxConcurrency,
          runId: options.runId,
          timeout: options.timeout,
          signal: options.signal
        });
        const callOptions = { ...options };
        delete callOptions.callbacks;
        delete callOptions.tags;
        delete callOptions.metadata;
        delete callOptions.runName;
        delete callOptions.configurable;
        delete callOptions.recursionLimit;
        delete callOptions.maxConcurrency;
        delete callOptions.runId;
        delete callOptions.timeout;
        delete callOptions.signal;
        return [runnableConfig, callOptions];
      }
      async _callWithConfig(func, input, options) {
        const config = require_config3.ensureConfig(options);
        const callbackManager_ = await require_config3.getCallbackManagerForConfig(config);
        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), config.runId, config?.runType, void 0, void 0, config?.runName ?? this.getName());
        delete config.runId;
        let output;
        try {
          const promise = func.call(this, input, config, runManager);
          output = await require_signal2.raceWithSignal(promise, options?.signal);
        } catch (e) {
          await runManager?.handleChainError(e);
          throw e;
        }
        await runManager?.handleChainEnd(_coerceToDict(output, "output"));
        return output;
      }
      /**
      * Internal method that handles batching and configuration for a runnable
      * It takes a function, input values, and optional configuration, and
      * returns a promise that resolves to the output values.
      * @param func The function to be executed for each input value.
      * @param input The input values to be processed.
      * @param config Optional configuration for the function execution.
      * @returns A promise that resolves to the output values.
      */
      async _batchWithConfig(func, inputs, options, batchOptions) {
        const optionsList = this._getOptionsList(options ?? {}, inputs.length);
        const callbackManagers = await Promise.all(optionsList.map(require_config3.getCallbackManagerForConfig));
        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {
          const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], "input"), optionsList[i].runId, optionsList[i].runType, void 0, void 0, optionsList[i].runName ?? this.getName());
          delete optionsList[i].runId;
          return handleStartRes;
        }));
        let outputs;
        try {
          const promise = func.call(this, inputs, optionsList, runManagers, batchOptions);
          outputs = await require_signal2.raceWithSignal(promise, optionsList?.[0]?.signal);
        } catch (e) {
          await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));
          throw e;
        }
        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(outputs, "output"))));
        return outputs;
      }
      /** @internal */
      _concatOutputChunks(first, second) {
        return require_utils_stream.concat(first, second);
      }
      /**
      * Helper method to transform an Iterator of Input values into an Iterator of
      * Output values, with callbacks.
      * Use this to implement `stream()` or `transform()` in Runnable subclasses.
      */
      async *_transformStreamWithConfig(inputGenerator, transformer, options) {
        let finalInput;
        let finalInputSupported = true;
        let finalOutput;
        let finalOutputSupported = true;
        const config = require_config3.ensureConfig(options);
        const callbackManager_ = await require_config3.getCallbackManagerForConfig(config);
        const outerThis = this;
        async function* wrapInputForTracing() {
          for await (const chunk of inputGenerator) {
            if (finalInputSupported) if (finalInput === void 0) finalInput = chunk;
            else try {
              finalInput = outerThis._concatOutputChunks(finalInput, chunk);
            } catch {
              finalInput = void 0;
              finalInputSupported = false;
            }
            yield chunk;
          }
        }
        let runManager;
        try {
          const pipe = await require_utils_stream.pipeGeneratorWithSetup(transformer.bind(this), wrapInputForTracing(), async () => callbackManager_?.handleChainStart(this.toJSON(), { input: "" }, config.runId, config.runType, void 0, void 0, config.runName ?? this.getName()), options?.signal, config);
          delete config.runId;
          runManager = pipe.setup;
          const streamEventsHandler = runManager?.handlers.find(require_event_stream2.isStreamEventsHandler);
          let iterator = pipe.output;
          if (streamEventsHandler !== void 0 && runManager !== void 0) iterator = streamEventsHandler.tapOutputIterable(runManager.runId, iterator);
          const streamLogHandler = runManager?.handlers.find(require_tracers_log_stream.isLogStreamHandler);
          if (streamLogHandler !== void 0 && runManager !== void 0) iterator = streamLogHandler.tapOutputIterable(runManager.runId, iterator);
          for await (const chunk of iterator) {
            yield chunk;
            if (finalOutputSupported) if (finalOutput === void 0) finalOutput = chunk;
            else try {
              finalOutput = this._concatOutputChunks(finalOutput, chunk);
            } catch {
              finalOutput = void 0;
              finalOutputSupported = false;
            }
          }
        } catch (e) {
          await runManager?.handleChainError(e, void 0, void 0, void 0, { inputs: _coerceToDict(finalInput, "input") });
          throw e;
        }
        await runManager?.handleChainEnd(finalOutput ?? {}, void 0, void 0, void 0, { inputs: _coerceToDict(finalInput, "input") });
      }
      getGraph(_) {
        const graph = new require_runnables_graph.Graph();
        const inputNode = graph.addNode({
          name: `${this.getName()}Input`,
          schema: zod_v3.z.any()
        });
        const runnableNode = graph.addNode(this);
        const outputNode = graph.addNode({
          name: `${this.getName()}Output`,
          schema: zod_v3.z.any()
        });
        graph.addEdge(inputNode, runnableNode);
        graph.addEdge(runnableNode, outputNode);
        return graph;
      }
      /**
      * Create a new runnable sequence that runs each individual runnable in series,
      * piping the output of one runnable into another runnable or runnable-like.
      * @param coerceable A runnable, function, or object whose values are functions or runnables.
      * @returns A new runnable sequence.
      */
      pipe(coerceable) {
        return new RunnableSequence({
          first: this,
          last: _coerceToRunnable(coerceable)
        });
      }
      /**
      * Pick keys from the dict output of this runnable. Returns a new runnable.
      */
      pick(keys) {
        return this.pipe(new RunnablePick(keys));
      }
      /**
      * Assigns new fields to the dict output of this runnable. Returns a new runnable.
      */
      assign(mapping) {
        return this.pipe(new RunnableAssign(new RunnableMap({ steps: mapping })));
      }
      /**
      * Default implementation of transform, which buffers input and then calls stream.
      * Subclasses should override this method if they can start producing output while
      * input is still being generated.
      * @param generator
      * @param options
      */
      async *transform(generator, options) {
        let finalChunk;
        for await (const chunk of generator) if (finalChunk === void 0) finalChunk = chunk;
        else finalChunk = this._concatOutputChunks(finalChunk, chunk);
        yield* this._streamIterator(finalChunk, require_config3.ensureConfig(options));
      }
      /**
      * Stream all output from a runnable, as reported to the callback system.
      * This includes all inner runs of LLMs, Retrievers, Tools, etc.
      * Output is streamed as Log objects, which include a list of
      * jsonpatch ops that describe how the state of the run has changed in each
      * step, and the final state of the run.
      * The jsonpatch ops can be applied in order to construct state.
      * @param input
      * @param options
      * @param streamOptions
      */
      async *streamLog(input, options, streamOptions) {
        const logStreamCallbackHandler = new require_tracers_log_stream.LogStreamCallbackHandler({
          ...streamOptions,
          autoClose: false,
          _schemaFormat: "original"
        });
        const config = require_config3.ensureConfig(options);
        yield* this._streamLog(input, logStreamCallbackHandler, config);
      }
      async *_streamLog(input, logStreamCallbackHandler, config) {
        const { callbacks } = config;
        if (callbacks === void 0) config.callbacks = [logStreamCallbackHandler];
        else if (Array.isArray(callbacks)) config.callbacks = callbacks.concat([logStreamCallbackHandler]);
        else {
          const copiedCallbacks = callbacks.copy();
          copiedCallbacks.addHandler(logStreamCallbackHandler, true);
          config.callbacks = copiedCallbacks;
        }
        const runnableStreamPromise = this.stream(input, config);
        async function consumeRunnableStream() {
          try {
            const runnableStream = await runnableStreamPromise;
            for await (const chunk of runnableStream) {
              const patch = new require_tracers_log_stream.RunLogPatch({ ops: [{
                op: "add",
                path: "/streamed_output/-",
                value: chunk
              }] });
              await logStreamCallbackHandler.writer.write(patch);
            }
          } finally {
            await logStreamCallbackHandler.writer.close();
          }
        }
        const runnableStreamConsumePromise = consumeRunnableStream();
        try {
          for await (const log of logStreamCallbackHandler) yield log;
        } finally {
          await runnableStreamConsumePromise;
        }
      }
      streamEvents(input, options, streamOptions) {
        let stream;
        if (options.version === "v1") stream = this._streamEventsV1(input, options, streamOptions);
        else if (options.version === "v2") stream = this._streamEventsV2(input, options, streamOptions);
        else throw new Error(`Only versions "v1" and "v2" of the schema are currently supported.`);
        if (options.encoding === "text/event-stream") return require_wrappers2.convertToHttpEventStream(stream);
        else return require_utils_stream.IterableReadableStream.fromAsyncGenerator(stream);
      }
      async *_streamEventsV2(input, options, streamOptions) {
        const eventStreamer = new require_event_stream2.EventStreamCallbackHandler({
          ...streamOptions,
          autoClose: false
        });
        const config = require_config3.ensureConfig(options);
        const runId = config.runId ?? (0, uuid.v4)();
        config.runId = runId;
        const callbacks = config.callbacks;
        if (callbacks === void 0) config.callbacks = [eventStreamer];
        else if (Array.isArray(callbacks)) config.callbacks = callbacks.concat(eventStreamer);
        else {
          const copiedCallbacks = callbacks.copy();
          copiedCallbacks.addHandler(eventStreamer, true);
          config.callbacks = copiedCallbacks;
        }
        const abortController = new AbortController();
        const outerThis = this;
        async function consumeRunnableStream() {
          let signal;
          let listener = null;
          try {
            if (options?.signal) if ("any" in AbortSignal) signal = AbortSignal.any([abortController.signal, options.signal]);
            else {
              signal = options.signal;
              listener = () => {
                abortController.abort();
              };
              options.signal.addEventListener("abort", listener, { once: true });
            }
            else signal = abortController.signal;
            const runnableStream = await outerThis.stream(input, {
              ...config,
              signal
            });
            const tappedStream = eventStreamer.tapOutputIterable(runId, runnableStream);
            for await (const _ of tappedStream) if (abortController.signal.aborted) break;
          } finally {
            await eventStreamer.finish();
            if (signal && listener) signal.removeEventListener("abort", listener);
          }
        }
        const runnableStreamConsumePromise = consumeRunnableStream();
        let firstEventSent = false;
        let firstEventRunId;
        try {
          for await (const event of eventStreamer) {
            if (!firstEventSent) {
              event.data.input = input;
              firstEventSent = true;
              firstEventRunId = event.run_id;
              yield event;
              continue;
            }
            if (event.run_id === firstEventRunId && event.event.endsWith("_end")) {
              if (event.data?.input) delete event.data.input;
            }
            yield event;
          }
        } finally {
          abortController.abort();
          await runnableStreamConsumePromise;
        }
      }
      async *_streamEventsV1(input, options, streamOptions) {
        let runLog;
        let hasEncounteredStartEvent = false;
        const config = require_config3.ensureConfig(options);
        const rootTags = config.tags ?? [];
        const rootMetadata = config.metadata ?? {};
        const rootName = config.runName ?? this.getName();
        const logStreamCallbackHandler = new require_tracers_log_stream.LogStreamCallbackHandler({
          ...streamOptions,
          autoClose: false,
          _schemaFormat: "streaming_events"
        });
        const rootEventFilter = new require_utils$1._RootEventFilter({ ...streamOptions });
        const logStream = this._streamLog(input, logStreamCallbackHandler, config);
        for await (const log of logStream) {
          if (!runLog) runLog = require_tracers_log_stream.RunLog.fromRunLogPatch(log);
          else runLog = runLog.concat(log);
          if (runLog.state === void 0) throw new Error(`Internal error: "streamEvents" state is missing. Please open a bug report.`);
          if (!hasEncounteredStartEvent) {
            hasEncounteredStartEvent = true;
            const state$2 = { ...runLog.state };
            const event = {
              run_id: state$2.id,
              event: `on_${state$2.type}_start`,
              name: rootName,
              tags: rootTags,
              metadata: rootMetadata,
              data: { input }
            };
            if (rootEventFilter.includeEvent(event, state$2.type)) yield event;
          }
          const paths = log.ops.filter((op) => op.path.startsWith("/logs/")).map((op) => op.path.split("/")[2]);
          const dedupedPaths = [...new Set(paths)];
          for (const path of dedupedPaths) {
            let eventType;
            let data = {};
            const logEntry = runLog.state.logs[path];
            if (logEntry.end_time === void 0) if (logEntry.streamed_output.length > 0) eventType = "stream";
            else eventType = "start";
            else eventType = "end";
            if (eventType === "start") {
              if (logEntry.inputs !== void 0) data.input = logEntry.inputs;
            } else if (eventType === "end") {
              if (logEntry.inputs !== void 0) data.input = logEntry.inputs;
              data.output = logEntry.final_output;
            } else if (eventType === "stream") {
              const chunkCount = logEntry.streamed_output.length;
              if (chunkCount !== 1) throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: "${logEntry.name}"`);
              data = { chunk: logEntry.streamed_output[0] };
              logEntry.streamed_output = [];
            }
            yield {
              event: `on_${logEntry.type}_${eventType}`,
              name: logEntry.name,
              run_id: logEntry.id,
              tags: logEntry.tags,
              metadata: logEntry.metadata,
              data
            };
          }
          const { state: state$1 } = runLog;
          if (state$1.streamed_output.length > 0) {
            const chunkCount = state$1.streamed_output.length;
            if (chunkCount !== 1) throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: "${state$1.name}"`);
            const data = { chunk: state$1.streamed_output[0] };
            state$1.streamed_output = [];
            const event = {
              event: `on_${state$1.type}_stream`,
              run_id: state$1.id,
              tags: rootTags,
              metadata: rootMetadata,
              name: rootName,
              data
            };
            if (rootEventFilter.includeEvent(event, state$1.type)) yield event;
          }
        }
        const state = runLog?.state;
        if (state !== void 0) {
          const event = {
            event: `on_${state.type}_end`,
            name: rootName,
            run_id: state.id,
            tags: rootTags,
            metadata: rootMetadata,
            data: { output: state.final_output }
          };
          if (rootEventFilter.includeEvent(event, state.type)) yield event;
        }
      }
      static isRunnable(thing) {
        return require_utils$1.isRunnableInterface(thing);
      }
      /**
      * Bind lifecycle listeners to a Runnable, returning a new Runnable.
      * The Run object contains information about the run, including its id,
      * type, input, output, error, startTime, endTime, and any tags or metadata
      * added to the run.
      *
      * @param {Object} params - The object containing the callback functions.
      * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
      * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
      * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
      */
      withListeners({ onStart, onEnd, onError }) {
        return new RunnableBinding({
          bound: this,
          config: {},
          configFactories: [(config) => ({ callbacks: [new require_root_listener2.RootListenersTracer({
            config,
            onStart,
            onEnd,
            onError
          })] })]
        });
      }
      /**
      * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`
      * which contains the runnable, name, description and schema.
      *
      * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.
      *
      * @param fields
      * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.
      * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.
      * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.
      * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.
      */
      asTool(fields) {
        return convertRunnableToTool(this, fields);
      }
    };
    var RunnableBinding = class RunnableBinding2 extends Runnable {
      static lc_name() {
        return "RunnableBinding";
      }
      lc_namespace = ["langchain_core", "runnables"];
      lc_serializable = true;
      bound;
      config;
      kwargs;
      configFactories;
      constructor(fields) {
        super(fields);
        this.bound = fields.bound;
        this.kwargs = fields.kwargs;
        this.config = fields.config;
        this.configFactories = fields.configFactories;
      }
      getName(suffix) {
        return this.bound.getName(suffix);
      }
      async _mergeConfig(...options) {
        const config = require_config3.mergeConfigs(this.config, ...options);
        return require_config3.mergeConfigs(config, ...this.configFactories ? await Promise.all(this.configFactories.map(async (configFactory) => await configFactory(config))) : []);
      }
      withConfig(config) {
        return new this.constructor({
          bound: this.bound,
          kwargs: this.kwargs,
          config: {
            ...this.config,
            ...config
          }
        });
      }
      withRetry(fields) {
        return new RunnableRetry({
          bound: this.bound,
          kwargs: this.kwargs,
          config: this.config,
          maxAttemptNumber: fields?.stopAfterAttempt,
          ...fields
        });
      }
      async invoke(input, options) {
        return this.bound.invoke(input, await this._mergeConfig(options, this.kwargs));
      }
      async batch(inputs, options, batchOptions) {
        const mergedOptions = Array.isArray(options) ? await Promise.all(options.map(async (individualOption) => this._mergeConfig(require_config3.ensureConfig(individualOption), this.kwargs))) : await this._mergeConfig(require_config3.ensureConfig(options), this.kwargs);
        return this.bound.batch(inputs, mergedOptions, batchOptions);
      }
      /** @internal */
      _concatOutputChunks(first, second) {
        return this.bound._concatOutputChunks(first, second);
      }
      async *_streamIterator(input, options) {
        yield* this.bound._streamIterator(input, await this._mergeConfig(require_config3.ensureConfig(options), this.kwargs));
      }
      async stream(input, options) {
        return this.bound.stream(input, await this._mergeConfig(require_config3.ensureConfig(options), this.kwargs));
      }
      async *transform(generator, options) {
        yield* this.bound.transform(generator, await this._mergeConfig(require_config3.ensureConfig(options), this.kwargs));
      }
      streamEvents(input, options, streamOptions) {
        const outerThis = this;
        const generator = async function* () {
          yield* outerThis.bound.streamEvents(input, {
            ...await outerThis._mergeConfig(require_config3.ensureConfig(options), outerThis.kwargs),
            version: options.version
          }, streamOptions);
        };
        return require_utils_stream.IterableReadableStream.fromAsyncGenerator(generator());
      }
      static isRunnableBinding(thing) {
        return thing.bound && Runnable.isRunnable(thing.bound);
      }
      /**
      * Bind lifecycle listeners to a Runnable, returning a new Runnable.
      * The Run object contains information about the run, including its id,
      * type, input, output, error, startTime, endTime, and any tags or metadata
      * added to the run.
      *
      * @param {Object} params - The object containing the callback functions.
      * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
      * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
      * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
      */
      withListeners({ onStart, onEnd, onError }) {
        return new RunnableBinding2({
          bound: this.bound,
          kwargs: this.kwargs,
          config: this.config,
          configFactories: [(config) => ({ callbacks: [new require_root_listener2.RootListenersTracer({
            config,
            onStart,
            onEnd,
            onError
          })] })]
        });
      }
    };
    var RunnableEach = class RunnableEach2 extends Runnable {
      static lc_name() {
        return "RunnableEach";
      }
      lc_serializable = true;
      lc_namespace = ["langchain_core", "runnables"];
      bound;
      constructor(fields) {
        super(fields);
        this.bound = fields.bound;
      }
      /**
      * Invokes the runnable with the specified input and configuration.
      * @param input The input to invoke the runnable with.
      * @param config The configuration to invoke the runnable with.
      * @returns A promise that resolves to the output of the runnable.
      */
      async invoke(inputs, config) {
        return this._callWithConfig(this._invoke.bind(this), inputs, config);
      }
      /**
      * A helper method that is used to invoke the runnable with the specified input and configuration.
      * @param input The input to invoke the runnable with.
      * @param config The configuration to invoke the runnable with.
      * @returns A promise that resolves to the output of the runnable.
      */
      async _invoke(inputs, config, runManager) {
        return this.bound.batch(inputs, require_config3.patchConfig(config, { callbacks: runManager?.getChild() }));
      }
      /**
      * Bind lifecycle listeners to a Runnable, returning a new Runnable.
      * The Run object contains information about the run, including its id,
      * type, input, output, error, startTime, endTime, and any tags or metadata
      * added to the run.
      *
      * @param {Object} params - The object containing the callback functions.
      * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
      * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
      * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
      */
      withListeners({ onStart, onEnd, onError }) {
        return new RunnableEach2({ bound: this.bound.withListeners({
          onStart,
          onEnd,
          onError
        }) });
      }
    };
    var RunnableRetry = class extends RunnableBinding {
      static lc_name() {
        return "RunnableRetry";
      }
      lc_namespace = ["langchain_core", "runnables"];
      maxAttemptNumber = 3;
      onFailedAttempt = () => {
      };
      constructor(fields) {
        super(fields);
        this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;
        this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;
      }
      _patchConfigForRetry(attempt, config, runManager) {
        const tag = attempt > 1 ? `retry:attempt:${attempt}` : void 0;
        return require_config3.patchConfig(config, { callbacks: runManager?.getChild(tag) });
      }
      async _invoke(input, config, runManager) {
        return (0, p_retry.default)((attemptNumber) => super.invoke(input, this._patchConfigForRetry(attemptNumber, config, runManager)), {
          onFailedAttempt: (error) => this.onFailedAttempt(error, input),
          retries: Math.max(this.maxAttemptNumber - 1, 0),
          randomize: true
        });
      }
      /**
      * Method that invokes the runnable with the specified input, run manager,
      * and config. It handles the retry logic by catching any errors and
      * recursively invoking itself with the updated config for the next retry
      * attempt.
      * @param input The input for the runnable.
      * @param runManager The run manager for the runnable.
      * @param config The config for the runnable.
      * @returns A promise that resolves to the output of the runnable.
      */
      async invoke(input, config) {
        return this._callWithConfig(this._invoke.bind(this), input, config);
      }
      async _batch(inputs, configs, runManagers, batchOptions) {
        const resultsMap = {};
        try {
          await (0, p_retry.default)(async (attemptNumber) => {
            const remainingIndexes = inputs.map((_, i) => i).filter((i) => resultsMap[i.toString()] === void 0 || resultsMap[i.toString()] instanceof Error);
            const remainingInputs = remainingIndexes.map((i) => inputs[i]);
            const patchedConfigs = remainingIndexes.map((i) => this._patchConfigForRetry(attemptNumber, configs?.[i], runManagers?.[i]));
            const results = await super.batch(remainingInputs, patchedConfigs, {
              ...batchOptions,
              returnExceptions: true
            });
            let firstException;
            for (let i = 0; i < results.length; i += 1) {
              const result = results[i];
              const resultMapIndex = remainingIndexes[i];
              if (result instanceof Error) {
                if (firstException === void 0) {
                  firstException = result;
                  firstException.input = remainingInputs[i];
                }
              }
              resultsMap[resultMapIndex.toString()] = result;
            }
            if (firstException) throw firstException;
            return results;
          }, {
            onFailedAttempt: (error) => this.onFailedAttempt(error, error.input),
            retries: Math.max(this.maxAttemptNumber - 1, 0),
            randomize: true
          });
        } catch (e) {
          if (batchOptions?.returnExceptions !== true) throw e;
        }
        return Object.keys(resultsMap).sort((a, b) => parseInt(a, 10) - parseInt(b, 10)).map((key) => resultsMap[parseInt(key, 10)]);
      }
      async batch(inputs, options, batchOptions) {
        return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);
      }
    };
    var RunnableSequence = class RunnableSequence2 extends Runnable {
      static lc_name() {
        return "RunnableSequence";
      }
      first;
      middle = [];
      last;
      omitSequenceTags = false;
      lc_serializable = true;
      lc_namespace = ["langchain_core", "runnables"];
      constructor(fields) {
        super(fields);
        this.first = fields.first;
        this.middle = fields.middle ?? this.middle;
        this.last = fields.last;
        this.name = fields.name;
        this.omitSequenceTags = fields.omitSequenceTags ?? this.omitSequenceTags;
      }
      get steps() {
        return [
          this.first,
          ...this.middle,
          this.last
        ];
      }
      async invoke(input, options) {
        const config = require_config3.ensureConfig(options);
        const callbackManager_ = await require_config3.getCallbackManagerForConfig(config);
        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), config.runId, void 0, void 0, void 0, config?.runName);
        delete config.runId;
        let nextStepInput = input;
        let finalOutput;
        try {
          const initialSteps = [this.first, ...this.middle];
          for (let i = 0; i < initialSteps.length; i += 1) {
            const step = initialSteps[i];
            const promise = step.invoke(nextStepInput, require_config3.patchConfig(config, { callbacks: runManager?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${i + 1}`) }));
            nextStepInput = await require_signal2.raceWithSignal(promise, options?.signal);
          }
          if (options?.signal?.aborted) throw require_signal2.getAbortSignalError(options.signal);
          finalOutput = await this.last.invoke(nextStepInput, require_config3.patchConfig(config, { callbacks: runManager?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${this.steps.length}`) }));
        } catch (e) {
          await runManager?.handleChainError(e);
          throw e;
        }
        await runManager?.handleChainEnd(_coerceToDict(finalOutput, "output"));
        return finalOutput;
      }
      async batch(inputs, options, batchOptions) {
        const configList = this._getOptionsList(options ?? {}, inputs.length);
        const callbackManagers = await Promise.all(configList.map(require_config3.getCallbackManagerForConfig));
        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {
          const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], "input"), configList[i].runId, void 0, void 0, void 0, configList[i].runName);
          delete configList[i].runId;
          return handleStartRes;
        }));
        let nextStepInputs = inputs;
        try {
          for (let i = 0; i < this.steps.length; i += 1) {
            const step = this.steps[i];
            const promise = step.batch(nextStepInputs, runManagers.map((runManager, j) => {
              const childRunManager = runManager?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${i + 1}`);
              return require_config3.patchConfig(configList[j], { callbacks: childRunManager });
            }), batchOptions);
            nextStepInputs = await require_signal2.raceWithSignal(promise, configList[0]?.signal);
          }
        } catch (e) {
          await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));
          throw e;
        }
        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(nextStepInputs, "output"))));
        return nextStepInputs;
      }
      /** @internal */
      _concatOutputChunks(first, second) {
        return this.last._concatOutputChunks(first, second);
      }
      async *_streamIterator(input, options) {
        const callbackManager_ = await require_config3.getCallbackManagerForConfig(options);
        const { runId, ...otherOptions } = options ?? {};
        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), runId, void 0, void 0, void 0, otherOptions?.runName);
        const steps = [
          this.first,
          ...this.middle,
          this.last
        ];
        let concatSupported = true;
        let finalOutput;
        async function* inputGenerator() {
          yield input;
        }
        try {
          let finalGenerator = steps[0].transform(inputGenerator(), require_config3.patchConfig(otherOptions, { callbacks: runManager?.getChild(this.omitSequenceTags ? void 0 : `seq:step:1`) }));
          for (let i = 1; i < steps.length; i += 1) {
            const step = steps[i];
            finalGenerator = await step.transform(finalGenerator, require_config3.patchConfig(otherOptions, { callbacks: runManager?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${i + 1}`) }));
          }
          for await (const chunk of finalGenerator) {
            options?.signal?.throwIfAborted();
            yield chunk;
            if (concatSupported) if (finalOutput === void 0) finalOutput = chunk;
            else try {
              finalOutput = this._concatOutputChunks(finalOutput, chunk);
            } catch {
              finalOutput = void 0;
              concatSupported = false;
            }
          }
        } catch (e) {
          await runManager?.handleChainError(e);
          throw e;
        }
        await runManager?.handleChainEnd(_coerceToDict(finalOutput, "output"));
      }
      getGraph(config) {
        const graph = new require_runnables_graph.Graph();
        let currentLastNode = null;
        this.steps.forEach((step, index) => {
          const stepGraph = step.getGraph(config);
          if (index !== 0) stepGraph.trimFirstNode();
          if (index !== this.steps.length - 1) stepGraph.trimLastNode();
          graph.extend(stepGraph);
          const stepFirstNode = stepGraph.firstNode();
          if (!stepFirstNode) throw new Error(`Runnable ${step} has no first node`);
          if (currentLastNode) graph.addEdge(currentLastNode, stepFirstNode);
          currentLastNode = stepGraph.lastNode();
        });
        return graph;
      }
      pipe(coerceable) {
        if (RunnableSequence2.isRunnableSequence(coerceable)) return new RunnableSequence2({
          first: this.first,
          middle: this.middle.concat([
            this.last,
            coerceable.first,
            ...coerceable.middle
          ]),
          last: coerceable.last,
          name: this.name ?? coerceable.name
        });
        else return new RunnableSequence2({
          first: this.first,
          middle: [...this.middle, this.last],
          last: _coerceToRunnable(coerceable),
          name: this.name
        });
      }
      static isRunnableSequence(thing) {
        return Array.isArray(thing.middle) && Runnable.isRunnable(thing);
      }
      static from([first, ...runnables], nameOrFields) {
        let extra = {};
        if (typeof nameOrFields === "string") extra.name = nameOrFields;
        else if (nameOrFields !== void 0) extra = nameOrFields;
        return new RunnableSequence2({
          ...extra,
          first: _coerceToRunnable(first),
          middle: runnables.slice(0, -1).map(_coerceToRunnable),
          last: _coerceToRunnable(runnables[runnables.length - 1])
        });
      }
    };
    var RunnableMap = class RunnableMap2 extends Runnable {
      static lc_name() {
        return "RunnableMap";
      }
      lc_namespace = ["langchain_core", "runnables"];
      lc_serializable = true;
      steps;
      getStepsKeys() {
        return Object.keys(this.steps);
      }
      constructor(fields) {
        super(fields);
        this.steps = {};
        for (const [key, value] of Object.entries(fields.steps)) this.steps[key] = _coerceToRunnable(value);
      }
      static from(steps) {
        return new RunnableMap2({ steps });
      }
      async invoke(input, options) {
        const config = require_config3.ensureConfig(options);
        const callbackManager_ = await require_config3.getCallbackManagerForConfig(config);
        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), { input }, config.runId, void 0, void 0, void 0, config?.runName);
        delete config.runId;
        const output = {};
        try {
          const promises = Object.entries(this.steps).map(async ([key, runnable]) => {
            output[key] = await runnable.invoke(input, require_config3.patchConfig(config, { callbacks: runManager?.getChild(`map:key:${key}`) }));
          });
          await require_signal2.raceWithSignal(Promise.all(promises), options?.signal);
        } catch (e) {
          await runManager?.handleChainError(e);
          throw e;
        }
        await runManager?.handleChainEnd(output);
        return output;
      }
      async *_transform(generator, runManager, options) {
        const steps = { ...this.steps };
        const inputCopies = require_utils_stream.atee(generator, Object.keys(steps).length);
        const tasks = new Map(Object.entries(steps).map(([key, runnable], i) => {
          const gen = runnable.transform(inputCopies[i], require_config3.patchConfig(options, { callbacks: runManager?.getChild(`map:key:${key}`) }));
          return [key, gen.next().then((result) => ({
            key,
            gen,
            result
          }))];
        }));
        while (tasks.size) {
          const promise = Promise.race(tasks.values());
          const { key, result, gen } = await require_signal2.raceWithSignal(promise, options?.signal);
          tasks.delete(key);
          if (!result.done) {
            yield { [key]: result.value };
            tasks.set(key, gen.next().then((result$1) => ({
              key,
              gen,
              result: result$1
            })));
          }
        }
      }
      transform(generator, options) {
        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
      }
      async stream(input, options) {
        async function* generator() {
          yield input;
        }
        const config = require_config3.ensureConfig(options);
        const wrappedGenerator = new require_utils_stream.AsyncGeneratorWithSetup({
          generator: this.transform(generator(), config),
          config
        });
        await wrappedGenerator.setup;
        return require_utils_stream.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
      }
    };
    var RunnableTraceable = class RunnableTraceable2 extends Runnable {
      lc_serializable = false;
      lc_namespace = ["langchain_core", "runnables"];
      func;
      constructor(fields) {
        super(fields);
        if (!(0, langsmith_singletons_traceable.isTraceableFunction)(fields.func)) throw new Error("RunnableTraceable requires a function that is wrapped in traceable higher-order function");
        this.func = fields.func;
      }
      async invoke(input, options) {
        const [config] = this._getOptionsList(options ?? {}, 1);
        const callbacks = await require_config3.getCallbackManagerForConfig(config);
        const promise = this.func(require_config3.patchConfig(config, { callbacks }), input);
        return require_signal2.raceWithSignal(promise, config?.signal);
      }
      async *_streamIterator(input, options) {
        const [config] = this._getOptionsList(options ?? {}, 1);
        const result = await this.invoke(input, options);
        if (require_iter2.isAsyncIterable(result)) {
          for await (const item of result) {
            config?.signal?.throwIfAborted();
            yield item;
          }
          return;
        }
        if (require_iter2.isIterator(result)) {
          while (true) {
            config?.signal?.throwIfAborted();
            const state = result.next();
            if (state.done) break;
            yield state.value;
          }
          return;
        }
        yield result;
      }
      static from(func) {
        return new RunnableTraceable2({ func });
      }
    };
    function assertNonTraceableFunction(func) {
      if ((0, langsmith_singletons_traceable.isTraceableFunction)(func)) throw new Error("RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.");
    }
    var RunnableLambda = class RunnableLambda2 extends Runnable {
      static lc_name() {
        return "RunnableLambda";
      }
      lc_namespace = ["langchain_core", "runnables"];
      func;
      constructor(fields) {
        if ((0, langsmith_singletons_traceable.isTraceableFunction)(fields.func)) return RunnableTraceable.from(fields.func);
        super(fields);
        assertNonTraceableFunction(fields.func);
        this.func = fields.func;
      }
      static from(func) {
        return new RunnableLambda2({ func });
      }
      async _invoke(input, config, runManager) {
        return new Promise((resolve, reject) => {
          const childConfig = require_config3.patchConfig(config, {
            callbacks: runManager?.getChild(),
            recursionLimit: (config?.recursionLimit ?? require_config3.DEFAULT_RECURSION_LIMIT) - 1
          });
          require_index.AsyncLocalStorageProviderSingleton.runWithConfig(require_config3.pickRunnableConfigKeys(childConfig), async () => {
            try {
              let output = await this.func(input, { ...childConfig });
              if (output && Runnable.isRunnable(output)) {
                if (config?.recursionLimit === 0) throw new Error("Recursion limit reached.");
                output = await output.invoke(input, {
                  ...childConfig,
                  recursionLimit: (childConfig.recursionLimit ?? require_config3.DEFAULT_RECURSION_LIMIT) - 1
                });
              } else if (require_iter2.isAsyncIterable(output)) {
                let finalOutput;
                for await (const chunk of require_iter2.consumeAsyncIterableInContext(childConfig, output)) {
                  config?.signal?.throwIfAborted();
                  if (finalOutput === void 0) finalOutput = chunk;
                  else try {
                    finalOutput = this._concatOutputChunks(finalOutput, chunk);
                  } catch {
                    finalOutput = chunk;
                  }
                }
                output = finalOutput;
              } else if (require_iter2.isIterableIterator(output)) {
                let finalOutput;
                for (const chunk of require_iter2.consumeIteratorInContext(childConfig, output)) {
                  config?.signal?.throwIfAborted();
                  if (finalOutput === void 0) finalOutput = chunk;
                  else try {
                    finalOutput = this._concatOutputChunks(finalOutput, chunk);
                  } catch {
                    finalOutput = chunk;
                  }
                }
                output = finalOutput;
              }
              resolve(output);
            } catch (e) {
              reject(e);
            }
          });
        });
      }
      async invoke(input, options) {
        return this._callWithConfig(this._invoke.bind(this), input, options);
      }
      async *_transform(generator, runManager, config) {
        let finalChunk;
        for await (const chunk of generator) if (finalChunk === void 0) finalChunk = chunk;
        else try {
          finalChunk = this._concatOutputChunks(finalChunk, chunk);
        } catch {
          finalChunk = chunk;
        }
        const childConfig = require_config3.patchConfig(config, {
          callbacks: runManager?.getChild(),
          recursionLimit: (config?.recursionLimit ?? require_config3.DEFAULT_RECURSION_LIMIT) - 1
        });
        const output = await new Promise((resolve, reject) => {
          require_index.AsyncLocalStorageProviderSingleton.runWithConfig(require_config3.pickRunnableConfigKeys(childConfig), async () => {
            try {
              const res = await this.func(finalChunk, {
                ...childConfig,
                config: childConfig
              });
              resolve(res);
            } catch (e) {
              reject(e);
            }
          });
        });
        if (output && Runnable.isRunnable(output)) {
          if (config?.recursionLimit === 0) throw new Error("Recursion limit reached.");
          const stream = await output.stream(finalChunk, childConfig);
          for await (const chunk of stream) yield chunk;
        } else if (require_iter2.isAsyncIterable(output)) for await (const chunk of require_iter2.consumeAsyncIterableInContext(childConfig, output)) {
          config?.signal?.throwIfAborted();
          yield chunk;
        }
        else if (require_iter2.isIterableIterator(output)) for (const chunk of require_iter2.consumeIteratorInContext(childConfig, output)) {
          config?.signal?.throwIfAborted();
          yield chunk;
        }
        else yield output;
      }
      transform(generator, options) {
        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
      }
      async stream(input, options) {
        async function* generator() {
          yield input;
        }
        const config = require_config3.ensureConfig(options);
        const wrappedGenerator = new require_utils_stream.AsyncGeneratorWithSetup({
          generator: this.transform(generator(), config),
          config
        });
        await wrappedGenerator.setup;
        return require_utils_stream.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
      }
    };
    var RunnableParallel = class extends RunnableMap {
    };
    var RunnableWithFallbacks = class extends Runnable {
      static lc_name() {
        return "RunnableWithFallbacks";
      }
      lc_namespace = ["langchain_core", "runnables"];
      lc_serializable = true;
      runnable;
      fallbacks;
      constructor(fields) {
        super(fields);
        this.runnable = fields.runnable;
        this.fallbacks = fields.fallbacks;
      }
      *runnables() {
        yield this.runnable;
        for (const fallback of this.fallbacks) yield fallback;
      }
      async invoke(input, options) {
        const config = require_config3.ensureConfig(options);
        const callbackManager_ = await require_config3.getCallbackManagerForConfig(config);
        const { runId, ...otherConfigFields } = config;
        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), runId, void 0, void 0, void 0, otherConfigFields?.runName);
        const childConfig = require_config3.patchConfig(otherConfigFields, { callbacks: runManager?.getChild() });
        const res = await require_index.AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {
          let firstError;
          for (const runnable of this.runnables()) {
            config?.signal?.throwIfAborted();
            try {
              const output = await runnable.invoke(input, childConfig);
              await runManager?.handleChainEnd(_coerceToDict(output, "output"));
              return output;
            } catch (e) {
              if (firstError === void 0) firstError = e;
            }
          }
          if (firstError === void 0) throw new Error("No error stored at end of fallback.");
          await runManager?.handleChainError(firstError);
          throw firstError;
        });
        return res;
      }
      async *_streamIterator(input, options) {
        const config = require_config3.ensureConfig(options);
        const callbackManager_ = await require_config3.getCallbackManagerForConfig(config);
        const { runId, ...otherConfigFields } = config;
        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), runId, void 0, void 0, void 0, otherConfigFields?.runName);
        let firstError;
        let stream;
        for (const runnable of this.runnables()) {
          config?.signal?.throwIfAborted();
          const childConfig = require_config3.patchConfig(otherConfigFields, { callbacks: runManager?.getChild() });
          try {
            const originalStream = await runnable.stream(input, childConfig);
            stream = require_iter2.consumeAsyncIterableInContext(childConfig, originalStream);
            break;
          } catch (e) {
            if (firstError === void 0) firstError = e;
          }
        }
        if (stream === void 0) {
          const error = firstError ?? /* @__PURE__ */ new Error("No error stored at end of fallback.");
          await runManager?.handleChainError(error);
          throw error;
        }
        let output;
        try {
          for await (const chunk of stream) {
            yield chunk;
            try {
              output = output === void 0 ? output : this._concatOutputChunks(output, chunk);
            } catch {
              output = void 0;
            }
          }
        } catch (e) {
          await runManager?.handleChainError(e);
          throw e;
        }
        await runManager?.handleChainEnd(_coerceToDict(output, "output"));
      }
      async batch(inputs, options, batchOptions) {
        if (batchOptions?.returnExceptions) throw new Error("Not implemented.");
        const configList = this._getOptionsList(options ?? {}, inputs.length);
        const callbackManagers = await Promise.all(configList.map((config) => require_config3.getCallbackManagerForConfig(config)));
        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {
          const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], "input"), configList[i].runId, void 0, void 0, void 0, configList[i].runName);
          delete configList[i].runId;
          return handleStartRes;
        }));
        let firstError;
        for (const runnable of this.runnables()) {
          configList[0].signal?.throwIfAborted();
          try {
            const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => require_config3.patchConfig(configList[j], { callbacks: runManager?.getChild() })), batchOptions);
            await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(outputs[i], "output"))));
            return outputs;
          } catch (e) {
            if (firstError === void 0) firstError = e;
          }
        }
        if (!firstError) throw new Error("No error stored at end of fallbacks.");
        await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(firstError)));
        throw firstError;
      }
    };
    function _coerceToRunnable(coerceable) {
      if (typeof coerceable === "function") return new RunnableLambda({ func: coerceable });
      else if (Runnable.isRunnable(coerceable)) return coerceable;
      else if (!Array.isArray(coerceable) && typeof coerceable === "object") {
        const runnables = {};
        for (const [key, value] of Object.entries(coerceable)) runnables[key] = _coerceToRunnable(value);
        return new RunnableMap({ steps: runnables });
      } else throw new Error(`Expected a Runnable, function or object.
Instead got an unsupported type.`);
    }
    var RunnableAssign = class extends Runnable {
      static lc_name() {
        return "RunnableAssign";
      }
      lc_namespace = ["langchain_core", "runnables"];
      lc_serializable = true;
      mapper;
      constructor(fields) {
        if (fields instanceof RunnableMap) fields = { mapper: fields };
        super(fields);
        this.mapper = fields.mapper;
      }
      async invoke(input, options) {
        const mapperResult = await this.mapper.invoke(input, options);
        return {
          ...input,
          ...mapperResult
        };
      }
      async *_transform(generator, runManager, options) {
        const mapperKeys = this.mapper.getStepsKeys();
        const [forPassthrough, forMapper] = require_utils_stream.atee(generator);
        const mapperOutput = this.mapper.transform(forMapper, require_config3.patchConfig(options, { callbacks: runManager?.getChild() }));
        const firstMapperChunkPromise = mapperOutput.next();
        for await (const chunk of forPassthrough) {
          if (typeof chunk !== "object" || Array.isArray(chunk)) throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);
          const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));
          if (Object.keys(filtered).length > 0) yield filtered;
        }
        yield (await firstMapperChunkPromise).value;
        for await (const chunk of mapperOutput) yield chunk;
      }
      transform(generator, options) {
        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
      }
      async stream(input, options) {
        async function* generator() {
          yield input;
        }
        const config = require_config3.ensureConfig(options);
        const wrappedGenerator = new require_utils_stream.AsyncGeneratorWithSetup({
          generator: this.transform(generator(), config),
          config
        });
        await wrappedGenerator.setup;
        return require_utils_stream.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
      }
    };
    var RunnablePick = class extends Runnable {
      static lc_name() {
        return "RunnablePick";
      }
      lc_namespace = ["langchain_core", "runnables"];
      lc_serializable = true;
      keys;
      constructor(fields) {
        if (typeof fields === "string" || Array.isArray(fields)) fields = { keys: fields };
        super(fields);
        this.keys = fields.keys;
      }
      async _pick(input) {
        if (typeof this.keys === "string") return input[this.keys];
        else {
          const picked = this.keys.map((key) => [key, input[key]]).filter((v) => v[1] !== void 0);
          return picked.length === 0 ? void 0 : Object.fromEntries(picked);
        }
      }
      async invoke(input, options) {
        return this._callWithConfig(this._pick.bind(this), input, options);
      }
      async *_transform(generator) {
        for await (const chunk of generator) {
          const picked = await this._pick(chunk);
          if (picked !== void 0) yield picked;
        }
      }
      transform(generator, options) {
        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
      }
      async stream(input, options) {
        async function* generator() {
          yield input;
        }
        const config = require_config3.ensureConfig(options);
        const wrappedGenerator = new require_utils_stream.AsyncGeneratorWithSetup({
          generator: this.transform(generator(), config),
          config
        });
        await wrappedGenerator.setup;
        return require_utils_stream.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
      }
    };
    var RunnableToolLike = class extends RunnableBinding {
      name;
      description;
      schema;
      constructor(fields) {
        const sequence = RunnableSequence.from([RunnableLambda.from(async (input) => {
          let toolInput;
          if (require_utils10._isToolCall(input)) try {
            toolInput = await require_zod3.interopParseAsync(this.schema, input.args);
          } catch {
            throw new require_utils10.ToolInputParsingException(`Received tool input did not match expected schema`, JSON.stringify(input.args));
          }
          else toolInput = input;
          return toolInput;
        }).withConfig({ runName: `${fields.name}:parse_input` }), fields.bound]).withConfig({ runName: fields.name });
        super({
          bound: sequence,
          config: fields.config ?? {}
        });
        this.name = fields.name;
        this.description = fields.description;
        this.schema = fields.schema;
      }
      static lc_name() {
        return "RunnableToolLike";
      }
    };
    function convertRunnableToTool(runnable, fields) {
      const name = fields.name ?? runnable.getName();
      const description = fields.description ?? require_zod3.getSchemaDescription(fields.schema);
      if (require_zod3.isSimpleStringZodSchema(fields.schema)) return new RunnableToolLike({
        name,
        description,
        schema: zod_v3.z.object({ input: zod_v3.z.string() }).transform((input) => input.input),
        bound: runnable
      });
      return new RunnableToolLike({
        name,
        description,
        schema: fields.schema,
        bound: runnable
      });
    }
    exports2.Runnable = Runnable;
    exports2.RunnableAssign = RunnableAssign;
    exports2.RunnableBinding = RunnableBinding;
    exports2.RunnableEach = RunnableEach;
    exports2.RunnableLambda = RunnableLambda;
    exports2.RunnableMap = RunnableMap;
    exports2.RunnableParallel = RunnableParallel;
    exports2.RunnablePick = RunnablePick;
    exports2.RunnableRetry = RunnableRetry;
    exports2.RunnableSequence = RunnableSequence;
    exports2.RunnableToolLike = RunnableToolLike;
    exports2.RunnableWithFallbacks = RunnableWithFallbacks;
    exports2._coerceToDict = _coerceToDict;
    exports2._coerceToRunnable = _coerceToRunnable;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompt_values.cjs
var require_prompt_values = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompt_values.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_load_serializable = require_serializable();
    var require_human2 = require_human();
    var require_utils10 = require_utils3();
    var prompt_values_exports = {};
    require_rolldown_runtime5.__export(prompt_values_exports, {
      BasePromptValue: () => BasePromptValue,
      ChatPromptValue: () => ChatPromptValue,
      ImagePromptValue: () => ImagePromptValue,
      StringPromptValue: () => StringPromptValue
    });
    var BasePromptValue = class extends require_load_serializable.Serializable {
    };
    var StringPromptValue = class extends BasePromptValue {
      static lc_name() {
        return "StringPromptValue";
      }
      lc_namespace = ["langchain_core", "prompt_values"];
      lc_serializable = true;
      value;
      constructor(value) {
        super({ value });
        this.value = value;
      }
      toString() {
        return this.value;
      }
      toChatMessages() {
        return [new require_human2.HumanMessage(this.value)];
      }
    };
    var ChatPromptValue = class extends BasePromptValue {
      lc_namespace = ["langchain_core", "prompt_values"];
      lc_serializable = true;
      static lc_name() {
        return "ChatPromptValue";
      }
      messages;
      constructor(fields) {
        if (Array.isArray(fields)) fields = { messages: fields };
        super(fields);
        this.messages = fields.messages;
      }
      toString() {
        return require_utils10.getBufferString(this.messages);
      }
      toChatMessages() {
        return this.messages;
      }
    };
    var ImagePromptValue = class extends BasePromptValue {
      lc_namespace = ["langchain_core", "prompt_values"];
      lc_serializable = true;
      static lc_name() {
        return "ImagePromptValue";
      }
      imageUrl;
      /** @ignore */
      value;
      constructor(fields) {
        if (!("imageUrl" in fields)) fields = { imageUrl: fields };
        super(fields);
        this.imageUrl = fields.imageUrl;
      }
      toString() {
        return this.imageUrl.url;
      }
      toChatMessages() {
        return [new require_human2.HumanMessage({ content: [{
          type: "image_url",
          image_url: {
            detail: this.imageUrl.detail,
            url: this.imageUrl.url
          }
        }] })];
      }
    };
    exports2.BasePromptValue = BasePromptValue;
    exports2.ChatPromptValue = ChatPromptValue;
    exports2.ImagePromptValue = ImagePromptValue;
    exports2.StringPromptValue = StringPromptValue;
    Object.defineProperty(exports2, "prompt_values_exports", {
      enumerable: true,
      get: function() {
        return prompt_values_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/js-sha256/hash.cjs
var require_hash = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/js-sha256/hash.cjs"(exports2) {
    "use strict";
    var HEX_CHARS = "0123456789abcdef".split("");
    var EXTRA = [
      -2147483648,
      8388608,
      32768,
      128
    ];
    var SHIFT = [
      24,
      16,
      8,
      0
    ];
    var K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var blocks = [];
    function Sha256(is224, sharedMemory) {
      if (sharedMemory) {
        blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
        this.blocks = blocks;
      } else this.blocks = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      if (is224) {
        this.h0 = 3238371032;
        this.h1 = 914150663;
        this.h2 = 812702999;
        this.h3 = 4144912697;
        this.h4 = 4290775857;
        this.h5 = 1750603025;
        this.h6 = 1694076839;
        this.h7 = 3204075428;
      } else {
        this.h0 = 1779033703;
        this.h1 = 3144134277;
        this.h2 = 1013904242;
        this.h3 = 2773480762;
        this.h4 = 1359893119;
        this.h5 = 2600822924;
        this.h6 = 528734635;
        this.h7 = 1541459225;
      }
      this.block = this.start = this.bytes = this.hBytes = 0;
      this.finalized = this.hashed = false;
      this.first = true;
      this.is224 = is224;
    }
    Sha256.prototype.update = function(message) {
      if (this.finalized) return;
      var notString, type = typeof message;
      if (type !== "string") {
        if (type === "object") {
          if (message === null) throw new Error(ERROR);
          else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) message = new Uint8Array(message);
          else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) throw new Error(ERROR);
          }
        } else throw new Error(ERROR);
        notString = true;
      }
      var code, index = 0, i, length = message.length, blocks$1 = this.blocks;
      while (index < length) {
        if (this.hashed) {
          this.hashed = false;
          blocks$1[0] = this.block;
          this.block = blocks$1[16] = blocks$1[1] = blocks$1[2] = blocks$1[3] = blocks$1[4] = blocks$1[5] = blocks$1[6] = blocks$1[7] = blocks$1[8] = blocks$1[9] = blocks$1[10] = blocks$1[11] = blocks$1[12] = blocks$1[13] = blocks$1[14] = blocks$1[15] = 0;
        }
        if (notString) for (i = this.start; index < length && i < 64; ++index) blocks$1[i >>> 2] |= message[index] << SHIFT[i++ & 3];
        else for (i = this.start; index < length && i < 64; ++index) {
          code = message.charCodeAt(index);
          if (code < 128) blocks$1[i >>> 2] |= code << SHIFT[i++ & 3];
          else if (code < 2048) {
            blocks$1[i >>> 2] |= (192 | code >>> 6) << SHIFT[i++ & 3];
            blocks$1[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
          } else if (code < 55296 || code >= 57344) {
            blocks$1[i >>> 2] |= (224 | code >>> 12) << SHIFT[i++ & 3];
            blocks$1[i >>> 2] |= (128 | code >>> 6 & 63) << SHIFT[i++ & 3];
            blocks$1[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
          } else {
            code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
            blocks$1[i >>> 2] |= (240 | code >>> 18) << SHIFT[i++ & 3];
            blocks$1[i >>> 2] |= (128 | code >>> 12 & 63) << SHIFT[i++ & 3];
            blocks$1[i >>> 2] |= (128 | code >>> 6 & 63) << SHIFT[i++ & 3];
            blocks$1[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
          }
        }
        this.lastByteIndex = i;
        this.bytes += i - this.start;
        if (i >= 64) {
          this.block = blocks$1[16];
          this.start = i - 64;
          this.hash();
          this.hashed = true;
        } else this.start = i;
      }
      if (this.bytes > 4294967295) {
        this.hBytes += this.bytes / 4294967296 << 0;
        this.bytes = this.bytes % 4294967296;
      }
      return this;
    };
    Sha256.prototype.finalize = function() {
      if (this.finalized) return;
      this.finalized = true;
      var blocks$1 = this.blocks, i = this.lastByteIndex;
      blocks$1[16] = this.block;
      blocks$1[i >>> 2] |= EXTRA[i & 3];
      this.block = blocks$1[16];
      if (i >= 56) {
        if (!this.hashed) this.hash();
        blocks$1[0] = this.block;
        blocks$1[16] = blocks$1[1] = blocks$1[2] = blocks$1[3] = blocks$1[4] = blocks$1[5] = blocks$1[6] = blocks$1[7] = blocks$1[8] = blocks$1[9] = blocks$1[10] = blocks$1[11] = blocks$1[12] = blocks$1[13] = blocks$1[14] = blocks$1[15] = 0;
      }
      blocks$1[14] = this.hBytes << 3 | this.bytes >>> 29;
      blocks$1[15] = this.bytes << 3;
      this.hash();
    };
    Sha256.prototype.hash = function() {
      var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks$1 = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
      for (j = 16; j < 64; ++j) {
        t1 = blocks$1[j - 15];
        s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
        t1 = blocks$1[j - 2];
        s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
        blocks$1[j] = blocks$1[j - 16] + s0 + blocks$1[j - 7] + s1 << 0;
      }
      bc = b & c;
      for (j = 0; j < 64; j += 4) {
        if (this.first) {
          if (this.is224) {
            ab = 300032;
            t1 = blocks$1[0] - 1413257819;
            h = t1 - 150054599 << 0;
            d = t1 + 24177077 << 0;
          } else {
            ab = 704751109;
            t1 = blocks$1[0] - 210244248;
            h = t1 - 1521486534 << 0;
            d = t1 + 143694565 << 0;
          }
          this.first = false;
        } else {
          s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
          s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
          ab = a & b;
          maj = ab ^ a & c ^ bc;
          ch = e & f ^ ~e & g;
          t1 = h + s1 + ch + K[j] + blocks$1[j];
          t2 = s0 + maj;
          h = d + t1 << 0;
          d = t1 + t2 << 0;
        }
        s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
        s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
        da = d & a;
        maj = da ^ d & b ^ ab;
        ch = g & h ^ ~g & e;
        t1 = f + s1 + ch + K[j + 1] + blocks$1[j + 1];
        t2 = s0 + maj;
        g = c + t1 << 0;
        c = t1 + t2 << 0;
        s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
        s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
        cd = c & d;
        maj = cd ^ c & a ^ da;
        ch = f & g ^ ~f & h;
        t1 = e + s1 + ch + K[j + 2] + blocks$1[j + 2];
        t2 = s0 + maj;
        f = b + t1 << 0;
        b = t1 + t2 << 0;
        s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
        s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);
        bc = b & c;
        maj = bc ^ b & d ^ cd;
        ch = f & g ^ ~f & h;
        t1 = e + s1 + ch + K[j + 3] + blocks$1[j + 3];
        t2 = s0 + maj;
        e = a + t1 << 0;
        a = t1 + t2 << 0;
        this.chromeBugWorkAround = true;
      }
      this.h0 = this.h0 + a << 0;
      this.h1 = this.h1 + b << 0;
      this.h2 = this.h2 + c << 0;
      this.h3 = this.h3 + d << 0;
      this.h4 = this.h4 + e << 0;
      this.h5 = this.h5 + f << 0;
      this.h6 = this.h6 + g << 0;
      this.h7 = this.h7 + h << 0;
    };
    Sha256.prototype.hex = function() {
      this.finalize();
      var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
      var hex = HEX_CHARS[h0 >>> 28 & 15] + HEX_CHARS[h0 >>> 24 & 15] + HEX_CHARS[h0 >>> 20 & 15] + HEX_CHARS[h0 >>> 16 & 15] + HEX_CHARS[h0 >>> 12 & 15] + HEX_CHARS[h0 >>> 8 & 15] + HEX_CHARS[h0 >>> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >>> 28 & 15] + HEX_CHARS[h1 >>> 24 & 15] + HEX_CHARS[h1 >>> 20 & 15] + HEX_CHARS[h1 >>> 16 & 15] + HEX_CHARS[h1 >>> 12 & 15] + HEX_CHARS[h1 >>> 8 & 15] + HEX_CHARS[h1 >>> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >>> 28 & 15] + HEX_CHARS[h2 >>> 24 & 15] + HEX_CHARS[h2 >>> 20 & 15] + HEX_CHARS[h2 >>> 16 & 15] + HEX_CHARS[h2 >>> 12 & 15] + HEX_CHARS[h2 >>> 8 & 15] + HEX_CHARS[h2 >>> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >>> 28 & 15] + HEX_CHARS[h3 >>> 24 & 15] + HEX_CHARS[h3 >>> 20 & 15] + HEX_CHARS[h3 >>> 16 & 15] + HEX_CHARS[h3 >>> 12 & 15] + HEX_CHARS[h3 >>> 8 & 15] + HEX_CHARS[h3 >>> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >>> 28 & 15] + HEX_CHARS[h4 >>> 24 & 15] + HEX_CHARS[h4 >>> 20 & 15] + HEX_CHARS[h4 >>> 16 & 15] + HEX_CHARS[h4 >>> 12 & 15] + HEX_CHARS[h4 >>> 8 & 15] + HEX_CHARS[h4 >>> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >>> 28 & 15] + HEX_CHARS[h5 >>> 24 & 15] + HEX_CHARS[h5 >>> 20 & 15] + HEX_CHARS[h5 >>> 16 & 15] + HEX_CHARS[h5 >>> 12 & 15] + HEX_CHARS[h5 >>> 8 & 15] + HEX_CHARS[h5 >>> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >>> 28 & 15] + HEX_CHARS[h6 >>> 24 & 15] + HEX_CHARS[h6 >>> 20 & 15] + HEX_CHARS[h6 >>> 16 & 15] + HEX_CHARS[h6 >>> 12 & 15] + HEX_CHARS[h6 >>> 8 & 15] + HEX_CHARS[h6 >>> 4 & 15] + HEX_CHARS[h6 & 15];
      if (!this.is224) hex += HEX_CHARS[h7 >>> 28 & 15] + HEX_CHARS[h7 >>> 24 & 15] + HEX_CHARS[h7 >>> 20 & 15] + HEX_CHARS[h7 >>> 16 & 15] + HEX_CHARS[h7 >>> 12 & 15] + HEX_CHARS[h7 >>> 8 & 15] + HEX_CHARS[h7 >>> 4 & 15] + HEX_CHARS[h7 & 15];
      return hex;
    };
    Sha256.prototype.toString = Sha256.prototype.hex;
    Sha256.prototype.digest = function() {
      this.finalize();
      var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
      var arr = [
        h0 >>> 24 & 255,
        h0 >>> 16 & 255,
        h0 >>> 8 & 255,
        h0 & 255,
        h1 >>> 24 & 255,
        h1 >>> 16 & 255,
        h1 >>> 8 & 255,
        h1 & 255,
        h2 >>> 24 & 255,
        h2 >>> 16 & 255,
        h2 >>> 8 & 255,
        h2 & 255,
        h3 >>> 24 & 255,
        h3 >>> 16 & 255,
        h3 >>> 8 & 255,
        h3 & 255,
        h4 >>> 24 & 255,
        h4 >>> 16 & 255,
        h4 >>> 8 & 255,
        h4 & 255,
        h5 >>> 24 & 255,
        h5 >>> 16 & 255,
        h5 >>> 8 & 255,
        h5 & 255,
        h6 >>> 24 & 255,
        h6 >>> 16 & 255,
        h6 >>> 8 & 255,
        h6 & 255
      ];
      if (!this.is224) arr.push(h7 >>> 24 & 255, h7 >>> 16 & 255, h7 >>> 8 & 255, h7 & 255);
      return arr;
    };
    Sha256.prototype.array = Sha256.prototype.digest;
    Sha256.prototype.arrayBuffer = function() {
      this.finalize();
      var buffer = /* @__PURE__ */ new ArrayBuffer(this.is224 ? 28 : 32);
      var dataView = new DataView(buffer);
      dataView.setUint32(0, this.h0);
      dataView.setUint32(4, this.h1);
      dataView.setUint32(8, this.h2);
      dataView.setUint32(12, this.h3);
      dataView.setUint32(16, this.h4);
      dataView.setUint32(20, this.h5);
      dataView.setUint32(24, this.h6);
      if (!this.is224) dataView.setUint32(28, this.h7);
      return buffer;
    };
    var sha256 = (...strings) => {
      return new Sha256(false, true).update(strings.join("")).hex();
    };
    exports2.sha256 = sha256;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/hash.cjs
var require_hash2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/hash.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_hash4 = require_hash();
    var hash_exports = {};
    require_rolldown_runtime5.__export(hash_exports, { sha256: () => require_hash4.sha256 });
    Object.defineProperty(exports2, "hash_exports", {
      enumerable: true,
      get: function() {
        return hash_exports;
      }
    });
    exports2.sha256 = require_hash4.sha256;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/caches/base.cjs
var require_base5 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/caches/base.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_utils10 = require_utils3();
    var require_hash4 = require_hash();
    require_hash2();
    var base_exports = {};
    require_rolldown_runtime5.__export(base_exports, {
      BaseCache: () => BaseCache,
      InMemoryCache: () => InMemoryCache,
      defaultHashKeyEncoder: () => defaultHashKeyEncoder,
      deserializeStoredGeneration: () => deserializeStoredGeneration,
      serializeGeneration: () => serializeGeneration
    });
    var defaultHashKeyEncoder = (...strings) => require_hash4.sha256(strings.join("_"));
    function deserializeStoredGeneration(storedGeneration) {
      if (storedGeneration.message !== void 0) return {
        text: storedGeneration.text,
        message: require_utils10.mapStoredMessageToChatMessage(storedGeneration.message)
      };
      else return { text: storedGeneration.text };
    }
    function serializeGeneration(generation) {
      const serializedValue = { text: generation.text };
      if (generation.message !== void 0) serializedValue.message = generation.message.toDict();
      return serializedValue;
    }
    var BaseCache = class {
      keyEncoder = defaultHashKeyEncoder;
      /**
      * Sets a custom key encoder function for the cache.
      * This function should take a prompt and an LLM key and return a string
      * that will be used as the cache key.
      * @param keyEncoderFn The custom key encoder function.
      */
      makeDefaultKeyEncoder(keyEncoderFn) {
        this.keyEncoder = keyEncoderFn;
      }
    };
    var GLOBAL_MAP = /* @__PURE__ */ new Map();
    var InMemoryCache = class InMemoryCache2 extends BaseCache {
      cache;
      constructor(map) {
        super();
        this.cache = map ?? /* @__PURE__ */ new Map();
      }
      /**
      * Retrieves data from the cache using a prompt and an LLM key. If the
      * data is not found, it returns null.
      * @param prompt The prompt used to find the data.
      * @param llmKey The LLM key used to find the data.
      * @returns The data corresponding to the prompt and LLM key, or null if not found.
      */
      lookup(prompt, llmKey) {
        return Promise.resolve(this.cache.get(this.keyEncoder(prompt, llmKey)) ?? null);
      }
      /**
      * Updates the cache with new data using a prompt and an LLM key.
      * @param prompt The prompt used to store the data.
      * @param llmKey The LLM key used to store the data.
      * @param value The data to be stored.
      */
      async update(prompt, llmKey, value) {
        this.cache.set(this.keyEncoder(prompt, llmKey), value);
      }
      /**
      * Returns a global instance of InMemoryCache using a predefined global
      * map as the initial cache.
      * @returns A global instance of InMemoryCache.
      */
      static global() {
        return new InMemoryCache2(GLOBAL_MAP);
      }
    };
    exports2.BaseCache = BaseCache;
    exports2.InMemoryCache = InMemoryCache;
    Object.defineProperty(exports2, "base_exports", {
      enumerable: true,
      get: function() {
        return base_exports;
      }
    });
    exports2.defaultHashKeyEncoder = defaultHashKeyEncoder;
    exports2.deserializeStoredGeneration = deserializeStoredGeneration;
    exports2.serializeGeneration = serializeGeneration;
  }
});

// node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/.pnpm/js-tiktoken@1.0.21/node_modules/js-tiktoken/dist/lite.cjs
var require_lite = __commonJS({
  "node_modules/.pnpm/js-tiktoken@1.0.21/node_modules/js-tiktoken/dist/lite.cjs"(exports2) {
    "use strict";
    var base64 = require_base64_js();
    function _interopDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var base64__default = /* @__PURE__ */ _interopDefault(base64);
    var __defProp2 = Object.defineProperty;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __publicField = (obj, key, value) => {
      __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    function bytePairMerge(piece, ranks) {
      let parts = Array.from(
        { length: piece.length },
        (_, i) => ({ start: i, end: i + 1 })
      );
      while (parts.length > 1) {
        let minRank = null;
        for (let i = 0; i < parts.length - 1; i++) {
          const slice = piece.slice(parts[i].start, parts[i + 1].end);
          const rank = ranks.get(slice.join(","));
          if (rank == null)
            continue;
          if (minRank == null || rank < minRank[0]) {
            minRank = [rank, i];
          }
        }
        if (minRank != null) {
          const i = minRank[1];
          parts[i] = { start: parts[i].start, end: parts[i + 1].end };
          parts.splice(i + 1, 1);
        } else {
          break;
        }
      }
      return parts;
    }
    function bytePairEncode(piece, ranks) {
      if (piece.length === 1)
        return [ranks.get(piece.join(","))];
      return bytePairMerge(piece, ranks).map((p) => ranks.get(piece.slice(p.start, p.end).join(","))).filter((x) => x != null);
    }
    function escapeRegex(str) {
      return str.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    var _Tiktoken = class {
      /** @internal */
      specialTokens;
      /** @internal */
      inverseSpecialTokens;
      /** @internal */
      patStr;
      /** @internal */
      textEncoder = new TextEncoder();
      /** @internal */
      textDecoder = new TextDecoder("utf-8");
      /** @internal */
      rankMap = /* @__PURE__ */ new Map();
      /** @internal */
      textMap = /* @__PURE__ */ new Map();
      constructor(ranks, extendedSpecialTokens) {
        this.patStr = ranks.pat_str;
        const uncompressed = ranks.bpe_ranks.split("\n").filter(Boolean).reduce((memo, x) => {
          const [_, offsetStr, ...tokens] = x.split(" ");
          const offset = Number.parseInt(offsetStr, 10);
          tokens.forEach((token, i) => memo[token] = offset + i);
          return memo;
        }, {});
        for (const [token, rank] of Object.entries(uncompressed)) {
          const bytes = base64__default.default.toByteArray(token);
          this.rankMap.set(bytes.join(","), rank);
          this.textMap.set(rank, bytes);
        }
        this.specialTokens = { ...ranks.special_tokens, ...extendedSpecialTokens };
        this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((memo, [text, rank]) => {
          memo[rank] = this.textEncoder.encode(text);
          return memo;
        }, {});
      }
      encode(text, allowedSpecial = [], disallowedSpecial = "all") {
        const regexes = new RegExp(this.patStr, "ug");
        const specialRegex = _Tiktoken.specialTokenRegex(
          Object.keys(this.specialTokens)
        );
        const ret = [];
        const allowedSpecialSet = new Set(
          allowedSpecial === "all" ? Object.keys(this.specialTokens) : allowedSpecial
        );
        const disallowedSpecialSet = new Set(
          disallowedSpecial === "all" ? Object.keys(this.specialTokens).filter(
            (x) => !allowedSpecialSet.has(x)
          ) : disallowedSpecial
        );
        if (disallowedSpecialSet.size > 0) {
          const disallowedSpecialRegex = _Tiktoken.specialTokenRegex([
            ...disallowedSpecialSet
          ]);
          const specialMatch = text.match(disallowedSpecialRegex);
          if (specialMatch != null) {
            throw new Error(
              `The text contains a special token that is not allowed: ${specialMatch[0]}`
            );
          }
        }
        let start = 0;
        while (true) {
          let nextSpecial = null;
          let startFind = start;
          while (true) {
            specialRegex.lastIndex = startFind;
            nextSpecial = specialRegex.exec(text);
            if (nextSpecial == null || allowedSpecialSet.has(nextSpecial[0]))
              break;
            startFind = nextSpecial.index + 1;
          }
          const end = nextSpecial?.index ?? text.length;
          for (const match of text.substring(start, end).matchAll(regexes)) {
            const piece = this.textEncoder.encode(match[0]);
            const token2 = this.rankMap.get(piece.join(","));
            if (token2 != null) {
              ret.push(token2);
              continue;
            }
            ret.push(...bytePairEncode(piece, this.rankMap));
          }
          if (nextSpecial == null)
            break;
          let token = this.specialTokens[nextSpecial[0]];
          ret.push(token);
          start = nextSpecial.index + nextSpecial[0].length;
        }
        return ret;
      }
      decode(tokens) {
        const res = [];
        let length = 0;
        for (let i2 = 0; i2 < tokens.length; ++i2) {
          const token = tokens[i2];
          const bytes = this.textMap.get(token) ?? this.inverseSpecialTokens[token];
          if (bytes != null) {
            res.push(bytes);
            length += bytes.length;
          }
        }
        const mergedArray = new Uint8Array(length);
        let i = 0;
        for (const bytes of res) {
          mergedArray.set(bytes, i);
          i += bytes.length;
        }
        return this.textDecoder.decode(mergedArray);
      }
    };
    var Tiktoken = _Tiktoken;
    __publicField(Tiktoken, "specialTokenRegex", (tokens) => {
      return new RegExp(tokens.map((i) => escapeRegex(i)).join("|"), "g");
    });
    function getEncodingNameForModel(model) {
      switch (model) {
        case "gpt2": {
          return "gpt2";
        }
        case "code-cushman-001":
        case "code-cushman-002":
        case "code-davinci-001":
        case "code-davinci-002":
        case "cushman-codex":
        case "davinci-codex":
        case "davinci-002":
        case "text-davinci-002":
        case "text-davinci-003": {
          return "p50k_base";
        }
        case "code-davinci-edit-001":
        case "text-davinci-edit-001": {
          return "p50k_edit";
        }
        case "ada":
        case "babbage":
        case "babbage-002":
        case "code-search-ada-code-001":
        case "code-search-babbage-code-001":
        case "curie":
        case "davinci":
        case "text-ada-001":
        case "text-babbage-001":
        case "text-curie-001":
        case "text-davinci-001":
        case "text-search-ada-doc-001":
        case "text-search-babbage-doc-001":
        case "text-search-curie-doc-001":
        case "text-search-davinci-doc-001":
        case "text-similarity-ada-001":
        case "text-similarity-babbage-001":
        case "text-similarity-curie-001":
        case "text-similarity-davinci-001": {
          return "r50k_base";
        }
        case "gpt-3.5-turbo-instruct-0914":
        case "gpt-3.5-turbo-instruct":
        case "gpt-3.5-turbo-16k-0613":
        case "gpt-3.5-turbo-16k":
        case "gpt-3.5-turbo-0613":
        case "gpt-3.5-turbo-0301":
        case "gpt-3.5-turbo":
        case "gpt-4-32k-0613":
        case "gpt-4-32k-0314":
        case "gpt-4-32k":
        case "gpt-4-0613":
        case "gpt-4-0314":
        case "gpt-4":
        case "gpt-3.5-turbo-1106":
        case "gpt-35-turbo":
        case "gpt-4-1106-preview":
        case "gpt-4-vision-preview":
        case "gpt-3.5-turbo-0125":
        case "gpt-4-turbo":
        case "gpt-4-turbo-2024-04-09":
        case "gpt-4-turbo-preview":
        case "gpt-4-0125-preview":
        case "text-embedding-ada-002":
        case "text-embedding-3-small":
        case "text-embedding-3-large": {
          return "cl100k_base";
        }
        case "gpt-4o":
        case "gpt-4o-2024-05-13":
        case "gpt-4o-2024-08-06":
        case "gpt-4o-2024-11-20":
        case "gpt-4o-mini-2024-07-18":
        case "gpt-4o-mini":
        case "gpt-4o-search-preview":
        case "gpt-4o-search-preview-2025-03-11":
        case "gpt-4o-mini-search-preview":
        case "gpt-4o-mini-search-preview-2025-03-11":
        case "gpt-4o-audio-preview":
        case "gpt-4o-audio-preview-2024-12-17":
        case "gpt-4o-audio-preview-2024-10-01":
        case "gpt-4o-mini-audio-preview":
        case "gpt-4o-mini-audio-preview-2024-12-17":
        case "o1":
        case "o1-2024-12-17":
        case "o1-mini":
        case "o1-mini-2024-09-12":
        case "o1-preview":
        case "o1-preview-2024-09-12":
        case "o1-pro":
        case "o1-pro-2025-03-19":
        case "o3":
        case "o3-2025-04-16":
        case "o3-mini":
        case "o3-mini-2025-01-31":
        case "o4-mini":
        case "o4-mini-2025-04-16":
        case "chatgpt-4o-latest":
        case "gpt-4o-realtime":
        case "gpt-4o-realtime-preview-2024-10-01":
        case "gpt-4o-realtime-preview-2024-12-17":
        case "gpt-4o-mini-realtime-preview":
        case "gpt-4o-mini-realtime-preview-2024-12-17":
        case "gpt-4.1":
        case "gpt-4.1-2025-04-14":
        case "gpt-4.1-mini":
        case "gpt-4.1-mini-2025-04-14":
        case "gpt-4.1-nano":
        case "gpt-4.1-nano-2025-04-14":
        case "gpt-4.5-preview":
        case "gpt-4.5-preview-2025-02-27":
        case "gpt-5":
        case "gpt-5-2025-08-07":
        case "gpt-5-nano":
        case "gpt-5-nano-2025-08-07":
        case "gpt-5-mini":
        case "gpt-5-mini-2025-08-07":
        case "gpt-5-chat-latest": {
          return "o200k_base";
        }
        default:
          throw new Error("Unknown model");
      }
    }
    exports2.Tiktoken = Tiktoken;
    exports2.getEncodingNameForModel = getEncodingNameForModel;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/tiktoken.cjs
var require_tiktoken = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/tiktoken.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_utils_async_caller = require_async_caller2();
    var js_tiktoken_lite = require_rolldown_runtime5.__toESM(require_lite());
    var tiktoken_exports = {};
    require_rolldown_runtime5.__export(tiktoken_exports, {
      encodingForModel: () => encodingForModel,
      getEncoding: () => getEncoding
    });
    var cache = {};
    var caller = /* @__PURE__ */ new require_utils_async_caller.AsyncCaller({});
    async function getEncoding(encoding) {
      if (!(encoding in cache)) cache[encoding] = caller.fetch(`https://tiktoken.pages.dev/js/${encoding}.json`).then((res) => res.json()).then((data) => new js_tiktoken_lite.Tiktoken(data)).catch((e) => {
        delete cache[encoding];
        throw e;
      });
      return await cache[encoding];
    }
    async function encodingForModel(model) {
      return getEncoding((0, js_tiktoken_lite.getEncodingNameForModel)(model));
    }
    exports2.encodingForModel = encodingForModel;
    exports2.getEncoding = getEncoding;
    Object.defineProperty(exports2, "tiktoken_exports", {
      enumerable: true,
      get: function() {
        return tiktoken_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/language_models/base.cjs
var require_base6 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/language_models/base.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_utils10 = require_utils3();
    var require_utils_async_caller = require_async_caller2();
    var require_base18 = require_base4();
    var require_prompt_values2 = require_prompt_values();
    var require_caches_base = require_base5();
    var require_utils_tiktoken = require_tiktoken();
    var base_exports = {};
    require_rolldown_runtime5.__export(base_exports, {
      BaseLangChain: () => BaseLangChain,
      BaseLanguageModel: () => BaseLanguageModel,
      calculateMaxTokens: () => calculateMaxTokens,
      getEmbeddingContextSize: () => getEmbeddingContextSize,
      getModelContextSize: () => getModelContextSize,
      getModelNameForTiktoken: () => getModelNameForTiktoken,
      isOpenAITool: () => isOpenAITool
    });
    var getModelNameForTiktoken = (modelName) => {
      if (modelName.startsWith("gpt-3.5-turbo-16k")) return "gpt-3.5-turbo-16k";
      if (modelName.startsWith("gpt-3.5-turbo-")) return "gpt-3.5-turbo";
      if (modelName.startsWith("gpt-4-32k")) return "gpt-4-32k";
      if (modelName.startsWith("gpt-4-")) return "gpt-4";
      if (modelName.startsWith("gpt-4o")) return "gpt-4o";
      return modelName;
    };
    var getEmbeddingContextSize = (modelName) => {
      switch (modelName) {
        case "text-embedding-ada-002":
          return 8191;
        default:
          return 2046;
      }
    };
    var getModelContextSize = (modelName) => {
      switch (getModelNameForTiktoken(modelName)) {
        case "gpt-3.5-turbo-16k":
          return 16384;
        case "gpt-3.5-turbo":
          return 4096;
        case "gpt-4-32k":
          return 32768;
        case "gpt-4":
          return 8192;
        case "text-davinci-003":
          return 4097;
        case "text-curie-001":
          return 2048;
        case "text-babbage-001":
          return 2048;
        case "text-ada-001":
          return 2048;
        case "code-davinci-002":
          return 8e3;
        case "code-cushman-001":
          return 2048;
        default:
          return 4097;
      }
    };
    function isOpenAITool(tool) {
      if (typeof tool !== "object" || !tool) return false;
      if ("type" in tool && tool.type === "function" && "function" in tool && typeof tool.function === "object" && tool.function && "name" in tool.function && "parameters" in tool.function) return true;
      return false;
    }
    var calculateMaxTokens = async ({ prompt, modelName }) => {
      let numTokens;
      try {
        numTokens = (await require_utils_tiktoken.encodingForModel(getModelNameForTiktoken(modelName))).encode(prompt).length;
      } catch {
        console.warn("Failed to calculate number of tokens, falling back to approximate count");
        numTokens = Math.ceil(prompt.length / 4);
      }
      const maxTokens = getModelContextSize(modelName);
      return maxTokens - numTokens;
    };
    var getVerbosity = () => false;
    var BaseLangChain = class extends require_base18.Runnable {
      /**
      * Whether to print out response text.
      */
      verbose;
      callbacks;
      tags;
      metadata;
      get lc_attributes() {
        return {
          callbacks: void 0,
          verbose: void 0
        };
      }
      constructor(params) {
        super(params);
        this.verbose = params.verbose ?? getVerbosity();
        this.callbacks = params.callbacks;
        this.tags = params.tags ?? [];
        this.metadata = params.metadata ?? {};
      }
    };
    var BaseLanguageModel = class extends BaseLangChain {
      /**
      * Keys that the language model accepts as call options.
      */
      get callKeys() {
        return [
          "stop",
          "timeout",
          "signal",
          "tags",
          "metadata",
          "callbacks"
        ];
      }
      /**
      * The async caller should be used by subclasses to make any async calls,
      * which will thus benefit from the concurrency and retry logic.
      */
      caller;
      cache;
      constructor({ callbacks, callbackManager, ...params }) {
        const { cache, ...rest } = params;
        super({
          callbacks: callbacks ?? callbackManager,
          ...rest
        });
        if (typeof cache === "object") this.cache = cache;
        else if (cache) this.cache = require_caches_base.InMemoryCache.global();
        else this.cache = void 0;
        this.caller = new require_utils_async_caller.AsyncCaller(params ?? {});
      }
      _encoding;
      /**
      * Get the number of tokens in the content.
      * @param content The content to get the number of tokens for.
      * @returns The number of tokens in the content.
      */
      async getNumTokens(content) {
        let textContent;
        if (typeof content === "string") textContent = content;
        else
          textContent = content.map((item) => {
            if (typeof item === "string") return item;
            if (item.type === "text" && "text" in item) return item.text;
            return "";
          }).join("");
        let numTokens = Math.ceil(textContent.length / 4);
        if (!this._encoding) try {
          this._encoding = await require_utils_tiktoken.encodingForModel("modelName" in this ? getModelNameForTiktoken(this.modelName) : "gpt2");
        } catch (error) {
          console.warn("Failed to calculate number of tokens, falling back to approximate count", error);
        }
        if (this._encoding) try {
          numTokens = this._encoding.encode(textContent).length;
        } catch (error) {
          console.warn("Failed to calculate number of tokens, falling back to approximate count", error);
        }
        return numTokens;
      }
      static _convertInputToPromptValue(input) {
        if (typeof input === "string") return new require_prompt_values2.StringPromptValue(input);
        else if (Array.isArray(input)) return new require_prompt_values2.ChatPromptValue(input.map(require_utils10.coerceMessageLikeToMessage));
        else return input;
      }
      /**
      * Get the identifying parameters of the LLM.
      */
      _identifyingParams() {
        return {};
      }
      /**
      * Create a unique cache key for a specific call to a specific language model.
      * @param callOptions Call options for the model
      * @returns A unique cache key.
      */
      _getSerializedCacheKeyParametersForCall({ config, ...callOptions }) {
        const params = {
          ...this._identifyingParams(),
          ...callOptions,
          _type: this._llmType(),
          _model: this._modelType()
        };
        const filteredEntries = Object.entries(params).filter(([_, value]) => value !== void 0);
        const serializedEntries = filteredEntries.map(([key, value]) => `${key}:${JSON.stringify(value)}`).sort().join(",");
        return serializedEntries;
      }
      /**
      * @deprecated
      * Return a json-like object representing this LLM.
      */
      serialize() {
        return {
          ...this._identifyingParams(),
          _type: this._llmType(),
          _model: this._modelType()
        };
      }
      /**
      * @deprecated
      * Load an LLM from a json-like object describing it.
      */
      static async deserialize(_data) {
        throw new Error("Use .toJSON() instead");
      }
    };
    exports2.BaseLangChain = BaseLangChain;
    exports2.BaseLanguageModel = BaseLanguageModel;
    Object.defineProperty(exports2, "base_exports", {
      enumerable: true,
      get: function() {
        return base_exports;
      }
    });
    exports2.calculateMaxTokens = calculateMaxTokens;
    exports2.getEmbeddingContextSize = getEmbeddingContextSize;
    exports2.getModelContextSize = getModelContextSize;
    exports2.getModelNameForTiktoken = getModelNameForTiktoken;
    exports2.isOpenAITool = isOpenAITool;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/tools/types.cjs
var require_types4 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/tools/types.cjs"(exports2) {
    var require_zod3 = require_zod();
    var require_base18 = require_base4();
    function isStructuredTool(tool) {
      return tool !== void 0 && Array.isArray(tool.lc_namespace);
    }
    function isRunnableToolLike(tool) {
      return tool !== void 0 && require_base18.Runnable.isRunnable(tool) && "lc_name" in tool.constructor && typeof tool.constructor.lc_name === "function" && tool.constructor.lc_name() === "RunnableToolLike";
    }
    function isStructuredToolParams(tool) {
      return !!tool && typeof tool === "object" && "name" in tool && "schema" in tool && (require_zod3.isInteropZodSchema(tool.schema) || tool.schema != null && typeof tool.schema === "object" && "type" in tool.schema && typeof tool.schema.type === "string" && [
        "null",
        "boolean",
        "object",
        "array",
        "number",
        "string"
      ].includes(tool.schema.type));
    }
    function isLangChainTool(tool) {
      return isStructuredToolParams(tool) || isRunnableToolLike(tool) || isStructuredTool(tool);
    }
    exports2.isLangChainTool = isLangChainTool;
    exports2.isRunnableToolLike = isRunnableToolLike;
    exports2.isStructuredTool = isStructuredTool;
    exports2.isStructuredToolParams = isStructuredToolParams;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/tools/index.cjs
var require_tools = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/tools/index.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_messages_tool = require_tool();
    var require_utils10 = require_utils2();
    var require_callbacks_manager = require_manager();
    var require_index = require_async_local_storage();
    require_singletons();
    var require_config3 = require_config();
    var require_signal2 = require_signal();
    var require_zod3 = require_zod();
    var require_utils_json_schema = require_json_schema2();
    var require_language_models_base = require_base6();
    var require_types10 = require_types4();
    var zod_v3 = require_rolldown_runtime5.__toESM(require_v3());
    var __cfworker_json_schema = require_rolldown_runtime5.__toESM(require_commonjs());
    var zod_v4 = require_rolldown_runtime5.__toESM(require_v4());
    var tools_exports = {};
    require_rolldown_runtime5.__export(tools_exports, {
      BaseToolkit: () => BaseToolkit,
      DynamicStructuredTool: () => DynamicStructuredTool,
      DynamicTool: () => DynamicTool,
      StructuredTool: () => StructuredTool,
      Tool: () => Tool,
      ToolInputParsingException: () => require_utils10.ToolInputParsingException,
      isLangChainTool: () => require_types10.isLangChainTool,
      isRunnableToolLike: () => require_types10.isRunnableToolLike,
      isStructuredTool: () => require_types10.isStructuredTool,
      isStructuredToolParams: () => require_types10.isStructuredToolParams,
      tool: () => tool
    });
    var StructuredTool = class extends require_language_models_base.BaseLangChain {
      /**
      * Whether to return the tool's output directly.
      *
      * Setting this to true means that after the tool is called,
      * an agent should stop looping.
      */
      returnDirect = false;
      verboseParsingErrors = false;
      get lc_namespace() {
        return ["langchain", "tools"];
      }
      /**
      * The tool response format.
      *
      * If "content" then the output of the tool is interpreted as the contents of a
      * ToolMessage. If "content_and_artifact" then the output is expected to be a
      * two-tuple corresponding to the (content, artifact) of a ToolMessage.
      *
      * @default "content"
      */
      responseFormat = "content";
      /**
      * Default config object for the tool runnable.
      */
      defaultConfig;
      constructor(fields) {
        super(fields ?? {});
        this.verboseParsingErrors = fields?.verboseParsingErrors ?? this.verboseParsingErrors;
        this.responseFormat = fields?.responseFormat ?? this.responseFormat;
        this.defaultConfig = fields?.defaultConfig ?? this.defaultConfig;
        this.metadata = fields?.metadata ?? this.metadata;
      }
      /**
      * Invokes the tool with the provided input and configuration.
      * @param input The input for the tool.
      * @param config Optional configuration for the tool.
      * @returns A Promise that resolves with the tool's output.
      */
      async invoke(input, config) {
        let toolInput;
        let enrichedConfig = require_config3.ensureConfig(require_config3.mergeConfigs(this.defaultConfig, config));
        if (require_utils10._isToolCall(input)) {
          toolInput = input.args;
          enrichedConfig = {
            ...enrichedConfig,
            toolCall: input
          };
        } else toolInput = input;
        return this.call(toolInput, enrichedConfig);
      }
      /**
      * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
      *
      * Calls the tool with the provided argument, configuration, and tags. It
      * parses the input according to the schema, handles any errors, and
      * manages callbacks.
      * @param arg The input argument for the tool.
      * @param configArg Optional configuration or callbacks for the tool.
      * @param tags Optional tags for the tool.
      * @returns A Promise that resolves with a string.
      */
      async call(arg, configArg, tags) {
        const inputForValidation = require_utils10._isToolCall(arg) ? arg.args : arg;
        let parsed;
        if (require_zod3.isInteropZodSchema(this.schema)) try {
          parsed = await require_zod3.interopParseAsync(this.schema, inputForValidation);
        } catch (e) {
          let message = `Received tool input did not match expected schema`;
          if (this.verboseParsingErrors) message = `${message}
Details: ${e.message}`;
          if (e instanceof Error && e.constructor.name === "ZodError") message = `${message}

${zod_v4.z.prettifyError(e)}`;
          throw new require_utils10.ToolInputParsingException(message, JSON.stringify(arg));
        }
        else {
          const result$1 = (0, __cfworker_json_schema.validate)(inputForValidation, this.schema);
          if (!result$1.valid) {
            let message = `Received tool input did not match expected schema`;
            if (this.verboseParsingErrors) message = `${message}
Details: ${result$1.errors.map((e) => `${e.keywordLocation}: ${e.error}`).join("\n")}`;
            throw new require_utils10.ToolInputParsingException(message, JSON.stringify(arg));
          }
          parsed = inputForValidation;
        }
        const config = require_callbacks_manager.parseCallbackConfigArg(configArg);
        const callbackManager_ = require_callbacks_manager.CallbackManager.configure(config.callbacks, this.callbacks, config.tags || tags, this.tags, config.metadata, this.metadata, { verbose: this.verbose });
        const runManager = await callbackManager_?.handleToolStart(this.toJSON(), typeof arg === "string" ? arg : JSON.stringify(arg), config.runId, void 0, void 0, void 0, config.runName);
        delete config.runId;
        let result;
        try {
          result = await this._call(parsed, runManager, config);
        } catch (e) {
          await runManager?.handleToolError(e);
          throw e;
        }
        let content;
        let artifact;
        if (this.responseFormat === "content_and_artifact") if (Array.isArray(result) && result.length === 2) [content, artifact] = result;
        else throw new Error(`Tool response format is "content_and_artifact" but the output was not a two-tuple.
Result: ${JSON.stringify(result)}`);
        else content = result;
        let toolCallId;
        if (require_utils10._isToolCall(arg)) toolCallId = arg.id;
        if (!toolCallId && require_utils10._configHasToolCallId(config)) toolCallId = config.toolCall.id;
        const formattedOutput = _formatToolOutput({
          content,
          artifact,
          toolCallId,
          name: this.name,
          metadata: this.metadata
        });
        await runManager?.handleToolEnd(formattedOutput);
        return formattedOutput;
      }
    };
    var Tool = class extends StructuredTool {
      schema = zod_v3.z.object({ input: zod_v3.z.string().optional() }).transform((obj) => obj.input);
      constructor(fields) {
        super(fields);
      }
      /**
      * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
      *
      * Calls the tool with the provided argument and callbacks. It handles
      * string inputs specifically.
      * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.
      * @param callbacks Optional callbacks for the tool.
      * @returns A Promise that resolves with a string.
      */
      call(arg, callbacks) {
        const structuredArg = typeof arg === "string" || arg == null ? { input: arg } : arg;
        return super.call(structuredArg, callbacks);
      }
    };
    var DynamicTool = class extends Tool {
      static lc_name() {
        return "DynamicTool";
      }
      name;
      description;
      func;
      constructor(fields) {
        super(fields);
        this.name = fields.name;
        this.description = fields.description;
        this.func = fields.func;
        this.returnDirect = fields.returnDirect ?? this.returnDirect;
      }
      /**
      * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
      */
      async call(arg, configArg) {
        const config = require_callbacks_manager.parseCallbackConfigArg(configArg);
        if (config.runName === void 0) config.runName = this.name;
        return super.call(arg, config);
      }
      /** @ignore */
      async _call(input, runManager, parentConfig) {
        return this.func(input, runManager, parentConfig);
      }
    };
    var DynamicStructuredTool = class extends StructuredTool {
      static lc_name() {
        return "DynamicStructuredTool";
      }
      name;
      description;
      func;
      schema;
      constructor(fields) {
        super(fields);
        this.name = fields.name;
        this.description = fields.description;
        this.func = fields.func;
        this.returnDirect = fields.returnDirect ?? this.returnDirect;
        this.schema = fields.schema;
      }
      /**
      * @deprecated Use .invoke() instead. Will be removed in 0.3.0.
      */
      async call(arg, configArg, tags) {
        const config = require_callbacks_manager.parseCallbackConfigArg(configArg);
        if (config.runName === void 0) config.runName = this.name;
        return super.call(arg, config, tags);
      }
      _call(arg, runManager, parentConfig) {
        return this.func(arg, runManager, parentConfig);
      }
    };
    var BaseToolkit = class {
      getTools() {
        return this.tools;
      }
    };
    function tool(func, fields) {
      const isSimpleStringSchema = require_zod3.isSimpleStringZodSchema(fields.schema);
      const isStringJSONSchema = require_utils_json_schema.validatesOnlyStrings(fields.schema);
      if (!fields.schema || isSimpleStringSchema || isStringJSONSchema) return new DynamicTool({
        ...fields,
        description: fields.description ?? fields.schema?.description ?? `${fields.name} tool`,
        func: async (input, runManager, config) => {
          return new Promise((resolve, reject) => {
            const childConfig = require_config3.patchConfig(config, { callbacks: runManager?.getChild() });
            require_index.AsyncLocalStorageProviderSingleton.runWithConfig(require_config3.pickRunnableConfigKeys(childConfig), async () => {
              try {
                resolve(func(input, childConfig));
              } catch (e) {
                reject(e);
              }
            });
          });
        }
      });
      const schema = fields.schema;
      const description = fields.description ?? fields.schema.description ?? `${fields.name} tool`;
      return new DynamicStructuredTool({
        ...fields,
        description,
        schema,
        func: async (input, runManager, config) => {
          return new Promise((resolve, reject) => {
            if (config?.signal) config.signal.addEventListener("abort", () => {
              return reject(require_signal2.getAbortSignalError(config.signal));
            });
            const childConfig = require_config3.patchConfig(config, { callbacks: runManager?.getChild() });
            require_index.AsyncLocalStorageProviderSingleton.runWithConfig(require_config3.pickRunnableConfigKeys(childConfig), async () => {
              try {
                const result = await func(input, childConfig);
                if (config?.signal?.aborted) return;
                resolve(result);
              } catch (e) {
                reject(e);
              }
            });
          });
        }
      });
    }
    function _formatToolOutput(params) {
      const { content, artifact, toolCallId, metadata } = params;
      if (toolCallId && !require_messages_tool.isDirectToolOutput(content)) if (typeof content === "string" || Array.isArray(content) && content.every((item) => typeof item === "object")) return new require_messages_tool.ToolMessage({
        status: "success",
        content,
        artifact,
        tool_call_id: toolCallId,
        name: params.name,
        metadata
      });
      else return new require_messages_tool.ToolMessage({
        status: "success",
        content: _stringify(content),
        artifact,
        tool_call_id: toolCallId,
        name: params.name,
        metadata
      });
      else return content;
    }
    function _stringify(content) {
      try {
        return JSON.stringify(content, null, 2) ?? "";
      } catch (_noOp) {
        return `${content}`;
      }
    }
    exports2.BaseToolkit = BaseToolkit;
    exports2.DynamicStructuredTool = DynamicStructuredTool;
    exports2.DynamicTool = DynamicTool;
    exports2.StructuredTool = StructuredTool;
    exports2.Tool = Tool;
    exports2.ToolInputParsingException = require_utils10.ToolInputParsingException;
    exports2.isLangChainTool = require_types10.isLangChainTool;
    exports2.isRunnableToolLike = require_types10.isRunnableToolLike;
    exports2.isStructuredTool = require_types10.isStructuredTool;
    exports2.isStructuredToolParams = require_types10.isStructuredToolParams;
    exports2.tool = tool;
    Object.defineProperty(exports2, "tools_exports", {
      enumerable: true,
      get: function() {
        return tools_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/transformers.cjs
var require_transformers = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/transformers.cjs"(exports2) {
    var require_base18 = require_base();
    var require_messages_tool = require_tool();
    var require_ai2 = require_ai();
    var require_chat3 = require_chat();
    var require_function3 = require_function();
    var require_human2 = require_human();
    var require_system2 = require_system();
    var require_modifier2 = require_modifier();
    var require_utils10 = require_utils3();
    var require_base$1 = require_base4();
    var _isMessageType = (msg, types) => {
      const typesAsStrings = [...new Set(types?.map((t) => {
        if (typeof t === "string") return t;
        const instantiatedMsgClass = new t({});
        if (!("getType" in instantiatedMsgClass) || typeof instantiatedMsgClass.getType !== "function") throw new Error("Invalid type provided.");
        return instantiatedMsgClass.getType();
      }))];
      const msgType = msg.getType();
      return typesAsStrings.some((t) => t === msgType);
    };
    function filterMessages(messagesOrOptions, options) {
      if (Array.isArray(messagesOrOptions)) return _filterMessages(messagesOrOptions, options);
      return require_base$1.RunnableLambda.from((input) => {
        return _filterMessages(input, messagesOrOptions);
      });
    }
    function _filterMessages(messages, options = {}) {
      const { includeNames, excludeNames, includeTypes, excludeTypes, includeIds, excludeIds } = options;
      const filtered = [];
      for (const msg of messages) {
        if (excludeNames && msg.name && excludeNames.includes(msg.name)) continue;
        else if (excludeTypes && _isMessageType(msg, excludeTypes)) continue;
        else if (excludeIds && msg.id && excludeIds.includes(msg.id)) continue;
        if (!(includeTypes || includeIds || includeNames)) filtered.push(msg);
        else if (includeNames && msg.name && includeNames.some((iName) => iName === msg.name)) filtered.push(msg);
        else if (includeTypes && _isMessageType(msg, includeTypes)) filtered.push(msg);
        else if (includeIds && msg.id && includeIds.some((id) => id === msg.id)) filtered.push(msg);
      }
      return filtered;
    }
    function mergeMessageRuns(messages) {
      if (Array.isArray(messages)) return _mergeMessageRuns(messages);
      return require_base$1.RunnableLambda.from(_mergeMessageRuns);
    }
    function _mergeMessageRuns(messages) {
      if (!messages.length) return [];
      const merged = [];
      for (const msg of messages) {
        const curr = msg;
        const last = merged.pop();
        if (!last) merged.push(curr);
        else if (curr.getType() === "tool" || !(curr.getType() === last.getType())) merged.push(last, curr);
        else {
          const lastChunk = require_utils10.convertToChunk(last);
          const currChunk = require_utils10.convertToChunk(curr);
          const mergedChunks = lastChunk.concat(currChunk);
          if (typeof lastChunk.content === "string" && typeof currChunk.content === "string") mergedChunks.content = `${lastChunk.content}
${currChunk.content}`;
          merged.push(_chunkToMsg(mergedChunks));
        }
      }
      return merged;
    }
    function trimMessages(messagesOrOptions, options) {
      if (Array.isArray(messagesOrOptions)) {
        const messages = messagesOrOptions;
        if (!options) throw new Error("Options parameter is required when providing messages.");
        return _trimMessagesHelper(messages, options);
      } else {
        const trimmerOptions = messagesOrOptions;
        return require_base$1.RunnableLambda.from((input) => _trimMessagesHelper(input, trimmerOptions)).withConfig({ runName: "trim_messages" });
      }
    }
    async function _trimMessagesHelper(messages, options) {
      const { maxTokens, tokenCounter, strategy = "last", allowPartial = false, endOn, startOn, includeSystem = false, textSplitter } = options;
      if (startOn && strategy === "first") throw new Error("`startOn` should only be specified if `strategy` is 'last'.");
      if (includeSystem && strategy === "first") throw new Error("`includeSystem` should only be specified if `strategy` is 'last'.");
      let listTokenCounter;
      if ("getNumTokens" in tokenCounter) listTokenCounter = async (msgs) => {
        const tokenCounts = await Promise.all(msgs.map((msg) => tokenCounter.getNumTokens(msg.content)));
        return tokenCounts.reduce((sum, count) => sum + count, 0);
      };
      else listTokenCounter = async (msgs) => tokenCounter(msgs);
      let textSplitterFunc = defaultTextSplitter;
      if (textSplitter) if ("splitText" in textSplitter) textSplitterFunc = textSplitter.splitText;
      else textSplitterFunc = async (text) => textSplitter(text);
      if (strategy === "first") return _firstMaxTokens(messages, {
        maxTokens,
        tokenCounter: listTokenCounter,
        textSplitter: textSplitterFunc,
        partialStrategy: allowPartial ? "first" : void 0,
        endOn
      });
      else if (strategy === "last") return _lastMaxTokens(messages, {
        maxTokens,
        tokenCounter: listTokenCounter,
        textSplitter: textSplitterFunc,
        allowPartial,
        includeSystem,
        startOn,
        endOn
      });
      else throw new Error(`Unrecognized strategy: '${strategy}'. Must be one of 'first' or 'last'.`);
    }
    async function _firstMaxTokens(messages, options) {
      const { maxTokens, tokenCounter, textSplitter, partialStrategy, endOn } = options;
      let messagesCopy = [...messages];
      let idx = 0;
      for (let i = 0; i < messagesCopy.length; i += 1) {
        const remainingMessages = i > 0 ? messagesCopy.slice(0, -i) : messagesCopy;
        if (await tokenCounter(remainingMessages) <= maxTokens) {
          idx = messagesCopy.length - i;
          break;
        }
      }
      if (idx < messagesCopy.length && partialStrategy) {
        let includedPartial = false;
        if (Array.isArray(messagesCopy[idx].content)) {
          const excluded = messagesCopy[idx];
          if (typeof excluded.content === "string") throw new Error("Expected content to be an array.");
          const numBlock = excluded.content.length;
          const reversedContent = partialStrategy === "last" ? [...excluded.content].reverse() : excluded.content;
          for (let i = 1; i <= numBlock; i += 1) {
            const partialContent = partialStrategy === "first" ? reversedContent.slice(0, i) : reversedContent.slice(-i);
            const fields = Object.fromEntries(Object.entries(excluded).filter(([k]) => k !== "type" && !k.startsWith("lc_")));
            const updatedMessage = _switchTypeToMessage(excluded.getType(), {
              ...fields,
              content: partialContent
            });
            const slicedMessages = [...messagesCopy.slice(0, idx), updatedMessage];
            if (await tokenCounter(slicedMessages) <= maxTokens) {
              messagesCopy = slicedMessages;
              idx += 1;
              includedPartial = true;
            } else break;
          }
          if (includedPartial && partialStrategy === "last") excluded.content = [...reversedContent].reverse();
        }
        if (!includedPartial) {
          const excluded = messagesCopy[idx];
          let text;
          if (Array.isArray(excluded.content) && excluded.content.some((block) => typeof block === "string" || block.type === "text")) {
            const textBlock = excluded.content.find((block) => block.type === "text" && block.text);
            text = textBlock?.text;
          } else if (typeof excluded.content === "string") text = excluded.content;
          if (text) {
            const splitTexts = await textSplitter(text);
            const numSplits = splitTexts.length;
            if (partialStrategy === "last") splitTexts.reverse();
            for (let _ = 0; _ < numSplits - 1; _ += 1) {
              splitTexts.pop();
              excluded.content = splitTexts.join("");
              if (await tokenCounter([...messagesCopy.slice(0, idx), excluded]) <= maxTokens) {
                if (partialStrategy === "last") excluded.content = [...splitTexts].reverse().join("");
                messagesCopy = [...messagesCopy.slice(0, idx), excluded];
                idx += 1;
                break;
              }
            }
          }
        }
      }
      if (endOn) {
        const endOnArr = Array.isArray(endOn) ? endOn : [endOn];
        while (idx > 0 && !_isMessageType(messagesCopy[idx - 1], endOnArr)) idx -= 1;
      }
      return messagesCopy.slice(0, idx);
    }
    async function _lastMaxTokens(messages, options) {
      const { allowPartial = false, includeSystem = false, endOn, startOn, ...rest } = options;
      let messagesCopy = messages.map((message) => {
        const fields = Object.fromEntries(Object.entries(message).filter(([k]) => k !== "type" && !k.startsWith("lc_")));
        return _switchTypeToMessage(message.getType(), fields, require_base18.isBaseMessageChunk(message));
      });
      if (endOn) {
        const endOnArr = Array.isArray(endOn) ? endOn : [endOn];
        while (messagesCopy.length > 0 && !_isMessageType(messagesCopy[messagesCopy.length - 1], endOnArr)) messagesCopy = messagesCopy.slice(0, -1);
      }
      const swappedSystem = includeSystem && messagesCopy[0]?.getType() === "system";
      let reversed_ = swappedSystem ? messagesCopy.slice(0, 1).concat(messagesCopy.slice(1).reverse()) : messagesCopy.reverse();
      reversed_ = await _firstMaxTokens(reversed_, {
        ...rest,
        partialStrategy: allowPartial ? "last" : void 0,
        endOn: startOn
      });
      if (swappedSystem) return [reversed_[0], ...reversed_.slice(1).reverse()];
      else return reversed_.reverse();
    }
    var _MSG_CHUNK_MAP = {
      human: {
        message: require_human2.HumanMessage,
        messageChunk: require_human2.HumanMessageChunk
      },
      ai: {
        message: require_ai2.AIMessage,
        messageChunk: require_ai2.AIMessageChunk
      },
      system: {
        message: require_system2.SystemMessage,
        messageChunk: require_system2.SystemMessageChunk
      },
      developer: {
        message: require_system2.SystemMessage,
        messageChunk: require_system2.SystemMessageChunk
      },
      tool: {
        message: require_messages_tool.ToolMessage,
        messageChunk: require_messages_tool.ToolMessageChunk
      },
      function: {
        message: require_function3.FunctionMessage,
        messageChunk: require_function3.FunctionMessageChunk
      },
      generic: {
        message: require_chat3.ChatMessage,
        messageChunk: require_chat3.ChatMessageChunk
      },
      remove: {
        message: require_modifier2.RemoveMessage,
        messageChunk: require_modifier2.RemoveMessage
      }
    };
    function _switchTypeToMessage(messageType, fields, returnChunk) {
      let chunk;
      let msg;
      switch (messageType) {
        case "human":
          if (returnChunk) chunk = new require_human2.HumanMessageChunk(fields);
          else msg = new require_human2.HumanMessage(fields);
          break;
        case "ai":
          if (returnChunk) {
            let aiChunkFields = { ...fields };
            if ("tool_calls" in aiChunkFields) aiChunkFields = {
              ...aiChunkFields,
              tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({
                ...tc,
                type: "tool_call_chunk",
                index: void 0,
                args: JSON.stringify(tc.args)
              }))
            };
            chunk = new require_ai2.AIMessageChunk(aiChunkFields);
          } else msg = new require_ai2.AIMessage(fields);
          break;
        case "system":
          if (returnChunk) chunk = new require_system2.SystemMessageChunk(fields);
          else msg = new require_system2.SystemMessage(fields);
          break;
        case "developer":
          if (returnChunk) chunk = new require_system2.SystemMessageChunk({
            ...fields,
            additional_kwargs: {
              ...fields.additional_kwargs,
              __openai_role__: "developer"
            }
          });
          else msg = new require_system2.SystemMessage({
            ...fields,
            additional_kwargs: {
              ...fields.additional_kwargs,
              __openai_role__: "developer"
            }
          });
          break;
        case "tool":
          if ("tool_call_id" in fields) if (returnChunk) chunk = new require_messages_tool.ToolMessageChunk(fields);
          else msg = new require_messages_tool.ToolMessage(fields);
          else throw new Error("Can not convert ToolMessage to ToolMessageChunk if 'tool_call_id' field is not defined.");
          break;
        case "function":
          if (returnChunk) chunk = new require_function3.FunctionMessageChunk(fields);
          else {
            if (!fields.name) throw new Error("FunctionMessage must have a 'name' field");
            msg = new require_function3.FunctionMessage(fields);
          }
          break;
        case "generic":
          if ("role" in fields) if (returnChunk) chunk = new require_chat3.ChatMessageChunk(fields);
          else msg = new require_chat3.ChatMessage(fields);
          else throw new Error("Can not convert ChatMessage to ChatMessageChunk if 'role' field is not defined.");
          break;
        default:
          throw new Error(`Unrecognized message type ${messageType}`);
      }
      if (returnChunk && chunk) return chunk;
      if (msg) return msg;
      throw new Error(`Unrecognized message type ${messageType}`);
    }
    function _chunkToMsg(chunk) {
      const chunkType = chunk.getType();
      let msg;
      const fields = Object.fromEntries(Object.entries(chunk).filter(([k]) => !["type", "tool_call_chunks"].includes(k) && !k.startsWith("lc_")));
      if (chunkType in _MSG_CHUNK_MAP) msg = _switchTypeToMessage(chunkType, fields);
      if (!msg) throw new Error(`Unrecognized message chunk class ${chunkType}. Supported classes are ${Object.keys(_MSG_CHUNK_MAP)}`);
      return msg;
    }
    function defaultTextSplitter(text) {
      const splits = text.split("\n");
      return Promise.resolve([...splits.slice(0, -1).map((s) => `${s}
`), splits[splits.length - 1]]);
    }
    exports2.defaultTextSplitter = defaultTextSplitter;
    exports2.filterMessages = filterMessages;
    exports2.mergeMessageRuns = mergeMessageRuns;
    exports2.trimMessages = trimMessages;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/content/tools.cjs
var require_tools2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/content/tools.cjs"(exports2) {
    var KNOWN_BLOCK_TYPES = [
      "tool_call",
      "tool_call_chunk",
      "invalid_tool_call",
      "server_tool_call",
      "server_tool_call_chunk",
      "server_tool_call_result"
    ];
    exports2.KNOWN_BLOCK_TYPES = KNOWN_BLOCK_TYPES;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/content/multimodal.cjs
var require_multimodal = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/content/multimodal.cjs"(exports2) {
    var KNOWN_BLOCK_TYPES = [
      "image",
      "video",
      "audio",
      "text-plain",
      "file"
    ];
    exports2.KNOWN_BLOCK_TYPES = KNOWN_BLOCK_TYPES;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/content/index.cjs
var require_content = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/content/index.cjs"(exports2) {
    var require_tools5 = require_tools2();
    var require_multimodal2 = require_multimodal();
    var KNOWN_BLOCK_TYPES$2 = [
      "text",
      "reasoning",
      ...require_tools5.KNOWN_BLOCK_TYPES,
      ...require_multimodal2.KNOWN_BLOCK_TYPES
    ];
    exports2.KNOWN_BLOCK_TYPES = KNOWN_BLOCK_TYPES$2;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/index.cjs
var require_messages2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/messages/index.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_data6 = require_data();
    var require_message3 = require_message();
    var require_base18 = require_base();
    var require_metadata2 = require_metadata();
    var require_messages_tool = require_tool();
    var require_ai2 = require_ai();
    var require_chat3 = require_chat();
    var require_function3 = require_function();
    var require_human2 = require_human();
    var require_system2 = require_system();
    var require_modifier2 = require_modifier();
    var require_utils10 = require_utils3();
    var require_transformers3 = require_transformers();
    var require_index = require_content();
    var messages_exports = {};
    require_rolldown_runtime5.__export(messages_exports, {
      AIMessage: () => require_ai2.AIMessage,
      AIMessageChunk: () => require_ai2.AIMessageChunk,
      BaseMessage: () => require_base18.BaseMessage,
      BaseMessageChunk: () => require_base18.BaseMessageChunk,
      ChatMessage: () => require_chat3.ChatMessage,
      ChatMessageChunk: () => require_chat3.ChatMessageChunk,
      FunctionMessage: () => require_function3.FunctionMessage,
      FunctionMessageChunk: () => require_function3.FunctionMessageChunk,
      HumanMessage: () => require_human2.HumanMessage,
      HumanMessageChunk: () => require_human2.HumanMessageChunk,
      KNOWN_BLOCK_TYPES: () => require_index.KNOWN_BLOCK_TYPES,
      RemoveMessage: () => require_modifier2.RemoveMessage,
      SystemMessage: () => require_system2.SystemMessage,
      SystemMessageChunk: () => require_system2.SystemMessageChunk,
      ToolMessage: () => require_messages_tool.ToolMessage,
      ToolMessageChunk: () => require_messages_tool.ToolMessageChunk,
      _isMessageFieldWithRole: () => require_base18._isMessageFieldWithRole,
      _mergeDicts: () => require_base18._mergeDicts,
      _mergeLists: () => require_base18._mergeLists,
      _mergeObj: () => require_base18._mergeObj,
      _mergeStatus: () => require_base18._mergeStatus,
      coerceMessageLikeToMessage: () => require_utils10.coerceMessageLikeToMessage,
      convertToChunk: () => require_utils10.convertToChunk,
      convertToOpenAIImageBlock: () => require_data6.convertToOpenAIImageBlock,
      convertToProviderContentBlock: () => require_data6.convertToProviderContentBlock,
      defaultTextSplitter: () => require_transformers3.defaultTextSplitter,
      defaultToolCallParser: () => require_messages_tool.defaultToolCallParser,
      filterMessages: () => require_transformers3.filterMessages,
      getBufferString: () => require_utils10.getBufferString,
      iife: () => require_utils10.iife,
      isAIMessage: () => require_ai2.isAIMessage,
      isAIMessageChunk: () => require_ai2.isAIMessageChunk,
      isBase64ContentBlock: () => require_data6.isBase64ContentBlock,
      isBaseMessage: () => require_base18.isBaseMessage,
      isBaseMessageChunk: () => require_base18.isBaseMessageChunk,
      isChatMessage: () => require_chat3.isChatMessage,
      isChatMessageChunk: () => require_chat3.isChatMessageChunk,
      isDataContentBlock: () => require_data6.isDataContentBlock,
      isDirectToolOutput: () => require_messages_tool.isDirectToolOutput,
      isFunctionMessage: () => require_function3.isFunctionMessage,
      isFunctionMessageChunk: () => require_function3.isFunctionMessageChunk,
      isHumanMessage: () => require_human2.isHumanMessage,
      isHumanMessageChunk: () => require_human2.isHumanMessageChunk,
      isIDContentBlock: () => require_data6.isIDContentBlock,
      isMessage: () => require_message3.isMessage,
      isOpenAIToolCallArray: () => require_base18.isOpenAIToolCallArray,
      isPlainTextContentBlock: () => require_data6.isPlainTextContentBlock,
      isSystemMessage: () => require_system2.isSystemMessage,
      isSystemMessageChunk: () => require_system2.isSystemMessageChunk,
      isToolMessage: () => require_messages_tool.isToolMessage,
      isToolMessageChunk: () => require_messages_tool.isToolMessageChunk,
      isURLContentBlock: () => require_data6.isURLContentBlock,
      mapChatMessagesToStoredMessages: () => require_utils10.mapChatMessagesToStoredMessages,
      mapStoredMessageToChatMessage: () => require_utils10.mapStoredMessageToChatMessage,
      mapStoredMessagesToChatMessages: () => require_utils10.mapStoredMessagesToChatMessages,
      mergeContent: () => require_base18.mergeContent,
      mergeMessageRuns: () => require_transformers3.mergeMessageRuns,
      mergeResponseMetadata: () => require_metadata2.mergeResponseMetadata,
      mergeUsageMetadata: () => require_metadata2.mergeUsageMetadata,
      parseBase64DataUrl: () => require_data6.parseBase64DataUrl,
      parseMimeType: () => require_data6.parseMimeType,
      trimMessages: () => require_transformers3.trimMessages
    });
    exports2.AIMessage = require_ai2.AIMessage;
    exports2.AIMessageChunk = require_ai2.AIMessageChunk;
    exports2.BaseMessage = require_base18.BaseMessage;
    exports2.BaseMessageChunk = require_base18.BaseMessageChunk;
    exports2.ChatMessage = require_chat3.ChatMessage;
    exports2.ChatMessageChunk = require_chat3.ChatMessageChunk;
    exports2.FunctionMessage = require_function3.FunctionMessage;
    exports2.FunctionMessageChunk = require_function3.FunctionMessageChunk;
    exports2.HumanMessage = require_human2.HumanMessage;
    exports2.HumanMessageChunk = require_human2.HumanMessageChunk;
    exports2.KNOWN_BLOCK_TYPES = require_index.KNOWN_BLOCK_TYPES;
    exports2.RemoveMessage = require_modifier2.RemoveMessage;
    exports2.SystemMessage = require_system2.SystemMessage;
    exports2.SystemMessageChunk = require_system2.SystemMessageChunk;
    exports2.ToolMessage = require_messages_tool.ToolMessage;
    exports2.ToolMessageChunk = require_messages_tool.ToolMessageChunk;
    exports2._isMessageFieldWithRole = require_base18._isMessageFieldWithRole;
    exports2._mergeDicts = require_base18._mergeDicts;
    exports2._mergeLists = require_base18._mergeLists;
    exports2._mergeObj = require_base18._mergeObj;
    exports2._mergeStatus = require_base18._mergeStatus;
    exports2.coerceMessageLikeToMessage = require_utils10.coerceMessageLikeToMessage;
    exports2.convertToChunk = require_utils10.convertToChunk;
    exports2.convertToOpenAIImageBlock = require_data6.convertToOpenAIImageBlock;
    exports2.convertToProviderContentBlock = require_data6.convertToProviderContentBlock;
    exports2.defaultTextSplitter = require_transformers3.defaultTextSplitter;
    exports2.defaultToolCallParser = require_messages_tool.defaultToolCallParser;
    exports2.filterMessages = require_transformers3.filterMessages;
    exports2.getBufferString = require_utils10.getBufferString;
    exports2.iife = require_utils10.iife;
    exports2.isAIMessage = require_ai2.isAIMessage;
    exports2.isAIMessageChunk = require_ai2.isAIMessageChunk;
    exports2.isBase64ContentBlock = require_data6.isBase64ContentBlock;
    exports2.isBaseMessage = require_base18.isBaseMessage;
    exports2.isBaseMessageChunk = require_base18.isBaseMessageChunk;
    exports2.isChatMessage = require_chat3.isChatMessage;
    exports2.isChatMessageChunk = require_chat3.isChatMessageChunk;
    exports2.isDataContentBlock = require_data6.isDataContentBlock;
    exports2.isDirectToolOutput = require_messages_tool.isDirectToolOutput;
    exports2.isFunctionMessage = require_function3.isFunctionMessage;
    exports2.isFunctionMessageChunk = require_function3.isFunctionMessageChunk;
    exports2.isHumanMessage = require_human2.isHumanMessage;
    exports2.isHumanMessageChunk = require_human2.isHumanMessageChunk;
    exports2.isIDContentBlock = require_data6.isIDContentBlock;
    exports2.isMessage = require_message3.isMessage;
    exports2.isOpenAIToolCallArray = require_base18.isOpenAIToolCallArray;
    exports2.isPlainTextContentBlock = require_data6.isPlainTextContentBlock;
    exports2.isSystemMessage = require_system2.isSystemMessage;
    exports2.isSystemMessageChunk = require_system2.isSystemMessageChunk;
    exports2.isToolMessage = require_messages_tool.isToolMessage;
    exports2.isToolMessageChunk = require_messages_tool.isToolMessageChunk;
    exports2.isURLContentBlock = require_data6.isURLContentBlock;
    exports2.mapChatMessagesToStoredMessages = require_utils10.mapChatMessagesToStoredMessages;
    exports2.mapStoredMessageToChatMessage = require_utils10.mapStoredMessageToChatMessage;
    exports2.mapStoredMessagesToChatMessages = require_utils10.mapStoredMessagesToChatMessages;
    exports2.mergeContent = require_base18.mergeContent;
    exports2.mergeMessageRuns = require_transformers3.mergeMessageRuns;
    exports2.mergeResponseMetadata = require_metadata2.mergeResponseMetadata;
    exports2.mergeUsageMetadata = require_metadata2.mergeUsageMetadata;
    Object.defineProperty(exports2, "messages_exports", {
      enumerable: true,
      get: function() {
        return messages_exports;
      }
    });
    exports2.parseBase64DataUrl = require_data6.parseBase64DataUrl;
    exports2.parseMimeType = require_data6.parseMimeType;
    exports2.trimMessages = require_transformers3.trimMessages;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/_virtual/rolldown_runtime.cjs
var require_rolldown_runtime3 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/_virtual/rolldown_runtime.cjs"(exports2) {
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames2(from), i = 0, n = keys.length, key; i < n; i++) {
        key = keys[i];
        if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: ((k) => from[k]).bind(null, key),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", {
      value: mod,
      enumerable: true
    }) : target, mod));
    exports2.__toESM = __toESM2;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/setup/async_local_storage.cjs
var require_async_local_storage2 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/setup/async_local_storage.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime3();
    var __langchain_core_singletons = require_rolldown_runtime5.__toESM(require_singletons());
    var node_async_hooks = require_rolldown_runtime5.__toESM(require("node:async_hooks"));
    function initializeAsyncLocalStorageSingleton() {
      __langchain_core_singletons.AsyncLocalStorageProviderSingleton.initializeGlobalInstance(new node_async_hooks.AsyncLocalStorage());
    }
    exports2.initializeAsyncLocalStorageSingleton = initializeAsyncLocalStorageSingleton;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/errors.cjs
var require_errors5 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/errors.cjs"(exports2) {
    var BaseLangGraphError = class extends Error {
      lc_error_code;
      constructor(message, fields) {
        let finalMessage = message ?? "";
        if (fields?.lc_error_code) finalMessage = `${finalMessage}

Troubleshooting URL: https://docs.langchain.com/oss/javascript/langgraph/${fields.lc_error_code}/
`;
        super(finalMessage);
        this.lc_error_code = fields?.lc_error_code;
      }
    };
    var GraphBubbleUp = class extends BaseLangGraphError {
      get is_bubble_up() {
        return true;
      }
    };
    var GraphRecursionError = class extends BaseLangGraphError {
      constructor(message, fields) {
        super(message, fields);
        this.name = "GraphRecursionError";
      }
      static get unminifiable_name() {
        return "GraphRecursionError";
      }
    };
    var GraphValueError = class extends BaseLangGraphError {
      constructor(message, fields) {
        super(message, fields);
        this.name = "GraphValueError";
      }
      static get unminifiable_name() {
        return "GraphValueError";
      }
    };
    var GraphInterrupt = class extends GraphBubbleUp {
      interrupts;
      constructor(interrupts, fields) {
        super(JSON.stringify(interrupts, null, 2), fields);
        this.name = "GraphInterrupt";
        this.interrupts = interrupts ?? [];
      }
      static get unminifiable_name() {
        return "GraphInterrupt";
      }
    };
    var NodeInterrupt = class extends GraphInterrupt {
      constructor(message, fields) {
        super([{ value: message }], fields);
        this.name = "NodeInterrupt";
      }
      static get unminifiable_name() {
        return "NodeInterrupt";
      }
    };
    var ParentCommand = class extends GraphBubbleUp {
      command;
      constructor(command) {
        super();
        this.name = "ParentCommand";
        this.command = command;
      }
      static get unminifiable_name() {
        return "ParentCommand";
      }
    };
    function isParentCommand(e) {
      return e !== void 0 && e.name === ParentCommand.unminifiable_name;
    }
    function isGraphBubbleUp(e) {
      return e !== void 0 && e.is_bubble_up === true;
    }
    function isGraphInterrupt(e) {
      return e !== void 0 && [GraphInterrupt.unminifiable_name, NodeInterrupt.unminifiable_name].includes(e.name);
    }
    var EmptyInputError = class extends BaseLangGraphError {
      constructor(message, fields) {
        super(message, fields);
        this.name = "EmptyInputError";
      }
      static get unminifiable_name() {
        return "EmptyInputError";
      }
    };
    var EmptyChannelError = class extends BaseLangGraphError {
      constructor(message, fields) {
        super(message, fields);
        this.name = "EmptyChannelError";
      }
      static get unminifiable_name() {
        return "EmptyChannelError";
      }
    };
    var InvalidUpdateError = class extends BaseLangGraphError {
      constructor(message, fields) {
        super(message, fields);
        this.name = "InvalidUpdateError";
      }
      static get unminifiable_name() {
        return "InvalidUpdateError";
      }
    };
    var MultipleSubgraphsError = class extends BaseLangGraphError {
      constructor(message, fields) {
        super(message, fields);
        this.name = "MultipleSubgraphError";
      }
      static get unminifiable_name() {
        return "MultipleSubgraphError";
      }
    };
    var UnreachableNodeError = class extends BaseLangGraphError {
      constructor(message, fields) {
        super(message, fields);
        this.name = "UnreachableNodeError";
      }
      static get unminifiable_name() {
        return "UnreachableNodeError";
      }
    };
    var RemoteException = class extends BaseLangGraphError {
      constructor(message, fields) {
        super(message, fields);
        this.name = "RemoteException";
      }
      static get unminifiable_name() {
        return "RemoteException";
      }
    };
    var getSubgraphsSeenSet = () => {
      if (globalThis[Symbol.for("LG_CHECKPOINT_SEEN_NS_SET")] === void 0) globalThis[Symbol.for("LG_CHECKPOINT_SEEN_NS_SET")] = /* @__PURE__ */ new Set();
      return globalThis[Symbol.for("LG_CHECKPOINT_SEEN_NS_SET")];
    };
    exports2.BaseLangGraphError = BaseLangGraphError;
    exports2.EmptyChannelError = EmptyChannelError;
    exports2.EmptyInputError = EmptyInputError;
    exports2.GraphBubbleUp = GraphBubbleUp;
    exports2.GraphInterrupt = GraphInterrupt;
    exports2.GraphRecursionError = GraphRecursionError;
    exports2.GraphValueError = GraphValueError;
    exports2.InvalidUpdateError = InvalidUpdateError;
    exports2.MultipleSubgraphsError = MultipleSubgraphsError;
    exports2.NodeInterrupt = NodeInterrupt;
    exports2.ParentCommand = ParentCommand;
    exports2.RemoteException = RemoteException;
    exports2.UnreachableNodeError = UnreachableNodeError;
    exports2.getSubgraphsSeenSet = getSubgraphsSeenSet;
    exports2.isGraphBubbleUp = isGraphBubbleUp;
    exports2.isGraphInterrupt = isGraphInterrupt;
    exports2.isParentCommand = isParentCommand;
  }
});

// node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/_virtual/rolldown_runtime.cjs
var require_rolldown_runtime4 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/_virtual/rolldown_runtime.cjs"(exports2) {
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames2(from), i = 0, n = keys.length, key; i < n; i++) {
        key = keys[i];
        if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: ((k) => from[k]).bind(null, key),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", {
      value: mod,
      enumerable: true
    }) : target, mod));
    exports2.__toESM = __toESM2;
  }
});

// node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/id.cjs
var require_id2 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/id.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime4();
    var uuid = require_rolldown_runtime5.__toESM((init_esm_node(), __toCommonJS(esm_node_exports)));
    function uuid6(clockseq) {
      return (0, uuid.v6)({ clockseq });
    }
    function uuid5(name, namespace) {
      const namespaceBytes = namespace.replace(/-/g, "").match(/.{2}/g).map((byte) => parseInt(byte, 16));
      return (0, uuid.v5)(name, new Uint8Array(namespaceBytes));
    }
    exports2.uuid5 = uuid5;
    exports2.uuid6 = uuid6;
  }
});

// node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/serde/types.cjs
var require_types5 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/serde/types.cjs"(exports2) {
    var TASKS = "__pregel_tasks";
    var ERROR2 = "__error__";
    var SCHEDULED = "__scheduled__";
    var INTERRUPT = "__interrupt__";
    var RESUME = "__resume__";
    exports2.ERROR = ERROR2;
    exports2.INTERRUPT = INTERRUPT;
    exports2.RESUME = RESUME;
    exports2.SCHEDULED = SCHEDULED;
    exports2.TASKS = TASKS;
  }
});

// node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/serde/utils/fast-safe-stringify/index.cjs
var require_fast_safe_stringify2 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/serde/utils/fast-safe-stringify/index.cjs"(exports2) {
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function stringify2(obj, replacer, spacer, options) {
      if (typeof options === "undefined") options = defaultOptions();
      decirc(obj, "", 0, [], void 0, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) res = JSON.stringify(obj, replacer, spacer);
        else res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) Object.defineProperty(part[0], part[1], part[3]);
          else part[0][part[1]] = part[2];
        }
      }
      return res;
    }
    function setReplace(replace, val, k, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
      if (propertyDescriptor.get !== void 0) if (propertyDescriptor.configurable) {
        Object.defineProperty(parent, k, { value: replace });
        arr.push([
          parent,
          k,
          val,
          propertyDescriptor
        ]);
      } else replacerStack.push([
        val,
        k,
        replace
      ]);
      else {
        parent[k] = replace;
        arr.push([
          parent,
          k,
          val
        ]);
      }
    }
    function decirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) if (stack[i] === val) {
          setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) for (i = 0; i < val.length; i++) decirc(val[i], i, i, stack, val, depth, options);
        else {
          var keys = Object.keys(val);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            decirc(val[key], key, i, stack, val, depth, options);
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
        return v;
      };
      return function(key, val) {
        if (replacerStack.length > 0) for (var i = 0; i < replacerStack.length; i++) {
          var part = replacerStack[i];
          if (part[1] === key && part[0] === val) {
            val = part[2];
            replacerStack.splice(i, 1);
            break;
          }
        }
        return replacer.call(this, key, val);
      };
    }
    exports2.stringify = stringify2;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/load/import_constants.cjs
var require_import_constants = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/load/import_constants.cjs"(exports2) {
    var optionalImportEntrypoints = [];
    exports2.optionalImportEntrypoints = optionalImportEntrypoints;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/agents.cjs
var require_agents = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/agents.cjs"(exports2) {
    var agents_exports = {};
    Object.defineProperty(exports2, "agents_exports", {
      enumerable: true,
      get: function() {
        return agents_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/chat_history.cjs
var require_chat_history = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/chat_history.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_load_serializable = require_serializable();
    var require_ai2 = require_ai();
    var require_human2 = require_human();
    require_messages2();
    var chat_history_exports = {};
    require_rolldown_runtime5.__export(chat_history_exports, {
      BaseChatMessageHistory: () => BaseChatMessageHistory,
      BaseListChatMessageHistory: () => BaseListChatMessageHistory,
      InMemoryChatMessageHistory: () => InMemoryChatMessageHistory
    });
    var BaseChatMessageHistory = class extends require_load_serializable.Serializable {
      /**
      * Add a list of messages.
      *
      * Implementations should override this method to handle bulk addition of messages
      * in an efficient manner to avoid unnecessary round-trips to the underlying store.
      *
      * @param messages - A list of BaseMessage objects to store.
      */
      async addMessages(messages) {
        for (const message of messages) await this.addMessage(message);
      }
    };
    var BaseListChatMessageHistory = class extends require_load_serializable.Serializable {
      /**
      * This is a convenience method for adding a human message string to the store.
      * Please note that this is a convenience method. Code should favor the
      * bulk addMessages interface instead to save on round-trips to the underlying
      * persistence layer.
      * This method may be deprecated in a future release.
      */
      addUserMessage(message) {
        return this.addMessage(new require_human2.HumanMessage(message));
      }
      /**
      * This is a convenience method for adding an AI message string to the store.
      * Please note that this is a convenience method. Code should favor the bulk
      * addMessages interface instead to save on round-trips to the underlying
      * persistence layer.
      * This method may be deprecated in a future release.
      */
      addAIMessage(message) {
        return this.addMessage(new require_ai2.AIMessage(message));
      }
      /**
      * Add a list of messages.
      *
      * Implementations should override this method to handle bulk addition of messages
      * in an efficient manner to avoid unnecessary round-trips to the underlying store.
      *
      * @param messages - A list of BaseMessage objects to store.
      */
      async addMessages(messages) {
        for (const message of messages) await this.addMessage(message);
      }
      /**
      * Remove all messages from the store.
      */
      clear() {
        throw new Error("Not implemented.");
      }
    };
    var InMemoryChatMessageHistory = class extends BaseListChatMessageHistory {
      lc_namespace = [
        "langchain",
        "stores",
        "message",
        "in_memory"
      ];
      messages = [];
      constructor(messages) {
        super(...arguments);
        this.messages = messages ?? [];
      }
      /**
      * Method to get all the messages stored in the ChatMessageHistory
      * instance.
      * @returns Array of stored BaseMessage instances.
      */
      async getMessages() {
        return this.messages;
      }
      /**
      * Method to add a new message to the ChatMessageHistory instance.
      * @param message The BaseMessage instance to add.
      * @returns A promise that resolves when the message has been added.
      */
      async addMessage(message) {
        this.messages.push(message);
      }
      /**
      * Method to clear all the messages from the ChatMessageHistory instance.
      * @returns A promise that resolves when all messages have been cleared.
      */
      async clear() {
        this.messages = [];
      }
    };
    exports2.BaseChatMessageHistory = BaseChatMessageHistory;
    exports2.BaseListChatMessageHistory = BaseListChatMessageHistory;
    exports2.InMemoryChatMessageHistory = InMemoryChatMessageHistory;
    Object.defineProperty(exports2, "chat_history_exports", {
      enumerable: true,
      get: function() {
        return chat_history_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/embeddings.cjs
var require_embeddings = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/embeddings.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_utils_async_caller = require_async_caller2();
    var embeddings_exports = {};
    require_rolldown_runtime5.__export(embeddings_exports, { Embeddings: () => Embeddings });
    var Embeddings = class {
      /**
      * The async caller should be used by subclasses to make any async calls,
      * which will thus benefit from the concurrency and retry logic.
      */
      caller;
      constructor(params) {
        this.caller = new require_utils_async_caller.AsyncCaller(params ?? {});
      }
    };
    exports2.Embeddings = Embeddings;
    Object.defineProperty(exports2, "embeddings_exports", {
      enumerable: true,
      get: function() {
        return embeddings_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/index.cjs
var require_dist3 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/index.cjs"(exports2) {
    var src_exports = {};
    Object.defineProperty(exports2, "src_exports", {
      enumerable: true,
      get: function() {
        return src_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/memory.cjs
var require_memory = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/memory.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var memory_exports = {};
    require_rolldown_runtime5.__export(memory_exports, {
      BaseMemory: () => BaseMemory,
      getInputValue: () => getInputValue,
      getOutputValue: () => getOutputValue,
      getPromptInputKey: () => getPromptInputKey
    });
    var BaseMemory = class {
    };
    var getValue = (values, key) => {
      if (key !== void 0) return values[key];
      const keys = Object.keys(values);
      if (keys.length === 1) return values[keys[0]];
    };
    var getInputValue = (inputValues, inputKey) => {
      const value = getValue(inputValues, inputKey);
      if (!value) {
        const keys = Object.keys(inputValues);
        throw new Error(`input values have ${keys.length} keys, you must specify an input key or pass only 1 key as input`);
      }
      return value;
    };
    var getOutputValue = (outputValues, outputKey) => {
      const value = getValue(outputValues, outputKey);
      if (!value && value !== "") {
        const keys = Object.keys(outputValues);
        throw new Error(`output values have ${keys.length} keys, you must specify an output key or pass only 1 key as output`);
      }
      return value;
    };
    function getPromptInputKey(inputs, memoryVariables) {
      const promptInputKeys = Object.keys(inputs).filter((key) => !memoryVariables.includes(key) && key !== "stop");
      if (promptInputKeys.length !== 1) throw new Error(`One input key expected, but got ${promptInputKeys.length}`);
      return promptInputKeys[0];
    }
    exports2.BaseMemory = BaseMemory;
    exports2.getInputValue = getInputValue;
    exports2.getOutputValue = getOutputValue;
    exports2.getPromptInputKey = getPromptInputKey;
    Object.defineProperty(exports2, "memory_exports", {
      enumerable: true,
      get: function() {
        return memory_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/stores.cjs
var require_stores = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/stores.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_load_serializable = require_serializable();
    var stores_exports = {};
    require_rolldown_runtime5.__export(stores_exports, {
      BaseStore: () => BaseStore,
      InMemoryStore: () => InMemoryStore
    });
    var BaseStore = class extends require_load_serializable.Serializable {
    };
    var InMemoryStore = class extends BaseStore {
      lc_namespace = ["langchain", "storage"];
      store = {};
      /**
      * Retrieves the values associated with the given keys from the store.
      * @param keys Keys to retrieve values for.
      * @returns Array of values associated with the given keys.
      */
      async mget(keys) {
        return keys.map((key) => this.store[key]);
      }
      /**
      * Sets the values for the given keys in the store.
      * @param keyValuePairs Array of key-value pairs to set in the store.
      * @returns Promise that resolves when all key-value pairs have been set.
      */
      async mset(keyValuePairs) {
        for (const [key, value] of keyValuePairs) this.store[key] = value;
      }
      /**
      * Deletes the given keys and their associated values from the store.
      * @param keys Keys to delete from the store.
      * @returns Promise that resolves when all keys have been deleted.
      */
      async mdelete(keys) {
        for (const key of keys) delete this.store[key];
      }
      /**
      * Asynchronous generator that yields keys from the store. If a prefix is
      * provided, it only yields keys that start with the prefix.
      * @param prefix Optional prefix to filter keys.
      * @returns AsyncGenerator that yields keys from the store.
      */
      async *yieldKeys(prefix) {
        const keys = Object.keys(this.store);
        for (const key of keys) if (prefix === void 0 || key.startsWith(prefix)) yield key;
      }
    };
    exports2.BaseStore = BaseStore;
    exports2.InMemoryStore = InMemoryStore;
    Object.defineProperty(exports2, "stores_exports", {
      enumerable: true,
      get: function() {
        return stores_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/retrievers/index.cjs
var require_retrievers = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/retrievers/index.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_callbacks_manager = require_manager();
    var require_config3 = require_config();
    var require_base18 = require_base4();
    var retrievers_exports = {};
    require_rolldown_runtime5.__export(retrievers_exports, { BaseRetriever: () => BaseRetriever });
    var BaseRetriever = class extends require_base18.Runnable {
      /**
      * Optional callbacks to handle various events in the retrieval process.
      */
      callbacks;
      /**
      * Tags to label or categorize the retrieval operation.
      */
      tags;
      /**
      * Metadata to provide additional context or information about the retrieval
      * operation.
      */
      metadata;
      /**
      * If set to `true`, enables verbose logging for the retrieval process.
      */
      verbose;
      /**
      * Constructs a new `BaseRetriever` instance with optional configuration fields.
      *
      * @param fields - Optional input configuration that can include `callbacks`,
      *                 `tags`, `metadata`, and `verbose` settings for custom retriever behavior.
      */
      constructor(fields) {
        super(fields);
        this.callbacks = fields?.callbacks;
        this.tags = fields?.tags ?? [];
        this.metadata = fields?.metadata ?? {};
        this.verbose = fields?.verbose ?? false;
      }
      /**
      * TODO: This should be an abstract method, but we'd like to avoid breaking
      * changes to people currently using subclassed custom retrievers.
      * Change it on next major release.
      */
      /**
      * Placeholder method for retrieving relevant documents based on a query.
      *
      * This method is intended to be implemented by subclasses and will be
      * converted to an abstract method in the next major release. Currently, it
      * throws an error if not implemented, ensuring that custom retrievers define
      * the specific retrieval logic.
      *
      * @param _query - The query string used to search for relevant documents.
      * @param _callbacks - (optional) Callback manager for managing callbacks
      *                     during retrieval.
      * @returns A promise resolving to an array of `DocumentInterface` instances relevant to the query.
      * @throws {Error} Throws an error indicating the method is not implemented.
      */
      _getRelevantDocuments(_query, _callbacks) {
        throw new Error("Not implemented!");
      }
      /**
      * Executes a retrieval operation.
      *
      * @param input - The query string used to search for relevant documents.
      * @param options - (optional) Configuration options for the retrieval run,
      *                  which may include callbacks, tags, and metadata.
      * @returns A promise that resolves to an array of `DocumentInterface` instances
      *          representing the most relevant documents to the query.
      */
      async invoke(input, options) {
        const parsedConfig = require_config3.ensureConfig(require_callbacks_manager.parseCallbackConfigArg(options));
        const callbackManager_ = await require_callbacks_manager.CallbackManager.configure(parsedConfig.callbacks, this.callbacks, parsedConfig.tags, this.tags, parsedConfig.metadata, this.metadata, { verbose: this.verbose });
        const runManager = await callbackManager_?.handleRetrieverStart(this.toJSON(), input, parsedConfig.runId, void 0, void 0, void 0, parsedConfig.runName);
        try {
          const results = await this._getRelevantDocuments(input, runManager);
          await runManager?.handleRetrieverEnd(results);
          return results;
        } catch (error) {
          await runManager?.handleRetrieverError(error);
          throw error;
        }
      }
    };
    exports2.BaseRetriever = BaseRetriever;
    Object.defineProperty(exports2, "retrievers_exports", {
      enumerable: true,
      get: function() {
        return retrievers_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/vectorstores.cjs
var require_vectorstores = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/vectorstores.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_load_serializable = require_serializable();
    var require_retrievers_index = require_retrievers();
    var vectorstores_exports = {};
    require_rolldown_runtime5.__export(vectorstores_exports, {
      SaveableVectorStore: () => SaveableVectorStore,
      VectorStore: () => VectorStore,
      VectorStoreRetriever: () => VectorStoreRetriever
    });
    var VectorStoreRetriever = class extends require_retrievers_index.BaseRetriever {
      static lc_name() {
        return "VectorStoreRetriever";
      }
      get lc_namespace() {
        return ["langchain_core", "vectorstores"];
      }
      /**
      * The instance of `VectorStore` used for storing and retrieving document embeddings.
      * This vector store must implement the `VectorStoreInterface` to be compatible
      * with the retrievers operations.
      */
      vectorStore;
      /**
      * Specifies the number of documents to retrieve for each search query.
      * Defaults to 4 if not specified, providing a basic result count for similarity or MMR searches.
      */
      k = 4;
      /**
      * Determines the type of search operation to perform on the vector store.
      *
      * - `"similarity"` (default): Conducts a similarity search based purely on vector similarity
      *   to the query.
      * - `"mmr"`: Executes a maximal marginal relevance (MMR) search, balancing relevance and
      *   diversity in the retrieved results.
      */
      searchType = "similarity";
      /**
      * Additional options specific to maximal marginal relevance (MMR) search, applicable
      * only if `searchType` is set to `"mmr"`.
      *
      * Includes:
      * - `fetchK`: The initial number of documents fetched before applying the MMR algorithm,
      *   allowing for a larger selection from which to choose the most diverse results.
      * - `lambda`: A parameter between 0 and 1 to adjust the relevance-diversity balance,
      *   where 0 prioritizes diversity and 1 prioritizes relevance.
      */
      searchKwargs;
      /**
      * Optional filter applied to search results, defined by the `FilterType` of the vector store.
      * Allows for refined, targeted results by restricting the returned documents based
      * on specified filter criteria.
      */
      filter;
      /**
      * Returns the type of vector store, as defined by the `vectorStore` instance.
      *
      * @returns {string} The vector store type.
      */
      _vectorstoreType() {
        return this.vectorStore._vectorstoreType();
      }
      /**
      * Initializes a new instance of `VectorStoreRetriever` with the specified configuration.
      *
      * This constructor configures the retriever to interact with a given `VectorStore`
      * and supports different retrieval strategies, including similarity search and maximal
      * marginal relevance (MMR) search. Various options allow customization of the number
      * of documents retrieved per query, filtering based on conditions, and fine-tuning
      * MMR-specific parameters.
      *
      * @param fields - Configuration options for setting up the retriever:
      *
      *   - `vectorStore` (required): The `VectorStore` instance implementing `VectorStoreInterface`
      *     that will be used to store and retrieve document embeddings. This is the core component
      *     of the retriever, enabling vector-based similarity and MMR searches.
      *
      *   - `k` (optional): Specifies the number of documents to retrieve per search query. If not
      *     provided, defaults to 4. This count determines the number of most relevant documents returned
      *     for each search operation, balancing performance with comprehensiveness.
      *
      *   - `searchType` (optional): Defines the search approach used by the retriever, allowing for
      *     flexibility between two methods:
      *       - `"similarity"` (default): A similarity-based search, retrieving documents with high vector
      *         similarity to the query. This type prioritizes relevance and is often used when diversity
      *         among results is less critical.
      *       - `"mmr"`: Maximal Marginal Relevance search, which combines relevance with diversity. MMR
      *         is useful for scenarios where varied content is essential, as it selects results that
      *         both match the query and introduce content diversity.
      *
      *   - `filter` (optional): A filter of type `FilterType`, defined by the vector store, that allows
      *     for refined and targeted search results. This filter applies specified conditions to limit
      *     which documents are eligible for retrieval, offering control over the scope of results.
      *
      *   - `searchKwargs` (optional, applicable only if `searchType` is `"mmr"`): Additional settings
      *     for configuring MMR-specific behavior. These parameters allow further tuning of the MMR
      *     search process:
      *       - `fetchK`: The initial number of documents fetched from the vector store before the MMR
      *         algorithm is applied. Fetching a larger set enables the algorithm to select a more
      *         diverse subset of documents.
      *       - `lambda`: A parameter controlling the relevance-diversity balance, where 0 emphasizes
      *         diversity and 1 prioritizes relevance. Intermediate values provide a blend of the two,
      *         allowing customization based on the importance of content variety relative to query relevance.
      */
      constructor(fields) {
        super(fields);
        this.vectorStore = fields.vectorStore;
        this.k = fields.k ?? this.k;
        this.searchType = fields.searchType ?? this.searchType;
        this.filter = fields.filter;
        if (fields.searchType === "mmr") this.searchKwargs = fields.searchKwargs;
      }
      /**
      * Retrieves relevant documents based on the specified query, using either
      * similarity or maximal marginal relevance (MMR) search.
      *
      * If `searchType` is set to `"mmr"`, performs an MMR search to balance
      * similarity and diversity among results. If `searchType` is `"similarity"`,
      * retrieves results purely based on similarity to the query.
      *
      * @param query - The query string used to find relevant documents.
      * @param runManager - Optional callback manager for tracking retrieval progress.
      * @returns A promise that resolves to an array of `DocumentInterface` instances
      *          representing the most relevant documents to the query.
      * @throws {Error} Throws an error if MMR search is requested but not supported
      *                 by the vector store.
      * @protected
      */
      async _getRelevantDocuments(query, runManager) {
        if (this.searchType === "mmr") {
          if (typeof this.vectorStore.maxMarginalRelevanceSearch !== "function") throw new Error(`The vector store backing this retriever, ${this._vectorstoreType()} does not support max marginal relevance search.`);
          return this.vectorStore.maxMarginalRelevanceSearch(query, {
            k: this.k,
            filter: this.filter,
            ...this.searchKwargs
          }, runManager?.getChild("vectorstore"));
        }
        return this.vectorStore.similaritySearch(query, this.k, this.filter, runManager?.getChild("vectorstore"));
      }
      /**
      * Adds an array of documents to the vector store, embedding them as part of
      * the storage process.
      *
      * This method delegates document embedding and storage to the `addDocuments`
      * method of the underlying vector store.
      *
      * @param documents - An array of documents to embed and add to the vector store.
      * @param options - Optional settings to customize document addition.
      * @returns A promise that resolves to an array of document IDs or `void`,
      *          depending on the vector store's implementation.
      */
      async addDocuments(documents, options) {
        return this.vectorStore.addDocuments(documents, options);
      }
    };
    var VectorStore = class extends require_load_serializable.Serializable {
      /**
      * Namespace within LangChain to uniquely identify this vector store's
      * location, based on the vector store type.
      *
      * @internal
      */
      lc_namespace = [
        "langchain",
        "vectorstores",
        this._vectorstoreType()
      ];
      /**
      * Embeddings interface for generating vector embeddings from text queries,
      * enabling vector-based similarity searches.
      */
      embeddings;
      /**
      * Initializes a new vector store with embeddings and database configuration.
      *
      * @param embeddings - Instance of `EmbeddingsInterface` used to embed queries.
      * @param dbConfig - Configuration settings for the database or storage system.
      */
      constructor(embeddings, dbConfig) {
        super(dbConfig);
        this.embeddings = embeddings;
      }
      /**
      * Deletes documents from the vector store based on the specified parameters.
      *
      * @param _params - Flexible key-value pairs defining conditions for document deletion.
      * @returns A promise that resolves once the deletion is complete.
      */
      async delete(_params) {
        throw new Error("Not implemented.");
      }
      /**
      * Searches for documents similar to a text query by embedding the query and
      * performing a similarity search on the resulting vector.
      *
      * @param query - Text query for finding similar documents.
      * @param k - Number of similar results to return. Defaults to 4.
      * @param filter - Optional filter based on `FilterType`.
      * @param _callbacks - Optional callbacks for monitoring search progress
      * @returns A promise resolving to an array of `DocumentInterface` instances representing similar documents.
      */
      async similaritySearch(query, k = 4, filter = void 0, _callbacks = void 0) {
        const results = await this.similaritySearchVectorWithScore(await this.embeddings.embedQuery(query), k, filter);
        return results.map((result) => result[0]);
      }
      /**
      * Searches for documents similar to a text query by embedding the query,
      * and returns results with similarity scores.
      *
      * @param query - Text query for finding similar documents.
      * @param k - Number of similar results to return. Defaults to 4.
      * @param filter - Optional filter based on `FilterType`.
      * @param _callbacks - Optional callbacks for monitoring search progress
      * @returns A promise resolving to an array of tuples, each containing a
      *          document and its similarity score.
      */
      async similaritySearchWithScore(query, k = 4, filter = void 0, _callbacks = void 0) {
        return this.similaritySearchVectorWithScore(await this.embeddings.embedQuery(query), k, filter);
      }
      /**
      * Creates a `VectorStore` instance from an array of text strings and optional
      * metadata, using the specified embeddings and database configuration.
      *
      * Subclasses must implement this method to define how text and metadata
      * are embedded and stored in the vector store. Throws an error if not overridden.
      *
      * @param _texts - Array of strings representing the text documents to be stored.
      * @param _metadatas - Metadata for the texts, either as an array (one for each text)
      *                     or a single object (applied to all texts).
      * @param _embeddings - Instance of `EmbeddingsInterface` to embed the texts.
      * @param _dbConfig - Database configuration settings.
      * @returns A promise that resolves to a new `VectorStore` instance.
      * @throws {Error} Throws an error if this method is not overridden by a subclass.
      */
      static fromTexts(_texts, _metadatas, _embeddings, _dbConfig) {
        throw new Error("the Langchain vectorstore implementation you are using forgot to override this, please report a bug");
      }
      /**
      * Creates a `VectorStore` instance from an array of documents, using the specified
      * embeddings and database configuration.
      *
      * Subclasses must implement this method to define how documents are embedded
      * and stored. Throws an error if not overridden.
      *
      * @param _docs - Array of `DocumentInterface` instances representing the documents to be stored.
      * @param _embeddings - Instance of `EmbeddingsInterface` to embed the documents.
      * @param _dbConfig - Database configuration settings.
      * @returns A promise that resolves to a new `VectorStore` instance.
      * @throws {Error} Throws an error if this method is not overridden by a subclass.
      */
      static fromDocuments(_docs, _embeddings, _dbConfig) {
        throw new Error("the Langchain vectorstore implementation you are using forgot to override this, please report a bug");
      }
      /**
      * Creates a `VectorStoreRetriever` instance with flexible configuration options.
      *
      * @param kOrFields
      *    - If a number is provided, it sets the `k` parameter (number of items to retrieve).
      *    - If an object is provided, it should contain various configuration options.
      * @param filter
      *    - Optional filter criteria to limit the items retrieved based on the specified filter type.
      * @param callbacks
      *    - Optional callbacks that may be triggered at specific stages of the retrieval process.
      * @param tags
      *    - Tags to categorize or label the `VectorStoreRetriever`. Defaults to an empty array if not provided.
      * @param metadata
      *    - Additional metadata as key-value pairs to add contextual information for the retrieval process.
      * @param verbose
      *    - If `true`, enables detailed logging for the retrieval process. Defaults to `false`.
      *
      * @returns
      *    - A configured `VectorStoreRetriever` instance based on the provided parameters.
      *
      * @example
      * Basic usage with a `k` value:
      * ```typescript
      * const retriever = myVectorStore.asRetriever(5);
      * ```
      *
      * Usage with a configuration object:
      * ```typescript
      * const retriever = myVectorStore.asRetriever({
      *   k: 10,
      *   filter: myFilter,
      *   tags: ['example', 'test'],
      *   verbose: true,
      *   searchType: 'mmr',
      *   searchKwargs: { alpha: 0.5 },
      * });
      * ```
      */
      asRetriever(kOrFields, filter, callbacks, tags, metadata, verbose) {
        if (typeof kOrFields === "number") return new VectorStoreRetriever({
          vectorStore: this,
          k: kOrFields,
          filter,
          tags: [...tags ?? [], this._vectorstoreType()],
          metadata,
          verbose,
          callbacks
        });
        else {
          const params = {
            vectorStore: this,
            k: kOrFields?.k,
            filter: kOrFields?.filter,
            tags: [...kOrFields?.tags ?? [], this._vectorstoreType()],
            metadata: kOrFields?.metadata,
            verbose: kOrFields?.verbose,
            callbacks: kOrFields?.callbacks,
            searchType: kOrFields?.searchType
          };
          if (kOrFields?.searchType === "mmr") return new VectorStoreRetriever({
            ...params,
            searchKwargs: kOrFields.searchKwargs
          });
          return new VectorStoreRetriever({ ...params });
        }
      }
    };
    var SaveableVectorStore = class extends VectorStore {
      /**
      * Loads a vector store instance from the specified directory, using the
      * provided embeddings to ensure compatibility.
      *
      * This static method reconstructs a `SaveableVectorStore` from previously
      * saved data. Implementations should interpret the saved data format to
      * recreate the vector store instance.
      *
      * @param _directory - The directory path from which the vector store
      * data will be loaded.
      * @param _embeddings - An instance of `EmbeddingsInterface` to align
      * the embeddings with the loaded vector data.
      * @returns A promise that resolves to a `SaveableVectorStore` instance
      * constructed from the saved data.
      */
      static load(_directory, _embeddings) {
        throw new Error("Not implemented");
      }
    };
    exports2.SaveableVectorStore = SaveableVectorStore;
    exports2.VectorStore = VectorStore;
    exports2.VectorStoreRetriever = VectorStoreRetriever;
    Object.defineProperty(exports2, "vectorstores_exports", {
      enumerable: true,
      get: function() {
        return vectorstores_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/document_loaders/base.cjs
var require_base7 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/document_loaders/base.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var base_exports = {};
    require_rolldown_runtime5.__export(base_exports, { BaseDocumentLoader: () => BaseDocumentLoader });
    var BaseDocumentLoader = class {
    };
    exports2.BaseDocumentLoader = BaseDocumentLoader;
    Object.defineProperty(exports2, "base_exports", {
      enumerable: true,
      get: function() {
        return base_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/document_loaders/langsmith.cjs
var require_langsmith2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/document_loaders/langsmith.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_document_loaders_base = require_base7();
    var langsmith = require_rolldown_runtime5.__toESM(require_langsmith());
    var langsmith_exports = {};
    require_rolldown_runtime5.__export(langsmith_exports, { LangSmithLoader: () => LangSmithLoader });
    var LangSmithLoader = class extends require_document_loaders_base.BaseDocumentLoader {
      datasetId;
      datasetName;
      exampleIds;
      asOf;
      splits;
      inlineS3Urls;
      offset;
      limit;
      metadata;
      filter;
      contentKey;
      formatContent;
      client;
      constructor(fields) {
        super();
        if (fields.client && fields.clientConfig) throw new Error("client and clientConfig cannot both be provided.");
        this.client = fields.client ?? new langsmith.Client(fields?.clientConfig);
        this.contentKey = fields.contentKey ? fields.contentKey.split(".") : [];
        this.formatContent = fields.formatContent ?? _stringify;
        this.datasetId = fields.datasetId;
        this.datasetName = fields.datasetName;
        this.exampleIds = fields.exampleIds;
        this.asOf = fields.asOf;
        this.splits = fields.splits;
        this.inlineS3Urls = fields.inlineS3Urls;
        this.offset = fields.offset;
        this.limit = fields.limit;
        this.metadata = fields.metadata;
        this.filter = fields.filter;
      }
      async load() {
        const documents = [];
        for await (const example of this.client.listExamples({
          datasetId: this.datasetId,
          datasetName: this.datasetName,
          exampleIds: this.exampleIds,
          asOf: this.asOf,
          splits: this.splits,
          inlineS3Urls: this.inlineS3Urls,
          offset: this.offset,
          limit: this.limit,
          metadata: this.metadata,
          filter: this.filter
        })) {
          let content = example.inputs;
          for (const key of this.contentKey) content = content[key];
          const contentStr = this.formatContent(content);
          const metadata = example;
          ["created_at", "modified_at"].forEach((k) => {
            if (k in metadata) {
              if (typeof metadata[k] === "object") metadata[k] = metadata[k].toString();
            }
          });
          documents.push({
            pageContent: contentStr,
            metadata
          });
        }
        return documents;
      }
    };
    function _stringify(x) {
      if (typeof x === "string") return x;
      else try {
        return JSON.stringify(x, null, 2);
      } catch {
        return String(x);
      }
    }
    exports2.LangSmithLoader = LangSmithLoader;
    Object.defineProperty(exports2, "langsmith_exports", {
      enumerable: true,
      get: function() {
        return langsmith_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/documents/document.cjs
var require_document = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/documents/document.cjs"(exports2) {
    var Document = class {
      pageContent;
      metadata;
      /**
      * An optional identifier for the document.
      *
      * Ideally this should be unique across the document collection and formatted
      * as a UUID, but this will not be enforced.
      */
      id;
      constructor(fields) {
        this.pageContent = fields.pageContent !== void 0 ? fields.pageContent.toString() : "";
        this.metadata = fields.metadata ?? {};
        this.id = fields.id;
      }
    };
    exports2.Document = Document;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/documents/transformers.cjs
var require_transformers2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/documents/transformers.cjs"(exports2) {
    var require_base18 = require_base4();
    var BaseDocumentTransformer = class extends require_base18.Runnable {
      lc_namespace = [
        "langchain_core",
        "documents",
        "transformers"
      ];
      /**
      * Method to invoke the document transformation. This method calls the
      * transformDocuments method with the provided input.
      * @param input The input documents to be transformed.
      * @param _options Optional configuration object to customize the behavior of callbacks.
      * @returns A Promise that resolves to the transformed documents.
      */
      invoke(input, _options) {
        return this.transformDocuments(input);
      }
    };
    var MappingDocumentTransformer = class extends BaseDocumentTransformer {
      async transformDocuments(documents) {
        const newDocuments = [];
        for (const document2 of documents) {
          const transformedDocument = await this._transformDocument(document2);
          newDocuments.push(transformedDocument);
        }
        return newDocuments;
      }
    };
    exports2.BaseDocumentTransformer = BaseDocumentTransformer;
    exports2.MappingDocumentTransformer = MappingDocumentTransformer;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/documents/index.cjs
var require_documents = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/documents/index.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_document2 = require_document();
    var require_transformers3 = require_transformers2();
    var documents_exports = {};
    require_rolldown_runtime5.__export(documents_exports, {
      BaseDocumentTransformer: () => require_transformers3.BaseDocumentTransformer,
      Document: () => require_document2.Document,
      MappingDocumentTransformer: () => require_transformers3.MappingDocumentTransformer
    });
    exports2.BaseDocumentTransformer = require_transformers3.BaseDocumentTransformer;
    exports2.Document = require_document2.Document;
    exports2.MappingDocumentTransformer = require_transformers3.MappingDocumentTransformer;
    Object.defineProperty(exports2, "documents_exports", {
      enumerable: true,
      get: function() {
        return documents_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/example_selectors/base.cjs
var require_base8 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/example_selectors/base.cjs"(exports2) {
    var require_load_serializable = require_serializable();
    var BaseExampleSelector = class extends require_load_serializable.Serializable {
      lc_namespace = [
        "langchain_core",
        "example_selectors",
        "base"
      ];
    };
    exports2.BaseExampleSelector = BaseExampleSelector;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/example_selectors/conditional.cjs
var require_conditional = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/example_selectors/conditional.cjs"(exports2) {
    var BasePromptSelector = class {
      /**
      * Asynchronous version of `getPrompt` that also accepts an options object
      * for partial variables.
      * @param llm The language model for which to get a prompt.
      * @param options Optional object for partial variables.
      * @returns A Promise that resolves to a prompt template.
      */
      async getPromptAsync(llm, options) {
        const prompt = this.getPrompt(llm);
        return prompt.partial(options?.partialVariables ?? {});
      }
    };
    var ConditionalPromptSelector = class extends BasePromptSelector {
      defaultPrompt;
      conditionals;
      constructor(default_prompt, conditionals = []) {
        super();
        this.defaultPrompt = default_prompt;
        this.conditionals = conditionals;
      }
      /**
      * Method that selects a prompt based on a set of conditions. If none of
      * the conditions are met, it returns the default prompt.
      * @param llm The language model for which to get a prompt.
      * @returns A prompt template.
      */
      getPrompt(llm) {
        for (const [condition, prompt] of this.conditionals) if (condition(llm)) return prompt;
        return this.defaultPrompt;
      }
    };
    function isLLM(llm) {
      return llm._modelType() === "base_llm";
    }
    function isChatModel(llm) {
      return llm._modelType() === "base_chat_model";
    }
    exports2.BasePromptSelector = BasePromptSelector;
    exports2.ConditionalPromptSelector = ConditionalPromptSelector;
    exports2.isChatModel = isChatModel;
    exports2.isLLM = isLLM;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/example_selectors/length_based.cjs
var require_length_based = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/example_selectors/length_based.cjs"(exports2) {
    var require_base18 = require_base8();
    function getLengthBased(text) {
      return text.split(/\n| /).length;
    }
    var LengthBasedExampleSelector = class LengthBasedExampleSelector2 extends require_base18.BaseExampleSelector {
      examples = [];
      examplePrompt;
      getTextLength = getLengthBased;
      maxLength = 2048;
      exampleTextLengths = [];
      constructor(data) {
        super(data);
        this.examplePrompt = data.examplePrompt;
        this.maxLength = data.maxLength ?? 2048;
        this.getTextLength = data.getTextLength ?? getLengthBased;
      }
      /**
      * Adds an example to the list of examples and calculates its length.
      * @param example The example to be added.
      * @returns Promise that resolves when the example has been added and its length calculated.
      */
      async addExample(example) {
        this.examples.push(example);
        const stringExample = await this.examplePrompt.format(example);
        this.exampleTextLengths.push(this.getTextLength(stringExample));
      }
      /**
      * Calculates the lengths of the examples.
      * @param v Array of lengths of the examples.
      * @param values Instance of LengthBasedExampleSelector.
      * @returns Promise that resolves with an array of lengths of the examples.
      */
      async calculateExampleTextLengths(v, values) {
        if (v.length > 0) return v;
        const { examples, examplePrompt } = values;
        const stringExamples = await Promise.all(examples.map((eg) => examplePrompt.format(eg)));
        return stringExamples.map((eg) => this.getTextLength(eg));
      }
      /**
      * Selects examples until the total length of the selected examples
      * reaches the maxLength.
      * @param inputVariables The input variables for the examples.
      * @returns Promise that resolves with an array of selected examples.
      */
      async selectExamples(inputVariables) {
        const inputs = Object.values(inputVariables).join(" ");
        let remainingLength = this.maxLength - this.getTextLength(inputs);
        let i = 0;
        const examples = [];
        while (remainingLength > 0 && i < this.examples.length) {
          const newLength = remainingLength - this.exampleTextLengths[i];
          if (newLength < 0) break;
          else {
            examples.push(this.examples[i]);
            remainingLength = newLength;
          }
          i += 1;
        }
        return examples;
      }
      /**
      * Creates a new instance of LengthBasedExampleSelector and adds a list of
      * examples to it.
      * @param examples Array of examples to be added.
      * @param args Input parameters for the LengthBasedExampleSelector.
      * @returns Promise that resolves with a new instance of LengthBasedExampleSelector with the examples added.
      */
      static async fromExamples(examples, args) {
        const selector = new LengthBasedExampleSelector2(args);
        await Promise.all(examples.map((eg) => selector.addExample(eg)));
        return selector;
      }
    };
    exports2.LengthBasedExampleSelector = LengthBasedExampleSelector;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/example_selectors/semantic_similarity.cjs
var require_semantic_similarity = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/example_selectors/semantic_similarity.cjs"(exports2) {
    var require_document2 = require_document();
    var require_base18 = require_base8();
    function sortedValues(values) {
      return Object.keys(values).sort().map((key) => values[key]);
    }
    var SemanticSimilarityExampleSelector = class SemanticSimilarityExampleSelector2 extends require_base18.BaseExampleSelector {
      vectorStoreRetriever;
      exampleKeys;
      inputKeys;
      constructor(data) {
        super(data);
        this.exampleKeys = data.exampleKeys;
        this.inputKeys = data.inputKeys;
        if (data.vectorStore !== void 0) this.vectorStoreRetriever = data.vectorStore.asRetriever({
          k: data.k ?? 4,
          filter: data.filter
        });
        else if (data.vectorStoreRetriever) this.vectorStoreRetriever = data.vectorStoreRetriever;
        else throw new Error(`You must specify one of "vectorStore" and "vectorStoreRetriever".`);
      }
      /**
      * Method that adds a new example to the vectorStore. The example is
      * converted to a string and added to the vectorStore as a document.
      * @param example The example to be added to the vectorStore.
      * @returns Promise that resolves when the example has been added to the vectorStore.
      */
      async addExample(example) {
        const inputKeys = this.inputKeys ?? Object.keys(example);
        const stringExample = sortedValues(inputKeys.reduce((acc, key) => ({
          ...acc,
          [key]: example[key]
        }), {})).join(" ");
        await this.vectorStoreRetriever.addDocuments([new require_document2.Document({
          pageContent: stringExample,
          metadata: example
        })]);
      }
      /**
      * Method that selects which examples to use based on semantic similarity.
      * It performs a similarity search in the vectorStore using the input
      * variables and returns the examples with the highest similarity.
      * @param inputVariables The input variables used for the similarity search.
      * @returns Promise that resolves with an array of the selected examples.
      */
      async selectExamples(inputVariables) {
        const inputKeys = this.inputKeys ?? Object.keys(inputVariables);
        const query = sortedValues(inputKeys.reduce((acc, key) => ({
          ...acc,
          [key]: inputVariables[key]
        }), {})).join(" ");
        const exampleDocs = await this.vectorStoreRetriever.invoke(query);
        const examples = exampleDocs.map((doc) => doc.metadata);
        if (this.exampleKeys) return examples.map((example) => this.exampleKeys.reduce((acc, key) => ({
          ...acc,
          [key]: example[key]
        }), {}));
        return examples;
      }
      /**
      * Static method that creates a new instance of
      * SemanticSimilarityExampleSelector. It takes a list of examples, an
      * instance of Embeddings, a VectorStore class, and an options object as
      * parameters. It converts the examples to strings, creates a VectorStore
      * from the strings and the embeddings, and returns a new
      * SemanticSimilarityExampleSelector with the created VectorStore and the
      * options provided.
      * @param examples The list of examples to be used.
      * @param embeddings The instance of Embeddings to be used.
      * @param vectorStoreCls The VectorStore class to be used.
      * @param options The options object for the SemanticSimilarityExampleSelector.
      * @returns Promise that resolves with a new instance of SemanticSimilarityExampleSelector.
      */
      static async fromExamples(examples, embeddings, vectorStoreCls, options = {}) {
        const inputKeys = options.inputKeys ?? null;
        const stringExamples = examples.map((example) => sortedValues(inputKeys ? inputKeys.reduce((acc, key) => ({
          ...acc,
          [key]: example[key]
        }), {}) : example).join(" "));
        const vectorStore = await vectorStoreCls.fromTexts(stringExamples, examples, embeddings, options);
        return new SemanticSimilarityExampleSelector2({
          vectorStore,
          k: options.k ?? 4,
          exampleKeys: options.exampleKeys,
          inputKeys: options.inputKeys
        });
      }
    };
    exports2.SemanticSimilarityExampleSelector = SemanticSimilarityExampleSelector;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/example_selectors/index.cjs
var require_example_selectors = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/example_selectors/index.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_base18 = require_base8();
    var require_conditional2 = require_conditional();
    var require_length_based2 = require_length_based();
    var require_semantic_similarity2 = require_semantic_similarity();
    var example_selectors_exports = {};
    require_rolldown_runtime5.__export(example_selectors_exports, {
      BaseExampleSelector: () => require_base18.BaseExampleSelector,
      BasePromptSelector: () => require_conditional2.BasePromptSelector,
      ConditionalPromptSelector: () => require_conditional2.ConditionalPromptSelector,
      LengthBasedExampleSelector: () => require_length_based2.LengthBasedExampleSelector,
      SemanticSimilarityExampleSelector: () => require_semantic_similarity2.SemanticSimilarityExampleSelector,
      isChatModel: () => require_conditional2.isChatModel,
      isLLM: () => require_conditional2.isLLM
    });
    exports2.BaseExampleSelector = require_base18.BaseExampleSelector;
    exports2.BasePromptSelector = require_conditional2.BasePromptSelector;
    exports2.ConditionalPromptSelector = require_conditional2.ConditionalPromptSelector;
    exports2.LengthBasedExampleSelector = require_length_based2.LengthBasedExampleSelector;
    exports2.SemanticSimilarityExampleSelector = require_semantic_similarity2.SemanticSimilarityExampleSelector;
    Object.defineProperty(exports2, "example_selectors_exports", {
      enumerable: true,
      get: function() {
        return example_selectors_exports;
      }
    });
    exports2.isChatModel = require_conditional2.isChatModel;
    exports2.isLLM = require_conditional2.isLLM;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/passthrough.cjs
var require_passthrough = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/passthrough.cjs"(exports2) {
    var require_config3 = require_config();
    var require_utils_stream = require_stream();
    var require_base18 = require_base4();
    var RunnablePassthrough = class extends require_base18.Runnable {
      static lc_name() {
        return "RunnablePassthrough";
      }
      lc_namespace = ["langchain_core", "runnables"];
      lc_serializable = true;
      func;
      constructor(fields) {
        super(fields);
        if (fields) this.func = fields.func;
      }
      async invoke(input, options) {
        const config = require_config3.ensureConfig(options);
        if (this.func) await this.func(input, config);
        return this._callWithConfig((input$1) => Promise.resolve(input$1), input, config);
      }
      async *transform(generator, options) {
        const config = require_config3.ensureConfig(options);
        let finalOutput;
        let finalOutputSupported = true;
        for await (const chunk of this._transformStreamWithConfig(generator, (input) => input, config)) {
          yield chunk;
          if (finalOutputSupported) if (finalOutput === void 0) finalOutput = chunk;
          else try {
            finalOutput = require_utils_stream.concat(finalOutput, chunk);
          } catch {
            finalOutput = void 0;
            finalOutputSupported = false;
          }
        }
        if (this.func && finalOutput !== void 0) await this.func(finalOutput, config);
      }
      /**
      * A runnable that assigns key-value pairs to the input.
      *
      * The example below shows how you could use it with an inline function.
      *
      * @example
      * ```typescript
      * const prompt =
      *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}
      * Question: {question}
      * SQL Query:`);
      *
      * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`
      * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.
      * // In this case, we're passing the schema.
      * const sqlQueryGeneratorChain = RunnableSequence.from([
      *   RunnablePassthrough.assign({
      *     schema: async () => db.getTableInfo(),
      *   }),
      *   prompt,
      *   new ChatOpenAI({ model: "gpt-4o-mini" }).withConfig({ stop: ["\nSQLResult:"] }),
      *   new StringOutputParser(),
      * ]);
      * const result = await sqlQueryGeneratorChain.invoke({
      *   question: "How many employees are there?",
      * });
      * ```
      */
      static assign(mapping) {
        return new require_base18.RunnableAssign(new require_base18.RunnableMap({ steps: mapping }));
      }
    };
    exports2.RunnablePassthrough = RunnablePassthrough;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/language_models/utils.cjs
var require_utils5 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/language_models/utils.cjs"(exports2) {
    var iife = (fn) => fn();
    function castStandardMessageContent(message) {
      const Cls = message.constructor;
      return new Cls({
        ...message,
        content: message.contentBlocks,
        response_metadata: {
          ...message.response_metadata,
          output_version: "v1"
        }
      });
    }
    exports2.castStandardMessageContent = castStandardMessageContent;
    exports2.iife = iife;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/language_models/chat_models.cjs
var require_chat_models = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/language_models/chat_models.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_data6 = require_data();
    var require_base18 = require_base();
    var require_ai2 = require_ai();
    var require_utils10 = require_utils3();
    var require_utils_env = require_env();
    var require_callbacks_base = require_base2();
    var require_callbacks_manager = require_manager();
    var require_utils_stream = require_stream();
    var require_outputs2 = require_outputs();
    var require_zod3 = require_zod();
    var require_utils_json_schema = require_json_schema2();
    var require_base$1 = require_base4();
    require_messages2();
    var require_language_models_base = require_base6();
    var require_passthrough2 = require_passthrough();
    var require_utils$1 = require_utils5();
    var chat_models_exports = {};
    require_rolldown_runtime5.__export(chat_models_exports, {
      BaseChatModel: () => BaseChatModel,
      SimpleChatModel: () => SimpleChatModel
    });
    function _formatForTracing(messages) {
      const messagesToTrace = [];
      for (const message of messages) {
        let messageToTrace = message;
        if (Array.isArray(message.content)) for (let idx = 0; idx < message.content.length; idx++) {
          const block = message.content[idx];
          if (require_data6.isURLContentBlock(block) || require_data6.isBase64ContentBlock(block)) {
            if (messageToTrace === message) messageToTrace = new message.constructor({
              ...messageToTrace,
              content: [
                ...message.content.slice(0, idx),
                require_data6.convertToOpenAIImageBlock(block),
                ...message.content.slice(idx + 1)
              ]
            });
          }
        }
        messagesToTrace.push(messageToTrace);
      }
      return messagesToTrace;
    }
    var BaseChatModel = class BaseChatModel2 extends require_language_models_base.BaseLanguageModel {
      lc_namespace = [
        "langchain",
        "chat_models",
        this._llmType()
      ];
      disableStreaming = false;
      outputVersion;
      get callKeys() {
        return [...super.callKeys, "outputVersion"];
      }
      constructor(fields) {
        super(fields);
        this.outputVersion = require_utils$1.iife(() => {
          const outputVersion = fields.outputVersion ?? require_utils_env.getEnvironmentVariable("LC_OUTPUT_VERSION");
          if (outputVersion && ["v0", "v1"].includes(outputVersion)) return outputVersion;
          return "v0";
        });
      }
      _separateRunnableConfigFromCallOptionsCompat(options) {
        const [runnableConfig, callOptions] = super._separateRunnableConfigFromCallOptions(options);
        callOptions.signal = runnableConfig.signal;
        return [runnableConfig, callOptions];
      }
      /**
      * Invokes the chat model with a single input.
      * @param input The input for the language model.
      * @param options The call options.
      * @returns A Promise that resolves to a BaseMessageChunk.
      */
      async invoke(input, options) {
        const promptValue = BaseChatModel2._convertInputToPromptValue(input);
        const result = await this.generatePrompt([promptValue], options, options?.callbacks);
        const chatGeneration = result.generations[0][0];
        return chatGeneration.message;
      }
      async *_streamResponseChunks(_messages, _options, _runManager) {
        throw new Error("Not implemented.");
      }
      async *_streamIterator(input, options) {
        if (this._streamResponseChunks === BaseChatModel2.prototype._streamResponseChunks || this.disableStreaming) yield this.invoke(input, options);
        else {
          const prompt = BaseChatModel2._convertInputToPromptValue(input);
          const messages = prompt.toChatMessages();
          const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(options);
          const inheritableMetadata = {
            ...runnableConfig.metadata,
            ...this.getLsParams(callOptions)
          };
          const callbackManager_ = await require_callbacks_manager.CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });
          const extra = {
            options: callOptions,
            invocation_params: this?.invocationParams(callOptions),
            batch_size: 1
          };
          const outputVersion = callOptions.outputVersion ?? this.outputVersion;
          const runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), [_formatForTracing(messages)], runnableConfig.runId, void 0, extra, void 0, void 0, runnableConfig.runName);
          let generationChunk;
          let llmOutput;
          try {
            for await (const chunk of this._streamResponseChunks(messages, callOptions, runManagers?.[0])) {
              if (chunk.message.id == null) {
                const runId = runManagers?.at(0)?.runId;
                if (runId != null) chunk.message._updateId(`run-${runId}`);
              }
              chunk.message.response_metadata = {
                ...chunk.generationInfo,
                ...chunk.message.response_metadata
              };
              if (outputVersion === "v1") yield require_utils$1.castStandardMessageContent(chunk.message);
              else yield chunk.message;
              if (!generationChunk) generationChunk = chunk;
              else generationChunk = generationChunk.concat(chunk);
              if (require_ai2.isAIMessageChunk(chunk.message) && chunk.message.usage_metadata !== void 0) llmOutput = { tokenUsage: {
                promptTokens: chunk.message.usage_metadata.input_tokens,
                completionTokens: chunk.message.usage_metadata.output_tokens,
                totalTokens: chunk.message.usage_metadata.total_tokens
              } };
            }
          } catch (err) {
            await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));
            throw err;
          }
          await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMEnd({
            generations: [[generationChunk]],
            llmOutput
          })));
        }
      }
      getLsParams(options) {
        const providerName = this.getName().startsWith("Chat") ? this.getName().replace("Chat", "") : this.getName();
        return {
          ls_model_type: "chat",
          ls_stop: options.stop,
          ls_provider: providerName
        };
      }
      /** @ignore */
      async _generateUncached(messages, parsedOptions, handledOptions, startedRunManagers) {
        const baseMessages = messages.map((messageList) => messageList.map(require_utils10.coerceMessageLikeToMessage));
        let runManagers;
        if (startedRunManagers !== void 0 && startedRunManagers.length === baseMessages.length) runManagers = startedRunManagers;
        else {
          const inheritableMetadata = {
            ...handledOptions.metadata,
            ...this.getLsParams(parsedOptions)
          };
          const callbackManager_ = await require_callbacks_manager.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });
          const extra = {
            options: parsedOptions,
            invocation_params: this?.invocationParams(parsedOptions),
            batch_size: 1
          };
          runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), baseMessages.map(_formatForTracing), handledOptions.runId, void 0, extra, void 0, void 0, handledOptions.runName);
        }
        const outputVersion = parsedOptions.outputVersion ?? this.outputVersion;
        const generations = [];
        const llmOutputs = [];
        const hasStreamingHandler = !!runManagers?.[0].handlers.find(require_callbacks_base.callbackHandlerPrefersStreaming);
        if (hasStreamingHandler && !this.disableStreaming && baseMessages.length === 1 && this._streamResponseChunks !== BaseChatModel2.prototype._streamResponseChunks) try {
          const stream = await this._streamResponseChunks(baseMessages[0], parsedOptions, runManagers?.[0]);
          let aggregated;
          let llmOutput;
          for await (const chunk of stream) {
            if (chunk.message.id == null) {
              const runId = runManagers?.at(0)?.runId;
              if (runId != null) chunk.message._updateId(`run-${runId}`);
            }
            if (aggregated === void 0) aggregated = chunk;
            else aggregated = require_utils_stream.concat(aggregated, chunk);
            if (require_ai2.isAIMessageChunk(chunk.message) && chunk.message.usage_metadata !== void 0) llmOutput = { tokenUsage: {
              promptTokens: chunk.message.usage_metadata.input_tokens,
              completionTokens: chunk.message.usage_metadata.output_tokens,
              totalTokens: chunk.message.usage_metadata.total_tokens
            } };
          }
          if (aggregated === void 0) throw new Error("Received empty response from chat model call.");
          generations.push([aggregated]);
          await runManagers?.[0].handleLLMEnd({
            generations,
            llmOutput
          });
        } catch (e) {
          await runManagers?.[0].handleLLMError(e);
          throw e;
        }
        else {
          const results = await Promise.allSettled(baseMessages.map(async (messageList, i) => {
            const generateResults = await this._generate(messageList, {
              ...parsedOptions,
              promptIndex: i
            }, runManagers?.[i]);
            if (outputVersion === "v1") for (const generation of generateResults.generations) generation.message = require_utils$1.castStandardMessageContent(generation.message);
            return generateResults;
          }));
          await Promise.all(results.map(async (pResult, i) => {
            if (pResult.status === "fulfilled") {
              const result = pResult.value;
              for (const generation of result.generations) {
                if (generation.message.id == null) {
                  const runId = runManagers?.at(0)?.runId;
                  if (runId != null) generation.message._updateId(`run-${runId}`);
                }
                generation.message.response_metadata = {
                  ...generation.generationInfo,
                  ...generation.message.response_metadata
                };
              }
              if (result.generations.length === 1) result.generations[0].message.response_metadata = {
                ...result.llmOutput,
                ...result.generations[0].message.response_metadata
              };
              generations[i] = result.generations;
              llmOutputs[i] = result.llmOutput;
              return runManagers?.[i]?.handleLLMEnd({
                generations: [result.generations],
                llmOutput: result.llmOutput
              });
            } else {
              await runManagers?.[i]?.handleLLMError(pResult.reason);
              return Promise.reject(pResult.reason);
            }
          }));
        }
        const output = {
          generations,
          llmOutput: llmOutputs.length ? this._combineLLMOutput?.(...llmOutputs) : void 0
        };
        Object.defineProperty(output, require_outputs2.RUN_KEY, {
          value: runManagers ? { runIds: runManagers?.map((manager) => manager.runId) } : void 0,
          configurable: true
        });
        return output;
      }
      async _generateCached({ messages, cache, llmStringKey, parsedOptions, handledOptions }) {
        const baseMessages = messages.map((messageList) => messageList.map(require_utils10.coerceMessageLikeToMessage));
        const inheritableMetadata = {
          ...handledOptions.metadata,
          ...this.getLsParams(parsedOptions)
        };
        const callbackManager_ = await require_callbacks_manager.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });
        const extra = {
          options: parsedOptions,
          invocation_params: this?.invocationParams(parsedOptions),
          batch_size: 1
        };
        const runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), baseMessages.map(_formatForTracing), handledOptions.runId, void 0, extra, void 0, void 0, handledOptions.runName);
        const missingPromptIndices = [];
        const results = await Promise.allSettled(baseMessages.map(async (baseMessage, index) => {
          const prompt = BaseChatModel2._convertInputToPromptValue(baseMessage).toString();
          const result = await cache.lookup(prompt, llmStringKey);
          if (result == null) missingPromptIndices.push(index);
          return result;
        }));
        const cachedResults = results.map((result, index) => ({
          result,
          runManager: runManagers?.[index]
        })).filter(({ result }) => result.status === "fulfilled" && result.value != null || result.status === "rejected");
        const outputVersion = parsedOptions.outputVersion ?? this.outputVersion;
        const generations = [];
        await Promise.all(cachedResults.map(async ({ result: promiseResult, runManager }, i) => {
          if (promiseResult.status === "fulfilled") {
            const result = promiseResult.value;
            generations[i] = result.map((result$1) => {
              if ("message" in result$1 && require_base18.isBaseMessage(result$1.message) && require_ai2.isAIMessage(result$1.message)) {
                result$1.message.usage_metadata = {
                  input_tokens: 0,
                  output_tokens: 0,
                  total_tokens: 0
                };
                if (outputVersion === "v1") result$1.message = require_utils$1.castStandardMessageContent(result$1.message);
              }
              result$1.generationInfo = {
                ...result$1.generationInfo,
                tokenUsage: {}
              };
              return result$1;
            });
            if (result.length) await runManager?.handleLLMNewToken(result[0].text);
            return runManager?.handleLLMEnd({ generations: [result] }, void 0, void 0, void 0, { cached: true });
          } else {
            await runManager?.handleLLMError(promiseResult.reason, void 0, void 0, void 0, { cached: true });
            return Promise.reject(promiseResult.reason);
          }
        }));
        const output = {
          generations,
          missingPromptIndices,
          startedRunManagers: runManagers
        };
        Object.defineProperty(output, require_outputs2.RUN_KEY, {
          value: runManagers ? { runIds: runManagers?.map((manager) => manager.runId) } : void 0,
          configurable: true
        });
        return output;
      }
      /**
      * Generates chat based on the input messages.
      * @param messages An array of arrays of BaseMessage instances.
      * @param options The call options or an array of stop sequences.
      * @param callbacks The callbacks for the language model.
      * @returns A Promise that resolves to an LLMResult.
      */
      async generate(messages, options, callbacks) {
        let parsedOptions;
        if (Array.isArray(options)) parsedOptions = { stop: options };
        else parsedOptions = options;
        const baseMessages = messages.map((messageList) => messageList.map(require_utils10.coerceMessageLikeToMessage));
        const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);
        runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;
        if (!this.cache) return this._generateUncached(baseMessages, callOptions, runnableConfig);
        const { cache } = this;
        const llmStringKey = this._getSerializedCacheKeyParametersForCall(callOptions);
        const { generations, missingPromptIndices, startedRunManagers } = await this._generateCached({
          messages: baseMessages,
          cache,
          llmStringKey,
          parsedOptions: callOptions,
          handledOptions: runnableConfig
        });
        let llmOutput = {};
        if (missingPromptIndices.length > 0) {
          const results = await this._generateUncached(missingPromptIndices.map((i) => baseMessages[i]), callOptions, runnableConfig, startedRunManagers !== void 0 ? missingPromptIndices.map((i) => startedRunManagers?.[i]) : void 0);
          await Promise.all(results.generations.map(async (generation, index) => {
            const promptIndex = missingPromptIndices[index];
            generations[promptIndex] = generation;
            const prompt = BaseChatModel2._convertInputToPromptValue(baseMessages[promptIndex]).toString();
            return cache.update(prompt, llmStringKey, generation);
          }));
          llmOutput = results.llmOutput ?? {};
        }
        return {
          generations,
          llmOutput
        };
      }
      /**
      * Get the parameters used to invoke the model
      */
      invocationParams(_options) {
        return {};
      }
      _modelType() {
        return "base_chat_model";
      }
      /**
      * Generates a prompt based on the input prompt values.
      * @param promptValues An array of BasePromptValue instances.
      * @param options The call options or an array of stop sequences.
      * @param callbacks The callbacks for the language model.
      * @returns A Promise that resolves to an LLMResult.
      */
      async generatePrompt(promptValues, options, callbacks) {
        const promptMessages = promptValues.map((promptValue) => promptValue.toChatMessages());
        return this.generate(promptMessages, options, callbacks);
      }
      withStructuredOutput(outputSchema, config) {
        if (typeof this.bindTools !== "function") throw new Error(`Chat model must implement ".bindTools()" to use withStructuredOutput.`);
        if (config?.strict) throw new Error(`"strict" mode is not supported for this model by default.`);
        const schema = outputSchema;
        const name = config?.name;
        const description = require_zod3.getSchemaDescription(schema) ?? "A function available to call.";
        const method = config?.method;
        const includeRaw = config?.includeRaw;
        if (method === "jsonMode") throw new Error(`Base withStructuredOutput implementation only supports "functionCalling" as a method.`);
        let functionName = name ?? "extract";
        let tools;
        if (require_zod3.isInteropZodSchema(schema)) tools = [{
          type: "function",
          function: {
            name: functionName,
            description,
            parameters: require_utils_json_schema.toJsonSchema(schema)
          }
        }];
        else {
          if ("name" in schema) functionName = schema.name;
          tools = [{
            type: "function",
            function: {
              name: functionName,
              description,
              parameters: schema
            }
          }];
        }
        const llm = this.bindTools(tools);
        const outputParser = require_base$1.RunnableLambda.from((input) => {
          if (!require_ai2.AIMessageChunk.isInstance(input)) throw new Error("Input is not an AIMessageChunk.");
          if (!input.tool_calls || input.tool_calls.length === 0) throw new Error("No tool calls found in the response.");
          const toolCall = input.tool_calls.find((tc) => tc.name === functionName);
          if (!toolCall) throw new Error(`No tool call found with name ${functionName}.`);
          return toolCall.args;
        });
        if (!includeRaw) return llm.pipe(outputParser).withConfig({ runName: "StructuredOutput" });
        const parserAssign = require_passthrough2.RunnablePassthrough.assign({ parsed: (input, config$1) => outputParser.invoke(input.raw, config$1) });
        const parserNone = require_passthrough2.RunnablePassthrough.assign({ parsed: () => null });
        const parsedWithFallback = parserAssign.withFallbacks({ fallbacks: [parserNone] });
        return require_base$1.RunnableSequence.from([{ raw: llm }, parsedWithFallback]).withConfig({ runName: "StructuredOutputRunnable" });
      }
    };
    var SimpleChatModel = class extends BaseChatModel {
      async _generate(messages, options, runManager) {
        const text = await this._call(messages, options, runManager);
        const message = new require_ai2.AIMessage(text);
        if (typeof message.content !== "string") throw new Error("Cannot generate with a simple chat model when output is not a string.");
        return { generations: [{
          text: message.content,
          message
        }] };
      }
    };
    exports2.BaseChatModel = BaseChatModel;
    exports2.SimpleChatModel = SimpleChatModel;
    Object.defineProperty(exports2, "chat_models_exports", {
      enumerable: true,
      get: function() {
        return chat_models_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/language_models/llms.cjs
var require_llms = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/language_models/llms.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_callbacks_base = require_base2();
    var require_callbacks_manager = require_manager();
    var require_utils_stream = require_stream();
    var require_outputs2 = require_outputs();
    var require_language_models_base = require_base6();
    var llms_exports = {};
    require_rolldown_runtime5.__export(llms_exports, {
      BaseLLM: () => BaseLLM,
      LLM: () => LLM
    });
    var BaseLLM = class BaseLLM2 extends require_language_models_base.BaseLanguageModel {
      lc_namespace = [
        "langchain",
        "llms",
        this._llmType()
      ];
      /**
      * This method takes an input and options, and returns a string. It
      * converts the input to a prompt value and generates a result based on
      * the prompt.
      * @param input Input for the LLM.
      * @param options Options for the LLM call.
      * @returns A string result based on the prompt.
      */
      async invoke(input, options) {
        const promptValue = BaseLLM2._convertInputToPromptValue(input);
        const result = await this.generatePrompt([promptValue], options, options?.callbacks);
        return result.generations[0][0].text;
      }
      async *_streamResponseChunks(_input, _options, _runManager) {
        throw new Error("Not implemented.");
      }
      _separateRunnableConfigFromCallOptionsCompat(options) {
        const [runnableConfig, callOptions] = super._separateRunnableConfigFromCallOptions(options);
        callOptions.signal = runnableConfig.signal;
        return [runnableConfig, callOptions];
      }
      async *_streamIterator(input, options) {
        if (this._streamResponseChunks === BaseLLM2.prototype._streamResponseChunks) yield this.invoke(input, options);
        else {
          const prompt = BaseLLM2._convertInputToPromptValue(input);
          const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(options);
          const callbackManager_ = await require_callbacks_manager.CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, runnableConfig.metadata, this.metadata, { verbose: this.verbose });
          const extra = {
            options: callOptions,
            invocation_params: this?.invocationParams(callOptions),
            batch_size: 1
          };
          const runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), [prompt.toString()], runnableConfig.runId, void 0, extra, void 0, void 0, runnableConfig.runName);
          let generation = new require_outputs2.GenerationChunk({ text: "" });
          try {
            for await (const chunk of this._streamResponseChunks(prompt.toString(), callOptions, runManagers?.[0])) {
              if (!generation) generation = chunk;
              else generation = generation.concat(chunk);
              if (typeof chunk.text === "string") yield chunk.text;
            }
          } catch (err) {
            await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));
            throw err;
          }
          await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMEnd({ generations: [[generation]] })));
        }
      }
      /**
      * This method takes prompt values, options, and callbacks, and generates
      * a result based on the prompts.
      * @param promptValues Prompt values for the LLM.
      * @param options Options for the LLM call.
      * @param callbacks Callbacks for the LLM call.
      * @returns An LLMResult based on the prompts.
      */
      async generatePrompt(promptValues, options, callbacks) {
        const prompts = promptValues.map((promptValue) => promptValue.toString());
        return this.generate(prompts, options, callbacks);
      }
      /**
      * Get the parameters used to invoke the model
      */
      invocationParams(_options) {
        return {};
      }
      _flattenLLMResult(llmResult) {
        const llmResults = [];
        for (let i = 0; i < llmResult.generations.length; i += 1) {
          const genList = llmResult.generations[i];
          if (i === 0) llmResults.push({
            generations: [genList],
            llmOutput: llmResult.llmOutput
          });
          else {
            const llmOutput = llmResult.llmOutput ? {
              ...llmResult.llmOutput,
              tokenUsage: {}
            } : void 0;
            llmResults.push({
              generations: [genList],
              llmOutput
            });
          }
        }
        return llmResults;
      }
      /** @ignore */
      async _generateUncached(prompts, parsedOptions, handledOptions, startedRunManagers) {
        let runManagers;
        if (startedRunManagers !== void 0 && startedRunManagers.length === prompts.length) runManagers = startedRunManagers;
        else {
          const callbackManager_ = await require_callbacks_manager.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, { verbose: this.verbose });
          const extra = {
            options: parsedOptions,
            invocation_params: this?.invocationParams(parsedOptions),
            batch_size: prompts.length
          };
          runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), prompts, handledOptions.runId, void 0, extra, void 0, void 0, handledOptions?.runName);
        }
        const hasStreamingHandler = !!runManagers?.[0].handlers.find(require_callbacks_base.callbackHandlerPrefersStreaming);
        let output;
        if (hasStreamingHandler && prompts.length === 1 && this._streamResponseChunks !== BaseLLM2.prototype._streamResponseChunks) try {
          const stream = await this._streamResponseChunks(prompts[0], parsedOptions, runManagers?.[0]);
          let aggregated;
          for await (const chunk of stream) if (aggregated === void 0) aggregated = chunk;
          else aggregated = require_utils_stream.concat(aggregated, chunk);
          if (aggregated === void 0) throw new Error("Received empty response from chat model call.");
          output = {
            generations: [[aggregated]],
            llmOutput: {}
          };
          await runManagers?.[0].handleLLMEnd(output);
        } catch (e) {
          await runManagers?.[0].handleLLMError(e);
          throw e;
        }
        else {
          try {
            output = await this._generate(prompts, parsedOptions, runManagers?.[0]);
          } catch (err) {
            await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));
            throw err;
          }
          const flattenedOutputs = this._flattenLLMResult(output);
          await Promise.all((runManagers ?? []).map((runManager, i) => runManager?.handleLLMEnd(flattenedOutputs[i])));
        }
        const runIds = runManagers?.map((manager) => manager.runId) || void 0;
        Object.defineProperty(output, require_outputs2.RUN_KEY, {
          value: runIds ? { runIds } : void 0,
          configurable: true
        });
        return output;
      }
      async _generateCached({ prompts, cache, llmStringKey, parsedOptions, handledOptions, runId }) {
        const callbackManager_ = await require_callbacks_manager.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, { verbose: this.verbose });
        const extra = {
          options: parsedOptions,
          invocation_params: this?.invocationParams(parsedOptions),
          batch_size: prompts.length
        };
        const runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), prompts, runId, void 0, extra, void 0, void 0, handledOptions?.runName);
        const missingPromptIndices = [];
        const results = await Promise.allSettled(prompts.map(async (prompt, index) => {
          const result = await cache.lookup(prompt, llmStringKey);
          if (result == null) missingPromptIndices.push(index);
          return result;
        }));
        const cachedResults = results.map((result, index) => ({
          result,
          runManager: runManagers?.[index]
        })).filter(({ result }) => result.status === "fulfilled" && result.value != null || result.status === "rejected");
        const generations = [];
        await Promise.all(cachedResults.map(async ({ result: promiseResult, runManager }, i) => {
          if (promiseResult.status === "fulfilled") {
            const result = promiseResult.value;
            generations[i] = result.map((result$1) => {
              result$1.generationInfo = {
                ...result$1.generationInfo,
                tokenUsage: {}
              };
              return result$1;
            });
            if (result.length) await runManager?.handleLLMNewToken(result[0].text);
            return runManager?.handleLLMEnd({ generations: [result] }, void 0, void 0, void 0, { cached: true });
          } else {
            await runManager?.handleLLMError(promiseResult.reason, void 0, void 0, void 0, { cached: true });
            return Promise.reject(promiseResult.reason);
          }
        }));
        const output = {
          generations,
          missingPromptIndices,
          startedRunManagers: runManagers
        };
        Object.defineProperty(output, require_outputs2.RUN_KEY, {
          value: runManagers ? { runIds: runManagers?.map((manager) => manager.runId) } : void 0,
          configurable: true
        });
        return output;
      }
      /**
      * Run the LLM on the given prompts and input, handling caching.
      */
      async generate(prompts, options, callbacks) {
        if (!Array.isArray(prompts)) throw new Error("Argument 'prompts' is expected to be a string[]");
        let parsedOptions;
        if (Array.isArray(options)) parsedOptions = { stop: options };
        else parsedOptions = options;
        const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);
        runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;
        if (!this.cache) return this._generateUncached(prompts, callOptions, runnableConfig);
        const { cache } = this;
        const llmStringKey = this._getSerializedCacheKeyParametersForCall(callOptions);
        const { generations, missingPromptIndices, startedRunManagers } = await this._generateCached({
          prompts,
          cache,
          llmStringKey,
          parsedOptions: callOptions,
          handledOptions: runnableConfig,
          runId: runnableConfig.runId
        });
        let llmOutput = {};
        if (missingPromptIndices.length > 0) {
          const results = await this._generateUncached(missingPromptIndices.map((i) => prompts[i]), callOptions, runnableConfig, startedRunManagers !== void 0 ? missingPromptIndices.map((i) => startedRunManagers?.[i]) : void 0);
          await Promise.all(results.generations.map(async (generation, index) => {
            const promptIndex = missingPromptIndices[index];
            generations[promptIndex] = generation;
            return cache.update(prompts[promptIndex], llmStringKey, generation);
          }));
          llmOutput = results.llmOutput ?? {};
        }
        return {
          generations,
          llmOutput
        };
      }
      /**
      * Get the identifying parameters of the LLM.
      */
      _identifyingParams() {
        return {};
      }
      _modelType() {
        return "base_llm";
      }
    };
    var LLM = class extends BaseLLM {
      async _generate(prompts, options, runManager) {
        const generations = await Promise.all(prompts.map((prompt, promptIndex) => this._call(prompt, {
          ...options,
          promptIndex
        }, runManager).then((text) => [{ text }])));
        return { generations };
      }
    };
    exports2.BaseLLM = BaseLLM;
    exports2.LLM = LLM;
    Object.defineProperty(exports2, "llms_exports", {
      enumerable: true,
      get: function() {
        return llms_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/indexing/record_manager.cjs
var require_record_manager = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/indexing/record_manager.cjs"(exports2) {
    var require_load_serializable = require_serializable();
    var UUIDV5_NAMESPACE = "10f90ea3-90a4-4962-bf75-83a0f3c1c62a";
    var RecordManager = class extends require_load_serializable.Serializable {
      lc_namespace = ["langchain", "recordmanagers"];
    };
    exports2.RecordManager = RecordManager;
    exports2.UUIDV5_NAMESPACE = UUIDV5_NAMESPACE;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/indexing/base.cjs
var require_base9 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/indexing/base.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_hash4 = require_hash();
    require_hash2();
    var require_document2 = require_document();
    var require_record_manager2 = require_record_manager();
    var uuid = require_rolldown_runtime5.__toESM((init_esm_node(), __toCommonJS(esm_node_exports)));
    var _HashedDocument = class {
      uid;
      hash_;
      contentHash;
      metadataHash;
      pageContent;
      metadata;
      keyEncoder = require_hash4.sha256;
      constructor(fields) {
        this.uid = fields.uid;
        this.pageContent = fields.pageContent;
        this.metadata = fields.metadata;
      }
      makeDefaultKeyEncoder(keyEncoderFn) {
        this.keyEncoder = keyEncoderFn;
      }
      calculateHashes() {
        const forbiddenKeys = [
          "hash_",
          "content_hash",
          "metadata_hash"
        ];
        for (const key of forbiddenKeys) if (key in this.metadata) throw new Error(`Metadata cannot contain key ${key} as it is reserved for internal use. Restricted keys: [${forbiddenKeys.join(", ")}]`);
        const contentHash = this._hashStringToUUID(this.pageContent);
        try {
          const metadataHash = this._hashNestedDictToUUID(this.metadata);
          this.contentHash = contentHash;
          this.metadataHash = metadataHash;
        } catch (e) {
          throw new Error(`Failed to hash metadata: ${e}. Please use a dict that can be serialized using json.`);
        }
        this.hash_ = this._hashStringToUUID(this.contentHash + this.metadataHash);
        if (!this.uid) this.uid = this.hash_;
      }
      toDocument() {
        return new require_document2.Document({
          pageContent: this.pageContent,
          metadata: this.metadata
        });
      }
      static fromDocument(document2, uid) {
        const doc = new this({
          pageContent: document2.pageContent,
          metadata: document2.metadata,
          uid: uid || document2.uid
        });
        doc.calculateHashes();
        return doc;
      }
      _hashStringToUUID(inputString) {
        const hash_value = this.keyEncoder(inputString);
        return (0, uuid.v5)(hash_value, require_record_manager2.UUIDV5_NAMESPACE);
      }
      _hashNestedDictToUUID(data) {
        const serialized_data = JSON.stringify(data, Object.keys(data).sort());
        const hash_value = this.keyEncoder(serialized_data);
        return (0, uuid.v5)(hash_value, require_record_manager2.UUIDV5_NAMESPACE);
      }
    };
    function _batch(size, iterable) {
      const batches = [];
      let currentBatch = [];
      iterable.forEach((item) => {
        currentBatch.push(item);
        if (currentBatch.length >= size) {
          batches.push(currentBatch);
          currentBatch = [];
        }
      });
      if (currentBatch.length > 0) batches.push(currentBatch);
      return batches;
    }
    function _deduplicateInOrder(hashedDocuments) {
      const seen = /* @__PURE__ */ new Set();
      const deduplicated = [];
      for (const hashedDoc of hashedDocuments) {
        if (!hashedDoc.hash_) throw new Error("Hashed document does not have a hash");
        if (!seen.has(hashedDoc.hash_)) {
          seen.add(hashedDoc.hash_);
          deduplicated.push(hashedDoc);
        }
      }
      return deduplicated;
    }
    function _getSourceIdAssigner(sourceIdKey) {
      if (sourceIdKey === null) return (_doc) => null;
      else if (typeof sourceIdKey === "string") return (doc) => doc.metadata[sourceIdKey];
      else if (typeof sourceIdKey === "function") return sourceIdKey;
      else throw new Error(`sourceIdKey should be null, a string or a function, got ${typeof sourceIdKey}`);
    }
    var _isBaseDocumentLoader = (arg) => {
      if ("load" in arg && typeof arg.load === "function" && "loadAndSplit" in arg && typeof arg.loadAndSplit === "function") return true;
      return false;
    };
    async function index(args) {
      const { docsSource, recordManager, vectorStore, options } = args;
      const { batchSize = 100, cleanup, sourceIdKey, cleanupBatchSize = 1e3, forceUpdate = false } = options ?? {};
      if (cleanup === "incremental" && !sourceIdKey) throw new Error("sourceIdKey is required when cleanup mode is incremental. Please provide through 'options.sourceIdKey'.");
      const docs = _isBaseDocumentLoader(docsSource) ? await docsSource.load() : docsSource;
      const sourceIdAssigner = _getSourceIdAssigner(sourceIdKey ?? null);
      const indexStartDt = await recordManager.getTime();
      let numAdded = 0;
      let numDeleted = 0;
      let numUpdated = 0;
      let numSkipped = 0;
      const batches = _batch(batchSize ?? 100, docs);
      for (const batch of batches) {
        const hashedDocs = _deduplicateInOrder(batch.map((doc) => _HashedDocument.fromDocument(doc)));
        const sourceIds = hashedDocs.map((doc) => sourceIdAssigner(doc));
        if (cleanup === "incremental") hashedDocs.forEach((_hashedDoc, index$1) => {
          const source = sourceIds[index$1];
          if (source === null) throw new Error("sourceIdKey must be provided when cleanup is incremental");
        });
        const batchExists = await recordManager.exists(hashedDocs.map((doc) => doc.uid));
        const uids = [];
        const docsToIndex = [];
        const docsToUpdate = [];
        const seenDocs = /* @__PURE__ */ new Set();
        hashedDocs.forEach((hashedDoc, i) => {
          const docExists = batchExists[i];
          if (docExists) if (forceUpdate) seenDocs.add(hashedDoc.uid);
          else {
            docsToUpdate.push(hashedDoc.uid);
            return;
          }
          uids.push(hashedDoc.uid);
          docsToIndex.push(hashedDoc.toDocument());
        });
        if (docsToUpdate.length > 0) {
          await recordManager.update(docsToUpdate, { timeAtLeast: indexStartDt });
          numSkipped += docsToUpdate.length;
        }
        if (docsToIndex.length > 0) {
          await vectorStore.addDocuments(docsToIndex, { ids: uids });
          numAdded += docsToIndex.length - seenDocs.size;
          numUpdated += seenDocs.size;
        }
        await recordManager.update(hashedDocs.map((doc) => doc.uid), {
          timeAtLeast: indexStartDt,
          groupIds: sourceIds
        });
        if (cleanup === "incremental") {
          sourceIds.forEach((sourceId) => {
            if (!sourceId) throw new Error("Source id cannot be null");
          });
          const uidsToDelete = await recordManager.listKeys({
            before: indexStartDt,
            groupIds: sourceIds
          });
          if (uidsToDelete.length > 0) {
            await vectorStore.delete({ ids: uidsToDelete });
            await recordManager.deleteKeys(uidsToDelete);
            numDeleted += uidsToDelete.length;
          }
        }
      }
      if (cleanup === "full") {
        let uidsToDelete = await recordManager.listKeys({
          before: indexStartDt,
          limit: cleanupBatchSize
        });
        while (uidsToDelete.length > 0) {
          await vectorStore.delete({ ids: uidsToDelete });
          await recordManager.deleteKeys(uidsToDelete);
          numDeleted += uidsToDelete.length;
          uidsToDelete = await recordManager.listKeys({
            before: indexStartDt,
            limit: cleanupBatchSize
          });
        }
      }
      return {
        numAdded,
        numDeleted,
        numUpdated,
        numSkipped
      };
    }
    exports2._HashedDocument = _HashedDocument;
    exports2._batch = _batch;
    exports2._deduplicateInOrder = _deduplicateInOrder;
    exports2._getSourceIdAssigner = _getSourceIdAssigner;
    exports2._isBaseDocumentLoader = _isBaseDocumentLoader;
    exports2.index = index;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/indexing/index.cjs
var require_indexing = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/indexing/index.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_record_manager2 = require_record_manager();
    var require_base18 = require_base9();
    var indexing_exports = {};
    require_rolldown_runtime5.__export(indexing_exports, {
      RecordManager: () => require_record_manager2.RecordManager,
      UUIDV5_NAMESPACE: () => require_record_manager2.UUIDV5_NAMESPACE,
      _HashedDocument: () => require_base18._HashedDocument,
      _batch: () => require_base18._batch,
      _deduplicateInOrder: () => require_base18._deduplicateInOrder,
      _getSourceIdAssigner: () => require_base18._getSourceIdAssigner,
      _isBaseDocumentLoader: () => require_base18._isBaseDocumentLoader,
      index: () => require_base18.index
    });
    exports2.RecordManager = require_record_manager2.RecordManager;
    exports2.UUIDV5_NAMESPACE = require_record_manager2.UUIDV5_NAMESPACE;
    exports2._HashedDocument = require_base18._HashedDocument;
    exports2._batch = require_base18._batch;
    exports2._deduplicateInOrder = require_base18._deduplicateInOrder;
    exports2._getSourceIdAssigner = require_base18._getSourceIdAssigner;
    exports2._isBaseDocumentLoader = require_base18._isBaseDocumentLoader;
    exports2.index = require_base18.index;
    Object.defineProperty(exports2, "indexing_exports", {
      enumerable: true,
      get: function() {
        return indexing_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/router.cjs
var require_router = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/router.cjs"(exports2) {
    var require_config3 = require_config();
    var require_base18 = require_base4();
    var RouterRunnable = class extends require_base18.Runnable {
      static lc_name() {
        return "RouterRunnable";
      }
      lc_namespace = ["langchain_core", "runnables"];
      lc_serializable = true;
      runnables;
      constructor(fields) {
        super(fields);
        this.runnables = fields.runnables;
      }
      async invoke(input, options) {
        const { key, input: actualInput } = input;
        const runnable = this.runnables[key];
        if (runnable === void 0) throw new Error(`No runnable associated with key "${key}".`);
        return runnable.invoke(actualInput, require_config3.ensureConfig(options));
      }
      async batch(inputs, options, batchOptions) {
        const keys = inputs.map((input) => input.key);
        const actualInputs = inputs.map((input) => input.input);
        const missingKey = keys.find((key) => this.runnables[key] === void 0);
        if (missingKey !== void 0) throw new Error(`One or more keys do not have a corresponding runnable.`);
        const runnables = keys.map((key) => this.runnables[key]);
        const optionsList = this._getOptionsList(options ?? {}, inputs.length);
        const maxConcurrency = optionsList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;
        const batchSize = maxConcurrency && maxConcurrency > 0 ? maxConcurrency : inputs.length;
        const batchResults = [];
        for (let i = 0; i < actualInputs.length; i += batchSize) {
          const batchPromises = actualInputs.slice(i, i + batchSize).map((actualInput, i$1) => runnables[i$1].invoke(actualInput, optionsList[i$1]));
          const batchResult = await Promise.all(batchPromises);
          batchResults.push(batchResult);
        }
        return batchResults.flat();
      }
      async stream(input, options) {
        const { key, input: actualInput } = input;
        const runnable = this.runnables[key];
        if (runnable === void 0) throw new Error(`No runnable associated with key "${key}".`);
        return runnable.stream(actualInput, options);
      }
    };
    exports2.RouterRunnable = RouterRunnable;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/branch.cjs
var require_branch = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/branch.cjs"(exports2) {
    var require_config3 = require_config();
    var require_utils_stream = require_stream();
    var require_base18 = require_base4();
    var RunnableBranch = class extends require_base18.Runnable {
      static lc_name() {
        return "RunnableBranch";
      }
      lc_namespace = ["langchain_core", "runnables"];
      lc_serializable = true;
      default;
      branches;
      constructor(fields) {
        super(fields);
        this.branches = fields.branches;
        this.default = fields.default;
      }
      /**
      * Convenience method for instantiating a RunnableBranch from
      * RunnableLikes (objects, functions, or Runnables).
      *
      * Each item in the input except for the last one should be a
      * tuple with two items. The first is a "condition" RunnableLike that
      * returns "true" if the second RunnableLike in the tuple should run.
      *
      * The final item in the input should be a RunnableLike that acts as a
      * default branch if no other branches match.
      *
      * @example
      * ```ts
      * import { RunnableBranch } from "@langchain/core/runnables";
      *
      * const branch = RunnableBranch.from([
      *   [(x: number) => x > 0, (x: number) => x + 1],
      *   [(x: number) => x < 0, (x: number) => x - 1],
      *   (x: number) => x
      * ]);
      * ```
      * @param branches An array where the every item except the last is a tuple of [condition, runnable]
      *   pairs. The last item is a default runnable which is invoked if no other condition matches.
      * @returns A new RunnableBranch.
      */
      static from(branches) {
        if (branches.length < 1) throw new Error("RunnableBranch requires at least one branch");
        const branchLikes = branches.slice(0, -1);
        const coercedBranches = branchLikes.map(([condition, runnable]) => [require_base18._coerceToRunnable(condition), require_base18._coerceToRunnable(runnable)]);
        const defaultBranch = require_base18._coerceToRunnable(branches[branches.length - 1]);
        return new this({
          branches: coercedBranches,
          default: defaultBranch
        });
      }
      async _invoke(input, config, runManager) {
        let result;
        for (let i = 0; i < this.branches.length; i += 1) {
          const [condition, branchRunnable] = this.branches[i];
          const conditionValue = await condition.invoke(input, require_config3.patchConfig(config, { callbacks: runManager?.getChild(`condition:${i + 1}`) }));
          if (conditionValue) {
            result = await branchRunnable.invoke(input, require_config3.patchConfig(config, { callbacks: runManager?.getChild(`branch:${i + 1}`) }));
            break;
          }
        }
        if (!result) result = await this.default.invoke(input, require_config3.patchConfig(config, { callbacks: runManager?.getChild("branch:default") }));
        return result;
      }
      async invoke(input, config = {}) {
        return this._callWithConfig(this._invoke, input, config);
      }
      async *_streamIterator(input, config) {
        const callbackManager_ = await require_config3.getCallbackManagerForConfig(config);
        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), require_base18._coerceToDict(input, "input"), config?.runId, void 0, void 0, void 0, config?.runName);
        let finalOutput;
        let finalOutputSupported = true;
        let stream;
        try {
          for (let i = 0; i < this.branches.length; i += 1) {
            const [condition, branchRunnable] = this.branches[i];
            const conditionValue = await condition.invoke(input, require_config3.patchConfig(config, { callbacks: runManager?.getChild(`condition:${i + 1}`) }));
            if (conditionValue) {
              stream = await branchRunnable.stream(input, require_config3.patchConfig(config, { callbacks: runManager?.getChild(`branch:${i + 1}`) }));
              for await (const chunk of stream) {
                yield chunk;
                if (finalOutputSupported) if (finalOutput === void 0) finalOutput = chunk;
                else try {
                  finalOutput = require_utils_stream.concat(finalOutput, chunk);
                } catch {
                  finalOutput = void 0;
                  finalOutputSupported = false;
                }
              }
              break;
            }
          }
          if (stream === void 0) {
            stream = await this.default.stream(input, require_config3.patchConfig(config, { callbacks: runManager?.getChild("branch:default") }));
            for await (const chunk of stream) {
              yield chunk;
              if (finalOutputSupported) if (finalOutput === void 0) finalOutput = chunk;
              else try {
                finalOutput = require_utils_stream.concat(finalOutput, chunk);
              } catch {
                finalOutput = void 0;
                finalOutputSupported = false;
              }
            }
          }
        } catch (e) {
          await runManager?.handleChainError(e);
          throw e;
        }
        await runManager?.handleChainEnd(finalOutput ?? {});
      }
    };
    exports2.RunnableBranch = RunnableBranch;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/history.cjs
var require_history = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/history.cjs"(exports2) {
    var require_base18 = require_base();
    var require_ai2 = require_ai();
    var require_human2 = require_human();
    var require_base$1 = require_base4();
    require_messages2();
    var require_passthrough2 = require_passthrough();
    var RunnableWithMessageHistory = class extends require_base$1.RunnableBinding {
      runnable;
      inputMessagesKey;
      outputMessagesKey;
      historyMessagesKey;
      getMessageHistory;
      constructor(fields) {
        let historyChain = require_base$1.RunnableLambda.from((input, options) => this._enterHistory(input, options ?? {})).withConfig({ runName: "loadHistory" });
        const messagesKey = fields.historyMessagesKey ?? fields.inputMessagesKey;
        if (messagesKey) historyChain = require_passthrough2.RunnablePassthrough.assign({ [messagesKey]: historyChain }).withConfig({ runName: "insertHistory" });
        const bound = historyChain.pipe(fields.runnable.withListeners({ onEnd: (run, config$1) => this._exitHistory(run, config$1 ?? {}) })).withConfig({ runName: "RunnableWithMessageHistory" });
        const config = fields.config ?? {};
        super({
          ...fields,
          config,
          bound
        });
        this.runnable = fields.runnable;
        this.getMessageHistory = fields.getMessageHistory;
        this.inputMessagesKey = fields.inputMessagesKey;
        this.outputMessagesKey = fields.outputMessagesKey;
        this.historyMessagesKey = fields.historyMessagesKey;
      }
      _getInputMessages(inputValue) {
        let parsedInputValue;
        if (typeof inputValue === "object" && !Array.isArray(inputValue) && !require_base18.isBaseMessage(inputValue)) {
          let key;
          if (this.inputMessagesKey) key = this.inputMessagesKey;
          else if (Object.keys(inputValue).length === 1) key = Object.keys(inputValue)[0];
          else key = "input";
          if (Array.isArray(inputValue[key]) && Array.isArray(inputValue[key][0])) parsedInputValue = inputValue[key][0];
          else parsedInputValue = inputValue[key];
        } else parsedInputValue = inputValue;
        if (typeof parsedInputValue === "string") return [new require_human2.HumanMessage(parsedInputValue)];
        else if (Array.isArray(parsedInputValue)) return parsedInputValue;
        else if (require_base18.isBaseMessage(parsedInputValue)) return [parsedInputValue];
        else throw new Error(`Expected a string, BaseMessage, or array of BaseMessages.
Got ${JSON.stringify(parsedInputValue, null, 2)}`);
      }
      _getOutputMessages(outputValue) {
        let parsedOutputValue;
        if (!Array.isArray(outputValue) && !require_base18.isBaseMessage(outputValue) && typeof outputValue !== "string") {
          let key;
          if (this.outputMessagesKey !== void 0) key = this.outputMessagesKey;
          else if (Object.keys(outputValue).length === 1) key = Object.keys(outputValue)[0];
          else key = "output";
          if (outputValue.generations !== void 0) parsedOutputValue = outputValue.generations[0][0].message;
          else parsedOutputValue = outputValue[key];
        } else parsedOutputValue = outputValue;
        if (typeof parsedOutputValue === "string") return [new require_ai2.AIMessage(parsedOutputValue)];
        else if (Array.isArray(parsedOutputValue)) return parsedOutputValue;
        else if (require_base18.isBaseMessage(parsedOutputValue)) return [parsedOutputValue];
        else throw new Error(`Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(parsedOutputValue, null, 2)}`);
      }
      async _enterHistory(input, kwargs) {
        const history = kwargs?.configurable?.messageHistory;
        const messages = await history.getMessages();
        if (this.historyMessagesKey === void 0) return messages.concat(this._getInputMessages(input));
        return messages;
      }
      async _exitHistory(run, config) {
        const history = config.configurable?.messageHistory;
        let inputs;
        if (Array.isArray(run.inputs) && Array.isArray(run.inputs[0])) inputs = run.inputs[0];
        else inputs = run.inputs;
        let inputMessages = this._getInputMessages(inputs);
        if (this.historyMessagesKey === void 0) {
          const existingMessages = await history.getMessages();
          inputMessages = inputMessages.slice(existingMessages.length);
        }
        const outputValue = run.outputs;
        if (!outputValue) throw new Error(`Output values from 'Run' undefined. Run: ${JSON.stringify(run, null, 2)}`);
        const outputMessages = this._getOutputMessages(outputValue);
        await history.addMessages([...inputMessages, ...outputMessages]);
      }
      async _mergeConfig(...configs) {
        const config = await super._mergeConfig(...configs);
        if (!config.configurable || !config.configurable.sessionId) {
          const exampleInput = { [this.inputMessagesKey ?? "input"]: "foo" };
          const exampleConfig = { configurable: { sessionId: "123" } };
          throw new Error(`sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()
eg. chain.invoke(${JSON.stringify(exampleInput)}, ${JSON.stringify(exampleConfig)})`);
        }
        const { sessionId } = config.configurable;
        config.configurable.messageHistory = await this.getMessageHistory(sessionId);
        return config;
      }
    };
    exports2.RunnableWithMessageHistory = RunnableWithMessageHistory;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/index.cjs
var require_runnables = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/runnables/index.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_config3 = require_config();
    var require_base18 = require_base4();
    var require_passthrough2 = require_passthrough();
    var require_router2 = require_router();
    var require_branch2 = require_branch();
    var require_history2 = require_history();
    var runnables_exports = {};
    require_rolldown_runtime5.__export(runnables_exports, {
      RouterRunnable: () => require_router2.RouterRunnable,
      Runnable: () => require_base18.Runnable,
      RunnableAssign: () => require_base18.RunnableAssign,
      RunnableBinding: () => require_base18.RunnableBinding,
      RunnableBranch: () => require_branch2.RunnableBranch,
      RunnableEach: () => require_base18.RunnableEach,
      RunnableLambda: () => require_base18.RunnableLambda,
      RunnableMap: () => require_base18.RunnableMap,
      RunnableParallel: () => require_base18.RunnableParallel,
      RunnablePassthrough: () => require_passthrough2.RunnablePassthrough,
      RunnablePick: () => require_base18.RunnablePick,
      RunnableRetry: () => require_base18.RunnableRetry,
      RunnableSequence: () => require_base18.RunnableSequence,
      RunnableToolLike: () => require_base18.RunnableToolLike,
      RunnableWithFallbacks: () => require_base18.RunnableWithFallbacks,
      RunnableWithMessageHistory: () => require_history2.RunnableWithMessageHistory,
      _coerceToRunnable: () => require_base18._coerceToRunnable,
      ensureConfig: () => require_config3.ensureConfig,
      getCallbackManagerForConfig: () => require_config3.getCallbackManagerForConfig,
      mergeConfigs: () => require_config3.mergeConfigs,
      patchConfig: () => require_config3.patchConfig,
      pickRunnableConfigKeys: () => require_config3.pickRunnableConfigKeys
    });
    exports2.RouterRunnable = require_router2.RouterRunnable;
    exports2.Runnable = require_base18.Runnable;
    exports2.RunnableAssign = require_base18.RunnableAssign;
    exports2.RunnableBinding = require_base18.RunnableBinding;
    exports2.RunnableBranch = require_branch2.RunnableBranch;
    exports2.RunnableEach = require_base18.RunnableEach;
    exports2.RunnableLambda = require_base18.RunnableLambda;
    exports2.RunnableMap = require_base18.RunnableMap;
    exports2.RunnableParallel = require_base18.RunnableParallel;
    exports2.RunnablePassthrough = require_passthrough2.RunnablePassthrough;
    exports2.RunnablePick = require_base18.RunnablePick;
    exports2.RunnableRetry = require_base18.RunnableRetry;
    exports2.RunnableSequence = require_base18.RunnableSequence;
    exports2.RunnableToolLike = require_base18.RunnableToolLike;
    exports2.RunnableWithFallbacks = require_base18.RunnableWithFallbacks;
    exports2.RunnableWithMessageHistory = require_history2.RunnableWithMessageHistory;
    exports2._coerceToRunnable = require_base18._coerceToRunnable;
    exports2.ensureConfig = require_config3.ensureConfig;
    exports2.getCallbackManagerForConfig = require_config3.getCallbackManagerForConfig;
    exports2.mergeConfigs = require_config3.mergeConfigs;
    exports2.patchConfig = require_config3.patchConfig;
    exports2.pickRunnableConfigKeys = require_config3.pickRunnableConfigKeys;
    Object.defineProperty(exports2, "runnables_exports", {
      enumerable: true,
      get: function() {
        return runnables_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/json_patch.cjs
var require_json_patch = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/json_patch.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_core6 = require_core3();
    var require_duplex2 = require_duplex();
    require_fast_json_patch();
    var json_patch_exports = {};
    require_rolldown_runtime5.__export(json_patch_exports, {
      applyPatch: () => require_core6.applyPatch,
      compare: () => require_duplex2.compare
    });
    exports2.applyPatch = require_core6.applyPatch;
    exports2.compare = require_duplex2.compare;
    Object.defineProperty(exports2, "json_patch_exports", {
      enumerable: true,
      get: function() {
        return json_patch_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/base.cjs
var require_base10 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/base.cjs"(exports2) {
    var require_index = require_errors4();
    var require_base18 = require_base4();
    require_runnables();
    var BaseLLMOutputParser = class extends require_base18.Runnable {
      /**
      * Parses the result of an LLM call with a given prompt. By default, it
      * simply calls `parseResult`.
      * @param generations The generations from an LLM call.
      * @param _prompt The prompt used in the LLM call.
      * @param callbacks Optional callbacks.
      * @returns A promise of the parsed output.
      */
      parseResultWithPrompt(generations, _prompt, callbacks) {
        return this.parseResult(generations, callbacks);
      }
      _baseMessageToString(message) {
        return typeof message.content === "string" ? message.content : this._baseMessageContentToString(message.content);
      }
      _baseMessageContentToString(content) {
        return JSON.stringify(content);
      }
      /**
      * Calls the parser with a given input and optional configuration options.
      * If the input is a string, it creates a generation with the input as
      * text and calls `parseResult`. If the input is a `BaseMessage`, it
      * creates a generation with the input as a message and the content of the
      * input as text, and then calls `parseResult`.
      * @param input The input to the parser, which can be a string or a `BaseMessage`.
      * @param options Optional configuration options.
      * @returns A promise of the parsed output.
      */
      async invoke(input, options) {
        if (typeof input === "string") return this._callWithConfig(async (input$1, options$1) => this.parseResult([{ text: input$1 }], options$1?.callbacks), input, {
          ...options,
          runType: "parser"
        });
        else return this._callWithConfig(async (input$1, options$1) => this.parseResult([{
          message: input$1,
          text: this._baseMessageToString(input$1)
        }], options$1?.callbacks), input, {
          ...options,
          runType: "parser"
        });
      }
    };
    var BaseOutputParser = class extends BaseLLMOutputParser {
      parseResult(generations, callbacks) {
        return this.parse(generations[0].text, callbacks);
      }
      async parseWithPrompt(text, _prompt, callbacks) {
        return this.parse(text, callbacks);
      }
      /**
      * Return the string type key uniquely identifying this class of parser
      */
      _type() {
        throw new Error("_type not implemented");
      }
    };
    var OutputParserException = class extends Error {
      llmOutput;
      observation;
      sendToLLM;
      constructor(message, llmOutput, observation, sendToLLM = false) {
        super(message);
        this.llmOutput = llmOutput;
        this.observation = observation;
        this.sendToLLM = sendToLLM;
        if (sendToLLM) {
          if (observation === void 0 || llmOutput === void 0) throw new Error("Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true");
        }
        require_index.addLangChainErrorFields(this, "OUTPUT_PARSING_FAILURE");
      }
    };
    exports2.BaseLLMOutputParser = BaseLLMOutputParser;
    exports2.BaseOutputParser = BaseOutputParser;
    exports2.OutputParserException = OutputParserException;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/transform.cjs
var require_transform = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/transform.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_base18 = require_base();
    var require_utils10 = require_utils3();
    var require_outputs2 = require_outputs();
    var require_base$1 = require_base10();
    var __cfworker_json_schema = require_rolldown_runtime5.__toESM(require_commonjs());
    var BaseTransformOutputParser = class extends require_base$1.BaseOutputParser {
      async *_transform(inputGenerator) {
        for await (const chunk of inputGenerator) if (typeof chunk === "string") yield this.parseResult([{ text: chunk }]);
        else yield this.parseResult([{
          message: chunk,
          text: this._baseMessageToString(chunk)
        }]);
      }
      /**
      * Transforms an asynchronous generator of input into an asynchronous
      * generator of parsed output.
      * @param inputGenerator An asynchronous generator of input.
      * @param options A configuration object.
      * @returns An asynchronous generator of parsed output.
      */
      async *transform(inputGenerator, options) {
        yield* this._transformStreamWithConfig(inputGenerator, this._transform.bind(this), {
          ...options,
          runType: "parser"
        });
      }
    };
    var BaseCumulativeTransformOutputParser = class extends BaseTransformOutputParser {
      diff = false;
      constructor(fields) {
        super(fields);
        this.diff = fields?.diff ?? this.diff;
      }
      async *_transform(inputGenerator) {
        let prevParsed;
        let accGen;
        for await (const chunk of inputGenerator) {
          if (typeof chunk !== "string" && typeof chunk.content !== "string") throw new Error("Cannot handle non-string output.");
          let chunkGen;
          if (require_base18.isBaseMessageChunk(chunk)) {
            if (typeof chunk.content !== "string") throw new Error("Cannot handle non-string message output.");
            chunkGen = new require_outputs2.ChatGenerationChunk({
              message: chunk,
              text: chunk.content
            });
          } else if (require_base18.isBaseMessage(chunk)) {
            if (typeof chunk.content !== "string") throw new Error("Cannot handle non-string message output.");
            chunkGen = new require_outputs2.ChatGenerationChunk({
              message: require_utils10.convertToChunk(chunk),
              text: chunk.content
            });
          } else chunkGen = new require_outputs2.GenerationChunk({ text: chunk });
          if (accGen === void 0) accGen = chunkGen;
          else accGen = accGen.concat(chunkGen);
          const parsed = await this.parsePartialResult([accGen]);
          if (parsed !== void 0 && parsed !== null && !(0, __cfworker_json_schema.deepCompareStrict)(parsed, prevParsed)) {
            if (this.diff) yield this._diff(prevParsed, parsed);
            else yield parsed;
            prevParsed = parsed;
          }
        }
      }
      getFormatInstructions() {
        return "";
      }
    };
    exports2.BaseCumulativeTransformOutputParser = BaseCumulativeTransformOutputParser;
    exports2.BaseTransformOutputParser = BaseTransformOutputParser;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/bytes.cjs
var require_bytes = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/bytes.cjs"(exports2) {
    var require_transform2 = require_transform();
    var BytesOutputParser = class extends require_transform2.BaseTransformOutputParser {
      static lc_name() {
        return "BytesOutputParser";
      }
      lc_namespace = [
        "langchain_core",
        "output_parsers",
        "bytes"
      ];
      lc_serializable = true;
      textEncoder = new TextEncoder();
      parse(text) {
        return Promise.resolve(this.textEncoder.encode(text));
      }
      getFormatInstructions() {
        return "";
      }
    };
    exports2.BytesOutputParser = BytesOutputParser;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/list.cjs
var require_list = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/list.cjs"(exports2) {
    var require_base18 = require_base10();
    var require_transform2 = require_transform();
    var ListOutputParser = class extends require_transform2.BaseTransformOutputParser {
      re;
      async *_transform(inputGenerator) {
        let buffer = "";
        for await (const input of inputGenerator) {
          if (typeof input === "string") buffer += input;
          else buffer += input.content;
          if (!this.re) {
            const parts = await this.parse(buffer);
            if (parts.length > 1) {
              for (const part of parts.slice(0, -1)) yield [part];
              buffer = parts[parts.length - 1];
            }
          } else {
            const matches = [...buffer.matchAll(this.re)];
            if (matches.length > 1) {
              let doneIdx = 0;
              for (const match of matches.slice(0, -1)) {
                yield [match[1]];
                doneIdx += (match.index ?? 0) + match[0].length;
              }
              buffer = buffer.slice(doneIdx);
            }
          }
        }
        for (const part of await this.parse(buffer)) yield [part];
      }
    };
    var CommaSeparatedListOutputParser = class extends ListOutputParser {
      static lc_name() {
        return "CommaSeparatedListOutputParser";
      }
      lc_namespace = [
        "langchain_core",
        "output_parsers",
        "list"
      ];
      lc_serializable = true;
      /**
      * Parses the given text into an array of strings, using a comma as the
      * separator. If the parsing fails, throws an OutputParserException.
      * @param text The text to parse.
      * @returns An array of strings obtained by splitting the input text at each comma.
      */
      async parse(text) {
        try {
          return text.trim().split(",").map((s) => s.trim());
        } catch {
          throw new require_base18.OutputParserException(`Could not parse output: ${text}`, text);
        }
      }
      /**
      * Provides instructions on the expected format of the response for the
      * CommaSeparatedListOutputParser.
      * @returns A string containing instructions on the expected format of the response.
      */
      getFormatInstructions() {
        return `Your response should be a list of comma separated values, eg: \`foo, bar, baz\``;
      }
    };
    var CustomListOutputParser = class extends ListOutputParser {
      lc_namespace = [
        "langchain_core",
        "output_parsers",
        "list"
      ];
      length;
      separator;
      constructor({ length, separator }) {
        super(...arguments);
        this.length = length;
        this.separator = separator || ",";
      }
      /**
      * Parses the given text into an array of strings, using the specified
      * separator. If the parsing fails or the number of items in the list
      * doesn't match the expected length, throws an OutputParserException.
      * @param text The text to parse.
      * @returns An array of strings obtained by splitting the input text at each occurrence of the specified separator.
      */
      async parse(text) {
        try {
          const items = text.trim().split(this.separator).map((s) => s.trim());
          if (this.length !== void 0 && items.length !== this.length) throw new require_base18.OutputParserException(`Incorrect number of items. Expected ${this.length}, got ${items.length}.`);
          return items;
        } catch (e) {
          if (Object.getPrototypeOf(e) === require_base18.OutputParserException.prototype) throw e;
          throw new require_base18.OutputParserException(`Could not parse output: ${text}`);
        }
      }
      /**
      * Provides instructions on the expected format of the response for the
      * CustomListOutputParser, including the number of items and the
      * separator.
      * @returns A string containing instructions on the expected format of the response.
      */
      getFormatInstructions() {
        return `Your response should be a list of ${this.length === void 0 ? "" : `${this.length} `}items separated by "${this.separator}" (eg: \`foo${this.separator} bar${this.separator} baz\`)`;
      }
    };
    var NumberedListOutputParser = class extends ListOutputParser {
      static lc_name() {
        return "NumberedListOutputParser";
      }
      lc_namespace = [
        "langchain_core",
        "output_parsers",
        "list"
      ];
      lc_serializable = true;
      getFormatInstructions() {
        return `Your response should be a numbered list with each item on a new line. For example: 

1. foo

2. bar

3. baz`;
      }
      re = /\d+\.\s([^\n]+)/g;
      async parse(text) {
        return [...text.matchAll(this.re) ?? []].map((m) => m[1]);
      }
    };
    var MarkdownListOutputParser = class extends ListOutputParser {
      static lc_name() {
        return "NumberedListOutputParser";
      }
      lc_namespace = [
        "langchain_core",
        "output_parsers",
        "list"
      ];
      lc_serializable = true;
      getFormatInstructions() {
        return `Your response should be a numbered list with each item on a new line. For example: 

1. foo

2. bar

3. baz`;
      }
      re = /^\s*[-*]\s([^\n]+)$/gm;
      async parse(text) {
        return [...text.matchAll(this.re) ?? []].map((m) => m[1]);
      }
    };
    exports2.CommaSeparatedListOutputParser = CommaSeparatedListOutputParser;
    exports2.CustomListOutputParser = CustomListOutputParser;
    exports2.ListOutputParser = ListOutputParser;
    exports2.MarkdownListOutputParser = MarkdownListOutputParser;
    exports2.NumberedListOutputParser = NumberedListOutputParser;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/string.cjs
var require_string2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/string.cjs"(exports2) {
    var require_transform2 = require_transform();
    var StringOutputParser = class extends require_transform2.BaseTransformOutputParser {
      static lc_name() {
        return "StrOutputParser";
      }
      lc_namespace = [
        "langchain_core",
        "output_parsers",
        "string"
      ];
      lc_serializable = true;
      /**
      * Parses a string output from an LLM call. This method is meant to be
      * implemented by subclasses to define how a string output from an LLM
      * should be parsed.
      * @param text The string output from an LLM call.
      * @param callbacks Optional callbacks.
      * @returns A promise of the parsed output.
      */
      parse(text) {
        return Promise.resolve(text);
      }
      getFormatInstructions() {
        return "";
      }
      _textContentToString(content) {
        return content.text;
      }
      _imageUrlContentToString(_content) {
        throw new Error(`Cannot coerce a multimodal "image_url" message part into a string.`);
      }
      _messageContentToString(content) {
        switch (content.type) {
          case "text":
          case "text_delta":
            if ("text" in content) return this._textContentToString(content);
            break;
          case "image_url":
            if ("image_url" in content) return this._imageUrlContentToString(content);
            break;
          default:
            throw new Error(`Cannot coerce "${content.type}" message part into a string.`);
        }
        throw new Error(`Invalid content type: ${content.type}`);
      }
      _baseMessageContentToString(content) {
        return content.reduce((acc, item) => acc + this._messageContentToString(item), "");
      }
    };
    exports2.StringOutputParser = StringOutputParser;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/structured.cjs
var require_structured = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/structured.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_zod3 = require_zod();
    var require_utils_json_schema = require_json_schema2();
    var require_base18 = require_base10();
    var zod_v3 = require_rolldown_runtime5.__toESM(require_v3());
    var StructuredOutputParser = class extends require_base18.BaseOutputParser {
      static lc_name() {
        return "StructuredOutputParser";
      }
      lc_namespace = [
        "langchain",
        "output_parsers",
        "structured"
      ];
      toJSON() {
        return this.toJSONNotImplemented();
      }
      constructor(schema) {
        super(schema);
        this.schema = schema;
      }
      /**
      * Creates a new StructuredOutputParser from a Zod schema.
      * @param schema The Zod schema which the output should match
      * @returns A new instance of StructuredOutputParser.
      */
      static fromZodSchema(schema) {
        return new this(schema);
      }
      /**
      * Creates a new StructuredOutputParser from a set of names and
      * descriptions.
      * @param schemas An object where each key is a name and each value is a description
      * @returns A new instance of StructuredOutputParser.
      */
      static fromNamesAndDescriptions(schemas) {
        const zodSchema = zod_v3.z.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, zod_v3.z.string().describe(description)])));
        return new this(zodSchema);
      }
      /**
      * Returns a markdown code snippet with a JSON object formatted according
      * to the schema.
      * @param options Optional. The options for formatting the instructions
      * @returns A markdown code snippet with a JSON object formatted according to the schema.
      */
      getFormatInstructions() {
        return `You must format your output as a JSON value that adheres to a given "JSON Schema" instance.

"JSON Schema" is a declarative language that allows you to annotate and validate JSON documents.

For example, the example "JSON Schema" instance {{"properties": {{"foo": {{"description": "a list of test words", "type": "array", "items": {{"type": "string"}}}}}}, "required": ["foo"]}}
would match an object with one required property, "foo". The "type" property specifies "foo" must be an "array", and the "description" property semantically describes it as "a list of test words". The items within "foo" must be strings.
Thus, the object {{"foo": ["bar", "baz"]}} is a well-formatted instance of this example "JSON Schema". The object {{"properties": {{"foo": ["bar", "baz"]}}}} is not well-formatted.

Your output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!

Here is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:
\`\`\`json
${JSON.stringify(require_utils_json_schema.toJsonSchema(this.schema))}
\`\`\`
`;
      }
      /**
      * Parses the given text according to the schema.
      * @param text The text to parse
      * @returns The parsed output.
      */
      async parse(text) {
        try {
          const trimmedText = text.trim();
          const json = trimmedText.match(/^```(?:json)?\s*([\s\S]*?)```/)?.[1] || trimmedText.match(/```json\s*([\s\S]*?)```/)?.[1] || trimmedText;
          const escapedJson = json.replace(/"([^"\\]*(\\.[^"\\]*)*)"/g, (_match, capturedGroup) => {
            const escapedInsideQuotes = capturedGroup.replace(/\n/g, "\\n");
            return `"${escapedInsideQuotes}"`;
          }).replace(/\n/g, "");
          return await require_zod3.interopParseAsync(this.schema, JSON.parse(escapedJson));
        } catch (e) {
          throw new require_base18.OutputParserException(`Failed to parse. Text: "${text}". Error: ${e}`, text);
        }
      }
    };
    var JsonMarkdownStructuredOutputParser = class extends StructuredOutputParser {
      static lc_name() {
        return "JsonMarkdownStructuredOutputParser";
      }
      getFormatInstructions(options) {
        const interpolationDepth = options?.interpolationDepth ?? 1;
        if (interpolationDepth < 1) throw new Error("f string interpolation depth must be at least 1");
        return `Return a markdown code snippet with a JSON object formatted to look like:
\`\`\`json
${this._schemaToInstruction(require_utils_json_schema.toJsonSchema(this.schema)).replaceAll("{", "{".repeat(interpolationDepth)).replaceAll("}", "}".repeat(interpolationDepth))}
\`\`\``;
      }
      _schemaToInstruction(schemaInput, indent = 2) {
        const schema = schemaInput;
        if ("type" in schema) {
          let nullable = false;
          let type;
          if (Array.isArray(schema.type)) {
            const nullIdx = schema.type.findIndex((type$1) => type$1 === "null");
            if (nullIdx !== -1) {
              nullable = true;
              schema.type.splice(nullIdx, 1);
            }
            type = schema.type.join(" | ");
          } else type = schema.type;
          if (schema.type === "object" && schema.properties) {
            const description$1 = schema.description ? ` // ${schema.description}` : "";
            const properties = Object.entries(schema.properties).map(([key, value]) => {
              const isOptional = schema.required?.includes(key) ? "" : " (optional)";
              return `${" ".repeat(indent)}"${key}": ${this._schemaToInstruction(value, indent + 2)}${isOptional}`;
            }).join("\n");
            return `{
${properties}
${" ".repeat(indent - 2)}}${description$1}`;
          }
          if (schema.type === "array" && schema.items) {
            const description$1 = schema.description ? ` // ${schema.description}` : "";
            return `array[
${" ".repeat(indent)}${this._schemaToInstruction(schema.items, indent + 2)}
${" ".repeat(indent - 2)}] ${description$1}`;
          }
          const isNullable = nullable ? " (nullable)" : "";
          const description = schema.description ? ` // ${schema.description}` : "";
          return `${type}${description}${isNullable}`;
        }
        if ("anyOf" in schema) return schema.anyOf.map((s) => this._schemaToInstruction(s, indent)).join(`
${" ".repeat(indent - 2)}`);
        throw new Error("unsupported schema type");
      }
      static fromZodSchema(schema) {
        return new this(schema);
      }
      static fromNamesAndDescriptions(schemas) {
        const zodSchema = zod_v3.z.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, zod_v3.z.string().describe(description)])));
        return new this(zodSchema);
      }
    };
    var AsymmetricStructuredOutputParser = class extends require_base18.BaseOutputParser {
      structuredInputParser;
      constructor({ inputSchema }) {
        super(...arguments);
        this.structuredInputParser = new JsonMarkdownStructuredOutputParser(inputSchema);
      }
      async parse(text) {
        let parsedInput;
        try {
          parsedInput = await this.structuredInputParser.parse(text);
        } catch (e) {
          throw new require_base18.OutputParserException(`Failed to parse. Text: "${text}". Error: ${e}`, text);
        }
        return this.outputProcessor(parsedInput);
      }
      getFormatInstructions() {
        return this.structuredInputParser.getFormatInstructions();
      }
    };
    exports2.AsymmetricStructuredOutputParser = AsymmetricStructuredOutputParser;
    exports2.JsonMarkdownStructuredOutputParser = JsonMarkdownStructuredOutputParser;
    exports2.StructuredOutputParser = StructuredOutputParser;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/json.cjs
var require_json2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/json.cjs"(exports2) {
    var require_json3 = require_json();
    var require_duplex2 = require_duplex();
    var require_transform2 = require_transform();
    require_json_patch();
    var JsonOutputParser = class extends require_transform2.BaseCumulativeTransformOutputParser {
      static lc_name() {
        return "JsonOutputParser";
      }
      lc_namespace = ["langchain_core", "output_parsers"];
      lc_serializable = true;
      /** @internal */
      _concatOutputChunks(first, second) {
        if (this.diff) return super._concatOutputChunks(first, second);
        return second;
      }
      _diff(prev, next) {
        if (!next) return void 0;
        if (!prev) return [{
          op: "replace",
          path: "",
          value: next
        }];
        return require_duplex2.compare(prev, next);
      }
      async parsePartialResult(generations) {
        return require_json3.parseJsonMarkdown(generations[0].text);
      }
      async parse(text) {
        return require_json3.parseJsonMarkdown(text, JSON.parse);
      }
      getFormatInstructions() {
        return "";
      }
    };
    exports2.JsonOutputParser = JsonOutputParser;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/sax-js/sax.cjs
var require_sax = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/sax-js/sax.cjs"(exports2) {
    var initializeSax = function() {
      const sax$1 = {};
      sax$1.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax$1.SAXParser = SAXParser;
      sax$1.SAXStream = SAXStream;
      sax$1.createStream = createStream;
      sax$1.MAX_BUFFER_LENGTH = 64 * 1024;
      const buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax$1.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) return new SAXParser(strict, opt);
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax$1.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax$1.XML_ENTITIES) : Object.create(sax$1.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) parser.ns = Object.create(rootNS);
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) parser.position = parser.line = parser.column = 0;
        emit(parser, "onready");
      }
      if (!Object.create) Object.create = function(o) {
        function F() {
        }
        F.prototype = o;
        var newf = new F();
        return newf;
      };
      if (!Object.keys) Object.keys = function(o) {
        var a = [];
        for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
        return a;
      };
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax$1.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) switch (buffers[i]) {
            case "textNode":
              closeText(parser);
              break;
            case "cdata":
              emitNode(parser, "oncdata", parser.cdata);
              parser.cdata = "";
              break;
            case "script":
              emitNode(parser, "onscript", parser.script);
              parser.script = "";
              break;
            default:
              error(parser, "Max buffer length exceeded: " + buffers[i]);
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax$1.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) parser[buffers[i]] = "";
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream = ReadableStream;
      if (!Stream) Stream = function() {
      };
      var streamWraps = sax$1.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) return new SAXStream(strict, opt);
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream.prototype, { constructor: { value: SAXStream } });
      SAXStream.prototype.write = function(data) {
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) this.write(chunk);
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) me._parser["on" + ev] = function() {
          var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          args.splice(0, 0, ev);
          me.emit.apply(me, args);
        };
        return Stream.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = {
        xml: XML_NAMESPACE,
        xmlns: XMLNS_NAMESPACE
      };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S = 0;
      sax$1.STATE = {
        BEGIN: S++,
        BEGIN_WHITESPACE: S++,
        TEXT: S++,
        TEXT_ENTITY: S++,
        OPEN_WAKA: S++,
        SGML_DECL: S++,
        SGML_DECL_QUOTED: S++,
        DOCTYPE: S++,
        DOCTYPE_QUOTED: S++,
        DOCTYPE_DTD: S++,
        DOCTYPE_DTD_QUOTED: S++,
        COMMENT_STARTING: S++,
        COMMENT: S++,
        COMMENT_ENDING: S++,
        COMMENT_ENDED: S++,
        CDATA: S++,
        CDATA_ENDING: S++,
        CDATA_ENDING_2: S++,
        PROC_INST: S++,
        PROC_INST_BODY: S++,
        PROC_INST_ENDING: S++,
        OPEN_TAG: S++,
        OPEN_TAG_SLASH: S++,
        ATTRIB: S++,
        ATTRIB_NAME: S++,
        ATTRIB_NAME_SAW_WHITE: S++,
        ATTRIB_VALUE: S++,
        ATTRIB_VALUE_QUOTED: S++,
        ATTRIB_VALUE_CLOSED: S++,
        ATTRIB_VALUE_UNQUOTED: S++,
        ATTRIB_VALUE_ENTITY_Q: S++,
        ATTRIB_VALUE_ENTITY_U: S++,
        CLOSE_TAG: S++,
        CLOSE_TAG_SAW_WHITE: S++,
        SCRIPT: S++,
        SCRIPT_ENDING: S++
      };
      sax$1.XML_ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      };
      sax$1.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
      };
      Object.keys(sax$1.ENTITIES).forEach(function(key) {
        var e = sax$1.ENTITIES[key];
        var s$1 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax$1.ENTITIES[key] = s$1;
      });
      for (var s in sax$1.STATE) sax$1.STATE[sax$1.STATE[s]] = s;
      S = sax$1.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, " ");
        return text;
      }
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) error(parser, "Unexpected end");
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) throw new Error("bad call to strictFail");
        if (parser.strict) error(parser, message);
      }
      function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = {
          name: parser.tagName,
          attributes: {}
        };
        if (parser.opt.xmlns) tag.ns = parent.ns;
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return {
          prefix,
          local
        };
      }
      function attrib(parser) {
        if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]();
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") if (local === "xml" && parser.attribValue !== XML_NAMESPACE) strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue);
          else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue);
          else {
            var tag = parser.tag;
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns === parent.ns) tag.ns = Object.create(parent.ns);
            tag.ns[local] = parser.attribValue;
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) Object.keys(tag.ns).forEach(function(p) {
            emitNode(parser, "onopennamespace", {
              prefix: p,
              uri: tag.ns[p]
            });
          });
          for (var i = 0, l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") parser.state = S.SCRIPT;
          else parser.state = S.TEXT;
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) tagName = tagName[parser.looseCase]();
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) strictFail(parser, "Unexpected close tag");
          else break;
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s$1 = parser.tags.length;
        while (s$1-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns) x[i] = tag.ns[i];
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) Object.keys(tag.ns).forEach(function(p) {
            var n = tag.ns[p];
            emitNode(parser, "onclosenamespace", {
              prefix: p,
              uri: n
            });
          });
        }
        if (t === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) return parser.ENTITIES[entity];
        if (parser.ENTITIES[entityLC]) return parser.ENTITIES[entityLC];
        entity = entityLC;
        if (entity.charAt(0) === "#") if (entity.charAt(1) === "x") {
          entity = entity.slice(2);
          num = parseInt(entity, 16);
          numStr = num.toString(16);
        } else {
          entity = entity.slice(1);
          num = parseInt(entity, 10);
          numStr = num.toString(10);
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) result = chunk.charAt(i);
        return result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) throw this.error;
        if (parser.closed) return error(parser, "Cannot write after close. Assign an onready handler.");
        if (chunk === null) return end(parser);
        if (typeof chunk === "object") chunk = chunk.toString();
        var i = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) break;
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else parser.column++;
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") continue;
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else parser.column++;
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) strictFail(parser, "Text data outside of root node.");
                if (c === "&") parser.state = S.TEXT_ENTITY;
                else parser.textNode += c;
              }
              continue;
            case S.SCRIPT:
              if (c === "<") parser.state = S.SCRIPT_ENDING;
              else parser.script += c;
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") parser.state = S.CLOSE_TAG;
              else {
                parser.script += "<" + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c)) {
              } else if (isMatch(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) strictFail(parser, "Inappropriately located doctype declaration");
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (isQuote(c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else parser.sgmlDecl += c;
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") parser.state = S.DOCTYPE_DTD;
                else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              parser.doctype += c;
              if (c === "]") parser.state = S.DOCTYPE;
              else if (isQuote(c)) {
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-") parser.state = S.COMMENT_ENDING;
              else parser.comment += c;
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) emitNode(parser, "oncomment", parser.comment);
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S.COMMENT;
              } else parser.state = S.TEXT;
              continue;
            case S.CDATA:
              if (c === "]") parser.state = S.CDATA_ENDING;
              else parser.cdata += c;
              continue;
            case S.CDATA_ENDING:
              if (c === "]") parser.state = S.CDATA_ENDING_2;
              else {
                parser.cdata += "]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) emitNode(parser, "oncdata", parser.cdata);
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c === "]") parser.cdata += "]";
              else {
                parser.cdata += "]]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?") parser.state = S.PROC_INST_ENDING;
              else if (isWhitespace(c)) parser.state = S.PROC_INST_BODY;
              else parser.procInstName += c;
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c)) continue;
              else if (c === "?") parser.state = S.PROC_INST_ENDING;
              else parser.procInstBody += c;
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch(nameBody, c)) parser.tagName += c;
              else {
                newTag(parser);
                if (c === ">") openTag(parser);
                else if (c === "/") parser.state = S.OPEN_TAG_SLASH;
                else {
                  if (!isWhitespace(c)) strictFail(parser, "Invalid character in tag name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (isWhitespace(c)) continue;
              else if (c === ">") openTag(parser);
              else if (c === "/") parser.state = S.OPEN_TAG_SLASH;
              else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else strictFail(parser, "Invalid attribute name");
              continue;
            case S.ATTRIB_NAME:
              if (c === "=") parser.state = S.ATTRIB_VALUE;
              else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c)) parser.state = S.ATTRIB_NAME_SAW_WHITE;
              else if (isMatch(nameBody, c)) parser.attribName += c;
              else strictFail(parser, "Invalid attribute name");
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") parser.state = S.ATTRIB_VALUE;
              else if (isWhitespace(c)) continue;
              else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") openTag(parser);
                else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace(c)) continue;
              else if (isQuote(c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser, "Unquoted attribute value");
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                else parser.attribValue += c;
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) parser.state = S.ATTRIB;
              else if (c === ">") openTag(parser);
              else if (c === "/") parser.state = S.OPEN_TAG_SLASH;
              else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else strictFail(parser, "Invalid attribute name");
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_U;
                else parser.attribValue += c;
                continue;
              }
              attrib(parser);
              if (c === ">") openTag(parser);
              else parser.state = S.ATTRIB;
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) if (isWhitespace(c)) continue;
              else if (notMatch(nameStart, c)) if (parser.script) {
                parser.script += "</" + c;
                parser.state = S.SCRIPT;
              } else strictFail(parser, "Invalid tagname in closing tag.");
              else parser.tagName = c;
              else if (c === ">") closeTag(parser);
              else if (isMatch(nameBody, c)) parser.tagName += c;
              else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (!isWhitespace(c)) strictFail(parser, "Invalid tagname in closing tag");
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) continue;
              if (c === ">") closeTag(parser);
              else strictFail(parser, "Invalid characters in closing tag");
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c === ";") if (parser.opt.unparsedEntities) {
                var parsedEntity = parseEntity(parser);
                parser.entity = "";
                parser.state = returnState;
                parser.write(parsedEntity);
              } else {
                parser[buffer] += parseEntity(parser);
                parser.entity = "";
                parser.state = returnState;
              }
              else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) parser.entity += c;
              else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default:
              throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
        if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser);
        return parser;
      }
      if (!String.fromCodePoint) (function() {
        var stringFromCharCode = String.fromCharCode;
        var floor = Math.floor;
        var fromCodePoint = function() {
          var MAX_SIZE = 16384;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index = -1;
          var length = arguments.length;
          if (!length) return "";
          var result = "";
          while (++index < length) {
            var codePoint = Number(arguments[index]);
            if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) throw RangeError("Invalid code point: " + codePoint);
            if (codePoint <= 65535) codeUnits.push(codePoint);
            else {
              codePoint -= 65536;
              highSurrogate = (codePoint >> 10) + 55296;
              lowSurrogate = codePoint % 1024 + 56320;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 === length || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        if (Object.defineProperty) Object.defineProperty(String, "fromCodePoint", {
          value: fromCodePoint,
          configurable: true,
          writable: true
        });
        else String.fromCodePoint = fromCodePoint;
      })();
      return sax$1;
    };
    var sax = initializeSax();
    exports2.sax = sax;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/xml.cjs
var require_xml = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/xml.cjs"(exports2) {
    var require_duplex2 = require_duplex();
    var require_transform2 = require_transform();
    require_json_patch();
    var require_sax2 = require_sax();
    var XML_FORMAT_INSTRUCTIONS = `The output should be formatted as a XML file.
1. Output should conform to the tags below. 
2. If tags are not given, make them on your own.
3. Remember to always open and close all the tags.

As an example, for the tags ["foo", "bar", "baz"]:
1. String "<foo>
   <bar>
      <baz></baz>
   </bar>
</foo>" is a well-formatted instance of the schema. 
2. String "<foo>
   <bar>
   </foo>" is a badly-formatted instance.
3. String "<foo>
   <tag>
   </tag>
</foo>" is a badly-formatted instance.

Here are the output tags:
\`\`\`
{tags}
\`\`\``;
    var XMLOutputParser = class extends require_transform2.BaseCumulativeTransformOutputParser {
      tags;
      constructor(fields) {
        super(fields);
        this.tags = fields?.tags;
      }
      static lc_name() {
        return "XMLOutputParser";
      }
      lc_namespace = ["langchain_core", "output_parsers"];
      lc_serializable = true;
      _diff(prev, next) {
        if (!next) return void 0;
        if (!prev) return [{
          op: "replace",
          path: "",
          value: next
        }];
        return require_duplex2.compare(prev, next);
      }
      async parsePartialResult(generations) {
        return parseXMLMarkdown(generations[0].text);
      }
      async parse(text) {
        return parseXMLMarkdown(text);
      }
      getFormatInstructions() {
        const withTags = !!(this.tags && this.tags.length > 0);
        return withTags ? XML_FORMAT_INSTRUCTIONS.replace("{tags}", this.tags?.join(", ") ?? "") : XML_FORMAT_INSTRUCTIONS;
      }
    };
    var strip = (text) => text.split("\n").map((line) => line.replace(/^\s+/, "")).join("\n").trim();
    var parseParsedResult = (input) => {
      if (Object.keys(input).length === 0) return {};
      const result = {};
      if (input.children.length > 0) {
        result[input.name] = input.children.map(parseParsedResult);
        return result;
      } else {
        result[input.name] = input.text ?? void 0;
        return result;
      }
    };
    function parseXMLMarkdown(s) {
      const cleanedString = strip(s);
      const parser = require_sax2.sax.parser(true);
      let parsedResult = {};
      const elementStack = [];
      parser.onopentag = (node) => {
        const element = {
          name: node.name,
          attributes: node.attributes,
          children: [],
          text: "",
          isSelfClosing: node.isSelfClosing
        };
        if (elementStack.length > 0) {
          const parentElement = elementStack[elementStack.length - 1];
          parentElement.children.push(element);
        } else parsedResult = element;
        if (!node.isSelfClosing) elementStack.push(element);
      };
      parser.onclosetag = () => {
        if (elementStack.length > 0) {
          const lastElement = elementStack.pop();
          if (elementStack.length === 0 && lastElement) parsedResult = lastElement;
        }
      };
      parser.ontext = (text) => {
        if (elementStack.length > 0) {
          const currentElement = elementStack[elementStack.length - 1];
          currentElement.text += text;
        }
      };
      parser.onattribute = (attr) => {
        if (elementStack.length > 0) {
          const currentElement = elementStack[elementStack.length - 1];
          currentElement.attributes[attr.name] = attr.value;
        }
      };
      const match = /```(xml)?(.*)```/s.exec(cleanedString);
      const xmlString = match ? match[2] : cleanedString;
      parser.write(xmlString).close();
      if (parsedResult && parsedResult.name === "?xml") parsedResult = parsedResult.children[0];
      return parseParsedResult(parsedResult);
    }
    exports2.XMLOutputParser = XMLOutputParser;
    exports2.XML_FORMAT_INSTRUCTIONS = XML_FORMAT_INSTRUCTIONS;
    exports2.parseXMLMarkdown = parseXMLMarkdown;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/index.cjs
var require_output_parsers = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/index.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_json3 = require_json();
    var require_base18 = require_base10();
    var require_transform2 = require_transform();
    var require_bytes2 = require_bytes();
    var require_list2 = require_list();
    var require_string4 = require_string2();
    var require_structured3 = require_structured();
    var require_json$1 = require_json2();
    var require_xml2 = require_xml();
    var output_parsers_exports = {};
    require_rolldown_runtime5.__export(output_parsers_exports, {
      AsymmetricStructuredOutputParser: () => require_structured3.AsymmetricStructuredOutputParser,
      BaseCumulativeTransformOutputParser: () => require_transform2.BaseCumulativeTransformOutputParser,
      BaseLLMOutputParser: () => require_base18.BaseLLMOutputParser,
      BaseOutputParser: () => require_base18.BaseOutputParser,
      BaseTransformOutputParser: () => require_transform2.BaseTransformOutputParser,
      BytesOutputParser: () => require_bytes2.BytesOutputParser,
      CommaSeparatedListOutputParser: () => require_list2.CommaSeparatedListOutputParser,
      CustomListOutputParser: () => require_list2.CustomListOutputParser,
      JsonMarkdownStructuredOutputParser: () => require_structured3.JsonMarkdownStructuredOutputParser,
      JsonOutputParser: () => require_json$1.JsonOutputParser,
      ListOutputParser: () => require_list2.ListOutputParser,
      MarkdownListOutputParser: () => require_list2.MarkdownListOutputParser,
      NumberedListOutputParser: () => require_list2.NumberedListOutputParser,
      OutputParserException: () => require_base18.OutputParserException,
      StringOutputParser: () => require_string4.StringOutputParser,
      StructuredOutputParser: () => require_structured3.StructuredOutputParser,
      XMLOutputParser: () => require_xml2.XMLOutputParser,
      XML_FORMAT_INSTRUCTIONS: () => require_xml2.XML_FORMAT_INSTRUCTIONS,
      parseJsonMarkdown: () => require_json3.parseJsonMarkdown,
      parsePartialJson: () => require_json3.parsePartialJson,
      parseXMLMarkdown: () => require_xml2.parseXMLMarkdown
    });
    exports2.AsymmetricStructuredOutputParser = require_structured3.AsymmetricStructuredOutputParser;
    exports2.BaseCumulativeTransformOutputParser = require_transform2.BaseCumulativeTransformOutputParser;
    exports2.BaseLLMOutputParser = require_base18.BaseLLMOutputParser;
    exports2.BaseOutputParser = require_base18.BaseOutputParser;
    exports2.BaseTransformOutputParser = require_transform2.BaseTransformOutputParser;
    exports2.BytesOutputParser = require_bytes2.BytesOutputParser;
    exports2.CommaSeparatedListOutputParser = require_list2.CommaSeparatedListOutputParser;
    exports2.CustomListOutputParser = require_list2.CustomListOutputParser;
    exports2.JsonMarkdownStructuredOutputParser = require_structured3.JsonMarkdownStructuredOutputParser;
    exports2.JsonOutputParser = require_json$1.JsonOutputParser;
    exports2.ListOutputParser = require_list2.ListOutputParser;
    exports2.MarkdownListOutputParser = require_list2.MarkdownListOutputParser;
    exports2.NumberedListOutputParser = require_list2.NumberedListOutputParser;
    exports2.OutputParserException = require_base18.OutputParserException;
    exports2.StringOutputParser = require_string4.StringOutputParser;
    exports2.StructuredOutputParser = require_structured3.StructuredOutputParser;
    exports2.XMLOutputParser = require_xml2.XMLOutputParser;
    exports2.XML_FORMAT_INSTRUCTIONS = require_xml2.XML_FORMAT_INSTRUCTIONS;
    Object.defineProperty(exports2, "output_parsers_exports", {
      enumerable: true,
      get: function() {
        return output_parsers_exports;
      }
    });
    exports2.parseJsonMarkdown = require_json3.parseJsonMarkdown;
    exports2.parsePartialJson = require_json3.parsePartialJson;
    exports2.parseXMLMarkdown = require_xml2.parseXMLMarkdown;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/openai_tools/json_output_tools_parsers.cjs
var require_json_output_tools_parsers = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/openai_tools/json_output_tools_parsers.cjs"(exports2) {
    var require_json3 = require_json();
    var require_ai2 = require_ai();
    var require_zod3 = require_zod();
    var require_base18 = require_base10();
    var require_transform2 = require_transform();
    require_json2();
    function parseToolCall(rawToolCall, options) {
      if (rawToolCall.function === void 0) return void 0;
      let functionArgs;
      if (options?.partial) try {
        functionArgs = require_json3.parsePartialJson(rawToolCall.function.arguments ?? "{}");
      } catch {
        return void 0;
      }
      else try {
        functionArgs = JSON.parse(rawToolCall.function.arguments);
      } catch (e) {
        throw new require_base18.OutputParserException([
          `Function "${rawToolCall.function.name}" arguments:`,
          ``,
          rawToolCall.function.arguments,
          ``,
          `are not valid JSON.`,
          `Error: ${e.message}`
        ].join("\n"));
      }
      const parsedToolCall = {
        name: rawToolCall.function.name,
        args: functionArgs,
        type: "tool_call"
      };
      if (options?.returnId) parsedToolCall.id = rawToolCall.id;
      return parsedToolCall;
    }
    function convertLangChainToolCallToOpenAI(toolCall) {
      if (toolCall.id === void 0) throw new Error(`All OpenAI tool calls must have an "id" field.`);
      return {
        id: toolCall.id,
        type: "function",
        function: {
          name: toolCall.name,
          arguments: JSON.stringify(toolCall.args)
        }
      };
    }
    function makeInvalidToolCall(rawToolCall, errorMsg) {
      return {
        name: rawToolCall.function?.name,
        args: rawToolCall.function?.arguments,
        id: rawToolCall.id,
        error: errorMsg,
        type: "invalid_tool_call"
      };
    }
    var JsonOutputToolsParser = class extends require_transform2.BaseCumulativeTransformOutputParser {
      static lc_name() {
        return "JsonOutputToolsParser";
      }
      returnId = false;
      lc_namespace = [
        "langchain",
        "output_parsers",
        "openai_tools"
      ];
      lc_serializable = true;
      constructor(fields) {
        super(fields);
        this.returnId = fields?.returnId ?? this.returnId;
      }
      _diff() {
        throw new Error("Not supported.");
      }
      async parse() {
        throw new Error("Not implemented.");
      }
      async parseResult(generations) {
        const result = await this.parsePartialResult(generations, false);
        return result;
      }
      /**
      * Parses the output and returns a JSON object. If `argsOnly` is true,
      * only the arguments of the function call are returned.
      * @param generations The output of the LLM to parse.
      * @returns A JSON object representation of the function call or its arguments.
      */
      async parsePartialResult(generations, partial = true) {
        const message = generations[0].message;
        let toolCalls;
        if (require_ai2.isAIMessage(message) && message.tool_calls?.length) toolCalls = message.tool_calls.map((toolCall) => {
          const { id, ...rest } = toolCall;
          if (!this.returnId) return rest;
          return {
            id,
            ...rest
          };
        });
        else if (message.additional_kwargs.tool_calls !== void 0) {
          const rawToolCalls = JSON.parse(JSON.stringify(message.additional_kwargs.tool_calls));
          toolCalls = rawToolCalls.map((rawToolCall) => {
            return parseToolCall(rawToolCall, {
              returnId: this.returnId,
              partial
            });
          });
        }
        if (!toolCalls) return [];
        const parsedToolCalls = [];
        for (const toolCall of toolCalls) if (toolCall !== void 0) {
          const backwardsCompatibleToolCall = {
            type: toolCall.name,
            args: toolCall.args,
            id: toolCall.id
          };
          parsedToolCalls.push(backwardsCompatibleToolCall);
        }
        return parsedToolCalls;
      }
    };
    var JsonOutputKeyToolsParser = class extends JsonOutputToolsParser {
      static lc_name() {
        return "JsonOutputKeyToolsParser";
      }
      lc_namespace = [
        "langchain",
        "output_parsers",
        "openai_tools"
      ];
      lc_serializable = true;
      returnId = false;
      /** The type of tool calls to return. */
      keyName;
      /** Whether to return only the first tool call. */
      returnSingle = false;
      zodSchema;
      constructor(params) {
        super(params);
        this.keyName = params.keyName;
        this.returnSingle = params.returnSingle ?? this.returnSingle;
        this.zodSchema = params.zodSchema;
      }
      async _validateResult(result) {
        if (this.zodSchema === void 0) return result;
        const zodParsedResult = await require_zod3.interopSafeParseAsync(this.zodSchema, result);
        if (zodParsedResult.success) return zodParsedResult.data;
        else throw new require_base18.OutputParserException(`Failed to parse. Text: "${JSON.stringify(result, null, 2)}". Error: ${JSON.stringify(zodParsedResult.error?.issues)}`, JSON.stringify(result, null, 2));
      }
      async parsePartialResult(generations) {
        const results = await super.parsePartialResult(generations);
        const matchingResults = results.filter((result) => result.type === this.keyName);
        let returnedValues = matchingResults;
        if (!matchingResults.length) return void 0;
        if (!this.returnId) returnedValues = matchingResults.map((result) => result.args);
        if (this.returnSingle) return returnedValues[0];
        return returnedValues;
      }
      async parseResult(generations) {
        const results = await super.parsePartialResult(generations, false);
        const matchingResults = results.filter((result) => result.type === this.keyName);
        let returnedValues = matchingResults;
        if (!matchingResults.length) return void 0;
        if (!this.returnId) returnedValues = matchingResults.map((result) => result.args);
        if (this.returnSingle) return this._validateResult(returnedValues[0]);
        const toolCallResults = await Promise.all(returnedValues.map((value) => this._validateResult(value)));
        return toolCallResults;
      }
    };
    exports2.JsonOutputKeyToolsParser = JsonOutputKeyToolsParser;
    exports2.JsonOutputToolsParser = JsonOutputToolsParser;
    exports2.convertLangChainToolCallToOpenAI = convertLangChainToolCallToOpenAI;
    exports2.makeInvalidToolCall = makeInvalidToolCall;
    exports2.parseToolCall = parseToolCall;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/openai_tools/index.cjs
var require_openai_tools = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/openai_tools/index.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_json_output_tools_parsers2 = require_json_output_tools_parsers();
    var openai_tools_exports = {};
    require_rolldown_runtime5.__export(openai_tools_exports, {
      JsonOutputKeyToolsParser: () => require_json_output_tools_parsers2.JsonOutputKeyToolsParser,
      JsonOutputToolsParser: () => require_json_output_tools_parsers2.JsonOutputToolsParser,
      convertLangChainToolCallToOpenAI: () => require_json_output_tools_parsers2.convertLangChainToolCallToOpenAI,
      makeInvalidToolCall: () => require_json_output_tools_parsers2.makeInvalidToolCall,
      parseToolCall: () => require_json_output_tools_parsers2.parseToolCall
    });
    exports2.JsonOutputKeyToolsParser = require_json_output_tools_parsers2.JsonOutputKeyToolsParser;
    exports2.JsonOutputToolsParser = require_json_output_tools_parsers2.JsonOutputToolsParser;
    exports2.convertLangChainToolCallToOpenAI = require_json_output_tools_parsers2.convertLangChainToolCallToOpenAI;
    exports2.makeInvalidToolCall = require_json_output_tools_parsers2.makeInvalidToolCall;
    Object.defineProperty(exports2, "openai_tools_exports", {
      enumerable: true,
      get: function() {
        return openai_tools_exports;
      }
    });
    exports2.parseToolCall = require_json_output_tools_parsers2.parseToolCall;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/openai_functions/json_output_functions_parsers.cjs
var require_json_output_functions_parsers = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/openai_functions/json_output_functions_parsers.cjs"(exports2) {
    var require_json3 = require_json();
    var require_duplex2 = require_duplex();
    var require_base18 = require_base10();
    var require_transform2 = require_transform();
    require_json_patch();
    require_json2();
    var OutputFunctionsParser = class extends require_base18.BaseLLMOutputParser {
      static lc_name() {
        return "OutputFunctionsParser";
      }
      lc_namespace = [
        "langchain",
        "output_parsers",
        "openai_functions"
      ];
      lc_serializable = true;
      argsOnly = true;
      constructor(config) {
        super();
        this.argsOnly = config?.argsOnly ?? this.argsOnly;
      }
      /**
      * Parses the output and returns a string representation of the function
      * call or its arguments.
      * @param generations The output of the LLM to parse.
      * @returns A string representation of the function call or its arguments.
      */
      async parseResult(generations) {
        if ("message" in generations[0]) {
          const gen = generations[0];
          const functionCall = gen.message.additional_kwargs.function_call;
          if (!functionCall) throw new Error(`No function_call in message ${JSON.stringify(generations)}`);
          if (!functionCall.arguments) throw new Error(`No arguments in function_call ${JSON.stringify(generations)}`);
          if (this.argsOnly) return functionCall.arguments;
          return JSON.stringify(functionCall);
        } else throw new Error(`No message in generations ${JSON.stringify(generations)}`);
      }
    };
    var JsonOutputFunctionsParser = class extends require_transform2.BaseCumulativeTransformOutputParser {
      static lc_name() {
        return "JsonOutputFunctionsParser";
      }
      lc_namespace = [
        "langchain",
        "output_parsers",
        "openai_functions"
      ];
      lc_serializable = true;
      outputParser;
      argsOnly = true;
      constructor(config) {
        super(config);
        this.argsOnly = config?.argsOnly ?? this.argsOnly;
        this.outputParser = new OutputFunctionsParser(config);
      }
      _diff(prev, next) {
        if (!next) return void 0;
        const ops = require_duplex2.compare(prev ?? {}, next);
        return ops;
      }
      async parsePartialResult(generations) {
        const generation = generations[0];
        if (!generation.message) return void 0;
        const { message } = generation;
        const functionCall = message.additional_kwargs.function_call;
        if (!functionCall) return void 0;
        if (this.argsOnly) return require_json3.parsePartialJson(functionCall.arguments);
        return {
          ...functionCall,
          arguments: require_json3.parsePartialJson(functionCall.arguments)
        };
      }
      /**
      * Parses the output and returns a JSON object. If `argsOnly` is true,
      * only the arguments of the function call are returned.
      * @param generations The output of the LLM to parse.
      * @returns A JSON object representation of the function call or its arguments.
      */
      async parseResult(generations) {
        const result = await this.outputParser.parseResult(generations);
        if (!result) throw new Error(`No result from "OutputFunctionsParser" ${JSON.stringify(generations)}`);
        return this.parse(result);
      }
      async parse(text) {
        const parsedResult = JSON.parse(text);
        if (this.argsOnly) return parsedResult;
        parsedResult.arguments = JSON.parse(parsedResult.arguments);
        return parsedResult;
      }
      getFormatInstructions() {
        return "";
      }
    };
    var JsonKeyOutputFunctionsParser = class extends require_base18.BaseLLMOutputParser {
      static lc_name() {
        return "JsonKeyOutputFunctionsParser";
      }
      lc_namespace = [
        "langchain",
        "output_parsers",
        "openai_functions"
      ];
      lc_serializable = true;
      outputParser = new JsonOutputFunctionsParser();
      attrName;
      get lc_aliases() {
        return { attrName: "key_name" };
      }
      constructor(fields) {
        super(fields);
        this.attrName = fields.attrName;
      }
      /**
      * Parses the output and returns a specific attribute of the parsed JSON
      * object.
      * @param generations The output of the LLM to parse.
      * @returns The value of a specific attribute of the parsed JSON object.
      */
      async parseResult(generations) {
        const result = await this.outputParser.parseResult(generations);
        return result[this.attrName];
      }
    };
    exports2.JsonKeyOutputFunctionsParser = JsonKeyOutputFunctionsParser;
    exports2.JsonOutputFunctionsParser = JsonOutputFunctionsParser;
    exports2.OutputFunctionsParser = OutputFunctionsParser;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/openai_functions/index.cjs
var require_openai_functions = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/output_parsers/openai_functions/index.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_json_output_functions_parsers2 = require_json_output_functions_parsers();
    var openai_functions_exports = {};
    require_rolldown_runtime5.__export(openai_functions_exports, {
      JsonKeyOutputFunctionsParser: () => require_json_output_functions_parsers2.JsonKeyOutputFunctionsParser,
      JsonOutputFunctionsParser: () => require_json_output_functions_parsers2.JsonOutputFunctionsParser,
      OutputFunctionsParser: () => require_json_output_functions_parsers2.OutputFunctionsParser
    });
    exports2.JsonKeyOutputFunctionsParser = require_json_output_functions_parsers2.JsonKeyOutputFunctionsParser;
    exports2.JsonOutputFunctionsParser = require_json_output_functions_parsers2.JsonOutputFunctionsParser;
    exports2.OutputFunctionsParser = require_json_output_functions_parsers2.OutputFunctionsParser;
    Object.defineProperty(exports2, "openai_functions_exports", {
      enumerable: true,
      get: function() {
        return openai_functions_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompts/base.cjs
var require_base11 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompts/base.cjs"(exports2) {
    var require_base18 = require_base4();
    var BasePromptTemplate = class extends require_base18.Runnable {
      lc_serializable = true;
      lc_namespace = [
        "langchain_core",
        "prompts",
        this._getPromptType()
      ];
      get lc_attributes() {
        return { partialVariables: void 0 };
      }
      inputVariables;
      outputParser;
      partialVariables;
      /**
      * Metadata to be used for tracing.
      */
      metadata;
      /** Tags to be used for tracing. */
      tags;
      constructor(input) {
        super(input);
        const { inputVariables } = input;
        if (inputVariables.includes("stop")) throw new Error("Cannot have an input variable named 'stop', as it is used internally, please rename.");
        Object.assign(this, input);
      }
      /**
      * Merges partial variables and user variables.
      * @param userVariables The user variables to merge with the partial variables.
      * @returns A Promise that resolves to an object containing the merged variables.
      */
      async mergePartialAndUserVariables(userVariables) {
        const partialVariables = this.partialVariables ?? {};
        const partialValues = {};
        for (const [key, value] of Object.entries(partialVariables)) if (typeof value === "string") partialValues[key] = value;
        else partialValues[key] = await value();
        const allKwargs = {
          ...partialValues,
          ...userVariables
        };
        return allKwargs;
      }
      /**
      * Invokes the prompt template with the given input and options.
      * @param input The input to invoke the prompt template with.
      * @param options Optional configuration for the callback.
      * @returns A Promise that resolves to the output of the prompt template.
      */
      async invoke(input, options) {
        const metadata = {
          ...this.metadata,
          ...options?.metadata
        };
        const tags = [...this.tags ?? [], ...options?.tags ?? []];
        return this._callWithConfig((input$1) => this.formatPromptValue(input$1), input, {
          ...options,
          tags,
          metadata,
          runType: "prompt"
        });
      }
    };
    exports2.BasePromptTemplate = BasePromptTemplate;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompts/string.cjs
var require_string3 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompts/string.cjs"(exports2) {
    var require_prompt_values2 = require_prompt_values();
    var require_base18 = require_base11();
    var BaseStringPromptTemplate = class extends require_base18.BasePromptTemplate {
      /**
      * Formats the prompt given the input values and returns a formatted
      * prompt value.
      * @param values The input values to format the prompt.
      * @returns A Promise that resolves to a formatted prompt value.
      */
      async formatPromptValue(values) {
        const formattedPrompt = await this.format(values);
        return new require_prompt_values2.StringPromptValue(formattedPrompt);
      }
    };
    exports2.BaseStringPromptTemplate = BaseStringPromptTemplate;
  }
});

// node_modules/.pnpm/mustache@4.2.0/node_modules/mustache/mustache.js
var require_mustache = __commonJS({
  "node_modules/.pnpm/mustache@4.2.0/node_modules/mustache/mustache.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.Mustache = factory());
    })(exports2, (function() {
      "use strict";
      var objectToString = Object.prototype.toString;
      var isArray = Array.isArray || function isArrayPolyfill(object) {
        return objectToString.call(object) === "[object Array]";
      };
      function isFunction(object) {
        return typeof object === "function";
      }
      function typeStr(obj) {
        return isArray(obj) ? "array" : typeof obj;
      }
      function escapeRegExp(string) {
        return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
      }
      function hasProperty(obj, propName) {
        return obj != null && typeof obj === "object" && propName in obj;
      }
      function primitiveHasOwnProperty(primitive, propName) {
        return primitive != null && typeof primitive !== "object" && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);
      }
      var regExpTest = RegExp.prototype.test;
      function testRegExp(re, string) {
        return regExpTest.call(re, string);
      }
      var nonSpaceRe = /\S/;
      function isWhitespace(string) {
        return !testRegExp(nonSpaceRe, string);
      }
      var entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;",
        "`": "&#x60;",
        "=": "&#x3D;"
      };
      function escapeHtml(string) {
        return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
          return entityMap[s];
        });
      }
      var whiteRe = /\s*/;
      var spaceRe = /\s+/;
      var equalsRe = /\s*=/;
      var curlyRe = /\s*\}/;
      var tagRe = /#|\^|\/|>|\{|&|=|!/;
      function parseTemplate(template, tags) {
        if (!template)
          return [];
        var lineHasNonSpace = false;
        var sections = [];
        var tokens = [];
        var spaces = [];
        var hasTag = false;
        var nonSpace = false;
        var indentation = "";
        var tagIndex = 0;
        function stripSpace() {
          if (hasTag && !nonSpace) {
            while (spaces.length)
              delete tokens[spaces.pop()];
          } else {
            spaces = [];
          }
          hasTag = false;
          nonSpace = false;
        }
        var openingTagRe, closingTagRe, closingCurlyRe;
        function compileTags(tagsToCompile) {
          if (typeof tagsToCompile === "string")
            tagsToCompile = tagsToCompile.split(spaceRe, 2);
          if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
            throw new Error("Invalid tags: " + tagsToCompile);
          openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
          closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
          closingCurlyRe = new RegExp("\\s*" + escapeRegExp("}" + tagsToCompile[1]));
        }
        compileTags(tags || mustache.tags);
        var scanner = new Scanner(template);
        var start, type, value, chr, token, openSection;
        while (!scanner.eos()) {
          start = scanner.pos;
          value = scanner.scanUntil(openingTagRe);
          if (value) {
            for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
              chr = value.charAt(i);
              if (isWhitespace(chr)) {
                spaces.push(tokens.length);
                indentation += chr;
              } else {
                nonSpace = true;
                lineHasNonSpace = true;
                indentation += " ";
              }
              tokens.push(["text", chr, start, start + 1]);
              start += 1;
              if (chr === "\n") {
                stripSpace();
                indentation = "";
                tagIndex = 0;
                lineHasNonSpace = false;
              }
            }
          }
          if (!scanner.scan(openingTagRe))
            break;
          hasTag = true;
          type = scanner.scan(tagRe) || "name";
          scanner.scan(whiteRe);
          if (type === "=") {
            value = scanner.scanUntil(equalsRe);
            scanner.scan(equalsRe);
            scanner.scanUntil(closingTagRe);
          } else if (type === "{") {
            value = scanner.scanUntil(closingCurlyRe);
            scanner.scan(curlyRe);
            scanner.scanUntil(closingTagRe);
            type = "&";
          } else {
            value = scanner.scanUntil(closingTagRe);
          }
          if (!scanner.scan(closingTagRe))
            throw new Error("Unclosed tag at " + scanner.pos);
          if (type == ">") {
            token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];
          } else {
            token = [type, value, start, scanner.pos];
          }
          tagIndex++;
          tokens.push(token);
          if (type === "#" || type === "^") {
            sections.push(token);
          } else if (type === "/") {
            openSection = sections.pop();
            if (!openSection)
              throw new Error('Unopened section "' + value + '" at ' + start);
            if (openSection[1] !== value)
              throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
          } else if (type === "name" || type === "{" || type === "&") {
            nonSpace = true;
          } else if (type === "=") {
            compileTags(value);
          }
        }
        stripSpace();
        openSection = sections.pop();
        if (openSection)
          throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
        return nestTokens(squashTokens(tokens));
      }
      function squashTokens(tokens) {
        var squashedTokens = [];
        var token, lastToken;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          token = tokens[i];
          if (token) {
            if (token[0] === "text" && lastToken && lastToken[0] === "text") {
              lastToken[1] += token[1];
              lastToken[3] = token[3];
            } else {
              squashedTokens.push(token);
              lastToken = token;
            }
          }
        }
        return squashedTokens;
      }
      function nestTokens(tokens) {
        var nestedTokens = [];
        var collector = nestedTokens;
        var sections = [];
        var token, section;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          token = tokens[i];
          switch (token[0]) {
            case "#":
            case "^":
              collector.push(token);
              sections.push(token);
              collector = token[4] = [];
              break;
            case "/":
              section = sections.pop();
              section[5] = token[2];
              collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
              break;
            default:
              collector.push(token);
          }
        }
        return nestedTokens;
      }
      function Scanner(string) {
        this.string = string;
        this.tail = string;
        this.pos = 0;
      }
      Scanner.prototype.eos = function eos() {
        return this.tail === "";
      };
      Scanner.prototype.scan = function scan(re) {
        var match = this.tail.match(re);
        if (!match || match.index !== 0)
          return "";
        var string = match[0];
        this.tail = this.tail.substring(string.length);
        this.pos += string.length;
        return string;
      };
      Scanner.prototype.scanUntil = function scanUntil(re) {
        var index = this.tail.search(re), match;
        switch (index) {
          case -1:
            match = this.tail;
            this.tail = "";
            break;
          case 0:
            match = "";
            break;
          default:
            match = this.tail.substring(0, index);
            this.tail = this.tail.substring(index);
        }
        this.pos += match.length;
        return match;
      };
      function Context(view, parentContext) {
        this.view = view;
        this.cache = { ".": this.view };
        this.parent = parentContext;
      }
      Context.prototype.push = function push(view) {
        return new Context(view, this);
      };
      Context.prototype.lookup = function lookup(name) {
        var cache = this.cache;
        var value;
        if (cache.hasOwnProperty(name)) {
          value = cache[name];
        } else {
          var context = this, intermediateValue, names, index, lookupHit = false;
          while (context) {
            if (name.indexOf(".") > 0) {
              intermediateValue = context.view;
              names = name.split(".");
              index = 0;
              while (intermediateValue != null && index < names.length) {
                if (index === names.length - 1)
                  lookupHit = hasProperty(intermediateValue, names[index]) || primitiveHasOwnProperty(intermediateValue, names[index]);
                intermediateValue = intermediateValue[names[index++]];
              }
            } else {
              intermediateValue = context.view[name];
              lookupHit = hasProperty(context.view, name);
            }
            if (lookupHit) {
              value = intermediateValue;
              break;
            }
            context = context.parent;
          }
          cache[name] = value;
        }
        if (isFunction(value))
          value = value.call(this.view);
        return value;
      };
      function Writer() {
        this.templateCache = {
          _cache: {},
          set: function set(key, value) {
            this._cache[key] = value;
          },
          get: function get(key) {
            return this._cache[key];
          },
          clear: function clear() {
            this._cache = {};
          }
        };
      }
      Writer.prototype.clearCache = function clearCache() {
        if (typeof this.templateCache !== "undefined") {
          this.templateCache.clear();
        }
      };
      Writer.prototype.parse = function parse2(template, tags) {
        var cache = this.templateCache;
        var cacheKey = template + ":" + (tags || mustache.tags).join(":");
        var isCacheEnabled = typeof cache !== "undefined";
        var tokens = isCacheEnabled ? cache.get(cacheKey) : void 0;
        if (tokens == void 0) {
          tokens = parseTemplate(template, tags);
          isCacheEnabled && cache.set(cacheKey, tokens);
        }
        return tokens;
      };
      Writer.prototype.render = function render(template, view, partials, config) {
        var tags = this.getConfigTags(config);
        var tokens = this.parse(template, tags);
        var context = view instanceof Context ? view : new Context(view, void 0);
        return this.renderTokens(tokens, context, partials, template, config);
      };
      Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate, config) {
        var buffer = "";
        var token, symbol, value;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          value = void 0;
          token = tokens[i];
          symbol = token[0];
          if (symbol === "#") value = this.renderSection(token, context, partials, originalTemplate, config);
          else if (symbol === "^") value = this.renderInverted(token, context, partials, originalTemplate, config);
          else if (symbol === ">") value = this.renderPartial(token, context, partials, config);
          else if (symbol === "&") value = this.unescapedValue(token, context);
          else if (symbol === "name") value = this.escapedValue(token, context, config);
          else if (symbol === "text") value = this.rawValue(token);
          if (value !== void 0)
            buffer += value;
        }
        return buffer;
      };
      Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate, config) {
        var self2 = this;
        var buffer = "";
        var value = context.lookup(token[1]);
        function subRender(template) {
          return self2.render(template, context, partials, config);
        }
        if (!value) return;
        if (isArray(value)) {
          for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
            buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);
          }
        } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
          buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);
        } else if (isFunction(value)) {
          if (typeof originalTemplate !== "string")
            throw new Error("Cannot use higher-order sections without the original template");
          value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);
          if (value != null)
            buffer += value;
        } else {
          buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);
        }
        return buffer;
      };
      Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate, config) {
        var value = context.lookup(token[1]);
        if (!value || isArray(value) && value.length === 0)
          return this.renderTokens(token[4], context, partials, originalTemplate, config);
      };
      Writer.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {
        var filteredIndentation = indentation.replace(/[^ \t]/g, "");
        var partialByNl = partial.split("\n");
        for (var i = 0; i < partialByNl.length; i++) {
          if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
            partialByNl[i] = filteredIndentation + partialByNl[i];
          }
        }
        return partialByNl.join("\n");
      };
      Writer.prototype.renderPartial = function renderPartial(token, context, partials, config) {
        if (!partials) return;
        var tags = this.getConfigTags(config);
        var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
        if (value != null) {
          var lineHasNonSpace = token[6];
          var tagIndex = token[5];
          var indentation = token[4];
          var indentedValue = value;
          if (tagIndex == 0 && indentation) {
            indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
          }
          var tokens = this.parse(indentedValue, tags);
          return this.renderTokens(tokens, context, partials, indentedValue, config);
        }
      };
      Writer.prototype.unescapedValue = function unescapedValue(token, context) {
        var value = context.lookup(token[1]);
        if (value != null)
          return value;
      };
      Writer.prototype.escapedValue = function escapedValue(token, context, config) {
        var escape = this.getConfigEscape(config) || mustache.escape;
        var value = context.lookup(token[1]);
        if (value != null)
          return typeof value === "number" && escape === mustache.escape ? String(value) : escape(value);
      };
      Writer.prototype.rawValue = function rawValue(token) {
        return token[1];
      };
      Writer.prototype.getConfigTags = function getConfigTags(config) {
        if (isArray(config)) {
          return config;
        } else if (config && typeof config === "object") {
          return config.tags;
        } else {
          return void 0;
        }
      };
      Writer.prototype.getConfigEscape = function getConfigEscape(config) {
        if (config && typeof config === "object" && !isArray(config)) {
          return config.escape;
        } else {
          return void 0;
        }
      };
      var mustache = {
        name: "mustache.js",
        version: "4.2.0",
        tags: ["{{", "}}"],
        clearCache: void 0,
        escape: void 0,
        parse: void 0,
        render: void 0,
        Scanner: void 0,
        Context: void 0,
        Writer: void 0,
        /**
         * Allows a user to override the default caching strategy, by providing an
         * object with set, get and clear methods. This can also be used to disable
         * the cache by setting it to the literal `undefined`.
         */
        set templateCache(cache) {
          defaultWriter.templateCache = cache;
        },
        /**
         * Gets the default or overridden caching object from the default writer.
         */
        get templateCache() {
          return defaultWriter.templateCache;
        }
      };
      var defaultWriter = new Writer();
      mustache.clearCache = function clearCache() {
        return defaultWriter.clearCache();
      };
      mustache.parse = function parse2(template, tags) {
        return defaultWriter.parse(template, tags);
      };
      mustache.render = function render(template, view, partials, config) {
        if (typeof template !== "string") {
          throw new TypeError('Invalid template! Template should be a "string" but "' + typeStr(template) + '" was given as the first argument for mustache#render(template, view, partials)');
        }
        return defaultWriter.render(template, view, partials, config);
      };
      mustache.escape = escapeHtml;
      mustache.Scanner = Scanner;
      mustache.Context = Context;
      mustache.Writer = Writer;
      return mustache;
    }));
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompts/template.cjs
var require_template = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompts/template.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_index = require_errors4();
    var mustache = require_rolldown_runtime5.__toESM(require_mustache());
    function configureMustache() {
      mustache.default.escape = (text) => text;
    }
    var parseFString = (template) => {
      const chars = template.split("");
      const nodes = [];
      const nextBracket = (bracket, start) => {
        for (let i$1 = start; i$1 < chars.length; i$1 += 1) if (bracket.includes(chars[i$1])) return i$1;
        return -1;
      };
      let i = 0;
      while (i < chars.length) if (chars[i] === "{" && i + 1 < chars.length && chars[i + 1] === "{") {
        nodes.push({
          type: "literal",
          text: "{"
        });
        i += 2;
      } else if (chars[i] === "}" && i + 1 < chars.length && chars[i + 1] === "}") {
        nodes.push({
          type: "literal",
          text: "}"
        });
        i += 2;
      } else if (chars[i] === "{") {
        const j = nextBracket("}", i);
        if (j < 0) throw new Error("Unclosed '{' in template.");
        nodes.push({
          type: "variable",
          name: chars.slice(i + 1, j).join("")
        });
        i = j + 1;
      } else if (chars[i] === "}") throw new Error("Single '}' in template.");
      else {
        const next = nextBracket("{}", i);
        const text = (next < 0 ? chars.slice(i) : chars.slice(i, next)).join("");
        nodes.push({
          type: "literal",
          text
        });
        i = next < 0 ? chars.length : next;
      }
      return nodes;
    };
    var mustacheTemplateToNodes = (template, context = []) => {
      const nodes = [];
      for (const temp of template) if (temp[0] === "name") {
        const name = temp[1].includes(".") ? temp[1].split(".")[0] : temp[1];
        nodes.push({
          type: "variable",
          name
        });
      } else if ([
        "#",
        "&",
        "^",
        ">"
      ].includes(temp[0])) {
        nodes.push({
          type: "variable",
          name: temp[1]
        });
        if (temp[0] === "#" && temp.length > 4 && Array.isArray(temp[4])) {
          const newContext = [...context, temp[1]];
          const nestedNodes = mustacheTemplateToNodes(temp[4], newContext);
          nodes.push(...nestedNodes);
        }
      } else nodes.push({
        type: "literal",
        text: temp[1]
      });
      return nodes;
    };
    var parseMustache = (template) => {
      configureMustache();
      const parsed = mustache.default.parse(template);
      return mustacheTemplateToNodes(parsed);
    };
    var interpolateFString = (template, values) => {
      return parseFString(template).reduce((res, node) => {
        if (node.type === "variable") {
          if (node.name in values) {
            const stringValue = typeof values[node.name] === "string" ? values[node.name] : JSON.stringify(values[node.name]);
            return res + stringValue;
          }
          throw new Error(`(f-string) Missing value for input ${node.name}`);
        }
        return res + node.text;
      }, "");
    };
    var interpolateMustache = (template, values) => {
      configureMustache();
      return mustache.default.render(template, values);
    };
    var DEFAULT_FORMATTER_MAPPING = {
      "f-string": interpolateFString,
      mustache: interpolateMustache
    };
    var DEFAULT_PARSER_MAPPING = {
      "f-string": parseFString,
      mustache: parseMustache
    };
    var renderTemplate = (template, templateFormat, inputValues) => {
      try {
        return DEFAULT_FORMATTER_MAPPING[templateFormat](template, inputValues);
      } catch (e) {
        const error = require_index.addLangChainErrorFields(e, "INVALID_PROMPT_INPUT");
        throw error;
      }
    };
    var parseTemplate = (template, templateFormat) => DEFAULT_PARSER_MAPPING[templateFormat](template);
    var checkValidTemplate = (template, templateFormat, inputVariables) => {
      if (!(templateFormat in DEFAULT_FORMATTER_MAPPING)) {
        const validFormats = Object.keys(DEFAULT_FORMATTER_MAPPING);
        throw new Error(`Invalid template format. Got \`${templateFormat}\`;
                         should be one of ${validFormats}`);
      }
      try {
        const dummyInputs = inputVariables.reduce((acc, v) => {
          acc[v] = "foo";
          return acc;
        }, {});
        if (Array.isArray(template)) template.forEach((message) => {
          if (message.type === "text" && "text" in message && typeof message.text === "string") renderTemplate(message.text, templateFormat, dummyInputs);
          else if (message.type === "image_url") {
            if (typeof message.image_url === "string") renderTemplate(message.image_url, templateFormat, dummyInputs);
            else if (typeof message.image_url === "object" && message.image_url !== null && "url" in message.image_url && typeof message.image_url.url === "string") {
              const imageUrl = message.image_url.url;
              renderTemplate(imageUrl, templateFormat, dummyInputs);
            }
          } else throw new Error(`Invalid message template received. ${JSON.stringify(message, null, 2)}`);
        });
        else renderTemplate(template, templateFormat, dummyInputs);
      } catch (e) {
        throw new Error(`Invalid prompt schema: ${e.message}`);
      }
    };
    exports2.DEFAULT_FORMATTER_MAPPING = DEFAULT_FORMATTER_MAPPING;
    exports2.DEFAULT_PARSER_MAPPING = DEFAULT_PARSER_MAPPING;
    exports2.checkValidTemplate = checkValidTemplate;
    exports2.interpolateFString = interpolateFString;
    exports2.interpolateMustache = interpolateMustache;
    exports2.parseFString = parseFString;
    exports2.parseMustache = parseMustache;
    exports2.parseTemplate = parseTemplate;
    exports2.renderTemplate = renderTemplate;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompts/prompt.cjs
var require_prompt = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompts/prompt.cjs"(exports2) {
    var require_string4 = require_string3();
    var require_template2 = require_template();
    var PromptTemplate = class PromptTemplate2 extends require_string4.BaseStringPromptTemplate {
      static lc_name() {
        return "PromptTemplate";
      }
      template;
      templateFormat = "f-string";
      validateTemplate = true;
      /**
      * Additional fields which should be included inside
      * the message content array if using a complex message
      * content.
      */
      additionalContentFields;
      constructor(input) {
        super(input);
        if (input.templateFormat === "mustache" && input.validateTemplate === void 0) this.validateTemplate = false;
        Object.assign(this, input);
        if (this.validateTemplate) {
          if (this.templateFormat === "mustache") throw new Error("Mustache templates cannot be validated.");
          let totalInputVariables = this.inputVariables;
          if (this.partialVariables) totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));
          require_template2.checkValidTemplate(this.template, this.templateFormat, totalInputVariables);
        }
      }
      _getPromptType() {
        return "prompt";
      }
      /**
      * Formats the prompt template with the provided values.
      * @param values The values to be used to format the prompt template.
      * @returns A promise that resolves to a string which is the formatted prompt.
      */
      async format(values) {
        const allValues = await this.mergePartialAndUserVariables(values);
        return require_template2.renderTemplate(this.template, this.templateFormat, allValues);
      }
      /**
      * Take examples in list format with prefix and suffix to create a prompt.
      *
      * Intended to be used a a way to dynamically create a prompt from examples.
      *
      * @param examples - List of examples to use in the prompt.
      * @param suffix - String to go after the list of examples. Should generally set up the user's input.
      * @param inputVariables - A list of variable names the final prompt template will expect
      * @param exampleSeparator - The separator to use in between examples
      * @param prefix - String that should go before any examples. Generally includes examples.
      *
      * @returns The final prompt template generated.
      */
      static fromExamples(examples, suffix, inputVariables, exampleSeparator = "\n\n", prefix = "") {
        const template = [
          prefix,
          ...examples,
          suffix
        ].join(exampleSeparator);
        return new PromptTemplate2({
          inputVariables,
          template
        });
      }
      static fromTemplate(template, options) {
        const { templateFormat = "f-string", ...rest } = options ?? {};
        const names = /* @__PURE__ */ new Set();
        require_template2.parseTemplate(template, templateFormat).forEach((node) => {
          if (node.type === "variable") names.add(node.name);
        });
        return new PromptTemplate2({
          inputVariables: [...names],
          templateFormat,
          template,
          ...rest
        });
      }
      /**
      * Partially applies values to the prompt template.
      * @param values The values to be partially applied to the prompt template.
      * @returns A new instance of PromptTemplate with the partially applied values.
      */
      async partial(values) {
        const newInputVariables = this.inputVariables.filter((iv) => !(iv in values));
        const newPartialVariables = {
          ...this.partialVariables ?? {},
          ...values
        };
        const promptDict = {
          ...this,
          inputVariables: newInputVariables,
          partialVariables: newPartialVariables
        };
        return new PromptTemplate2(promptDict);
      }
      serialize() {
        if (this.outputParser !== void 0) throw new Error("Cannot serialize a prompt template with an output parser");
        return {
          _type: this._getPromptType(),
          input_variables: this.inputVariables,
          template: this.template,
          template_format: this.templateFormat
        };
      }
      static async deserialize(data) {
        if (!data.template) throw new Error("Prompt template must have a template");
        const res = new PromptTemplate2({
          inputVariables: data.input_variables,
          template: data.template,
          templateFormat: data.template_format
        });
        return res;
      }
    };
    exports2.PromptTemplate = PromptTemplate;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompts/image.cjs
var require_image = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompts/image.cjs"(exports2) {
    var require_prompt_values2 = require_prompt_values();
    var require_base18 = require_base11();
    var require_template2 = require_template();
    var ImagePromptTemplate = class ImagePromptTemplate2 extends require_base18.BasePromptTemplate {
      static lc_name() {
        return "ImagePromptTemplate";
      }
      lc_namespace = [
        "langchain_core",
        "prompts",
        "image"
      ];
      template;
      templateFormat = "f-string";
      validateTemplate = true;
      /**
      * Additional fields which should be included inside
      * the message content array if using a complex message
      * content.
      */
      additionalContentFields;
      constructor(input) {
        super(input);
        this.template = input.template;
        this.templateFormat = input.templateFormat ?? this.templateFormat;
        this.validateTemplate = input.validateTemplate ?? this.validateTemplate;
        this.additionalContentFields = input.additionalContentFields;
        if (this.validateTemplate) {
          let totalInputVariables = this.inputVariables;
          if (this.partialVariables) totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));
          require_template2.checkValidTemplate([{
            type: "image_url",
            image_url: this.template
          }], this.templateFormat, totalInputVariables);
        }
      }
      _getPromptType() {
        return "prompt";
      }
      /**
      * Partially applies values to the prompt template.
      * @param values The values to be partially applied to the prompt template.
      * @returns A new instance of ImagePromptTemplate with the partially applied values.
      */
      async partial(values) {
        const newInputVariables = this.inputVariables.filter((iv) => !(iv in values));
        const newPartialVariables = {
          ...this.partialVariables ?? {},
          ...values
        };
        const promptDict = {
          ...this,
          inputVariables: newInputVariables,
          partialVariables: newPartialVariables
        };
        return new ImagePromptTemplate2(promptDict);
      }
      /**
      * Formats the prompt template with the provided values.
      * @param values The values to be used to format the prompt template.
      * @returns A promise that resolves to a string which is the formatted prompt.
      */
      async format(values) {
        const formatted = {};
        for (const [key, value] of Object.entries(this.template)) if (typeof value === "string") formatted[key] = require_template2.renderTemplate(value, this.templateFormat, values);
        else formatted[key] = value;
        const url = values.url || formatted.url;
        const detail = values.detail || formatted.detail;
        if (!url) throw new Error("Must provide either an image URL.");
        if (typeof url !== "string") throw new Error("url must be a string.");
        const output = { url };
        if (detail) output.detail = detail;
        return output;
      }
      /**
      * Formats the prompt given the input values and returns a formatted
      * prompt value.
      * @param values The input values to format the prompt.
      * @returns A Promise that resolves to a formatted prompt value.
      */
      async formatPromptValue(values) {
        const formattedPrompt = await this.format(values);
        return new require_prompt_values2.ImagePromptValue(formattedPrompt);
      }
    };
    exports2.ImagePromptTemplate = ImagePromptTemplate;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompts/dict.cjs
var require_dict = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompts/dict.cjs"(exports2) {
    var require_base18 = require_base4();
    var require_template2 = require_template();
    var DictPromptTemplate = class extends require_base18.Runnable {
      lc_namespace = [
        "langchain_core",
        "prompts",
        "dict"
      ];
      lc_serializable = true;
      template;
      templateFormat;
      inputVariables;
      static lc_name() {
        return "DictPromptTemplate";
      }
      constructor(fields) {
        const templateFormat = fields.templateFormat ?? "f-string";
        const inputVariables = _getInputVariables(fields.template, templateFormat);
        super({
          inputVariables,
          ...fields
        });
        this.template = fields.template;
        this.templateFormat = templateFormat;
        this.inputVariables = inputVariables;
      }
      async format(values) {
        return _insertInputVariables(this.template, values, this.templateFormat);
      }
      async invoke(values) {
        return await this._callWithConfig(this.format.bind(this), values, { runType: "prompt" });
      }
    };
    function _getInputVariables(template, templateFormat) {
      const inputVariables = [];
      for (const v of Object.values(template)) if (typeof v === "string") require_template2.parseTemplate(v, templateFormat).forEach((t) => {
        if (t.type === "variable") inputVariables.push(t.name);
      });
      else if (Array.isArray(v)) {
        for (const x of v) if (typeof x === "string") require_template2.parseTemplate(x, templateFormat).forEach((t) => {
          if (t.type === "variable") inputVariables.push(t.name);
        });
        else if (typeof x === "object") inputVariables.push(..._getInputVariables(x, templateFormat));
      } else if (typeof v === "object" && v !== null) inputVariables.push(..._getInputVariables(v, templateFormat));
      return Array.from(new Set(inputVariables));
    }
    function _insertInputVariables(template, inputs, templateFormat) {
      const formatted = {};
      for (const [k, v] of Object.entries(template)) if (typeof v === "string") formatted[k] = require_template2.renderTemplate(v, templateFormat, inputs);
      else if (Array.isArray(v)) {
        const formattedV = [];
        for (const x of v) if (typeof x === "string") formattedV.push(require_template2.renderTemplate(x, templateFormat, inputs));
        else if (typeof x === "object") formattedV.push(_insertInputVariables(x, inputs, templateFormat));
        formatted[k] = formattedV;
      } else if (typeof v === "object" && v !== null) formatted[k] = _insertInputVariables(v, inputs, templateFormat);
      else formatted[k] = v;
      return formatted;
    }
    exports2.DictPromptTemplate = DictPromptTemplate;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompts/chat.cjs
var require_chat2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompts/chat.cjs"(exports2) {
    var require_base18 = require_base();
    var require_ai2 = require_ai();
    var require_chat3 = require_chat();
    var require_human2 = require_human();
    var require_system2 = require_system();
    var require_index = require_errors4();
    var require_utils10 = require_utils3();
    var require_base$1 = require_base4();
    require_messages2();
    var require_prompt_values2 = require_prompt_values();
    var require_base$2 = require_base11();
    var require_string4 = require_string3();
    var require_template2 = require_template();
    var require_prompt2 = require_prompt();
    var require_image2 = require_image();
    var require_dict2 = require_dict();
    var BaseMessagePromptTemplate = class extends require_base$1.Runnable {
      lc_namespace = [
        "langchain_core",
        "prompts",
        "chat"
      ];
      lc_serializable = true;
      /**
      * Calls the formatMessages method with the provided input and options.
      * @param input Input for the formatMessages method
      * @param options Optional BaseCallbackConfig
      * @returns Formatted output messages
      */
      async invoke(input, options) {
        return this._callWithConfig((input$1) => this.formatMessages(input$1), input, {
          ...options,
          runType: "prompt"
        });
      }
    };
    var MessagesPlaceholder = class extends BaseMessagePromptTemplate {
      static lc_name() {
        return "MessagesPlaceholder";
      }
      variableName;
      optional;
      constructor(fields) {
        if (typeof fields === "string") fields = { variableName: fields };
        super(fields);
        this.variableName = fields.variableName;
        this.optional = fields.optional ?? false;
      }
      get inputVariables() {
        return [this.variableName];
      }
      async formatMessages(values) {
        const input = values[this.variableName];
        if (this.optional && !input) return [];
        else if (!input) {
          const error = /* @__PURE__ */ new Error(`Field "${this.variableName}" in prompt uses a MessagesPlaceholder, which expects an array of BaseMessages as an input value. Received: undefined`);
          error.name = "InputFormatError";
          throw error;
        }
        let formattedMessages;
        try {
          if (Array.isArray(input)) formattedMessages = input.map(require_utils10.coerceMessageLikeToMessage);
          else formattedMessages = [require_utils10.coerceMessageLikeToMessage(input)];
        } catch (e) {
          const readableInput = typeof input === "string" ? input : JSON.stringify(input, null, 2);
          const error = new Error([
            `Field "${this.variableName}" in prompt uses a MessagesPlaceholder, which expects an array of BaseMessages or coerceable values as input.`,
            `Received value: ${readableInput}`,
            `Additional message: ${e.message}`
          ].join("\n\n"));
          error.name = "InputFormatError";
          error.lc_error_code = e.lc_error_code;
          throw error;
        }
        return formattedMessages;
      }
    };
    var BaseMessageStringPromptTemplate = class extends BaseMessagePromptTemplate {
      prompt;
      constructor(fields) {
        if (!("prompt" in fields)) fields = { prompt: fields };
        super(fields);
        this.prompt = fields.prompt;
      }
      get inputVariables() {
        return this.prompt.inputVariables;
      }
      async formatMessages(values) {
        return [await this.format(values)];
      }
    };
    var BaseChatPromptTemplate = class extends require_base$2.BasePromptTemplate {
      constructor(input) {
        super(input);
      }
      async format(values) {
        return (await this.formatPromptValue(values)).toString();
      }
      async formatPromptValue(values) {
        const resultMessages = await this.formatMessages(values);
        return new require_prompt_values2.ChatPromptValue(resultMessages);
      }
    };
    var ChatMessagePromptTemplate = class extends BaseMessageStringPromptTemplate {
      static lc_name() {
        return "ChatMessagePromptTemplate";
      }
      role;
      constructor(fields, role) {
        if (!("prompt" in fields)) fields = {
          prompt: fields,
          role
        };
        super(fields);
        this.role = fields.role;
      }
      async format(values) {
        return new require_chat3.ChatMessage(await this.prompt.format(values), this.role);
      }
      static fromTemplate(template, role, options) {
        return new this(require_prompt2.PromptTemplate.fromTemplate(template, { templateFormat: options?.templateFormat }), role);
      }
    };
    function isTextTemplateParam(param) {
      if (param === null || typeof param !== "object" || Array.isArray(param)) return false;
      return Object.keys(param).length === 1 && "text" in param && typeof param.text === "string";
    }
    function isImageTemplateParam(param) {
      if (param === null || typeof param !== "object" || Array.isArray(param)) return false;
      return "image_url" in param && (typeof param.image_url === "string" || typeof param.image_url === "object" && param.image_url !== null && "url" in param.image_url && typeof param.image_url.url === "string");
    }
    var _StringImageMessagePromptTemplate = class extends BaseMessagePromptTemplate {
      lc_namespace = [
        "langchain_core",
        "prompts",
        "chat"
      ];
      lc_serializable = true;
      inputVariables = [];
      additionalOptions = {};
      prompt;
      messageClass;
      static _messageClass() {
        throw new Error("Can not invoke _messageClass from inside _StringImageMessagePromptTemplate");
      }
      chatMessageClass;
      constructor(fields, additionalOptions) {
        if (!("prompt" in fields)) fields = { prompt: fields };
        super(fields);
        this.prompt = fields.prompt;
        if (Array.isArray(this.prompt)) {
          let inputVariables = [];
          this.prompt.forEach((prompt) => {
            if ("inputVariables" in prompt) inputVariables = inputVariables.concat(prompt.inputVariables);
          });
          this.inputVariables = inputVariables;
        } else this.inputVariables = this.prompt.inputVariables;
        this.additionalOptions = additionalOptions ?? this.additionalOptions;
      }
      createMessage(content) {
        const constructor = this.constructor;
        if (constructor._messageClass()) {
          const MsgClass = constructor._messageClass();
          return new MsgClass({ content });
        } else if (constructor.chatMessageClass) {
          const MsgClass = constructor.chatMessageClass();
          return new MsgClass({
            content,
            role: this.getRoleFromMessageClass(MsgClass.lc_name())
          });
        } else throw new Error("No message class defined");
      }
      getRoleFromMessageClass(name) {
        switch (name) {
          case "HumanMessage":
            return "human";
          case "AIMessage":
            return "ai";
          case "SystemMessage":
            return "system";
          case "ChatMessage":
            return "chat";
          default:
            throw new Error("Invalid message class name");
        }
      }
      static fromTemplate(template, additionalOptions) {
        if (typeof template === "string") return new this(require_prompt2.PromptTemplate.fromTemplate(template, additionalOptions));
        const prompt = [];
        for (const item of template) if (typeof item === "string") prompt.push(require_prompt2.PromptTemplate.fromTemplate(item, additionalOptions));
        else if (item === null) {
        } else if (isTextTemplateParam(item)) {
          let text = "";
          if (typeof item.text === "string") text = item.text ?? "";
          const options = {
            ...additionalOptions,
            additionalContentFields: item
          };
          prompt.push(require_prompt2.PromptTemplate.fromTemplate(text, options));
        } else if (isImageTemplateParam(item)) {
          let imgTemplate = item.image_url ?? "";
          let imgTemplateObject;
          let inputVariables = [];
          if (typeof imgTemplate === "string") {
            let parsedTemplate;
            if (additionalOptions?.templateFormat === "mustache") parsedTemplate = require_template2.parseMustache(imgTemplate);
            else parsedTemplate = require_template2.parseFString(imgTemplate);
            const variables = parsedTemplate.flatMap((item$1) => item$1.type === "variable" ? [item$1.name] : []);
            if ((variables?.length ?? 0) > 0) {
              if (variables.length > 1) throw new Error(`Only one format variable allowed per image template.
Got: ${variables}
From: ${imgTemplate}`);
              inputVariables = [variables[0]];
            } else inputVariables = [];
            imgTemplate = { url: imgTemplate };
            imgTemplateObject = new require_image2.ImagePromptTemplate({
              template: imgTemplate,
              inputVariables,
              templateFormat: additionalOptions?.templateFormat,
              additionalContentFields: item
            });
          } else if (typeof imgTemplate === "object") {
            if ("url" in imgTemplate) {
              let parsedTemplate;
              if (additionalOptions?.templateFormat === "mustache") parsedTemplate = require_template2.parseMustache(imgTemplate.url);
              else parsedTemplate = require_template2.parseFString(imgTemplate.url);
              inputVariables = parsedTemplate.flatMap((item$1) => item$1.type === "variable" ? [item$1.name] : []);
            } else inputVariables = [];
            imgTemplateObject = new require_image2.ImagePromptTemplate({
              template: imgTemplate,
              inputVariables,
              templateFormat: additionalOptions?.templateFormat,
              additionalContentFields: item
            });
          } else throw new Error("Invalid image template");
          prompt.push(imgTemplateObject);
        } else if (typeof item === "object") prompt.push(new require_dict2.DictPromptTemplate({
          template: item,
          templateFormat: additionalOptions?.templateFormat
        }));
        return new this({
          prompt,
          additionalOptions
        });
      }
      async format(input) {
        if (this.prompt instanceof require_string4.BaseStringPromptTemplate) {
          const text = await this.prompt.format(input);
          return this.createMessage(text);
        } else {
          const content = [];
          for (const prompt of this.prompt) {
            let inputs = {};
            if (!("inputVariables" in prompt)) throw new Error(`Prompt ${prompt} does not have inputVariables defined.`);
            for (const item of prompt.inputVariables) {
              if (!inputs) inputs = { [item]: input[item] };
              inputs = {
                ...inputs,
                [item]: input[item]
              };
            }
            if (prompt instanceof require_string4.BaseStringPromptTemplate) {
              const formatted = await prompt.format(inputs);
              let additionalContentFields;
              if ("additionalContentFields" in prompt) additionalContentFields = prompt.additionalContentFields;
              if (formatted !== "") content.push({
                ...additionalContentFields,
                type: "text",
                text: formatted
              });
            } else if (prompt instanceof require_image2.ImagePromptTemplate) {
              const formatted = await prompt.format(inputs);
              let additionalContentFields;
              if ("additionalContentFields" in prompt) additionalContentFields = prompt.additionalContentFields;
              content.push({
                ...additionalContentFields,
                type: "image_url",
                image_url: formatted
              });
            } else if (prompt instanceof require_dict2.DictPromptTemplate) {
              const formatted = await prompt.format(inputs);
              let additionalContentFields;
              if ("additionalContentFields" in prompt) additionalContentFields = prompt.additionalContentFields;
              content.push({
                ...additionalContentFields,
                ...formatted
              });
            }
          }
          return this.createMessage(content);
        }
      }
      async formatMessages(values) {
        return [await this.format(values)];
      }
    };
    var HumanMessagePromptTemplate = class extends _StringImageMessagePromptTemplate {
      static _messageClass() {
        return require_human2.HumanMessage;
      }
      static lc_name() {
        return "HumanMessagePromptTemplate";
      }
    };
    var AIMessagePromptTemplate = class extends _StringImageMessagePromptTemplate {
      static _messageClass() {
        return require_ai2.AIMessage;
      }
      static lc_name() {
        return "AIMessagePromptTemplate";
      }
    };
    var SystemMessagePromptTemplate = class extends _StringImageMessagePromptTemplate {
      static _messageClass() {
        return require_system2.SystemMessage;
      }
      static lc_name() {
        return "SystemMessagePromptTemplate";
      }
    };
    function _isBaseMessagePromptTemplate(baseMessagePromptTemplateLike) {
      return typeof baseMessagePromptTemplateLike.formatMessages === "function";
    }
    function _coerceMessagePromptTemplateLike(messagePromptTemplateLike, extra) {
      if (_isBaseMessagePromptTemplate(messagePromptTemplateLike) || require_base18.isBaseMessage(messagePromptTemplateLike)) return messagePromptTemplateLike;
      if (Array.isArray(messagePromptTemplateLike) && messagePromptTemplateLike[0] === "placeholder") {
        const messageContent = messagePromptTemplateLike[1];
        if (extra?.templateFormat === "mustache" && typeof messageContent === "string" && messageContent.slice(0, 2) === "{{" && messageContent.slice(-2) === "}}") {
          const variableName = messageContent.slice(2, -2);
          return new MessagesPlaceholder({
            variableName,
            optional: true
          });
        } else if (typeof messageContent === "string" && messageContent[0] === "{" && messageContent[messageContent.length - 1] === "}") {
          const variableName = messageContent.slice(1, -1);
          return new MessagesPlaceholder({
            variableName,
            optional: true
          });
        }
        throw new Error(`Invalid placeholder template for format ${extra?.templateFormat ?? `"f-string"`}: "${messagePromptTemplateLike[1]}". Expected a variable name surrounded by ${extra?.templateFormat === "mustache" ? "double" : "single"} curly braces.`);
      }
      const message = require_utils10.coerceMessageLikeToMessage(messagePromptTemplateLike);
      let templateData;
      if (typeof message.content === "string") templateData = message.content;
      else templateData = message.content.map((item) => {
        if ("text" in item) return {
          ...item,
          text: item.text
        };
        else if ("image_url" in item) return {
          ...item,
          image_url: item.image_url
        };
        else return item;
      });
      if (message._getType() === "human") return HumanMessagePromptTemplate.fromTemplate(templateData, extra);
      else if (message._getType() === "ai") return AIMessagePromptTemplate.fromTemplate(templateData, extra);
      else if (message._getType() === "system") return SystemMessagePromptTemplate.fromTemplate(templateData, extra);
      else if (require_chat3.ChatMessage.isInstance(message)) return ChatMessagePromptTemplate.fromTemplate(message.content, message.role, extra);
      else throw new Error(`Could not coerce message prompt template from input. Received message type: "${message._getType()}".`);
    }
    function isMessagesPlaceholder(x) {
      return x.constructor.lc_name() === "MessagesPlaceholder";
    }
    var ChatPromptTemplate = class ChatPromptTemplate2 extends BaseChatPromptTemplate {
      static lc_name() {
        return "ChatPromptTemplate";
      }
      get lc_aliases() {
        return { promptMessages: "messages" };
      }
      promptMessages;
      validateTemplate = true;
      templateFormat = "f-string";
      constructor(input) {
        super(input);
        if (input.templateFormat === "mustache" && input.validateTemplate === void 0) this.validateTemplate = false;
        Object.assign(this, input);
        if (this.validateTemplate) {
          const inputVariablesMessages = /* @__PURE__ */ new Set();
          for (const promptMessage of this.promptMessages) {
            if (promptMessage instanceof require_base18.BaseMessage) continue;
            for (const inputVariable of promptMessage.inputVariables) inputVariablesMessages.add(inputVariable);
          }
          const totalInputVariables = this.inputVariables;
          const inputVariablesInstance = new Set(this.partialVariables ? totalInputVariables.concat(Object.keys(this.partialVariables)) : totalInputVariables);
          const difference = new Set([...inputVariablesInstance].filter((x) => !inputVariablesMessages.has(x)));
          if (difference.size > 0) throw new Error(`Input variables \`${[...difference]}\` are not used in any of the prompt messages.`);
          const otherDifference = new Set([...inputVariablesMessages].filter((x) => !inputVariablesInstance.has(x)));
          if (otherDifference.size > 0) throw new Error(`Input variables \`${[...otherDifference]}\` are used in prompt messages but not in the prompt template.`);
        }
      }
      _getPromptType() {
        return "chat";
      }
      async _parseImagePrompts(message, inputValues) {
        if (typeof message.content === "string") return message;
        const formattedMessageContent = await Promise.all(message.content.map(async (item) => {
          if (item.type !== "image_url") return item;
          let imageUrl = "";
          if (typeof item.image_url === "string") imageUrl = item.image_url;
          else if (typeof item.image_url === "object" && item.image_url !== null && "url" in item.image_url && typeof item.image_url.url === "string") imageUrl = item.image_url.url;
          const promptTemplatePlaceholder = require_prompt2.PromptTemplate.fromTemplate(imageUrl, { templateFormat: this.templateFormat });
          const formattedUrl = await promptTemplatePlaceholder.format(inputValues);
          if (typeof item.image_url === "object" && item.image_url !== null && "url" in item.image_url) item.image_url.url = formattedUrl;
          else item.image_url = formattedUrl;
          return item;
        }));
        message.content = formattedMessageContent;
        return message;
      }
      async formatMessages(values) {
        const allValues = await this.mergePartialAndUserVariables(values);
        let resultMessages = [];
        for (const promptMessage of this.promptMessages) if (promptMessage instanceof require_base18.BaseMessage) resultMessages.push(await this._parseImagePrompts(promptMessage, allValues));
        else {
          let inputValues;
          if (this.templateFormat === "mustache") inputValues = { ...allValues };
          else inputValues = promptMessage.inputVariables.reduce((acc, inputVariable) => {
            if (!(inputVariable in allValues) && !(isMessagesPlaceholder(promptMessage) && promptMessage.optional)) {
              const error = require_index.addLangChainErrorFields(/* @__PURE__ */ new Error(`Missing value for input variable \`${inputVariable.toString()}\``), "INVALID_PROMPT_INPUT");
              throw error;
            }
            acc[inputVariable] = allValues[inputVariable];
            return acc;
          }, {});
          const message = await promptMessage.formatMessages(inputValues);
          resultMessages = resultMessages.concat(message);
        }
        return resultMessages;
      }
      async partial(values) {
        const newInputVariables = this.inputVariables.filter((iv) => !(iv in values));
        const newPartialVariables = {
          ...this.partialVariables ?? {},
          ...values
        };
        const promptDict = {
          ...this,
          inputVariables: newInputVariables,
          partialVariables: newPartialVariables
        };
        return new ChatPromptTemplate2(promptDict);
      }
      static fromTemplate(template, options) {
        const prompt = require_prompt2.PromptTemplate.fromTemplate(template, options);
        const humanTemplate = new HumanMessagePromptTemplate({ prompt });
        return this.fromMessages([humanTemplate]);
      }
      /**
      * Create a chat model-specific prompt from individual chat messages
      * or message-like tuples.
      * @param promptMessages Messages to be passed to the chat model
      * @returns A new ChatPromptTemplate
      */
      static fromMessages(promptMessages, extra) {
        const flattenedMessages = promptMessages.reduce((acc, promptMessage) => acc.concat(promptMessage instanceof ChatPromptTemplate2 ? promptMessage.promptMessages : [_coerceMessagePromptTemplateLike(promptMessage, extra)]), []);
        const flattenedPartialVariables = promptMessages.reduce((acc, promptMessage) => promptMessage instanceof ChatPromptTemplate2 ? Object.assign(acc, promptMessage.partialVariables) : acc, /* @__PURE__ */ Object.create(null));
        const inputVariables = /* @__PURE__ */ new Set();
        for (const promptMessage of flattenedMessages) {
          if (promptMessage instanceof require_base18.BaseMessage) continue;
          for (const inputVariable of promptMessage.inputVariables) {
            if (inputVariable in flattenedPartialVariables) continue;
            inputVariables.add(inputVariable);
          }
        }
        return new this({
          ...extra,
          inputVariables: [...inputVariables],
          promptMessages: flattenedMessages,
          partialVariables: flattenedPartialVariables,
          templateFormat: extra?.templateFormat
        });
      }
    };
    exports2.AIMessagePromptTemplate = AIMessagePromptTemplate;
    exports2.BaseChatPromptTemplate = BaseChatPromptTemplate;
    exports2.BaseMessagePromptTemplate = BaseMessagePromptTemplate;
    exports2.BaseMessageStringPromptTemplate = BaseMessageStringPromptTemplate;
    exports2.ChatMessagePromptTemplate = ChatMessagePromptTemplate;
    exports2.ChatPromptTemplate = ChatPromptTemplate;
    exports2.HumanMessagePromptTemplate = HumanMessagePromptTemplate;
    exports2.MessagesPlaceholder = MessagesPlaceholder;
    exports2.SystemMessagePromptTemplate = SystemMessagePromptTemplate;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompts/few_shot.cjs
var require_few_shot = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompts/few_shot.cjs"(exports2) {
    var require_string4 = require_string3();
    var require_template2 = require_template();
    var require_prompt2 = require_prompt();
    var require_chat3 = require_chat2();
    var FewShotPromptTemplate = class FewShotPromptTemplate2 extends require_string4.BaseStringPromptTemplate {
      lc_serializable = false;
      examples;
      exampleSelector;
      examplePrompt;
      suffix = "";
      exampleSeparator = "\n\n";
      prefix = "";
      templateFormat = "f-string";
      validateTemplate = true;
      constructor(input) {
        super(input);
        Object.assign(this, input);
        if (this.examples !== void 0 && this.exampleSelector !== void 0) throw new Error("Only one of 'examples' and 'example_selector' should be provided");
        if (this.examples === void 0 && this.exampleSelector === void 0) throw new Error("One of 'examples' and 'example_selector' should be provided");
        if (this.validateTemplate) {
          let totalInputVariables = this.inputVariables;
          if (this.partialVariables) totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));
          require_template2.checkValidTemplate(this.prefix + this.suffix, this.templateFormat, totalInputVariables);
        }
      }
      _getPromptType() {
        return "few_shot";
      }
      static lc_name() {
        return "FewShotPromptTemplate";
      }
      async getExamples(inputVariables) {
        if (this.examples !== void 0) return this.examples;
        if (this.exampleSelector !== void 0) return this.exampleSelector.selectExamples(inputVariables);
        throw new Error("One of 'examples' and 'example_selector' should be provided");
      }
      async partial(values) {
        const newInputVariables = this.inputVariables.filter((iv) => !(iv in values));
        const newPartialVariables = {
          ...this.partialVariables ?? {},
          ...values
        };
        const promptDict = {
          ...this,
          inputVariables: newInputVariables,
          partialVariables: newPartialVariables
        };
        return new FewShotPromptTemplate2(promptDict);
      }
      /**
      * Formats the prompt with the given values.
      * @param values The values to format the prompt with.
      * @returns A promise that resolves to a string representing the formatted prompt.
      */
      async format(values) {
        const allValues = await this.mergePartialAndUserVariables(values);
        const examples = await this.getExamples(allValues);
        const exampleStrings = await Promise.all(examples.map((example) => this.examplePrompt.format(example)));
        const template = [
          this.prefix,
          ...exampleStrings,
          this.suffix
        ].join(this.exampleSeparator);
        return require_template2.renderTemplate(template, this.templateFormat, allValues);
      }
      serialize() {
        if (this.exampleSelector || !this.examples) throw new Error("Serializing an example selector is not currently supported");
        if (this.outputParser !== void 0) throw new Error("Serializing an output parser is not currently supported");
        return {
          _type: this._getPromptType(),
          input_variables: this.inputVariables,
          example_prompt: this.examplePrompt.serialize(),
          example_separator: this.exampleSeparator,
          suffix: this.suffix,
          prefix: this.prefix,
          template_format: this.templateFormat,
          examples: this.examples
        };
      }
      static async deserialize(data) {
        const { example_prompt } = data;
        if (!example_prompt) throw new Error("Missing example prompt");
        const examplePrompt = await require_prompt2.PromptTemplate.deserialize(example_prompt);
        let examples;
        if (Array.isArray(data.examples)) examples = data.examples;
        else throw new Error("Invalid examples format. Only list or string are supported.");
        return new FewShotPromptTemplate2({
          inputVariables: data.input_variables,
          examplePrompt,
          examples,
          exampleSeparator: data.example_separator,
          prefix: data.prefix,
          suffix: data.suffix,
          templateFormat: data.template_format
        });
      }
    };
    var FewShotChatMessagePromptTemplate = class FewShotChatMessagePromptTemplate2 extends require_chat3.BaseChatPromptTemplate {
      lc_serializable = true;
      examples;
      exampleSelector;
      examplePrompt;
      suffix = "";
      exampleSeparator = "\n\n";
      prefix = "";
      templateFormat = "f-string";
      validateTemplate = true;
      _getPromptType() {
        return "few_shot_chat";
      }
      static lc_name() {
        return "FewShotChatMessagePromptTemplate";
      }
      constructor(fields) {
        super(fields);
        this.examples = fields.examples;
        this.examplePrompt = fields.examplePrompt;
        this.exampleSeparator = fields.exampleSeparator ?? "\n\n";
        this.exampleSelector = fields.exampleSelector;
        this.prefix = fields.prefix ?? "";
        this.suffix = fields.suffix ?? "";
        this.templateFormat = fields.templateFormat ?? "f-string";
        this.validateTemplate = fields.validateTemplate ?? true;
        if (this.examples !== void 0 && this.exampleSelector !== void 0) throw new Error("Only one of 'examples' and 'example_selector' should be provided");
        if (this.examples === void 0 && this.exampleSelector === void 0) throw new Error("One of 'examples' and 'example_selector' should be provided");
        if (this.validateTemplate) {
          let totalInputVariables = this.inputVariables;
          if (this.partialVariables) totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));
          require_template2.checkValidTemplate(this.prefix + this.suffix, this.templateFormat, totalInputVariables);
        }
      }
      async getExamples(inputVariables) {
        if (this.examples !== void 0) return this.examples;
        if (this.exampleSelector !== void 0) return this.exampleSelector.selectExamples(inputVariables);
        throw new Error("One of 'examples' and 'example_selector' should be provided");
      }
      /**
      * Formats the list of values and returns a list of formatted messages.
      * @param values The values to format the prompt with.
      * @returns A promise that resolves to a string representing the formatted prompt.
      */
      async formatMessages(values) {
        const allValues = await this.mergePartialAndUserVariables(values);
        let examples = await this.getExamples(allValues);
        examples = examples.map((example) => {
          const result = {};
          this.examplePrompt.inputVariables.forEach((inputVariable) => {
            result[inputVariable] = example[inputVariable];
          });
          return result;
        });
        const messages = [];
        for (const example of examples) {
          const exampleMessages = await this.examplePrompt.formatMessages(example);
          messages.push(...exampleMessages);
        }
        return messages;
      }
      /**
      * Formats the prompt with the given values.
      * @param values The values to format the prompt with.
      * @returns A promise that resolves to a string representing the formatted prompt.
      */
      async format(values) {
        const allValues = await this.mergePartialAndUserVariables(values);
        const examples = await this.getExamples(allValues);
        const exampleMessages = await Promise.all(examples.map((example) => this.examplePrompt.formatMessages(example)));
        const exampleStrings = exampleMessages.flat().map((message) => message.content);
        const template = [
          this.prefix,
          ...exampleStrings,
          this.suffix
        ].join(this.exampleSeparator);
        return require_template2.renderTemplate(template, this.templateFormat, allValues);
      }
      /**
      * Partially formats the prompt with the given values.
      * @param values The values to partially format the prompt with.
      * @returns A promise that resolves to an instance of `FewShotChatMessagePromptTemplate` with the given values partially formatted.
      */
      async partial(values) {
        const newInputVariables = this.inputVariables.filter((variable) => !(variable in values));
        const newPartialVariables = {
          ...this.partialVariables ?? {},
          ...values
        };
        const promptDict = {
          ...this,
          inputVariables: newInputVariables,
          partialVariables: newPartialVariables
        };
        return new FewShotChatMessagePromptTemplate2(promptDict);
      }
    };
    exports2.FewShotChatMessagePromptTemplate = FewShotChatMessagePromptTemplate;
    exports2.FewShotPromptTemplate = FewShotPromptTemplate;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompts/pipeline.cjs
var require_pipeline2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompts/pipeline.cjs"(exports2) {
    var require_base18 = require_base11();
    var require_chat3 = require_chat2();
    var PipelinePromptTemplate = class PipelinePromptTemplate2 extends require_base18.BasePromptTemplate {
      static lc_name() {
        return "PipelinePromptTemplate";
      }
      pipelinePrompts;
      finalPrompt;
      constructor(input) {
        super({
          ...input,
          inputVariables: []
        });
        this.pipelinePrompts = input.pipelinePrompts;
        this.finalPrompt = input.finalPrompt;
        this.inputVariables = this.computeInputValues();
      }
      /**
      * Computes the input values required by the pipeline prompts.
      * @returns Array of input values required by the pipeline prompts.
      */
      computeInputValues() {
        const intermediateValues = this.pipelinePrompts.map((pipelinePrompt) => pipelinePrompt.name);
        const inputValues = this.pipelinePrompts.map((pipelinePrompt) => pipelinePrompt.prompt.inputVariables.filter((inputValue) => !intermediateValues.includes(inputValue))).flat();
        return [...new Set(inputValues)];
      }
      static extractRequiredInputValues(allValues, requiredValueNames) {
        return requiredValueNames.reduce((requiredValues, valueName) => {
          requiredValues[valueName] = allValues[valueName];
          return requiredValues;
        }, {});
      }
      /**
      * Formats the pipeline prompts based on the provided input values.
      * @param values Input values to format the pipeline prompts.
      * @returns Promise that resolves with the formatted input values.
      */
      async formatPipelinePrompts(values) {
        const allValues = await this.mergePartialAndUserVariables(values);
        for (const { name: pipelinePromptName, prompt: pipelinePrompt } of this.pipelinePrompts) {
          const pipelinePromptInputValues = PipelinePromptTemplate2.extractRequiredInputValues(allValues, pipelinePrompt.inputVariables);
          if (pipelinePrompt instanceof require_chat3.ChatPromptTemplate) allValues[pipelinePromptName] = await pipelinePrompt.formatMessages(pipelinePromptInputValues);
          else allValues[pipelinePromptName] = await pipelinePrompt.format(pipelinePromptInputValues);
        }
        return PipelinePromptTemplate2.extractRequiredInputValues(allValues, this.finalPrompt.inputVariables);
      }
      /**
      * Formats the final prompt value based on the provided input values.
      * @param values Input values to format the final prompt value.
      * @returns Promise that resolves with the formatted final prompt value.
      */
      async formatPromptValue(values) {
        return this.finalPrompt.formatPromptValue(await this.formatPipelinePrompts(values));
      }
      async format(values) {
        return this.finalPrompt.format(await this.formatPipelinePrompts(values));
      }
      /**
      * Handles partial prompts, which are prompts that have been partially
      * filled with input values.
      * @param values Partial input values.
      * @returns Promise that resolves with a new PipelinePromptTemplate instance with updated input variables.
      */
      async partial(values) {
        const promptDict = { ...this };
        promptDict.inputVariables = this.inputVariables.filter((iv) => !(iv in values));
        promptDict.partialVariables = {
          ...this.partialVariables ?? {},
          ...values
        };
        return new PipelinePromptTemplate2(promptDict);
      }
      serialize() {
        throw new Error("Not implemented.");
      }
      _getPromptType() {
        return "pipeline";
      }
    };
    exports2.PipelinePromptTemplate = PipelinePromptTemplate;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompts/structured.cjs
var require_structured2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompts/structured.cjs"(exports2) {
    var require_base18 = require_base4();
    var require_chat3 = require_chat2();
    function isWithStructuredOutput(x) {
      return typeof x === "object" && x != null && "withStructuredOutput" in x && typeof x.withStructuredOutput === "function";
    }
    function isRunnableBinding(x) {
      return typeof x === "object" && x != null && "lc_id" in x && Array.isArray(x.lc_id) && x.lc_id.join("/") === "langchain_core/runnables/RunnableBinding";
    }
    var StructuredPrompt = class StructuredPrompt2 extends require_chat3.ChatPromptTemplate {
      schema;
      method;
      lc_namespace = [
        "langchain_core",
        "prompts",
        "structured"
      ];
      get lc_aliases() {
        return {
          ...super.lc_aliases,
          schema: "schema_"
        };
      }
      constructor(input) {
        super(input);
        this.schema = input.schema;
        this.method = input.method;
      }
      pipe(coerceable) {
        if (isWithStructuredOutput(coerceable)) return super.pipe(coerceable.withStructuredOutput(this.schema));
        if (isRunnableBinding(coerceable) && isWithStructuredOutput(coerceable.bound)) return super.pipe(new require_base18.RunnableBinding({
          bound: coerceable.bound.withStructuredOutput(this.schema, ...this.method ? [{ method: this.method }] : []),
          kwargs: coerceable.kwargs ?? {},
          config: coerceable.config,
          configFactories: coerceable.configFactories
        }));
        throw new Error(`Structured prompts need to be piped to a language model that supports the "withStructuredOutput()" method.`);
      }
      static fromMessagesAndSchema(promptMessages, schema, method) {
        return StructuredPrompt2.fromMessages(promptMessages, {
          schema,
          method
        });
      }
    };
    exports2.StructuredPrompt = StructuredPrompt;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompts/index.cjs
var require_prompts2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/prompts/index.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_base18 = require_base11();
    var require_string4 = require_string3();
    var require_template2 = require_template();
    var require_prompt2 = require_prompt();
    var require_image2 = require_image();
    var require_dict2 = require_dict();
    var require_chat3 = require_chat2();
    var require_few_shot2 = require_few_shot();
    var require_pipeline3 = require_pipeline2();
    var require_structured3 = require_structured2();
    var prompts_exports = {};
    require_rolldown_runtime5.__export(prompts_exports, {
      AIMessagePromptTemplate: () => require_chat3.AIMessagePromptTemplate,
      BaseChatPromptTemplate: () => require_chat3.BaseChatPromptTemplate,
      BaseMessagePromptTemplate: () => require_chat3.BaseMessagePromptTemplate,
      BaseMessageStringPromptTemplate: () => require_chat3.BaseMessageStringPromptTemplate,
      BasePromptTemplate: () => require_base18.BasePromptTemplate,
      BaseStringPromptTemplate: () => require_string4.BaseStringPromptTemplate,
      ChatMessagePromptTemplate: () => require_chat3.ChatMessagePromptTemplate,
      ChatPromptTemplate: () => require_chat3.ChatPromptTemplate,
      DEFAULT_FORMATTER_MAPPING: () => require_template2.DEFAULT_FORMATTER_MAPPING,
      DEFAULT_PARSER_MAPPING: () => require_template2.DEFAULT_PARSER_MAPPING,
      DictPromptTemplate: () => require_dict2.DictPromptTemplate,
      FewShotChatMessagePromptTemplate: () => require_few_shot2.FewShotChatMessagePromptTemplate,
      FewShotPromptTemplate: () => require_few_shot2.FewShotPromptTemplate,
      HumanMessagePromptTemplate: () => require_chat3.HumanMessagePromptTemplate,
      ImagePromptTemplate: () => require_image2.ImagePromptTemplate,
      MessagesPlaceholder: () => require_chat3.MessagesPlaceholder,
      PipelinePromptTemplate: () => require_pipeline3.PipelinePromptTemplate,
      PromptTemplate: () => require_prompt2.PromptTemplate,
      StructuredPrompt: () => require_structured3.StructuredPrompt,
      SystemMessagePromptTemplate: () => require_chat3.SystemMessagePromptTemplate,
      checkValidTemplate: () => require_template2.checkValidTemplate,
      interpolateFString: () => require_template2.interpolateFString,
      interpolateMustache: () => require_template2.interpolateMustache,
      parseFString: () => require_template2.parseFString,
      parseMustache: () => require_template2.parseMustache,
      parseTemplate: () => require_template2.parseTemplate,
      renderTemplate: () => require_template2.renderTemplate
    });
    exports2.AIMessagePromptTemplate = require_chat3.AIMessagePromptTemplate;
    exports2.BaseChatPromptTemplate = require_chat3.BaseChatPromptTemplate;
    exports2.BaseMessagePromptTemplate = require_chat3.BaseMessagePromptTemplate;
    exports2.BaseMessageStringPromptTemplate = require_chat3.BaseMessageStringPromptTemplate;
    exports2.BasePromptTemplate = require_base18.BasePromptTemplate;
    exports2.BaseStringPromptTemplate = require_string4.BaseStringPromptTemplate;
    exports2.ChatMessagePromptTemplate = require_chat3.ChatMessagePromptTemplate;
    exports2.ChatPromptTemplate = require_chat3.ChatPromptTemplate;
    exports2.DEFAULT_FORMATTER_MAPPING = require_template2.DEFAULT_FORMATTER_MAPPING;
    exports2.DEFAULT_PARSER_MAPPING = require_template2.DEFAULT_PARSER_MAPPING;
    exports2.DictPromptTemplate = require_dict2.DictPromptTemplate;
    exports2.FewShotChatMessagePromptTemplate = require_few_shot2.FewShotChatMessagePromptTemplate;
    exports2.FewShotPromptTemplate = require_few_shot2.FewShotPromptTemplate;
    exports2.HumanMessagePromptTemplate = require_chat3.HumanMessagePromptTemplate;
    exports2.ImagePromptTemplate = require_image2.ImagePromptTemplate;
    exports2.MessagesPlaceholder = require_chat3.MessagesPlaceholder;
    exports2.PipelinePromptTemplate = require_pipeline3.PipelinePromptTemplate;
    exports2.PromptTemplate = require_prompt2.PromptTemplate;
    exports2.StructuredPrompt = require_structured3.StructuredPrompt;
    exports2.SystemMessagePromptTemplate = require_chat3.SystemMessagePromptTemplate;
    exports2.checkValidTemplate = require_template2.checkValidTemplate;
    exports2.interpolateFString = require_template2.interpolateFString;
    exports2.interpolateMustache = require_template2.interpolateMustache;
    exports2.parseFString = require_template2.parseFString;
    exports2.parseMustache = require_template2.parseMustache;
    exports2.parseTemplate = require_template2.parseTemplate;
    Object.defineProperty(exports2, "prompts_exports", {
      enumerable: true,
      get: function() {
        return prompts_exports;
      }
    });
    exports2.renderTemplate = require_template2.renderTemplate;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/retrievers/document_compressors/base.cjs
var require_base12 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/retrievers/document_compressors/base.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var base_exports = {};
    require_rolldown_runtime5.__export(base_exports, { BaseDocumentCompressor: () => BaseDocumentCompressor });
    var BaseDocumentCompressor = class {
      static isBaseDocumentCompressor(x) {
        return x?.compressDocuments !== void 0;
      }
    };
    exports2.BaseDocumentCompressor = BaseDocumentCompressor;
    Object.defineProperty(exports2, "base_exports", {
      enumerable: true,
      get: function() {
        return base_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/structured_query/ir.cjs
var require_ir = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/structured_query/ir.cjs"(exports2) {
    var Operators = {
      and: "and",
      or: "or",
      not: "not"
    };
    var Comparators = {
      eq: "eq",
      ne: "ne",
      lt: "lt",
      gt: "gt",
      lte: "lte",
      gte: "gte"
    };
    var Visitor = class {
    };
    var Expression = class {
      accept(visitor) {
        if (this.exprName === "Operation") return visitor.visitOperation(this);
        else if (this.exprName === "Comparison") return visitor.visitComparison(this);
        else if (this.exprName === "StructuredQuery") return visitor.visitStructuredQuery(this);
        else throw new Error("Unknown Expression type");
      }
    };
    var FilterDirective = class extends Expression {
    };
    var Comparison = class extends FilterDirective {
      exprName = "Comparison";
      constructor(comparator, attribute, value) {
        super();
        this.comparator = comparator;
        this.attribute = attribute;
        this.value = value;
      }
    };
    var Operation = class extends FilterDirective {
      exprName = "Operation";
      constructor(operator, args) {
        super();
        this.operator = operator;
        this.args = args;
      }
    };
    var StructuredQuery = class extends Expression {
      exprName = "StructuredQuery";
      constructor(query, filter) {
        super();
        this.query = query;
        this.filter = filter;
      }
    };
    exports2.Comparators = Comparators;
    exports2.Comparison = Comparison;
    exports2.Expression = Expression;
    exports2.FilterDirective = FilterDirective;
    exports2.Operation = Operation;
    exports2.Operators = Operators;
    exports2.StructuredQuery = StructuredQuery;
    exports2.Visitor = Visitor;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/structured_query/utils.cjs
var require_utils6 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/structured_query/utils.cjs"(exports2) {
    function isObject(obj) {
      return obj && typeof obj === "object" && !Array.isArray(obj);
    }
    function isFilterEmpty(filter) {
      if (!filter) return true;
      if (typeof filter === "string" && filter.length > 0) return false;
      if (typeof filter === "function") return false;
      return isObject(filter) && Object.keys(filter).length === 0;
    }
    function isInt(value) {
      if (typeof value === "number") return value % 1 === 0;
      else if (typeof value === "string") {
        const numberValue = parseInt(value, 10);
        return !Number.isNaN(numberValue) && numberValue % 1 === 0 && numberValue.toString() === value;
      }
      return false;
    }
    function isFloat(value) {
      if (typeof value === "number") return value % 1 !== 0;
      else if (typeof value === "string") {
        const numberValue = parseFloat(value);
        return !Number.isNaN(numberValue) && numberValue % 1 !== 0 && numberValue.toString() === value;
      }
      return false;
    }
    function isString(value) {
      return typeof value === "string" && (Number.isNaN(parseFloat(value)) || parseFloat(value).toString() !== value);
    }
    function isBoolean(value) {
      return typeof value === "boolean";
    }
    function castValue(input) {
      let value;
      if (isString(input)) value = input;
      else if (isInt(input)) value = parseInt(input, 10);
      else if (isFloat(input)) value = parseFloat(input);
      else if (isBoolean(input)) value = Boolean(input);
      else throw new Error("Unsupported value type");
      return value;
    }
    exports2.castValue = castValue;
    exports2.isBoolean = isBoolean;
    exports2.isFilterEmpty = isFilterEmpty;
    exports2.isFloat = isFloat;
    exports2.isInt = isInt;
    exports2.isObject = isObject;
    exports2.isString = isString;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/structured_query/base.cjs
var require_base13 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/structured_query/base.cjs"(exports2) {
    var require_ir2 = require_ir();
    var require_utils10 = require_utils6();
    var BaseTranslator = class extends require_ir2.Visitor {
    };
    var BasicTranslator = class extends BaseTranslator {
      allowedOperators;
      allowedComparators;
      constructor(opts) {
        super();
        this.allowedOperators = opts?.allowedOperators ?? [require_ir2.Operators.and, require_ir2.Operators.or];
        this.allowedComparators = opts?.allowedComparators ?? [
          require_ir2.Comparators.eq,
          require_ir2.Comparators.ne,
          require_ir2.Comparators.gt,
          require_ir2.Comparators.gte,
          require_ir2.Comparators.lt,
          require_ir2.Comparators.lte
        ];
      }
      formatFunction(func) {
        if (func in require_ir2.Comparators) {
          if (this.allowedComparators.length > 0 && this.allowedComparators.indexOf(func) === -1) throw new Error(`Comparator ${func} not allowed. Allowed comparators: ${this.allowedComparators.join(", ")}`);
        } else if (func in require_ir2.Operators) {
          if (this.allowedOperators.length > 0 && this.allowedOperators.indexOf(func) === -1) throw new Error(`Operator ${func} not allowed. Allowed operators: ${this.allowedOperators.join(", ")}`);
        } else throw new Error("Unknown comparator or operator");
        return `$${func}`;
      }
      /**
      * Visits an operation and returns a result.
      * @param operation The operation to visit.
      * @returns The result of visiting the operation.
      */
      visitOperation(operation) {
        const args = operation.args?.map((arg) => arg.accept(this));
        return { [this.formatFunction(operation.operator)]: args };
      }
      /**
      * Visits a comparison and returns a result.
      * @param comparison The comparison to visit.
      * @returns The result of visiting the comparison.
      */
      visitComparison(comparison) {
        return { [comparison.attribute]: { [this.formatFunction(comparison.comparator)]: require_utils10.castValue(comparison.value) } };
      }
      /**
      * Visits a structured query and returns a result.
      * @param query The structured query to visit.
      * @returns The result of visiting the structured query.
      */
      visitStructuredQuery(query) {
        let nextArg = {};
        if (query.filter) nextArg = { filter: query.filter.accept(this) };
        return nextArg;
      }
      mergeFilters(defaultFilter, generatedFilter, mergeType = "and", forceDefaultFilter = false) {
        if (require_utils10.isFilterEmpty(defaultFilter) && require_utils10.isFilterEmpty(generatedFilter)) return void 0;
        if (require_utils10.isFilterEmpty(defaultFilter) || mergeType === "replace") {
          if (require_utils10.isFilterEmpty(generatedFilter)) return void 0;
          return generatedFilter;
        }
        if (require_utils10.isFilterEmpty(generatedFilter)) {
          if (forceDefaultFilter) return defaultFilter;
          if (mergeType === "and") return void 0;
          return defaultFilter;
        }
        if (mergeType === "and") return { $and: [defaultFilter, generatedFilter] };
        else if (mergeType === "or") return { $or: [defaultFilter, generatedFilter] };
        else throw new Error("Unknown merge type");
      }
    };
    exports2.BaseTranslator = BaseTranslator;
    exports2.BasicTranslator = BasicTranslator;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/structured_query/functional.cjs
var require_functional = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/structured_query/functional.cjs"(exports2) {
    var require_ir2 = require_ir();
    var require_utils10 = require_utils6();
    var require_base18 = require_base13();
    var FunctionalTranslator = class extends require_base18.BaseTranslator {
      allowedOperators = [require_ir2.Operators.and, require_ir2.Operators.or];
      allowedComparators = [
        require_ir2.Comparators.eq,
        require_ir2.Comparators.ne,
        require_ir2.Comparators.gt,
        require_ir2.Comparators.gte,
        require_ir2.Comparators.lt,
        require_ir2.Comparators.lte
      ];
      formatFunction() {
        throw new Error("Not implemented");
      }
      /**
      * Returns the allowed comparators for a given data type.
      * @param input The input value to get the allowed comparators for.
      * @returns An array of allowed comparators for the input data type.
      */
      getAllowedComparatorsForType(inputType) {
        switch (inputType) {
          case "string":
            return [
              require_ir2.Comparators.eq,
              require_ir2.Comparators.ne,
              require_ir2.Comparators.gt,
              require_ir2.Comparators.gte,
              require_ir2.Comparators.lt,
              require_ir2.Comparators.lte
            ];
          case "number":
            return [
              require_ir2.Comparators.eq,
              require_ir2.Comparators.ne,
              require_ir2.Comparators.gt,
              require_ir2.Comparators.gte,
              require_ir2.Comparators.lt,
              require_ir2.Comparators.lte
            ];
          case "boolean":
            return [require_ir2.Comparators.eq, require_ir2.Comparators.ne];
          default:
            throw new Error(`Unsupported data type: ${inputType}`);
        }
      }
      /**
      * Returns a function that performs a comparison based on the provided
      * comparator.
      * @param comparator The comparator to base the comparison function on.
      * @returns A function that takes two arguments and returns a boolean based on the comparison.
      */
      getComparatorFunction(comparator) {
        switch (comparator) {
          case require_ir2.Comparators.eq:
            return (a, b) => a === b;
          case require_ir2.Comparators.ne:
            return (a, b) => a !== b;
          case require_ir2.Comparators.gt:
            return (a, b) => a > b;
          case require_ir2.Comparators.gte:
            return (a, b) => a >= b;
          case require_ir2.Comparators.lt:
            return (a, b) => a < b;
          case require_ir2.Comparators.lte:
            return (a, b) => a <= b;
          default:
            throw new Error("Unknown comparator");
        }
      }
      /**
      * Returns a function that performs an operation based on the provided
      * operator.
      * @param operator The operator to base the operation function on.
      * @returns A function that takes two boolean arguments and returns a boolean based on the operation.
      */
      getOperatorFunction(operator) {
        switch (operator) {
          case require_ir2.Operators.and:
            return (a, b) => a && b;
          case require_ir2.Operators.or:
            return (a, b) => a || b;
          default:
            throw new Error("Unknown operator");
        }
      }
      /**
      * Visits the operation part of a structured query and translates it into
      * a functional filter.
      * @param operation The operation part of a structured query.
      * @returns A function that takes a `Document` as an argument and returns a boolean based on the operation.
      */
      visitOperation(operation) {
        const { operator, args } = operation;
        if (this.allowedOperators.includes(operator)) {
          const operatorFunction = this.getOperatorFunction(operator);
          return (document2) => {
            if (!args) return true;
            return args.reduce((acc, arg) => {
              const result = arg.accept(this);
              if (typeof result === "function") return operatorFunction(acc, result(document2));
              else throw new Error("Filter is not a function");
            }, true);
          };
        } else throw new Error("Operator not allowed");
      }
      /**
      * Visits the comparison part of a structured query and translates it into
      * a functional filter.
      * @param comparison The comparison part of a structured query.
      * @returns A function that takes a `Document` as an argument and returns a boolean based on the comparison.
      */
      visitComparison(comparison) {
        const { comparator, attribute, value } = comparison;
        const undefinedTrue = [require_ir2.Comparators.ne];
        if (this.allowedComparators.includes(comparator)) {
          if (!this.getAllowedComparatorsForType(typeof value).includes(comparator)) throw new Error(`'${comparator}' comparator not allowed to be used with ${typeof value}`);
          const comparatorFunction = this.getComparatorFunction(comparator);
          return (document2) => {
            const documentValue = document2.metadata[attribute];
            if (documentValue === void 0) {
              if (undefinedTrue.includes(comparator)) return true;
              return false;
            }
            return comparatorFunction(documentValue, require_utils10.castValue(value));
          };
        } else throw new Error("Comparator not allowed");
      }
      /**
      * Visits a structured query and translates it into a functional filter.
      * @param query The structured query to translate.
      * @returns An object containing a `filter` property, which is a function that takes a `Document` as an argument and returns a boolean based on the structured query.
      */
      visitStructuredQuery(query) {
        if (!query.filter) return {};
        const filterFunction = query.filter?.accept(this);
        if (typeof filterFunction !== "function") throw new Error("Structured query filter is not a function");
        return { filter: filterFunction };
      }
      /**
      * Merges two filters into one, based on the specified merge type.
      * @param defaultFilter The default filter function.
      * @param generatedFilter The generated filter function.
      * @param mergeType The type of merge to perform. Can be 'and', 'or', or 'replace'. Default is 'and'.
      * @returns A function that takes a `Document` as an argument and returns a boolean based on the merged filters, or `undefined` if both filters are empty.
      */
      mergeFilters(defaultFilter, generatedFilter, mergeType = "and") {
        if (require_utils10.isFilterEmpty(defaultFilter) && require_utils10.isFilterEmpty(generatedFilter)) return void 0;
        if (require_utils10.isFilterEmpty(defaultFilter) || mergeType === "replace") {
          if (require_utils10.isFilterEmpty(generatedFilter)) return void 0;
          return generatedFilter;
        }
        if (require_utils10.isFilterEmpty(generatedFilter)) {
          if (mergeType === "and") return void 0;
          return defaultFilter;
        }
        if (mergeType === "and") return (document2) => defaultFilter(document2) && generatedFilter(document2);
        else if (mergeType === "or") return (document2) => defaultFilter(document2) || generatedFilter(document2);
        else throw new Error("Unknown merge type");
      }
    };
    exports2.FunctionalTranslator = FunctionalTranslator;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/structured_query/index.cjs
var require_structured_query = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/structured_query/index.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_ir2 = require_ir();
    var require_utils10 = require_utils6();
    var require_base18 = require_base13();
    var require_functional2 = require_functional();
    var structured_query_exports = {};
    require_rolldown_runtime5.__export(structured_query_exports, {
      BaseTranslator: () => require_base18.BaseTranslator,
      BasicTranslator: () => require_base18.BasicTranslator,
      Comparators: () => require_ir2.Comparators,
      Comparison: () => require_ir2.Comparison,
      Expression: () => require_ir2.Expression,
      FilterDirective: () => require_ir2.FilterDirective,
      FunctionalTranslator: () => require_functional2.FunctionalTranslator,
      Operation: () => require_ir2.Operation,
      Operators: () => require_ir2.Operators,
      StructuredQuery: () => require_ir2.StructuredQuery,
      Visitor: () => require_ir2.Visitor,
      castValue: () => require_utils10.castValue,
      isBoolean: () => require_utils10.isBoolean,
      isFilterEmpty: () => require_utils10.isFilterEmpty,
      isFloat: () => require_utils10.isFloat,
      isInt: () => require_utils10.isInt,
      isObject: () => require_utils10.isObject,
      isString: () => require_utils10.isString
    });
    exports2.BaseTranslator = require_base18.BaseTranslator;
    exports2.BasicTranslator = require_base18.BasicTranslator;
    exports2.Comparators = require_ir2.Comparators;
    exports2.Comparison = require_ir2.Comparison;
    exports2.Expression = require_ir2.Expression;
    exports2.FilterDirective = require_ir2.FilterDirective;
    exports2.FunctionalTranslator = require_functional2.FunctionalTranslator;
    exports2.Operation = require_ir2.Operation;
    exports2.Operators = require_ir2.Operators;
    exports2.StructuredQuery = require_ir2.StructuredQuery;
    exports2.Visitor = require_ir2.Visitor;
    exports2.castValue = require_utils10.castValue;
    exports2.isBoolean = require_utils10.isBoolean;
    exports2.isFilterEmpty = require_utils10.isFilterEmpty;
    exports2.isFloat = require_utils10.isFloat;
    exports2.isInt = require_utils10.isInt;
    exports2.isObject = require_utils10.isObject;
    exports2.isString = require_utils10.isString;
    Object.defineProperty(exports2, "structured_query_exports", {
      enumerable: true,
      get: function() {
        return structured_query_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/tracers/run_collector.cjs
var require_run_collector = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/tracers/run_collector.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_tracers_base = require_base3();
    var run_collector_exports = {};
    require_rolldown_runtime5.__export(run_collector_exports, { RunCollectorCallbackHandler: () => RunCollectorCallbackHandler });
    var RunCollectorCallbackHandler = class extends require_tracers_base.BaseTracer {
      /** The name of the callback handler. */
      name = "run_collector";
      /** The ID of the example. */
      exampleId;
      /** An array of traced runs. */
      tracedRuns;
      /**
      * Creates a new instance of the RunCollectorCallbackHandler class.
      * @param exampleId The ID of the example.
      */
      constructor({ exampleId } = {}) {
        super({ _awaitHandler: true });
        this.exampleId = exampleId;
        this.tracedRuns = [];
      }
      /**
      * Persists the given run object.
      * @param run The run object to persist.
      */
      async persistRun(run) {
        const run_ = { ...run };
        run_.reference_example_id = this.exampleId;
        this.tracedRuns.push(run_);
      }
    };
    exports2.RunCollectorCallbackHandler = RunCollectorCallbackHandler;
    Object.defineProperty(exports2, "run_collector_exports", {
      enumerable: true,
      get: function() {
        return run_collector_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/types/stream.cjs
var require_stream2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/types/stream.cjs"(exports2) {
    var stream_exports = {};
    Object.defineProperty(exports2, "stream_exports", {
      enumerable: true,
      get: function() {
        return stream_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/chunk_array.cjs
var require_chunk_array = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/chunk_array.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var chunk_array_exports = {};
    require_rolldown_runtime5.__export(chunk_array_exports, { chunkArray: () => chunkArray });
    var chunkArray = (arr, chunkSize) => arr.reduce((chunks, elem, index) => {
      const chunkIndex = Math.floor(index / chunkSize);
      const chunk = chunks[chunkIndex] || [];
      chunks[chunkIndex] = chunk.concat([elem]);
      return chunks;
    }, []);
    exports2.chunkArray = chunkArray;
    Object.defineProperty(exports2, "chunk_array_exports", {
      enumerable: true,
      get: function() {
        return chunk_array_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/event_source_parse.cjs
var require_event_source_parse = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/event_source_parse.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_utils_stream = require_stream();
    var event_source_parse_exports = {};
    require_rolldown_runtime5.__export(event_source_parse_exports, {
      EventStreamContentType: () => EventStreamContentType,
      convertEventStreamToIterableReadableDataStream: () => convertEventStreamToIterableReadableDataStream,
      getBytes: () => getBytes,
      getLines: () => getLines,
      getMessages: () => getMessages
    });
    var EventStreamContentType = "text/event-stream";
    async function getBytes(stream, onChunk) {
      if (stream instanceof ReadableStream) {
        const reader = stream.getReader();
        while (true) {
          const result = await reader.read();
          if (result.done) {
            onChunk(new Uint8Array(), true);
            break;
          }
          onChunk(result.value);
        }
      } else try {
        for await (const chunk of stream) onChunk(new Uint8Array(chunk));
        onChunk(new Uint8Array(), true);
      } catch (e) {
        throw new Error([
          "Parsing event source stream failed.",
          "Ensure your implementation of fetch returns a web or Node readable stream.",
          `Error: ${e.message}`
        ].join("\n"));
      }
    }
    var ControlChars = /* @__PURE__ */ (function(ControlChars$1) {
      ControlChars$1[ControlChars$1["NewLine"] = 10] = "NewLine";
      ControlChars$1[ControlChars$1["CarriageReturn"] = 13] = "CarriageReturn";
      ControlChars$1[ControlChars$1["Space"] = 32] = "Space";
      ControlChars$1[ControlChars$1["Colon"] = 58] = "Colon";
      return ControlChars$1;
    })(ControlChars || {});
    function getLines(onLine) {
      let buffer;
      let position;
      let fieldLength;
      let discardTrailingNewline = false;
      return function onChunk(arr, flush) {
        if (flush) {
          onLine(arr, 0, true);
          return;
        }
        if (buffer === void 0) {
          buffer = arr;
          position = 0;
          fieldLength = -1;
        } else buffer = concat(buffer, arr);
        const bufLength = buffer.length;
        let lineStart = 0;
        while (position < bufLength) {
          if (discardTrailingNewline) {
            if (buffer[position] === ControlChars.NewLine) lineStart = ++position;
            discardTrailingNewline = false;
          }
          let lineEnd = -1;
          for (; position < bufLength && lineEnd === -1; ++position) switch (buffer[position]) {
            case ControlChars.Colon:
              if (fieldLength === -1) fieldLength = position - lineStart;
              break;
            case ControlChars.CarriageReturn:
              discardTrailingNewline = true;
            case ControlChars.NewLine:
              lineEnd = position;
              break;
          }
          if (lineEnd === -1) break;
          onLine(buffer.subarray(lineStart, lineEnd), fieldLength);
          lineStart = position;
          fieldLength = -1;
        }
        if (lineStart === bufLength) buffer = void 0;
        else if (lineStart !== 0) {
          buffer = buffer.subarray(lineStart);
          position -= lineStart;
        }
      };
    }
    function getMessages(onMessage, onId, onRetry) {
      let message = newMessage();
      const decoder = new TextDecoder();
      return function onLine(line, fieldLength, flush) {
        if (flush) {
          if (!isEmpty(message)) {
            onMessage?.(message);
            message = newMessage();
          }
          return;
        }
        if (line.length === 0) {
          onMessage?.(message);
          message = newMessage();
        } else if (fieldLength > 0) {
          const field = decoder.decode(line.subarray(0, fieldLength));
          const valueOffset = fieldLength + (line[fieldLength + 1] === ControlChars.Space ? 2 : 1);
          const value = decoder.decode(line.subarray(valueOffset));
          switch (field) {
            case "data":
              message.data = message.data ? message.data + "\n" + value : value;
              break;
            case "event":
              message.event = value;
              break;
            case "id":
              onId?.(message.id = value);
              break;
            case "retry": {
              const retry = parseInt(value, 10);
              if (!Number.isNaN(retry)) onRetry?.(message.retry = retry);
              break;
            }
          }
        }
      };
    }
    function concat(a, b) {
      const res = new Uint8Array(a.length + b.length);
      res.set(a);
      res.set(b, a.length);
      return res;
    }
    function newMessage() {
      return {
        data: "",
        event: "",
        id: "",
        retry: void 0
      };
    }
    function convertEventStreamToIterableReadableDataStream(stream, onMetadataEvent) {
      const dataStream = new ReadableStream({ async start(controller) {
        const enqueueLine = getMessages((msg) => {
          if (msg.event === "error") throw new Error(msg.data ?? "Unspecified event streaming error.");
          else if (msg.event === "metadata") onMetadataEvent?.(msg);
          else if (msg.data) controller.enqueue(msg.data);
        });
        const onLine = (line, fieldLength, flush) => {
          enqueueLine(line, fieldLength, flush);
          if (flush) controller.close();
        };
        await getBytes(stream, getLines(onLine));
      } });
      return require_utils_stream.IterableReadableStream.fromReadableStream(dataStream);
    }
    function isEmpty(message) {
      return message.data === "" && message.event === "" && message.id === "" && message.retry === void 0;
    }
    exports2.EventStreamContentType = EventStreamContentType;
    exports2.convertEventStreamToIterableReadableDataStream = convertEventStreamToIterableReadableDataStream;
    Object.defineProperty(exports2, "event_source_parse_exports", {
      enumerable: true,
      get: function() {
        return event_source_parse_exports;
      }
    });
    exports2.getBytes = getBytes;
    exports2.getLines = getLines;
    exports2.getMessages = getMessages;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/function_calling.cjs
var require_function_calling = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/function_calling.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_utils_json_schema = require_json_schema2();
    var require_types10 = require_types4();
    var function_calling_exports = {};
    require_rolldown_runtime5.__export(function_calling_exports, {
      convertToOpenAIFunction: () => convertToOpenAIFunction,
      convertToOpenAITool: () => convertToOpenAITool,
      isLangChainTool: () => require_types10.isLangChainTool,
      isRunnableToolLike: () => require_types10.isRunnableToolLike,
      isStructuredTool: () => require_types10.isStructuredTool,
      isStructuredToolParams: () => require_types10.isStructuredToolParams
    });
    function convertToOpenAIFunction(tool, fields) {
      const fieldsCopy = typeof fields === "number" ? void 0 : fields;
      return {
        name: tool.name,
        description: tool.description,
        parameters: require_utils_json_schema.toJsonSchema(tool.schema),
        ...fieldsCopy?.strict !== void 0 ? { strict: fieldsCopy.strict } : {}
      };
    }
    function convertToOpenAITool(tool, fields) {
      const fieldsCopy = typeof fields === "number" ? void 0 : fields;
      let toolDef;
      if (require_types10.isLangChainTool(tool)) toolDef = {
        type: "function",
        function: convertToOpenAIFunction(tool)
      };
      else toolDef = tool;
      if (fieldsCopy?.strict !== void 0) toolDef.function.strict = fieldsCopy.strict;
      return toolDef;
    }
    exports2.convertToOpenAIFunction = convertToOpenAIFunction;
    exports2.convertToOpenAITool = convertToOpenAITool;
    Object.defineProperty(exports2, "function_calling_exports", {
      enumerable: true,
      get: function() {
        return function_calling_exports;
      }
    });
    exports2.isLangChainTool = require_types10.isLangChainTool;
    exports2.isRunnableToolLike = require_types10.isRunnableToolLike;
    exports2.isStructuredTool = require_types10.isStructuredTool;
    exports2.isStructuredToolParams = require_types10.isStructuredToolParams;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/ml-distance/similarities.cjs
var require_similarities = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/ml-distance/similarities.cjs"(exports2) {
    function cosine(a, b) {
      let p = 0;
      let p2 = 0;
      let q2 = 0;
      for (let i = 0; i < a.length; i++) {
        p += a[i] * b[i];
        p2 += a[i] * a[i];
        q2 += b[i] * b[i];
      }
      return p / (Math.sqrt(p2) * Math.sqrt(q2));
    }
    exports2.cosine = cosine;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/ml-distance/distances.cjs
var require_distances = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/ml-distance/distances.cjs"(exports2) {
    function innerProduct(a, b) {
      let ans = 0;
      for (let i = 0; i < a.length; i++) ans += a[i] * b[i];
      return ans;
    }
    exports2.innerProduct = innerProduct;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/ml-distance-euclidean/euclidean.cjs
var require_euclidean = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/ml-distance-euclidean/euclidean.cjs"(exports2) {
    function squaredEuclidean(p, q) {
      let d = 0;
      for (let i = 0; i < p.length; i++) d += (p[i] - q[i]) * (p[i] - q[i]);
      return d;
    }
    function euclidean(p, q) {
      return Math.sqrt(squaredEuclidean(p, q));
    }
    exports2.euclidean = euclidean;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/math.cjs
var require_math = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/math.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_similarities2 = require_similarities();
    var require_distances2 = require_distances();
    var require_euclidean2 = require_euclidean();
    var math_exports = {};
    require_rolldown_runtime5.__export(math_exports, {
      cosineSimilarity: () => cosineSimilarity,
      euclideanDistance: () => euclideanDistance,
      innerProduct: () => innerProduct$1,
      matrixFunc: () => matrixFunc,
      maximalMarginalRelevance: () => maximalMarginalRelevance,
      normalize: () => normalize
    });
    function matrixFunc(X, Y, func) {
      if (X.length === 0 || X[0].length === 0 || Y.length === 0 || Y[0].length === 0) return [[]];
      if (X[0].length !== Y[0].length) throw new Error(`Number of columns in X and Y must be the same. X has shape ${[X.length, X[0].length]} and Y has shape ${[Y.length, Y[0].length]}.`);
      return X.map((xVector) => Y.map((yVector) => func(xVector, yVector)).map((similarity) => Number.isNaN(similarity) ? 0 : similarity));
    }
    function normalize(M, similarity = false) {
      const max = matrixMaxVal(M);
      return M.map((row) => row.map((val) => similarity ? 1 - val / max : val / max));
    }
    function cosineSimilarity(X, Y) {
      return matrixFunc(X, Y, require_similarities2.cosine);
    }
    function innerProduct$1(X, Y) {
      return matrixFunc(X, Y, require_distances2.innerProduct);
    }
    function euclideanDistance(X, Y) {
      return matrixFunc(X, Y, require_euclidean2.euclidean);
    }
    function maximalMarginalRelevance(queryEmbedding, embeddingList, lambda = 0.5, k = 4) {
      if (Math.min(k, embeddingList.length) <= 0) return [];
      const queryEmbeddingExpanded = Array.isArray(queryEmbedding[0]) ? queryEmbedding : [queryEmbedding];
      const similarityToQuery = cosineSimilarity(queryEmbeddingExpanded, embeddingList)[0];
      const mostSimilarEmbeddingIndex = argMax(similarityToQuery).maxIndex;
      const selectedEmbeddings = [embeddingList[mostSimilarEmbeddingIndex]];
      const selectedEmbeddingsIndexes = [mostSimilarEmbeddingIndex];
      while (selectedEmbeddingsIndexes.length < Math.min(k, embeddingList.length)) {
        let bestScore = -Infinity;
        let bestIndex = -1;
        const similarityToSelected = cosineSimilarity(embeddingList, selectedEmbeddings);
        similarityToQuery.forEach((queryScore, queryScoreIndex) => {
          if (selectedEmbeddingsIndexes.includes(queryScoreIndex)) return;
          const maxSimilarityToSelected = Math.max(...similarityToSelected[queryScoreIndex]);
          const score = lambda * queryScore - (1 - lambda) * maxSimilarityToSelected;
          if (score > bestScore) {
            bestScore = score;
            bestIndex = queryScoreIndex;
          }
        });
        selectedEmbeddings.push(embeddingList[bestIndex]);
        selectedEmbeddingsIndexes.push(bestIndex);
      }
      return selectedEmbeddingsIndexes;
    }
    function argMax(array) {
      if (array.length === 0) return {
        maxIndex: -1,
        maxValue: NaN
      };
      let maxValue = array[0];
      let maxIndex = 0;
      for (let i = 1; i < array.length; i += 1) if (array[i] > maxValue) {
        maxIndex = i;
        maxValue = array[i];
      }
      return {
        maxIndex,
        maxValue
      };
    }
    function matrixMaxVal(arrays) {
      return arrays.reduce((acc, array) => Math.max(acc, argMax(array).maxValue), 0);
    }
    exports2.cosineSimilarity = cosineSimilarity;
    exports2.euclideanDistance = euclideanDistance;
    exports2.innerProduct = innerProduct$1;
    Object.defineProperty(exports2, "math_exports", {
      enumerable: true,
      get: function() {
        return math_exports;
      }
    });
    exports2.matrixFunc = matrixFunc;
    exports2.maximalMarginalRelevance = maximalMarginalRelevance;
    exports2.normalize = normalize;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/testing/chat_models.cjs
var require_chat_models2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/testing/chat_models.cjs"(exports2) {
    var require_ai2 = require_ai();
    var require_outputs2 = require_outputs();
    var require_utils_json_schema = require_json_schema2();
    var require_base18 = require_base4();
    require_messages2();
    var require_language_models_chat_models = require_chat_models();
    var FakeChatModel = class extends require_language_models_chat_models.BaseChatModel {
      _combineLLMOutput() {
        return [];
      }
      _llmType() {
        return "fake";
      }
      async _generate(messages, options, runManager) {
        if (options?.stop?.length) return { generations: [{
          message: new require_ai2.AIMessage(options.stop[0]),
          text: options.stop[0]
        }] };
        const text = messages.map((m) => {
          if (typeof m.content === "string") return m.content;
          return JSON.stringify(m.content, null, 2);
        }).join("\n");
        await runManager?.handleLLMNewToken(text);
        return {
          generations: [{
            message: new require_ai2.AIMessage(text),
            text
          }],
          llmOutput: {}
        };
      }
    };
    var FakeStreamingChatModel = class FakeStreamingChatModel2 extends require_language_models_chat_models.BaseChatModel {
      sleep = 50;
      responses = [];
      chunks = [];
      toolStyle = "openai";
      thrownErrorString;
      tools = [];
      constructor({ sleep = 50, responses = [], chunks = [], toolStyle = "openai", thrownErrorString, ...rest }) {
        super(rest);
        this.sleep = sleep;
        this.responses = responses;
        this.chunks = chunks;
        this.toolStyle = toolStyle;
        this.thrownErrorString = thrownErrorString;
      }
      _llmType() {
        return "fake";
      }
      bindTools(tools) {
        const merged = [...this.tools, ...tools];
        const toolDicts = merged.map((t) => {
          switch (this.toolStyle) {
            case "openai":
              return {
                type: "function",
                function: {
                  name: t.name,
                  description: t.description,
                  parameters: require_utils_json_schema.toJsonSchema(t.schema)
                }
              };
            case "anthropic":
              return {
                name: t.name,
                description: t.description,
                input_schema: require_utils_json_schema.toJsonSchema(t.schema)
              };
            case "bedrock":
              return { toolSpec: {
                name: t.name,
                description: t.description,
                inputSchema: require_utils_json_schema.toJsonSchema(t.schema)
              } };
            case "google":
              return {
                name: t.name,
                description: t.description,
                parameters: require_utils_json_schema.toJsonSchema(t.schema)
              };
            default:
              throw new Error(`Unsupported tool style: ${this.toolStyle}`);
          }
        });
        const wrapped = this.toolStyle === "google" ? [{ functionDeclarations: toolDicts }] : toolDicts;
        const next = new FakeStreamingChatModel2({
          sleep: this.sleep,
          responses: this.responses,
          chunks: this.chunks,
          toolStyle: this.toolStyle,
          thrownErrorString: this.thrownErrorString
        });
        next.tools = merged;
        return next.withConfig({ tools: wrapped });
      }
      async _generate(messages, _options, _runManager) {
        if (this.thrownErrorString) throw new Error(this.thrownErrorString);
        const content = this.responses?.[0]?.content ?? messages[0].content ?? "";
        const generation = { generations: [{
          text: "",
          message: new require_ai2.AIMessage({
            content,
            tool_calls: this.chunks?.[0]?.tool_calls
          })
        }] };
        return generation;
      }
      async *_streamResponseChunks(_messages, _options, runManager) {
        if (this.thrownErrorString) throw new Error(this.thrownErrorString);
        if (this.chunks?.length) {
          for (const msgChunk of this.chunks) {
            const cg = new require_outputs2.ChatGenerationChunk({
              message: new require_ai2.AIMessageChunk({
                content: msgChunk.content,
                tool_calls: msgChunk.tool_calls,
                additional_kwargs: msgChunk.additional_kwargs ?? {}
              }),
              text: msgChunk.content?.toString() ?? ""
            });
            yield cg;
            await runManager?.handleLLMNewToken(msgChunk.content, void 0, void 0, void 0, void 0, { chunk: cg });
          }
          return;
        }
        const fallback = this.responses?.[0] ?? new require_ai2.AIMessage(typeof _messages[0].content === "string" ? _messages[0].content : "");
        const text = typeof fallback.content === "string" ? fallback.content : "";
        for (const ch of text) {
          await new Promise((r) => setTimeout(r, this.sleep));
          const cg = new require_outputs2.ChatGenerationChunk({
            message: new require_ai2.AIMessageChunk({ content: ch }),
            text: ch
          });
          yield cg;
          await runManager?.handleLLMNewToken(ch, void 0, void 0, void 0, void 0, { chunk: cg });
        }
      }
    };
    var FakeListChatModel = class extends require_language_models_chat_models.BaseChatModel {
      static lc_name() {
        return "FakeListChatModel";
      }
      lc_serializable = true;
      responses;
      i = 0;
      sleep;
      emitCustomEvent = false;
      constructor(params) {
        super(params);
        const { responses, sleep, emitCustomEvent } = params;
        this.responses = responses;
        this.sleep = sleep;
        this.emitCustomEvent = emitCustomEvent ?? this.emitCustomEvent;
      }
      _combineLLMOutput() {
        return [];
      }
      _llmType() {
        return "fake-list";
      }
      async _generate(_messages, options, runManager) {
        await this._sleepIfRequested();
        if (options?.thrownErrorString) throw new Error(options.thrownErrorString);
        if (this.emitCustomEvent) await runManager?.handleCustomEvent("some_test_event", { someval: true });
        if (options?.stop?.length) return { generations: [this._formatGeneration(options.stop[0])] };
        else {
          const response = this._currentResponse();
          this._incrementResponse();
          return {
            generations: [this._formatGeneration(response)],
            llmOutput: {}
          };
        }
      }
      _formatGeneration(text) {
        return {
          message: new require_ai2.AIMessage(text),
          text
        };
      }
      async *_streamResponseChunks(_messages, options, runManager) {
        const response = this._currentResponse();
        this._incrementResponse();
        if (this.emitCustomEvent) await runManager?.handleCustomEvent("some_test_event", { someval: true });
        for await (const text of response) {
          await this._sleepIfRequested();
          if (options?.thrownErrorString) throw new Error(options.thrownErrorString);
          const chunk = this._createResponseChunk(text);
          yield chunk;
          runManager?.handleLLMNewToken(text);
        }
      }
      async _sleepIfRequested() {
        if (this.sleep !== void 0) await this._sleep();
      }
      async _sleep() {
        return new Promise((resolve) => {
          setTimeout(() => resolve(), this.sleep);
        });
      }
      _createResponseChunk(text) {
        return new require_outputs2.ChatGenerationChunk({
          message: new require_ai2.AIMessageChunk({ content: text }),
          text
        });
      }
      _currentResponse() {
        return this.responses[this.i];
      }
      _incrementResponse() {
        if (this.i < this.responses.length - 1) this.i += 1;
        else this.i = 0;
      }
      withStructuredOutput(_params, _config) {
        return require_base18.RunnableLambda.from(async (input) => {
          const message = await this.invoke(input);
          if (message.tool_calls?.[0]?.args) return message.tool_calls[0].args;
          if (typeof message.content === "string") return JSON.parse(message.content);
          throw new Error("No structured output found");
        });
      }
    };
    exports2.FakeChatModel = FakeChatModel;
    exports2.FakeListChatModel = FakeListChatModel;
    exports2.FakeStreamingChatModel = FakeStreamingChatModel;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/testing/embeddings.cjs
var require_embeddings2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/testing/embeddings.cjs"(exports2) {
    var require_embeddings3 = require_embeddings();
    var SyntheticEmbeddings = class extends require_embeddings3.Embeddings {
      vectorSize;
      constructor(params) {
        super(params ?? {});
        this.vectorSize = params?.vectorSize ?? 4;
      }
      /**
      * Generates synthetic embeddings for a list of documents.
      * @param documents List of documents to generate embeddings for.
      * @returns A promise that resolves with a list of synthetic embeddings for each document.
      */
      async embedDocuments(documents) {
        return Promise.all(documents.map((doc) => this.embedQuery(doc)));
      }
      /**
      * Generates a synthetic embedding for a document. The document is
      * converted into chunks, a numerical value is calculated for each chunk,
      * and an array of these values is returned as the embedding.
      * @param document The document to generate an embedding for.
      * @returns A promise that resolves with a synthetic embedding for the document.
      */
      async embedQuery(document2) {
        let doc = document2;
        doc = doc.toLowerCase().replaceAll(/[^a-z ]/g, "");
        const padMod = doc.length % this.vectorSize;
        const padGapSize = padMod === 0 ? 0 : this.vectorSize - padMod;
        const padSize = doc.length + padGapSize;
        doc = doc.padEnd(padSize, " ");
        const chunkSize = doc.length / this.vectorSize;
        const docChunk = [];
        for (let co = 0; co < doc.length; co += chunkSize) docChunk.push(doc.slice(co, co + chunkSize));
        const ret = docChunk.map((s) => {
          let sum = 0;
          for (let co = 0; co < s.length; co += 1) sum += s === " " ? 0 : s.charCodeAt(co);
          const ret$1 = sum % 26 / 26;
          return ret$1;
        });
        return ret;
      }
    };
    var FakeEmbeddings = class extends require_embeddings3.Embeddings {
      constructor(params) {
        super(params ?? {});
      }
      /**
      * Generates fixed embeddings for a list of documents.
      * @param documents List of documents to generate embeddings for.
      * @returns A promise that resolves with a list of fixed embeddings for each document.
      */
      embedDocuments(documents) {
        return Promise.resolve(documents.map(() => [
          0.1,
          0.2,
          0.3,
          0.4
        ]));
      }
      /**
      * Generates a fixed embedding for a query.
      * @param _ The query to generate an embedding for.
      * @returns A promise that resolves with a fixed embedding for the query.
      */
      embedQuery(_) {
        return Promise.resolve([
          0.1,
          0.2,
          0.3,
          0.4
        ]);
      }
    };
    exports2.FakeEmbeddings = FakeEmbeddings;
    exports2.SyntheticEmbeddings = SyntheticEmbeddings;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/testing/llms.cjs
var require_llms2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/testing/llms.cjs"(exports2) {
    var require_language_models_llms = require_llms();
    var FakeLLM = class extends require_language_models_llms.LLM {
      response;
      thrownErrorString;
      constructor(fields) {
        super(fields);
        this.response = fields.response;
        this.thrownErrorString = fields.thrownErrorString;
      }
      _llmType() {
        return "fake";
      }
      async _call(prompt, _options, runManager) {
        if (this.thrownErrorString) throw new Error(this.thrownErrorString);
        const response = this.response ?? prompt;
        await runManager?.handleLLMNewToken(response);
        return response;
      }
    };
    var FakeStreamingLLM = class extends require_language_models_llms.LLM {
      sleep = 50;
      responses;
      thrownErrorString;
      constructor(fields) {
        super(fields);
        this.sleep = fields.sleep ?? this.sleep;
        this.responses = fields.responses;
        this.thrownErrorString = fields.thrownErrorString;
      }
      _llmType() {
        return "fake";
      }
      async _call(prompt) {
        if (this.thrownErrorString) throw new Error(this.thrownErrorString);
        const response = this.responses?.[0];
        this.responses = this.responses?.slice(1);
        return response ?? prompt;
      }
      async *_streamResponseChunks(input, _options, runManager) {
        if (this.thrownErrorString) throw new Error(this.thrownErrorString);
        const response = this.responses?.[0];
        this.responses = this.responses?.slice(1);
        for (const c of response ?? input) {
          await new Promise((resolve) => setTimeout(resolve, this.sleep));
          yield {
            text: c,
            generationInfo: {}
          };
          await runManager?.handleLLMNewToken(c);
        }
      }
    };
    exports2.FakeLLM = FakeLLM;
    exports2.FakeStreamingLLM = FakeStreamingLLM;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/testing/message_history.cjs
var require_message_history = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/testing/message_history.cjs"(exports2) {
    var require_ai2 = require_ai();
    var require_human2 = require_human();
    var require_tracers_base = require_base3();
    require_messages2();
    var require_chat_history2 = require_chat_history();
    var FakeChatMessageHistory = class extends require_chat_history2.BaseChatMessageHistory {
      lc_namespace = [
        "langchain_core",
        "message",
        "fake"
      ];
      messages = [];
      constructor() {
        super();
      }
      async getMessages() {
        return this.messages;
      }
      async addMessage(message) {
        this.messages.push(message);
      }
      async addUserMessage(message) {
        this.messages.push(new require_human2.HumanMessage(message));
      }
      async addAIMessage(message) {
        this.messages.push(new require_ai2.AIMessage(message));
      }
      async clear() {
        this.messages = [];
      }
    };
    var FakeListChatMessageHistory = class extends require_chat_history2.BaseListChatMessageHistory {
      lc_namespace = [
        "langchain_core",
        "message",
        "fake"
      ];
      messages = [];
      constructor() {
        super();
      }
      async addMessage(message) {
        this.messages.push(message);
      }
      async getMessages() {
        return this.messages;
      }
    };
    var FakeTracer = class extends require_tracers_base.BaseTracer {
      name = "fake_tracer";
      runs = [];
      constructor() {
        super();
      }
      persistRun(run) {
        this.runs.push(run);
        return Promise.resolve();
      }
    };
    exports2.FakeChatMessageHistory = FakeChatMessageHistory;
    exports2.FakeListChatMessageHistory = FakeListChatMessageHistory;
    exports2.FakeTracer = FakeTracer;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/testing/output_parsers.cjs
var require_output_parsers2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/testing/output_parsers.cjs"(exports2) {
    var require_base18 = require_base10();
    var FakeSplitIntoListParser = class extends require_base18.BaseOutputParser {
      lc_namespace = ["tests", "fake"];
      getFormatInstructions() {
        return "";
      }
      async parse(text) {
        return text.split(",").map((value) => value.trim());
      }
    };
    exports2.FakeSplitIntoListParser = FakeSplitIntoListParser;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/testing/retrievers.cjs
var require_retrievers2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/testing/retrievers.cjs"(exports2) {
    var require_retrievers_index = require_retrievers();
    var require_document2 = require_document();
    var FakeRetriever = class extends require_retrievers_index.BaseRetriever {
      lc_namespace = ["test", "fake"];
      output = [new require_document2.Document({ pageContent: "foo" }), new require_document2.Document({ pageContent: "bar" })];
      constructor(fields) {
        super();
        this.output = fields?.output ?? this.output;
      }
      async _getRelevantDocuments(_query) {
        return this.output;
      }
    };
    exports2.FakeRetriever = FakeRetriever;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/testing/runnables.cjs
var require_runnables2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/testing/runnables.cjs"(exports2) {
    var require_base18 = require_base4();
    var FakeRunnable = class extends require_base18.Runnable {
      lc_namespace = ["tests", "fake"];
      returnOptions;
      constructor(fields) {
        super(fields);
        this.returnOptions = fields.returnOptions;
      }
      async invoke(input, options) {
        if (this.returnOptions) return options ?? {};
        return { input };
      }
    };
    exports2.FakeRunnable = FakeRunnable;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/testing/tools.cjs
var require_tools3 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/testing/tools.cjs"(exports2) {
    var require_tools_index = require_tools();
    var FakeTool = class extends require_tools_index.StructuredTool {
      name;
      description;
      schema;
      constructor(fields) {
        super(fields);
        this.name = fields.name;
        this.description = fields.description;
        this.schema = fields.schema;
      }
      async _call(arg, _runManager) {
        return JSON.stringify(arg);
      }
    };
    exports2.FakeTool = FakeTool;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/testing/tracers.cjs
var require_tracers = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/testing/tracers.cjs"(exports2) {
    var require_tracers_base = require_base3();
    var SingleRunExtractor = class extends require_tracers_base.BaseTracer {
      runPromiseResolver;
      runPromise;
      /** The name of the callback handler. */
      name = "single_run_extractor";
      constructor() {
        super();
        this.runPromise = new Promise((extract) => {
          this.runPromiseResolver = extract;
        });
      }
      async persistRun(run) {
        this.runPromiseResolver(run);
      }
      async extract() {
        return this.runPromise;
      }
    };
    exports2.SingleRunExtractor = SingleRunExtractor;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/testing/vectorstores.cjs
var require_vectorstores2 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/testing/vectorstores.cjs"(exports2) {
    var require_vectorstores3 = require_vectorstores();
    var require_document2 = require_document();
    var require_similarities2 = require_similarities();
    var FakeVectorStore = class FakeVectorStore2 extends require_vectorstores3.VectorStore {
      memoryVectors = [];
      similarity;
      _vectorstoreType() {
        return "memory";
      }
      constructor(embeddings, { similarity, ...rest } = {}) {
        super(embeddings, rest);
        this.similarity = similarity ?? require_similarities2.cosine;
      }
      /**
      * Method to add documents to the memory vector store. It extracts the
      * text from each document, generates embeddings for them, and adds the
      * resulting vectors to the store.
      * @param documents Array of `Document` instances to be added to the store.
      * @returns Promise that resolves when all documents have been added.
      */
      async addDocuments(documents) {
        const texts = documents.map(({ pageContent }) => pageContent);
        return this.addVectors(await this.embeddings.embedDocuments(texts), documents);
      }
      /**
      * Method to add vectors to the memory vector store. It creates
      * `MemoryVector` instances for each vector and document pair and adds
      * them to the store.
      * @param vectors Array of vectors to be added to the store.
      * @param documents Array of `Document` instances corresponding to the vectors.
      * @returns Promise that resolves when all vectors have been added.
      */
      async addVectors(vectors, documents) {
        const memoryVectors = vectors.map((embedding, idx) => ({
          content: documents[idx].pageContent,
          embedding,
          metadata: documents[idx].metadata
        }));
        this.memoryVectors = this.memoryVectors.concat(memoryVectors);
      }
      /**
      * Method to perform a similarity search in the memory vector store. It
      * calculates the similarity between the query vector and each vector in
      * the store, sorts the results by similarity, and returns the top `k`
      * results along with their scores.
      * @param query Query vector to compare against the vectors in the store.
      * @param k Number of top results to return.
      * @param filter Optional filter function to apply to the vectors before performing the search.
      * @returns Promise that resolves with an array of tuples, each containing a `Document` and its similarity score.
      */
      async similaritySearchVectorWithScore(query, k, filter) {
        const filterFunction = (memoryVector) => {
          if (!filter) return true;
          const doc = new require_document2.Document({
            metadata: memoryVector.metadata,
            pageContent: memoryVector.content
          });
          return filter(doc);
        };
        const filteredMemoryVectors = this.memoryVectors.filter(filterFunction);
        const searches = filteredMemoryVectors.map((vector, index) => ({
          similarity: this.similarity(query, vector.embedding),
          index
        })).sort((a, b) => a.similarity > b.similarity ? -1 : 0).slice(0, k);
        const result = searches.map((search) => [new require_document2.Document({
          metadata: filteredMemoryVectors[search.index].metadata,
          pageContent: filteredMemoryVectors[search.index].content
        }), search.similarity]);
        return result;
      }
      /**
      * Static method to create a `FakeVectorStore` instance from an array of
      * texts. It creates a `Document` for each text and metadata pair, and
      * adds them to the store.
      * @param texts Array of texts to be added to the store.
      * @param metadatas Array or single object of metadata corresponding to the texts.
      * @param embeddings `Embeddings` instance used to generate embeddings for the texts.
      * @param dbConfig Optional `FakeVectorStoreArgs` to configure the `FakeVectorStore` instance.
      * @returns Promise that resolves with a new `FakeVectorStore` instance.
      */
      static async fromTexts(texts, metadatas, embeddings, dbConfig) {
        const docs = [];
        for (let i = 0; i < texts.length; i += 1) {
          const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;
          const newDoc = new require_document2.Document({
            pageContent: texts[i],
            metadata
          });
          docs.push(newDoc);
        }
        return FakeVectorStore2.fromDocuments(docs, embeddings, dbConfig);
      }
      /**
      * Static method to create a `FakeVectorStore` instance from an array of
      * `Document` instances. It adds the documents to the store.
      * @param docs Array of `Document` instances to be added to the store.
      * @param embeddings `Embeddings` instance used to generate embeddings for the documents.
      * @param dbConfig Optional `FakeVectorStoreArgs` to configure the `FakeVectorStore` instance.
      * @returns Promise that resolves with a new `FakeVectorStore` instance.
      */
      static async fromDocuments(docs, embeddings, dbConfig) {
        const instance = new this(embeddings, dbConfig);
        await instance.addDocuments(docs);
        return instance;
      }
      /**
      * Static method to create a `FakeVectorStore` instance from an existing
      * index. It creates a new `FakeVectorStore` instance without adding any
      * documents or vectors.
      * @param embeddings `Embeddings` instance used to generate embeddings for the documents.
      * @param dbConfig Optional `FakeVectorStoreArgs` to configure the `FakeVectorStore` instance.
      * @returns Promise that resolves with a new `FakeVectorStore` instance.
      */
      static async fromExistingIndex(embeddings, dbConfig) {
        const instance = new this(embeddings, dbConfig);
        return instance;
      }
    };
    exports2.FakeVectorStore = FakeVectorStore;
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/testing/index.cjs
var require_testing = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/testing/index.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_chat_models3 = require_chat_models2();
    var require_embeddings3 = require_embeddings2();
    var require_llms3 = require_llms2();
    var require_message_history2 = require_message_history();
    var require_output_parsers3 = require_output_parsers2();
    var require_retrievers3 = require_retrievers2();
    var require_runnables3 = require_runnables2();
    var require_tools5 = require_tools3();
    var require_tracers2 = require_tracers();
    var require_vectorstores3 = require_vectorstores2();
    var testing_exports = {};
    require_rolldown_runtime5.__export(testing_exports, {
      FakeChatMessageHistory: () => require_message_history2.FakeChatMessageHistory,
      FakeChatModel: () => require_chat_models3.FakeChatModel,
      FakeEmbeddings: () => require_embeddings3.FakeEmbeddings,
      FakeLLM: () => require_llms3.FakeLLM,
      FakeListChatMessageHistory: () => require_message_history2.FakeListChatMessageHistory,
      FakeListChatModel: () => require_chat_models3.FakeListChatModel,
      FakeRetriever: () => require_retrievers3.FakeRetriever,
      FakeRunnable: () => require_runnables3.FakeRunnable,
      FakeSplitIntoListParser: () => require_output_parsers3.FakeSplitIntoListParser,
      FakeStreamingChatModel: () => require_chat_models3.FakeStreamingChatModel,
      FakeStreamingLLM: () => require_llms3.FakeStreamingLLM,
      FakeTool: () => require_tools5.FakeTool,
      FakeTracer: () => require_message_history2.FakeTracer,
      FakeVectorStore: () => require_vectorstores3.FakeVectorStore,
      SingleRunExtractor: () => require_tracers2.SingleRunExtractor,
      SyntheticEmbeddings: () => require_embeddings3.SyntheticEmbeddings
    });
    exports2.FakeChatMessageHistory = require_message_history2.FakeChatMessageHistory;
    exports2.FakeChatModel = require_chat_models3.FakeChatModel;
    exports2.FakeEmbeddings = require_embeddings3.FakeEmbeddings;
    exports2.FakeLLM = require_llms3.FakeLLM;
    exports2.FakeListChatMessageHistory = require_message_history2.FakeListChatMessageHistory;
    exports2.FakeListChatModel = require_chat_models3.FakeListChatModel;
    exports2.FakeRetriever = require_retrievers3.FakeRetriever;
    exports2.FakeRunnable = require_runnables3.FakeRunnable;
    exports2.FakeSplitIntoListParser = require_output_parsers3.FakeSplitIntoListParser;
    exports2.FakeStreamingChatModel = require_chat_models3.FakeStreamingChatModel;
    exports2.FakeStreamingLLM = require_llms3.FakeStreamingLLM;
    exports2.FakeTool = require_tools5.FakeTool;
    exports2.FakeTracer = require_message_history2.FakeTracer;
    exports2.FakeVectorStore = require_vectorstores3.FakeVectorStore;
    exports2.SingleRunExtractor = require_tracers2.SingleRunExtractor;
    exports2.SyntheticEmbeddings = require_embeddings3.SyntheticEmbeddings;
    Object.defineProperty(exports2, "testing_exports", {
      enumerable: true,
      get: function() {
        return testing_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/types/index.cjs
var require_types6 = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/utils/types/index.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_zod3 = require_zod();
    var types_exports = {};
    require_rolldown_runtime5.__export(types_exports, {
      extendInteropZodObject: () => require_zod3.extendInteropZodObject,
      getInteropZodDefaultGetter: () => require_zod3.getInteropZodDefaultGetter,
      getInteropZodObjectShape: () => require_zod3.getInteropZodObjectShape,
      getSchemaDescription: () => require_zod3.getSchemaDescription,
      interopParse: () => require_zod3.interopParse,
      interopParseAsync: () => require_zod3.interopParseAsync,
      interopSafeParse: () => require_zod3.interopSafeParse,
      interopSafeParseAsync: () => require_zod3.interopSafeParseAsync,
      interopZodObjectMakeFieldsOptional: () => require_zod3.interopZodObjectMakeFieldsOptional,
      interopZodObjectPartial: () => require_zod3.interopZodObjectPartial,
      interopZodObjectPassthrough: () => require_zod3.interopZodObjectPassthrough,
      interopZodObjectStrict: () => require_zod3.interopZodObjectStrict,
      interopZodTransformInputSchema: () => require_zod3.interopZodTransformInputSchema,
      isInteropZodLiteral: () => require_zod3.isInteropZodLiteral,
      isInteropZodObject: () => require_zod3.isInteropZodObject,
      isInteropZodSchema: () => require_zod3.isInteropZodSchema,
      isShapelessZodSchema: () => require_zod3.isShapelessZodSchema,
      isSimpleStringZodSchema: () => require_zod3.isSimpleStringZodSchema,
      isZodArrayV4: () => require_zod3.isZodArrayV4,
      isZodLiteralV3: () => require_zod3.isZodLiteralV3,
      isZodLiteralV4: () => require_zod3.isZodLiteralV4,
      isZodObjectV3: () => require_zod3.isZodObjectV3,
      isZodObjectV4: () => require_zod3.isZodObjectV4,
      isZodSchema: () => require_zod3.isZodSchema,
      isZodSchemaV3: () => require_zod3.isZodSchemaV3,
      isZodSchemaV4: () => require_zod3.isZodSchemaV4
    });
    exports2.extendInteropZodObject = require_zod3.extendInteropZodObject;
    exports2.getInteropZodDefaultGetter = require_zod3.getInteropZodDefaultGetter;
    exports2.getInteropZodObjectShape = require_zod3.getInteropZodObjectShape;
    exports2.getSchemaDescription = require_zod3.getSchemaDescription;
    exports2.interopParse = require_zod3.interopParse;
    exports2.interopParseAsync = require_zod3.interopParseAsync;
    exports2.interopSafeParse = require_zod3.interopSafeParse;
    exports2.interopSafeParseAsync = require_zod3.interopSafeParseAsync;
    exports2.interopZodObjectMakeFieldsOptional = require_zod3.interopZodObjectMakeFieldsOptional;
    exports2.interopZodObjectPartial = require_zod3.interopZodObjectPartial;
    exports2.interopZodObjectPassthrough = require_zod3.interopZodObjectPassthrough;
    exports2.interopZodObjectStrict = require_zod3.interopZodObjectStrict;
    exports2.interopZodTransformInputSchema = require_zod3.interopZodTransformInputSchema;
    exports2.isInteropZodLiteral = require_zod3.isInteropZodLiteral;
    exports2.isInteropZodObject = require_zod3.isInteropZodObject;
    exports2.isInteropZodSchema = require_zod3.isInteropZodSchema;
    exports2.isShapelessZodSchema = require_zod3.isShapelessZodSchema;
    exports2.isSimpleStringZodSchema = require_zod3.isSimpleStringZodSchema;
    exports2.isZodArrayV4 = require_zod3.isZodArrayV4;
    exports2.isZodLiteralV3 = require_zod3.isZodLiteralV3;
    exports2.isZodLiteralV4 = require_zod3.isZodLiteralV4;
    exports2.isZodObjectV3 = require_zod3.isZodObjectV3;
    exports2.isZodObjectV4 = require_zod3.isZodObjectV4;
    exports2.isZodSchema = require_zod3.isZodSchema;
    exports2.isZodSchemaV3 = require_zod3.isZodSchemaV3;
    exports2.isZodSchemaV4 = require_zod3.isZodSchemaV4;
    Object.defineProperty(exports2, "types_exports", {
      enumerable: true,
      get: function() {
        return types_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/load/import_map.cjs
var require_import_map = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/load/import_map.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime2();
    var require_agents2 = require_agents();
    var require_load_serializable = require_serializable();
    var require_messages_tool = require_tool();
    var require_utils_env = require_env();
    var require_callbacks_base = require_base2();
    var require_tracers_base = require_base3();
    var require_tracers_console = require_console();
    var require_tracers_tracer_langchain = require_tracer_langchain();
    var require_callbacks_promises = require_promises();
    var require_callbacks_manager = require_manager();
    var require_singletons_index = require_singletons();
    var require_utils_stream = require_stream();
    var require_tracers_log_stream = require_log_stream();
    var require_outputs2 = require_outputs();
    var require_utils_async_caller = require_async_caller2();
    var require_utils_json_schema = require_json_schema2();
    var require_runnables_graph = require_graph();
    var require_messages_index = require_messages2();
    var require_chat_history2 = require_chat_history();
    var require_embeddings3 = require_embeddings();
    var require_index = require_dist3();
    var require_memory5 = require_memory();
    var require_prompt_values2 = require_prompt_values();
    var require_stores2 = require_stores();
    var require_retrievers_index = require_retrievers();
    var require_vectorstores3 = require_vectorstores();
    var require_utils_hash = require_hash2();
    var require_caches_base = require_base5();
    var require_document_loaders_base = require_base7();
    var require_document_loaders_langsmith = require_langsmith2();
    var require_documents_index = require_documents();
    var require_example_selectors_index = require_example_selectors();
    var require_utils_tiktoken = require_tiktoken();
    var require_language_models_base = require_base6();
    var require_language_models_chat_models = require_chat_models();
    var require_language_models_llms = require_llms();
    var require_indexing_index = require_indexing();
    var require_runnables_index = require_runnables();
    var require_utils_json_patch = require_json_patch();
    var require_output_parsers_index = require_output_parsers();
    var require_output_parsers_openai_tools_index = require_openai_tools();
    var require_output_parsers_openai_functions_index = require_openai_functions();
    var require_prompts_index = require_prompts2();
    var require_retrievers_document_compressors_base = require_base12();
    var require_structured_query_index = require_structured_query();
    var require_tools_index = require_tools();
    var require_tracers_run_collector = require_run_collector();
    var require_types_stream = require_stream2();
    var require_utils_chunk_array = require_chunk_array();
    var require_utils_event_source_parse = require_event_source_parse();
    var require_utils_function_calling = require_function_calling();
    var require_utils_math = require_math();
    var require_utils_testing_index = require_testing();
    var require_utils_types_index = require_types6();
    var import_map_exports = {};
    require_rolldown_runtime5.__export(import_map_exports, {
      agents: () => require_agents2.agents_exports,
      caches: () => require_caches_base.base_exports,
      callbacks__base: () => require_callbacks_base.base_exports,
      callbacks__manager: () => require_callbacks_manager.manager_exports,
      callbacks__promises: () => require_callbacks_promises.promises_exports,
      chat_history: () => require_chat_history2.chat_history_exports,
      document_loaders__base: () => require_document_loaders_base.base_exports,
      document_loaders__langsmith: () => require_document_loaders_langsmith.langsmith_exports,
      documents: () => require_documents_index.documents_exports,
      embeddings: () => require_embeddings3.embeddings_exports,
      example_selectors: () => require_example_selectors_index.example_selectors_exports,
      index: () => require_index.src_exports,
      indexing: () => require_indexing_index.indexing_exports,
      language_models__base: () => require_language_models_base.base_exports,
      language_models__chat_models: () => require_language_models_chat_models.chat_models_exports,
      language_models__llms: () => require_language_models_llms.llms_exports,
      load__serializable: () => require_load_serializable.serializable_exports,
      memory: () => require_memory5.memory_exports,
      messages: () => require_messages_index.messages_exports,
      messages__tool: () => require_messages_tool.tool_exports,
      output_parsers: () => require_output_parsers_index.output_parsers_exports,
      output_parsers__openai_functions: () => require_output_parsers_openai_functions_index.openai_functions_exports,
      output_parsers__openai_tools: () => require_output_parsers_openai_tools_index.openai_tools_exports,
      outputs: () => require_outputs2.outputs_exports,
      prompt_values: () => require_prompt_values2.prompt_values_exports,
      prompts: () => require_prompts_index.prompts_exports,
      retrievers: () => require_retrievers_index.retrievers_exports,
      retrievers__document_compressors: () => require_retrievers_document_compressors_base.base_exports,
      runnables: () => require_runnables_index.runnables_exports,
      runnables__graph: () => require_runnables_graph.graph_exports,
      singletons: () => require_singletons_index.singletons_exports,
      stores: () => require_stores2.stores_exports,
      structured_query: () => require_structured_query_index.structured_query_exports,
      tools: () => require_tools_index.tools_exports,
      tracers__base: () => require_tracers_base.base_exports,
      tracers__console: () => require_tracers_console.console_exports,
      tracers__log_stream: () => require_tracers_log_stream.log_stream_exports,
      tracers__run_collector: () => require_tracers_run_collector.run_collector_exports,
      tracers__tracer_langchain: () => require_tracers_tracer_langchain.tracer_langchain_exports,
      types__stream: () => require_types_stream.stream_exports,
      utils__async_caller: () => require_utils_async_caller.async_caller_exports,
      utils__chunk_array: () => require_utils_chunk_array.chunk_array_exports,
      utils__env: () => require_utils_env.env_exports,
      utils__event_source_parse: () => require_utils_event_source_parse.event_source_parse_exports,
      utils__function_calling: () => require_utils_function_calling.function_calling_exports,
      utils__hash: () => require_utils_hash.hash_exports,
      utils__json_patch: () => require_utils_json_patch.json_patch_exports,
      utils__json_schema: () => require_utils_json_schema.json_schema_exports,
      utils__math: () => require_utils_math.math_exports,
      utils__stream: () => require_utils_stream.stream_exports,
      utils__testing: () => require_utils_testing_index.testing_exports,
      utils__tiktoken: () => require_utils_tiktoken.tiktoken_exports,
      utils__types: () => require_utils_types_index.types_exports,
      vectorstores: () => require_vectorstores3.vectorstores_exports
    });
    Object.defineProperty(exports2, "import_map_exports", {
      enumerable: true,
      get: function() {
        return import_map_exports;
      }
    });
  }
});

// node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/load/index.cjs
var require_load = __commonJS({
  "node_modules/.pnpm/@langchain+core@1.0.2/node_modules/@langchain/core/dist/load/index.cjs"(exports2) {
    var require_map_keys2 = require_map_keys();
    var require_load_serializable = require_serializable();
    var require_utils_env = require_env();
    var require_import_constants2 = require_import_constants();
    var require_import_map2 = require_import_map();
    function combineAliasesAndInvert(constructor) {
      const aliases = {};
      for (let current = constructor; current && current.prototype; current = Object.getPrototypeOf(current)) Object.assign(aliases, Reflect.get(current.prototype, "lc_aliases"));
      return Object.entries(aliases).reduce((acc, [key, value]) => {
        acc[value] = key;
        return acc;
      }, {});
    }
    async function reviver(value) {
      const { optionalImportsMap = {}, optionalImportEntrypoints: optionalImportEntrypoints$1 = [], importMap = {}, secretsMap = {}, path = ["$"] } = this;
      const pathStr = path.join(".");
      if (typeof value === "object" && value !== null && !Array.isArray(value) && "lc" in value && "type" in value && "id" in value && value.lc === 1 && value.type === "secret") {
        const serialized = value;
        const [key] = serialized.id;
        if (key in secretsMap) return secretsMap[key];
        else {
          const secretValueInEnv = require_utils_env.getEnvironmentVariable(key);
          if (secretValueInEnv) return secretValueInEnv;
          else throw new Error(`Missing key "${key}" for ${pathStr} in load(secretsMap={})`);
        }
      } else if (typeof value === "object" && value !== null && !Array.isArray(value) && "lc" in value && "type" in value && "id" in value && value.lc === 1 && value.type === "not_implemented") {
        const serialized = value;
        const str = JSON.stringify(serialized);
        throw new Error(`Trying to load an object that doesn't implement serialization: ${pathStr} -> ${str}`);
      } else if (typeof value === "object" && value !== null && !Array.isArray(value) && "lc" in value && "type" in value && "id" in value && "kwargs" in value && value.lc === 1) {
        const serialized = value;
        const str = JSON.stringify(serialized);
        const [name, ...namespaceReverse] = serialized.id.slice().reverse();
        const namespace = namespaceReverse.reverse();
        const importMaps = {
          langchain_core: require_import_map2.import_map_exports,
          langchain: importMap
        };
        let module$1 = null;
        const optionalImportNamespaceAliases = [namespace.join("/")];
        if (namespace[0] === "langchain_community") optionalImportNamespaceAliases.push(["langchain", ...namespace.slice(1)].join("/"));
        const matchingNamespaceAlias = optionalImportNamespaceAliases.find((alias) => alias in optionalImportsMap);
        if (require_import_constants2.optionalImportEntrypoints.concat(optionalImportEntrypoints$1).includes(namespace.join("/")) || matchingNamespaceAlias) if (matchingNamespaceAlias !== void 0) module$1 = await optionalImportsMap[matchingNamespaceAlias];
        else throw new Error(`Missing key "${namespace.join("/")}" for ${pathStr} in load(optionalImportsMap={})`);
        else {
          let finalImportMap;
          if (namespace[0] === "langchain" || namespace[0] === "langchain_core") {
            finalImportMap = importMaps[namespace[0]];
            namespace.shift();
          } else throw new Error(`Invalid namespace: ${pathStr} -> ${str}`);
          if (namespace.length === 0) throw new Error(`Invalid namespace: ${pathStr} -> ${str}`);
          let importMapKey;
          do {
            importMapKey = namespace.join("__");
            if (importMapKey in finalImportMap) break;
            else namespace.pop();
          } while (namespace.length > 0);
          if (importMapKey in finalImportMap) module$1 = finalImportMap[importMapKey];
        }
        if (typeof module$1 !== "object" || module$1 === null) throw new Error(`Invalid namespace: ${pathStr} -> ${str}`);
        const builder = module$1[name] ?? Object.values(module$1).find((v) => typeof v === "function" && require_load_serializable.get_lc_unique_name(v) === name);
        if (typeof builder !== "function") throw new Error(`Invalid identifer: ${pathStr} -> ${str}`);
        const kwargs = await reviver.call({
          ...this,
          path: [...path, "kwargs"]
        }, serialized.kwargs);
        if (serialized.type === "constructor") {
          const instance = new builder(require_map_keys2.mapKeys(kwargs, require_map_keys2.keyFromJson, combineAliasesAndInvert(builder)));
          Object.defineProperty(instance.constructor, "name", { value: name });
          return instance;
        } else throw new Error(`Invalid type: ${pathStr} -> ${str}`);
      } else if (typeof value === "object" && value !== null) if (Array.isArray(value)) return Promise.all(value.map((v, i) => reviver.call({
        ...this,
        path: [...path, `${i}`]
      }, v)));
      else return Object.fromEntries(await Promise.all(Object.entries(value).map(async ([key, value$1]) => [key, await reviver.call({
        ...this,
        path: [...path, key]
      }, value$1)])));
      return value;
    }
    async function load(text, mappings) {
      const json = JSON.parse(text);
      return reviver.call({ ...mappings }, json);
    }
    exports2.load = load;
  }
});

// node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/serde/jsonplus.cjs
var require_jsonplus = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/serde/jsonplus.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime4();
    var require_index = require_fast_safe_stringify2();
    var __langchain_core_load = require_rolldown_runtime5.__toESM(require_load());
    function isLangChainSerializedObject(value) {
      return value !== null && value.lc === 1 && value.type === "constructor" && Array.isArray(value.id);
    }
    async function _reviver(value) {
      if (value && typeof value === "object") if (Array.isArray(value)) {
        const revivedArray = await Promise.all(value.map((item) => _reviver(item)));
        return revivedArray;
      } else {
        const revivedObj = {};
        for (const [k, v] of Object.entries(value)) revivedObj[k] = await _reviver(v);
        if (revivedObj.lc === 2 && revivedObj.type === "undefined") return void 0;
        else if (revivedObj.lc === 2 && revivedObj.type === "constructor" && Array.isArray(revivedObj.id)) try {
          const constructorName = revivedObj.id[revivedObj.id.length - 1];
          let constructor;
          switch (constructorName) {
            case "Set":
              constructor = Set;
              break;
            case "Map":
              constructor = Map;
              break;
            case "RegExp":
              constructor = RegExp;
              break;
            case "Error":
              constructor = Error;
              break;
            default:
              return revivedObj;
          }
          if (revivedObj.method) return constructor[revivedObj.method](...revivedObj.args || []);
          else return new constructor(...revivedObj.args || []);
        } catch (error) {
          return revivedObj;
        }
        else if (isLangChainSerializedObject(revivedObj)) return (0, __langchain_core_load.load)(JSON.stringify(revivedObj));
        return revivedObj;
      }
      return value;
    }
    function _encodeConstructorArgs(constructor, method, args, kwargs) {
      return {
        lc: 2,
        type: "constructor",
        id: [constructor.name],
        method: method ?? null,
        args: args ?? [],
        kwargs: kwargs ?? {}
      };
    }
    function _default(obj) {
      if (obj === void 0) return {
        lc: 2,
        type: "undefined"
      };
      else if (obj instanceof Set || obj instanceof Map) return _encodeConstructorArgs(obj.constructor, void 0, [Array.from(obj)]);
      else if (obj instanceof RegExp) return _encodeConstructorArgs(RegExp, void 0, [obj.source, obj.flags]);
      else if (obj instanceof Error) return _encodeConstructorArgs(obj.constructor, void 0, [obj.message]);
      else if (obj?.lg_name === "Send") return {
        node: obj.node,
        args: obj.args
      };
      else return obj;
    }
    var JsonPlusSerializer = class {
      _dumps(obj) {
        const encoder = new TextEncoder();
        return encoder.encode(require_index.stringify(obj, (_, value) => {
          return _default(value);
        }));
      }
      async dumpsTyped(obj) {
        if (obj instanceof Uint8Array) return ["bytes", obj];
        else return ["json", this._dumps(obj)];
      }
      async _loads(data) {
        const parsed = JSON.parse(data);
        return _reviver(parsed);
      }
      async loadsTyped(type, data) {
        if (type === "bytes") return typeof data === "string" ? new TextEncoder().encode(data) : data;
        else if (type === "json") return this._loads(typeof data === "string" ? data : new TextDecoder().decode(data));
        else throw new Error(`Unknown serialization type: ${type}`);
      }
    };
    exports2.JsonPlusSerializer = JsonPlusSerializer;
  }
});

// node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/base.cjs
var require_base14 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/base.cjs"(exports2) {
    var require_id4 = require_id2();
    var require_types10 = require_types5();
    var require_jsonplus2 = require_jsonplus();
    function deepCopy(obj) {
      if (typeof obj !== "object" || obj === null) return obj;
      const newObj = Array.isArray(obj) ? [] : {};
      for (const key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = deepCopy(obj[key]);
      return newObj;
    }
    function emptyCheckpoint() {
      return {
        v: 4,
        id: require_id4.uuid6(-2),
        ts: (/* @__PURE__ */ new Date()).toISOString(),
        channel_values: {},
        channel_versions: {},
        versions_seen: {}
      };
    }
    function copyCheckpoint(checkpoint) {
      return {
        v: checkpoint.v,
        id: checkpoint.id,
        ts: checkpoint.ts,
        channel_values: { ...checkpoint.channel_values },
        channel_versions: { ...checkpoint.channel_versions },
        versions_seen: deepCopy(checkpoint.versions_seen)
      };
    }
    var BaseCheckpointSaver = class {
      serde = new require_jsonplus2.JsonPlusSerializer();
      constructor(serde) {
        this.serde = serde || this.serde;
      }
      async get(config) {
        const value = await this.getTuple(config);
        return value ? value.checkpoint : void 0;
      }
      /**
      * Generate the next version ID for a channel.
      *
      * Default is to use integer versions, incrementing by 1. If you override, you can use str/int/float versions,
      * as long as they are monotonically increasing.
      */
      getNextVersion(current) {
        if (typeof current === "string") throw new Error("Please override this method to use string versions.");
        return current !== void 0 && typeof current === "number" ? current + 1 : 1;
      }
    };
    function compareChannelVersions(a, b) {
      if (typeof a === "number" && typeof b === "number") return Math.sign(a - b);
      return String(a).localeCompare(String(b));
    }
    function maxChannelVersion(...versions) {
      return versions.reduce((max, version2, idx) => {
        if (idx === 0) return version2;
        return compareChannelVersions(max, version2) >= 0 ? max : version2;
      });
    }
    var WRITES_IDX_MAP = {
      [require_types10.ERROR]: -1,
      [require_types10.SCHEDULED]: -2,
      [require_types10.INTERRUPT]: -3,
      [require_types10.RESUME]: -4
    };
    function getCheckpointId(config) {
      return config.configurable?.checkpoint_id || config.configurable?.thread_ts || "";
    }
    exports2.BaseCheckpointSaver = BaseCheckpointSaver;
    exports2.WRITES_IDX_MAP = WRITES_IDX_MAP;
    exports2.compareChannelVersions = compareChannelVersions;
    exports2.copyCheckpoint = copyCheckpoint;
    exports2.deepCopy = deepCopy;
    exports2.emptyCheckpoint = emptyCheckpoint;
    exports2.getCheckpointId = getCheckpointId;
    exports2.maxChannelVersion = maxChannelVersion;
  }
});

// node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/memory.cjs
var require_memory2 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/memory.cjs"(exports2) {
    var require_types10 = require_types5();
    var require_base18 = require_base14();
    function _generateKey(threadId, checkpointNamespace, checkpointId) {
      return JSON.stringify([
        threadId,
        checkpointNamespace,
        checkpointId
      ]);
    }
    function _parseKey(key) {
      const [threadId, checkpointNamespace, checkpointId] = JSON.parse(key);
      return {
        threadId,
        checkpointNamespace,
        checkpointId
      };
    }
    var MemorySaver = class extends require_base18.BaseCheckpointSaver {
      storage = {};
      writes = {};
      constructor(serde) {
        super(serde);
      }
      /** @internal */
      async _migratePendingSends(mutableCheckpoint, threadId, checkpointNs, parentCheckpointId) {
        const deseriablizableCheckpoint = mutableCheckpoint;
        const parentKey = _generateKey(threadId, checkpointNs, parentCheckpointId);
        const pendingSends = await Promise.all(Object.values(this.writes[parentKey] ?? {}).filter(([_taskId, channel2]) => channel2 === require_types10.TASKS).map(async ([_taskId, _channel, writes]) => await this.serde.loadsTyped("json", writes)));
        deseriablizableCheckpoint.channel_values ??= {};
        deseriablizableCheckpoint.channel_values[require_types10.TASKS] = pendingSends;
        deseriablizableCheckpoint.channel_versions ??= {};
        deseriablizableCheckpoint.channel_versions[require_types10.TASKS] = Object.keys(deseriablizableCheckpoint.channel_versions).length > 0 ? require_base18.maxChannelVersion(...Object.values(deseriablizableCheckpoint.channel_versions)) : this.getNextVersion(void 0);
      }
      async getTuple(config) {
        const thread_id = config.configurable?.thread_id;
        const checkpoint_ns = config.configurable?.checkpoint_ns ?? "";
        let checkpoint_id = require_base18.getCheckpointId(config);
        if (checkpoint_id) {
          const saved = this.storage[thread_id]?.[checkpoint_ns]?.[checkpoint_id];
          if (saved !== void 0) {
            const [checkpoint, metadata, parentCheckpointId] = saved;
            const key = _generateKey(thread_id, checkpoint_ns, checkpoint_id);
            const deserializedCheckpoint = await this.serde.loadsTyped("json", checkpoint);
            if (deserializedCheckpoint.v < 4 && parentCheckpointId !== void 0) await this._migratePendingSends(deserializedCheckpoint, thread_id, checkpoint_ns, parentCheckpointId);
            const pendingWrites = await Promise.all(Object.values(this.writes[key] || {}).map(async ([taskId, channel2, value]) => {
              return [
                taskId,
                channel2,
                await this.serde.loadsTyped("json", value)
              ];
            }));
            const checkpointTuple = {
              config,
              checkpoint: deserializedCheckpoint,
              metadata: await this.serde.loadsTyped("json", metadata),
              pendingWrites
            };
            if (parentCheckpointId !== void 0) checkpointTuple.parentConfig = { configurable: {
              thread_id,
              checkpoint_ns,
              checkpoint_id: parentCheckpointId
            } };
            return checkpointTuple;
          }
        } else {
          const checkpoints = this.storage[thread_id]?.[checkpoint_ns];
          if (checkpoints !== void 0) {
            checkpoint_id = Object.keys(checkpoints).sort((a, b) => b.localeCompare(a))[0];
            const saved = checkpoints[checkpoint_id];
            const [checkpoint, metadata, parentCheckpointId] = saved;
            const key = _generateKey(thread_id, checkpoint_ns, checkpoint_id);
            const deserializedCheckpoint = await this.serde.loadsTyped("json", checkpoint);
            if (deserializedCheckpoint.v < 4 && parentCheckpointId !== void 0) await this._migratePendingSends(deserializedCheckpoint, thread_id, checkpoint_ns, parentCheckpointId);
            const pendingWrites = await Promise.all(Object.values(this.writes[key] || {}).map(async ([taskId, channel2, value]) => {
              return [
                taskId,
                channel2,
                await this.serde.loadsTyped("json", value)
              ];
            }));
            const checkpointTuple = {
              config: { configurable: {
                thread_id,
                checkpoint_id,
                checkpoint_ns
              } },
              checkpoint: deserializedCheckpoint,
              metadata: await this.serde.loadsTyped("json", metadata),
              pendingWrites
            };
            if (parentCheckpointId !== void 0) checkpointTuple.parentConfig = { configurable: {
              thread_id,
              checkpoint_ns,
              checkpoint_id: parentCheckpointId
            } };
            return checkpointTuple;
          }
        }
        return void 0;
      }
      async *list(config, options) {
        let { before, limit, filter } = options ?? {};
        const threadIds = config.configurable?.thread_id ? [config.configurable?.thread_id] : Object.keys(this.storage);
        const configCheckpointNamespace = config.configurable?.checkpoint_ns;
        const configCheckpointId = config.configurable?.checkpoint_id;
        for (const threadId of threadIds) for (const checkpointNamespace of Object.keys(this.storage[threadId] ?? {})) {
          if (configCheckpointNamespace !== void 0 && checkpointNamespace !== configCheckpointNamespace) continue;
          const checkpoints = this.storage[threadId]?.[checkpointNamespace] ?? {};
          const sortedCheckpoints = Object.entries(checkpoints).sort((a, b) => b[0].localeCompare(a[0]));
          for (const [checkpointId, [checkpoint, metadataStr, parentCheckpointId]] of sortedCheckpoints) {
            if (configCheckpointId && checkpointId !== configCheckpointId) continue;
            if (before && before.configurable?.checkpoint_id && checkpointId >= before.configurable.checkpoint_id) continue;
            const metadata = await this.serde.loadsTyped("json", metadataStr);
            if (filter && !Object.entries(filter).every(([key$1, value]) => metadata[key$1] === value)) continue;
            if (limit !== void 0) {
              if (limit <= 0) break;
              limit -= 1;
            }
            const key = _generateKey(threadId, checkpointNamespace, checkpointId);
            const writes = Object.values(this.writes[key] || {});
            const pendingWrites = await Promise.all(writes.map(async ([taskId, channel2, value]) => {
              return [
                taskId,
                channel2,
                await this.serde.loadsTyped("json", value)
              ];
            }));
            const deserializedCheckpoint = await this.serde.loadsTyped("json", checkpoint);
            if (deserializedCheckpoint.v < 4 && parentCheckpointId !== void 0) await this._migratePendingSends(deserializedCheckpoint, threadId, checkpointNamespace, parentCheckpointId);
            const checkpointTuple = {
              config: { configurable: {
                thread_id: threadId,
                checkpoint_ns: checkpointNamespace,
                checkpoint_id: checkpointId
              } },
              checkpoint: deserializedCheckpoint,
              metadata,
              pendingWrites
            };
            if (parentCheckpointId !== void 0) checkpointTuple.parentConfig = { configurable: {
              thread_id: threadId,
              checkpoint_ns: checkpointNamespace,
              checkpoint_id: parentCheckpointId
            } };
            yield checkpointTuple;
          }
        }
      }
      async put(config, checkpoint, metadata) {
        const preparedCheckpoint = require_base18.copyCheckpoint(checkpoint);
        const threadId = config.configurable?.thread_id;
        const checkpointNamespace = config.configurable?.checkpoint_ns ?? "";
        if (threadId === void 0) throw new Error(`Failed to put checkpoint. The passed RunnableConfig is missing a required "thread_id" field in its "configurable" property.`);
        if (!this.storage[threadId]) this.storage[threadId] = {};
        if (!this.storage[threadId][checkpointNamespace]) this.storage[threadId][checkpointNamespace] = {};
        const [[, serializedCheckpoint], [, serializedMetadata]] = await Promise.all([this.serde.dumpsTyped(preparedCheckpoint), this.serde.dumpsTyped(metadata)]);
        this.storage[threadId][checkpointNamespace][checkpoint.id] = [
          serializedCheckpoint,
          serializedMetadata,
          config.configurable?.checkpoint_id
        ];
        return { configurable: {
          thread_id: threadId,
          checkpoint_ns: checkpointNamespace,
          checkpoint_id: checkpoint.id
        } };
      }
      async putWrites(config, writes, taskId) {
        const threadId = config.configurable?.thread_id;
        const checkpointNamespace = config.configurable?.checkpoint_ns;
        const checkpointId = config.configurable?.checkpoint_id;
        if (threadId === void 0) throw new Error(`Failed to put writes. The passed RunnableConfig is missing a required "thread_id" field in its "configurable" property`);
        if (checkpointId === void 0) throw new Error(`Failed to put writes. The passed RunnableConfig is missing a required "checkpoint_id" field in its "configurable" property.`);
        const outerKey = _generateKey(threadId, checkpointNamespace, checkpointId);
        const outerWrites_ = this.writes[outerKey];
        if (this.writes[outerKey] === void 0) this.writes[outerKey] = {};
        await Promise.all(writes.map(async ([channel2, value], idx) => {
          const [, serializedValue] = await this.serde.dumpsTyped(value);
          const innerKey = [taskId, require_base18.WRITES_IDX_MAP[channel2] || idx];
          const innerKeyStr = `${innerKey[0]},${innerKey[1]}`;
          if (innerKey[1] >= 0 && outerWrites_ && innerKeyStr in outerWrites_) return;
          this.writes[outerKey][innerKeyStr] = [
            taskId,
            channel2,
            serializedValue
          ];
        }));
      }
      async deleteThread(threadId) {
        delete this.storage[threadId];
        for (const key of Object.keys(this.writes)) if (_parseKey(key).threadId === threadId) delete this.writes[key];
      }
    };
    exports2.MemorySaver = MemorySaver;
  }
});

// node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/store/base.cjs
var require_base15 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/store/base.cjs"(exports2) {
    var InvalidNamespaceError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "InvalidNamespaceError";
      }
    };
    function validateNamespace(namespace) {
      if (namespace.length === 0) throw new InvalidNamespaceError("Namespace cannot be empty.");
      for (const label of namespace) {
        if (typeof label !== "string") throw new InvalidNamespaceError(`Invalid namespace label '${label}' found in ${namespace}. Namespace labels must be strings, but got ${typeof label}.`);
        if (label.includes(".")) throw new InvalidNamespaceError(`Invalid namespace label '${label}' found in ${namespace}. Namespace labels cannot contain periods ('.').`);
        if (label === "") throw new InvalidNamespaceError(`Namespace labels cannot be empty strings. Got ${label} in ${namespace}`);
      }
      if (namespace[0] === "langgraph") throw new InvalidNamespaceError(`Root label for namespace cannot be "langgraph". Got: ${namespace}`);
    }
    function getTextAtPath(obj, path) {
      const parts = path.split(".");
      let current = obj;
      for (const part of parts) {
        if (part.includes("[")) {
          const [arrayName, indexStr] = part.split("[");
          const index = indexStr.replace("]", "");
          if (!current[arrayName]) return [];
          if (index === "*") {
            const results = [];
            for (const item of current[arrayName]) if (typeof item === "string") results.push(item);
            return results;
          }
          const idx = parseInt(index, 10);
          if (Number.isNaN(idx)) return [];
          current = current[arrayName][idx];
        } else current = current[part];
        if (current === void 0) return [];
      }
      return typeof current === "string" ? [current] : [];
    }
    function tokenizePath(path) {
      return path.split(".");
    }
    var BaseStore = class {
      /**
      * Retrieve a single item by its namespace and key.
      *
      * @param namespace Hierarchical path for the item
      * @param key Unique identifier within the namespace
      * @returns Promise resolving to the item or null if not found
      */
      async get(namespace, key) {
        return (await this.batch([{
          namespace,
          key
        }]))[0];
      }
      /**
      * Search for items within a namespace prefix.
      * Supports both metadata filtering and vector similarity search.
      *
      * @param namespacePrefix Hierarchical path prefix to search within
      * @param options Search options for filtering and pagination
      * @returns Promise resolving to list of matching items with relevance scores
      *
      * @example
      * // Search with filters
      * await store.search(["documents"], {
      *   filter: { type: "report", status: "active" },
      *   limit: 5,
      *   offset: 10
      * });
      *
      * // Vector similarity search
      * await store.search(["users", "content"], {
      *   query: "technical documentation about APIs",
      *   limit: 20
      * });
      */
      async search(namespacePrefix, options = {}) {
        const { filter, limit = 10, offset = 0, query } = options;
        return (await this.batch([{
          namespacePrefix,
          filter,
          limit,
          offset,
          query
        }]))[0];
      }
      /**
      * Store or update an item.
      *
      * @param namespace Hierarchical path for the item
      * @param key Unique identifier within the namespace
      * @param value Object containing the item's data
      * @param index Optional indexing configuration
      *
      * @example
      * // Simple storage
      * await store.put(["docs"], "report", { title: "Annual Report" });
      *
      * // With specific field indexing
      * await store.put(
      *   ["docs"],
      *   "report",
      *   {
      *     title: "Q4 Report",
      *     chapters: [{ content: "..." }, { content: "..." }]
      *   },
      *   ["title", "chapters[*].content"]
      * );
      */
      async put(namespace, key, value, index) {
        validateNamespace(namespace);
        await this.batch([{
          namespace,
          key,
          value,
          index
        }]);
      }
      /**
      * Delete an item from the store.
      *
      * @param namespace Hierarchical path for the item
      * @param key Unique identifier within the namespace
      */
      async delete(namespace, key) {
        await this.batch([{
          namespace,
          key,
          value: null
        }]);
      }
      /**
      * List and filter namespaces in the store.
      * Used to explore data organization and navigate the namespace hierarchy.
      *
      * @param options Options for listing namespaces
      * @returns Promise resolving to list of namespace paths
      *
      * @example
      * // List all namespaces under "documents"
      * await store.listNamespaces({
      *   prefix: ["documents"],
      *   maxDepth: 2
      * });
      *
      * // List namespaces ending with "v1"
      * await store.listNamespaces({
      *   suffix: ["v1"],
      *   limit: 50
      * });
      */
      async listNamespaces(options = {}) {
        const { prefix, suffix, maxDepth, limit = 100, offset = 0 } = options;
        const matchConditions = [];
        if (prefix) matchConditions.push({
          matchType: "prefix",
          path: prefix
        });
        if (suffix) matchConditions.push({
          matchType: "suffix",
          path: suffix
        });
        return (await this.batch([{
          matchConditions: matchConditions.length ? matchConditions : void 0,
          maxDepth,
          limit,
          offset
        }]))[0];
      }
      /**
      * Start the store. Override if initialization is needed.
      */
      start() {
      }
      /**
      * Stop the store. Override if cleanup is needed.
      */
      stop() {
      }
    };
    exports2.BaseStore = BaseStore;
    exports2.InvalidNamespaceError = InvalidNamespaceError;
    exports2.getTextAtPath = getTextAtPath;
    exports2.tokenizePath = tokenizePath;
  }
});

// node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/store/batch.cjs
var require_batch = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/store/batch.cjs"(exports2) {
    var require_base18 = require_base15();
    var extractStore = (input) => {
      if ("lg_name" in input && input.lg_name === "AsyncBatchedStore") return input.store;
      return input;
    };
    var AsyncBatchedStore = class extends require_base18.BaseStore {
      lg_name = "AsyncBatchedStore";
      store;
      queue = /* @__PURE__ */ new Map();
      nextKey = 0;
      running = false;
      processingTask = null;
      constructor(store) {
        super();
        this.store = extractStore(store);
      }
      get isRunning() {
        return this.running;
      }
      /**
      * @ignore
      * Batch is not implemented here as we're only extending `BaseStore`
      * to allow it to be passed where `BaseStore` is expected, and implement
      * the convenience methods (get, search, put, delete).
      */
      async batch(_operations) {
        throw new Error("The `batch` method is not implemented on `AsyncBatchedStore`.\n Instead, it calls the `batch` method on the wrapped store.\n If you are seeing this error, something is wrong.");
      }
      async get(namespace, key) {
        return this.enqueueOperation({
          namespace,
          key
        });
      }
      async search(namespacePrefix, options) {
        const { filter, limit = 10, offset = 0, query } = options || {};
        return this.enqueueOperation({
          namespacePrefix,
          filter,
          limit,
          offset,
          query
        });
      }
      async put(namespace, key, value) {
        return this.enqueueOperation({
          namespace,
          key,
          value
        });
      }
      async delete(namespace, key) {
        return this.enqueueOperation({
          namespace,
          key,
          value: null
        });
      }
      start() {
        if (!this.running) {
          this.running = true;
          this.processingTask = this.processBatchQueue();
        }
      }
      async stop() {
        this.running = false;
        if (this.processingTask) await this.processingTask;
      }
      enqueueOperation(operation) {
        return new Promise((resolve, reject) => {
          const key = this.nextKey;
          this.nextKey += 1;
          this.queue.set(key, {
            operation,
            resolve,
            reject
          });
        });
      }
      async processBatchQueue() {
        while (this.running) {
          await new Promise((resolve) => {
            setTimeout(resolve, 0);
          });
          if (this.queue.size === 0) continue;
          const batch = new Map(this.queue);
          this.queue.clear();
          try {
            const operations = Array.from(batch.values()).map(({ operation }) => operation);
            const results = await this.store.batch(operations);
            batch.forEach(({ resolve }, key) => {
              const index = Array.from(batch.keys()).indexOf(key);
              resolve(results[index]);
            });
          } catch (e) {
            batch.forEach(({ reject }) => {
              reject(e);
            });
          }
        }
      }
      toJSON() {
        return {
          queue: this.queue,
          nextKey: this.nextKey,
          running: this.running,
          store: "[LangGraphStore]"
        };
      }
    };
    exports2.AsyncBatchedStore = AsyncBatchedStore;
  }
});

// node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/store/utils.cjs
var require_utils7 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/store/utils.cjs"(exports2) {
    function tokenizePath(path) {
      if (!path) return [];
      const tokens = [];
      let current = [];
      let i = 0;
      while (i < path.length) {
        const char = path[i];
        if (char === "[") {
          if (current.length) {
            tokens.push(current.join(""));
            current = [];
          }
          let bracketCount = 1;
          const indexChars = ["["];
          i += 1;
          while (i < path.length && bracketCount > 0) {
            if (path[i] === "[") bracketCount += 1;
            else if (path[i] === "]") bracketCount -= 1;
            indexChars.push(path[i]);
            i += 1;
          }
          tokens.push(indexChars.join(""));
          continue;
        } else if (char === "{") {
          if (current.length) {
            tokens.push(current.join(""));
            current = [];
          }
          let braceCount = 1;
          const fieldChars = ["{"];
          i += 1;
          while (i < path.length && braceCount > 0) {
            if (path[i] === "{") braceCount += 1;
            else if (path[i] === "}") braceCount -= 1;
            fieldChars.push(path[i]);
            i += 1;
          }
          tokens.push(fieldChars.join(""));
          continue;
        } else if (char === ".") {
          if (current.length) {
            tokens.push(current.join(""));
            current = [];
          }
        } else current.push(char);
        i += 1;
      }
      if (current.length) tokens.push(current.join(""));
      return tokens;
    }
    function isFilterOperators(obj) {
      return typeof obj === "object" && obj !== null && Object.keys(obj).every((key) => key === "$eq" || key === "$ne" || key === "$gt" || key === "$gte" || key === "$lt" || key === "$lte" || key === "$in" || key === "$nin");
    }
    function compareValues(itemValue, filterValue) {
      if (isFilterOperators(filterValue)) {
        const operators = Object.keys(filterValue).filter((k) => k.startsWith("$"));
        return operators.every((op) => {
          const value = filterValue[op];
          switch (op) {
            case "$eq":
              return itemValue === value;
            case "$ne":
              return itemValue !== value;
            case "$gt":
              return Number(itemValue) > Number(value);
            case "$gte":
              return Number(itemValue) >= Number(value);
            case "$lt":
              return Number(itemValue) < Number(value);
            case "$lte":
              return Number(itemValue) <= Number(value);
            case "$in":
              return Array.isArray(value) ? value.includes(itemValue) : false;
            case "$nin":
              return Array.isArray(value) ? !value.includes(itemValue) : true;
            default:
              return false;
          }
        });
      }
      return itemValue === filterValue;
    }
    function getTextAtPath(obj, path) {
      if (!path || path === "$") return [JSON.stringify(obj, null, 2)];
      const tokens = Array.isArray(path) ? path : tokenizePath(path);
      function extractFromObj(obj$1, tokens$1, pos) {
        if (pos >= tokens$1.length) {
          if (typeof obj$1 === "string" || typeof obj$1 === "number" || typeof obj$1 === "boolean") return [String(obj$1)];
          if (obj$1 === null || obj$1 === void 0) return [];
          if (Array.isArray(obj$1) || typeof obj$1 === "object") return [JSON.stringify(obj$1, null, 2)];
          return [];
        }
        const token = tokens$1[pos];
        const results = [];
        if (pos === 0 && token === "$") results.push(JSON.stringify(obj$1, null, 2));
        if (token.startsWith("[") && token.endsWith("]")) {
          if (!Array.isArray(obj$1)) return [];
          const index = token.slice(1, -1);
          if (index === "*") for (const item of obj$1) results.push(...extractFromObj(item, tokens$1, pos + 1));
          else try {
            let idx = parseInt(index, 10);
            if (idx < 0) idx = obj$1.length + idx;
            if (idx >= 0 && idx < obj$1.length) results.push(...extractFromObj(obj$1[idx], tokens$1, pos + 1));
          } catch {
            return [];
          }
        } else if (token.startsWith("{") && token.endsWith("}")) {
          if (typeof obj$1 !== "object" || obj$1 === null) return [];
          const fields = token.slice(1, -1).split(",").map((f) => f.trim());
          for (const field of fields) {
            const nestedTokens = tokenizePath(field);
            if (nestedTokens.length) {
              let currentObj = obj$1;
              for (const nestedToken of nestedTokens) if (currentObj && typeof currentObj === "object" && nestedToken in currentObj) currentObj = currentObj[nestedToken];
              else {
                currentObj = void 0;
                break;
              }
              if (currentObj !== void 0) {
                if (typeof currentObj === "string" || typeof currentObj === "number" || typeof currentObj === "boolean") results.push(String(currentObj));
                else if (Array.isArray(currentObj) || typeof currentObj === "object") results.push(JSON.stringify(currentObj, null, 2));
              }
            }
          }
        } else if (token === "*") {
          if (Array.isArray(obj$1)) for (const item of obj$1) results.push(...extractFromObj(item, tokens$1, pos + 1));
          else if (typeof obj$1 === "object" && obj$1 !== null) for (const value of Object.values(obj$1)) results.push(...extractFromObj(value, tokens$1, pos + 1));
        } else if (typeof obj$1 === "object" && obj$1 !== null && token in obj$1) results.push(...extractFromObj(obj$1[token], tokens$1, pos + 1));
        return results;
      }
      return extractFromObj(obj, tokens, 0);
    }
    exports2.compareValues = compareValues;
    exports2.getTextAtPath = getTextAtPath;
    exports2.tokenizePath = tokenizePath;
  }
});

// node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/store/memory.cjs
var require_memory3 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/store/memory.cjs"(exports2) {
    var require_base18 = require_base15();
    var require_utils10 = require_utils7();
    var InMemoryStore = class extends require_base18.BaseStore {
      data = /* @__PURE__ */ new Map();
      vectors = /* @__PURE__ */ new Map();
      _indexConfig;
      constructor(options) {
        super();
        if (options?.index) this._indexConfig = {
          ...options.index,
          __tokenizedFields: (options.index.fields ?? ["$"]).map((p) => [p, p === "$" ? [p] : require_utils10.tokenizePath(p)])
        };
      }
      async batch(operations) {
        const results = [];
        const putOps = /* @__PURE__ */ new Map();
        const searchOps = /* @__PURE__ */ new Map();
        for (let i = 0; i < operations.length; i += 1) {
          const op = operations[i];
          if ("key" in op && "namespace" in op && !("value" in op)) results.push(this.getOperation(op));
          else if ("namespacePrefix" in op) {
            const candidates = this.filterItems(op);
            searchOps.set(i, [op, candidates]);
            results.push(null);
          } else if ("value" in op) {
            const key = `${op.namespace.join(":")}:${op.key}`;
            putOps.set(key, op);
            results.push(null);
          } else if ("matchConditions" in op) results.push(this.listNamespacesOperation(op));
        }
        if (searchOps.size > 0) if (this._indexConfig?.embeddings) {
          const queries = /* @__PURE__ */ new Set();
          for (const [op] of searchOps.values()) if (op.query) queries.add(op.query);
          const queryEmbeddings = queries.size > 0 ? await Promise.all(Array.from(queries).map((q) => this._indexConfig.embeddings.embedQuery(q))) : [];
          const queryVectors = Object.fromEntries(Array.from(queries).map((q, i) => [q, queryEmbeddings[i]]));
          for (const [i, [op, candidates]] of searchOps.entries()) if (op.query && queryVectors[op.query]) {
            const queryVector = queryVectors[op.query];
            const scoredResults = this.scoreResults(candidates, queryVector, op.offset ?? 0, op.limit ?? 10);
            results[i] = scoredResults;
          } else results[i] = this.paginateResults(candidates.map((item) => ({
            ...item,
            score: void 0
          })), op.offset ?? 0, op.limit ?? 10);
        } else for (const [i, [op, candidates]] of searchOps.entries()) results[i] = this.paginateResults(candidates.map((item) => ({
          ...item,
          score: void 0
        })), op.offset ?? 0, op.limit ?? 10);
        if (putOps.size > 0 && this._indexConfig?.embeddings) {
          const toEmbed = this.extractTexts(Array.from(putOps.values()));
          if (Object.keys(toEmbed).length > 0) {
            const embeddings = await this._indexConfig.embeddings.embedDocuments(Object.keys(toEmbed));
            this.insertVectors(toEmbed, embeddings);
          }
        }
        for (const op of putOps.values()) this.putOperation(op);
        return results;
      }
      getOperation(op) {
        const namespaceKey = op.namespace.join(":");
        const item = this.data.get(namespaceKey)?.get(op.key);
        return item ?? null;
      }
      putOperation(op) {
        const namespaceKey = op.namespace.join(":");
        if (!this.data.has(namespaceKey)) this.data.set(namespaceKey, /* @__PURE__ */ new Map());
        const namespaceMap = this.data.get(namespaceKey);
        if (op.value === null) namespaceMap.delete(op.key);
        else {
          const now = /* @__PURE__ */ new Date();
          if (namespaceMap.has(op.key)) {
            const item = namespaceMap.get(op.key);
            item.value = op.value;
            item.updatedAt = now;
          } else namespaceMap.set(op.key, {
            value: op.value,
            key: op.key,
            namespace: op.namespace,
            createdAt: now,
            updatedAt: now
          });
        }
      }
      listNamespacesOperation(op) {
        const allNamespaces = Array.from(this.data.keys()).map((ns) => ns.split(":"));
        let namespaces = allNamespaces;
        if (op.matchConditions && op.matchConditions.length > 0) namespaces = namespaces.filter((ns) => op.matchConditions.every((condition) => this.doesMatch(condition, ns)));
        if (op.maxDepth !== void 0) namespaces = Array.from(new Set(namespaces.map((ns) => ns.slice(0, op.maxDepth).join(":")))).map((ns) => ns.split(":"));
        namespaces.sort((a, b) => a.join(":").localeCompare(b.join(":")));
        return namespaces.slice(op.offset ?? 0, (op.offset ?? 0) + (op.limit ?? namespaces.length));
      }
      doesMatch(matchCondition, key) {
        const { matchType, path } = matchCondition;
        if (matchType === "prefix") {
          if (path.length > key.length) return false;
          return path.every((pElem, index) => {
            const kElem = key[index];
            return pElem === "*" || kElem === pElem;
          });
        } else if (matchType === "suffix") {
          if (path.length > key.length) return false;
          return path.every((pElem, index) => {
            const kElem = key[key.length - path.length + index];
            return pElem === "*" || kElem === pElem;
          });
        }
        throw new Error(`Unsupported match type: ${matchType}`);
      }
      filterItems(op) {
        const candidates = [];
        for (const [namespace, items] of this.data.entries()) if (namespace.startsWith(op.namespacePrefix.join(":"))) candidates.push(...items.values());
        let filteredCandidates = candidates;
        if (op.filter) filteredCandidates = candidates.filter((item) => Object.entries(op.filter).every(([key, value]) => require_utils10.compareValues(item.value[key], value)));
        return filteredCandidates;
      }
      scoreResults(candidates, queryVector, offset = 0, limit = 10) {
        const flatItems = [];
        const flatVectors = [];
        const scoreless = [];
        for (const item of candidates) {
          const vectors = this.getVectors(item);
          if (vectors.length) for (const vector of vectors) {
            flatItems.push(item);
            flatVectors.push(vector);
          }
          else scoreless.push(item);
        }
        const scores = this.cosineSimilarity(queryVector, flatVectors);
        const sortedResults = scores.map((score, i) => [score, flatItems[i]]).sort((a, b) => b[0] - a[0]);
        const seen = /* @__PURE__ */ new Set();
        const kept = [];
        for (const [score, item] of sortedResults) {
          const key = `${item.namespace.join(":")}:${item.key}`;
          if (seen.has(key)) continue;
          const ix = seen.size;
          if (ix >= offset + limit) break;
          if (ix < offset) {
            seen.add(key);
            continue;
          }
          seen.add(key);
          kept.push([score, item]);
        }
        if (scoreless.length && kept.length < limit) for (const item of scoreless.slice(0, limit - kept.length)) {
          const key = `${item.namespace.join(":")}:${item.key}`;
          if (!seen.has(key)) {
            seen.add(key);
            kept.push([void 0, item]);
          }
        }
        return kept.map(([score, item]) => ({
          ...item,
          score
        }));
      }
      paginateResults(results, offset, limit) {
        return results.slice(offset, offset + limit);
      }
      extractTexts(ops) {
        if (!ops.length || !this._indexConfig) return {};
        const toEmbed = {};
        for (const op of ops) if (op.value !== null && op.index !== false) {
          const paths = op.index === null || op.index === void 0 ? this._indexConfig.__tokenizedFields ?? [] : op.index.map((ix) => [ix, require_utils10.tokenizePath(ix)]);
          for (const [path, field] of paths) {
            const texts = require_utils10.getTextAtPath(op.value, field);
            if (texts.length) if (texts.length > 1) texts.forEach((text, i) => {
              if (!toEmbed[text]) toEmbed[text] = [];
              toEmbed[text].push([
                op.namespace,
                op.key,
                `${path}.${i}`
              ]);
            });
            else {
              if (!toEmbed[texts[0]]) toEmbed[texts[0]] = [];
              toEmbed[texts[0]].push([
                op.namespace,
                op.key,
                path
              ]);
            }
          }
        }
        return toEmbed;
      }
      insertVectors(texts, embeddings) {
        for (const [text, metadata] of Object.entries(texts)) {
          const embedding = embeddings.shift();
          if (!embedding) throw new Error(`No embedding found for text: ${text}`);
          for (const [namespace, key, field] of metadata) {
            const namespaceKey = namespace.join(":");
            if (!this.vectors.has(namespaceKey)) this.vectors.set(namespaceKey, /* @__PURE__ */ new Map());
            const namespaceMap = this.vectors.get(namespaceKey);
            if (!namespaceMap.has(key)) namespaceMap.set(key, /* @__PURE__ */ new Map());
            const itemMap = namespaceMap.get(key);
            itemMap.set(field, embedding);
          }
        }
      }
      getVectors(item) {
        const namespaceKey = item.namespace.join(":");
        const itemKey = item.key;
        if (!this.vectors.has(namespaceKey)) return [];
        const namespaceMap = this.vectors.get(namespaceKey);
        if (!namespaceMap.has(itemKey)) return [];
        const itemMap = namespaceMap.get(itemKey);
        const vectors = Array.from(itemMap.values());
        if (!vectors.length) return [];
        return vectors;
      }
      cosineSimilarity(X, Y) {
        if (!Y.length) return [];
        const dotProducts = Y.map((vector) => vector.reduce((acc, val, i) => acc + val * X[i], 0));
        const magnitude1 = Math.sqrt(X.reduce((acc, val) => acc + val * val, 0));
        const magnitudes2 = Y.map((vector) => Math.sqrt(vector.reduce((acc, val) => acc + val * val, 0)));
        return dotProducts.map((dot, i) => {
          const magnitude2 = magnitudes2[i];
          return magnitude1 && magnitude2 ? dot / (magnitude1 * magnitude2) : 0;
        });
      }
      get indexConfig() {
        return this._indexConfig;
      }
    };
    var MemoryStore = class extends InMemoryStore {
    };
    exports2.InMemoryStore = InMemoryStore;
    exports2.MemoryStore = MemoryStore;
  }
});

// node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/cache/base.cjs
var require_base16 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/cache/base.cjs"(exports2) {
    var require_jsonplus2 = require_jsonplus();
    var BaseCache = class {
      serde = new require_jsonplus2.JsonPlusSerializer();
      /**
      * Initialize the cache with a serializer.
      *
      * @param serde - The serializer to use.
      */
      constructor(serde) {
        this.serde = serde || this.serde;
      }
    };
    exports2.BaseCache = BaseCache;
  }
});

// node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/cache/memory.cjs
var require_memory4 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/cache/memory.cjs"(exports2) {
    var require_base18 = require_base16();
    var InMemoryCache = class extends require_base18.BaseCache {
      cache = {};
      async get(keys) {
        if (!keys.length) return [];
        const now = Date.now();
        return (await Promise.all(keys.map(async (fullKey) => {
          const [namespace, key] = fullKey;
          const strNamespace = namespace.join(",");
          if (strNamespace in this.cache && key in this.cache[strNamespace]) {
            const cached = this.cache[strNamespace][key];
            if (cached.exp == null || now < cached.exp) {
              const value = await this.serde.loadsTyped(cached.enc, cached.val);
              return [{
                key: fullKey,
                value
              }];
            } else delete this.cache[strNamespace][key];
          }
          return [];
        }))).flat();
      }
      async set(pairs) {
        const now = Date.now();
        for (const { key: fullKey, value, ttl } of pairs) {
          const [namespace, key] = fullKey;
          const strNamespace = namespace.join(",");
          const [enc, val] = await this.serde.dumpsTyped(value);
          const exp = ttl != null ? ttl * 1e3 + now : null;
          this.cache[strNamespace] ??= {};
          this.cache[strNamespace][key] = {
            enc,
            val,
            exp
          };
        }
      }
      async clear(namespaces) {
        if (!namespaces.length) {
          this.cache = {};
          return;
        }
        for (const namespace of namespaces) {
          const strNamespace = namespace.join(",");
          if (strNamespace in this.cache) delete this.cache[strNamespace];
        }
      }
    };
    exports2.InMemoryCache = InMemoryCache;
  }
});

// node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/cache/index.cjs
var require_cache = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/cache/index.cjs"() {
    var require_base18 = require_base16();
    var require_memory5 = require_memory4();
  }
});

// node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/index.cjs
var require_dist4 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph-checkpoint@1.0.0_@langchain+core@1.0.2/node_modules/@langchain/langgraph-checkpoint/dist/index.cjs"(exports2) {
    var require_id4 = require_id2();
    var require_types10 = require_types5();
    var require_base18 = require_base14();
    var require_memory5 = require_memory2();
    var require_base$1 = require_base15();
    var require_batch2 = require_batch();
    var require_memory$1 = require_memory3();
    var require_base$2 = require_base16();
    var require_memory$2 = require_memory4();
    require_cache();
    exports2.AsyncBatchedStore = require_batch2.AsyncBatchedStore;
    exports2.BaseCache = require_base$2.BaseCache;
    exports2.BaseCheckpointSaver = require_base18.BaseCheckpointSaver;
    exports2.BaseStore = require_base$1.BaseStore;
    exports2.ERROR = require_types10.ERROR;
    exports2.INTERRUPT = require_types10.INTERRUPT;
    exports2.InMemoryCache = require_memory$2.InMemoryCache;
    exports2.InMemoryStore = require_memory$1.InMemoryStore;
    exports2.InvalidNamespaceError = require_base$1.InvalidNamespaceError;
    exports2.MemorySaver = require_memory5.MemorySaver;
    exports2.MemoryStore = require_memory$1.MemoryStore;
    exports2.RESUME = require_types10.RESUME;
    exports2.SCHEDULED = require_types10.SCHEDULED;
    exports2.TASKS = require_types10.TASKS;
    exports2.WRITES_IDX_MAP = require_base18.WRITES_IDX_MAP;
    exports2.compareChannelVersions = require_base18.compareChannelVersions;
    exports2.copyCheckpoint = require_base18.copyCheckpoint;
    exports2.deepCopy = require_base18.deepCopy;
    exports2.emptyCheckpoint = require_base18.emptyCheckpoint;
    exports2.getCheckpointId = require_base18.getCheckpointId;
    exports2.getTextAtPath = require_base$1.getTextAtPath;
    exports2.maxChannelVersion = require_base18.maxChannelVersion;
    exports2.tokenizePath = require_base$1.tokenizePath;
    exports2.uuid5 = require_id4.uuid5;
    exports2.uuid6 = require_id4.uuid6;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/channels/base.cjs
var require_base17 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/channels/base.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime3();
    var require_errors10 = require_errors5();
    var __langchain_langgraph_checkpoint = require_rolldown_runtime5.__toESM(require_dist4());
    function isBaseChannel(obj) {
      return obj != null && obj.lg_is_channel === true;
    }
    var BaseChannel = class {
      ValueType;
      UpdateType;
      /** @ignore */
      lg_is_channel = true;
      /**
      * Mark the current value of the channel as consumed. By default, no-op.
      * A channel can use this method to modify its state, preventing the value
      * from being consumed again.
      *
      * Returns True if the channel was updated, False otherwise.
      */
      consume() {
        return false;
      }
      /**
      * Notify the channel that the Pregel run is finishing. By default, no-op.
      * A channel can use this method to modify its state, preventing finish.
      *
      * Returns True if the channel was updated, False otherwise.
      */
      finish() {
        return false;
      }
      /**
      * Return True if the channel is available (not empty), False otherwise.
      * Subclasses should override this method to provide a more efficient
      * implementation than calling get() and catching EmptyChannelError.
      */
      isAvailable() {
        try {
          this.get();
          return true;
        } catch (error) {
          if (error.name === require_errors10.EmptyChannelError.unminifiable_name) return false;
          throw error;
        }
      }
    };
    var IS_ONLY_BASE_CHANNEL = Symbol.for("LG_IS_ONLY_BASE_CHANNEL");
    function getOnlyChannels(channels) {
      if (channels[IS_ONLY_BASE_CHANNEL] === true) return channels;
      const newChannels = {};
      for (const k in channels) {
        if (!Object.prototype.hasOwnProperty.call(channels, k)) continue;
        const value = channels[k];
        if (isBaseChannel(value)) newChannels[k] = value;
      }
      Object.assign(newChannels, { [IS_ONLY_BASE_CHANNEL]: true });
      return newChannels;
    }
    function emptyChannels(channels, checkpoint) {
      const filteredChannels = getOnlyChannels(channels);
      const newChannels = {};
      for (const k in filteredChannels) {
        if (!Object.prototype.hasOwnProperty.call(filteredChannels, k)) continue;
        const channelValue = checkpoint.channel_values[k];
        newChannels[k] = filteredChannels[k].fromCheckpoint(channelValue);
      }
      Object.assign(newChannels, { [IS_ONLY_BASE_CHANNEL]: true });
      return newChannels;
    }
    function createCheckpoint(checkpoint, channels, step, options) {
      let values;
      if (channels === void 0) values = checkpoint.channel_values;
      else {
        values = {};
        for (const k in channels) {
          if (!Object.prototype.hasOwnProperty.call(channels, k)) continue;
          try {
            values[k] = channels[k].checkpoint();
          } catch (error) {
            if (error.name === require_errors10.EmptyChannelError.unminifiable_name) {
            } else throw error;
          }
        }
      }
      return {
        v: 4,
        id: options?.id ?? (0, __langchain_langgraph_checkpoint.uuid6)(step),
        ts: (/* @__PURE__ */ new Date()).toISOString(),
        channel_values: values,
        channel_versions: checkpoint.channel_versions,
        versions_seen: checkpoint.versions_seen
      };
    }
    exports2.BaseChannel = BaseChannel;
    exports2.createCheckpoint = createCheckpoint;
    exports2.emptyChannels = emptyChannels;
    exports2.getOnlyChannels = getOnlyChannels;
    exports2.isBaseChannel = isBaseChannel;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/channels/binop.cjs
var require_binop = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/channels/binop.cjs"(exports2) {
    var require_errors10 = require_errors5();
    var require_base18 = require_base17();
    var BinaryOperatorAggregate = class BinaryOperatorAggregate2 extends require_base18.BaseChannel {
      lc_graph_name = "BinaryOperatorAggregate";
      value;
      operator;
      initialValueFactory;
      constructor(operator, initialValueFactory) {
        super();
        this.operator = operator;
        this.initialValueFactory = initialValueFactory;
        this.value = initialValueFactory?.();
      }
      fromCheckpoint(checkpoint) {
        const empty = new BinaryOperatorAggregate2(this.operator, this.initialValueFactory);
        if (typeof checkpoint !== "undefined") empty.value = checkpoint;
        return empty;
      }
      update(values) {
        let newValues = values;
        if (!newValues.length) return false;
        if (this.value === void 0) {
          [this.value] = newValues;
          newValues = newValues.slice(1);
        }
        for (const value of newValues) if (this.value !== void 0) this.value = this.operator(this.value, value);
        return true;
      }
      get() {
        if (this.value === void 0) throw new require_errors10.EmptyChannelError();
        return this.value;
      }
      checkpoint() {
        if (this.value === void 0) throw new require_errors10.EmptyChannelError();
        return this.value;
      }
      isAvailable() {
        return this.value !== void 0;
      }
    };
    exports2.BinaryOperatorAggregate = BinaryOperatorAggregate;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/channels/last_value.cjs
var require_last_value = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/channels/last_value.cjs"(exports2) {
    var require_errors10 = require_errors5();
    var require_base18 = require_base17();
    var LastValue = class LastValue2 extends require_base18.BaseChannel {
      lc_graph_name = "LastValue";
      value = [];
      fromCheckpoint(checkpoint) {
        const empty = new LastValue2();
        if (typeof checkpoint !== "undefined") empty.value = [checkpoint];
        return empty;
      }
      update(values) {
        if (values.length === 0) return false;
        if (values.length !== 1) throw new require_errors10.InvalidUpdateError("LastValue can only receive one value per step.", { lc_error_code: "INVALID_CONCURRENT_GRAPH_UPDATE" });
        this.value = [values[values.length - 1]];
        return true;
      }
      get() {
        if (this.value.length === 0) throw new require_errors10.EmptyChannelError();
        return this.value[0];
      }
      checkpoint() {
        if (this.value.length === 0) throw new require_errors10.EmptyChannelError();
        return this.value[0];
      }
      isAvailable() {
        return this.value.length !== 0;
      }
    };
    var LastValueAfterFinish = class LastValueAfterFinish2 extends require_base18.BaseChannel {
      lc_graph_name = "LastValueAfterFinish";
      value = [];
      finished = false;
      fromCheckpoint(checkpoint) {
        const empty = new LastValueAfterFinish2();
        if (typeof checkpoint !== "undefined") {
          const [value, finished] = checkpoint;
          empty.value = [value];
          empty.finished = finished;
        }
        return empty;
      }
      update(values) {
        if (values.length === 0) return false;
        this.finished = false;
        this.value = [values[values.length - 1]];
        return true;
      }
      get() {
        if (this.value.length === 0 || !this.finished) throw new require_errors10.EmptyChannelError();
        return this.value[0];
      }
      checkpoint() {
        if (this.value.length === 0) return void 0;
        return [this.value[0], this.finished];
      }
      consume() {
        if (this.finished) {
          this.finished = false;
          this.value = [];
          return true;
        }
        return false;
      }
      finish() {
        if (!this.finished && this.value.length > 0) {
          this.finished = true;
          return true;
        }
        return false;
      }
      isAvailable() {
        return this.value.length !== 0 && this.finished;
      }
    };
    exports2.LastValue = LastValue;
    exports2.LastValueAfterFinish = LastValueAfterFinish;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/graph/annotation.cjs
var require_annotation = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/graph/annotation.cjs"(exports2) {
    var require_binop2 = require_binop();
    var require_last_value2 = require_last_value();
    var AnnotationRoot = class {
      lc_graph_name = "AnnotationRoot";
      spec;
      constructor(s) {
        this.spec = s;
      }
    };
    var Annotation = function(annotation) {
      if (annotation) return getChannel(annotation);
      else return new require_last_value2.LastValue();
    };
    Annotation.Root = (sd) => new AnnotationRoot(sd);
    function getChannel(reducer) {
      if (typeof reducer === "object" && reducer && "reducer" in reducer && reducer.reducer) return new require_binop2.BinaryOperatorAggregate(reducer.reducer, reducer.default);
      if (typeof reducer === "object" && reducer && "value" in reducer && reducer.value) return new require_binop2.BinaryOperatorAggregate(reducer.value, reducer.default);
      return new require_last_value2.LastValue();
    }
    exports2.Annotation = Annotation;
    exports2.AnnotationRoot = AnnotationRoot;
    exports2.getChannel = getChannel;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/constants.cjs
var require_constants4 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/constants.cjs"(exports2) {
    var START = "__start__";
    var END = "__end__";
    var INPUT = "__input__";
    var COPY = "__copy__";
    var ERROR2 = "__error__";
    var CACHE_NS_WRITES = "__pregel_ns_writes";
    var CONFIG_KEY_SEND = "__pregel_send";
    var CONFIG_KEY_CALL = "__pregel_call";
    var CONFIG_KEY_READ = "__pregel_read";
    var CONFIG_KEY_CHECKPOINTER = "__pregel_checkpointer";
    var CONFIG_KEY_RESUMING = "__pregel_resuming";
    var CONFIG_KEY_TASK_ID = "__pregel_task_id";
    var CONFIG_KEY_STREAM = "__pregel_stream";
    var CONFIG_KEY_RESUME_VALUE = "__pregel_resume_value";
    var CONFIG_KEY_RESUME_MAP = "__pregel_resume_map";
    var CONFIG_KEY_SCRATCHPAD = "__pregel_scratchpad";
    var CONFIG_KEY_PREVIOUS_STATE = "__pregel_previous";
    var CONFIG_KEY_DURABILITY = "__pregel_durability";
    var CONFIG_KEY_CHECKPOINT_ID = "checkpoint_id";
    var CONFIG_KEY_CHECKPOINT_NS = "checkpoint_ns";
    var CONFIG_KEY_NODE_FINISHED = "__pregel_node_finished";
    var CONFIG_KEY_CHECKPOINT_MAP = "checkpoint_map";
    var CONFIG_KEY_ABORT_SIGNALS = "__pregel_abort_signals";
    var INTERRUPT = "__interrupt__";
    var RESUME = "__resume__";
    var NO_WRITES = "__no_writes__";
    var RETURN = "__return__";
    var PREVIOUS = "__previous__";
    var TAG_HIDDEN = "langsmith:hidden";
    var TAG_NOSTREAM = "langsmith:nostream";
    var SELF = "__self__";
    var TASKS = "__pregel_tasks";
    var PUSH = "__pregel_push";
    var PULL = "__pregel_pull";
    var NULL_TASK_ID = "00000000-0000-0000-0000-000000000000";
    var RESERVED = [
      TAG_HIDDEN,
      INPUT,
      INTERRUPT,
      RESUME,
      ERROR2,
      NO_WRITES,
      CONFIG_KEY_SEND,
      CONFIG_KEY_READ,
      CONFIG_KEY_CHECKPOINTER,
      CONFIG_KEY_DURABILITY,
      CONFIG_KEY_STREAM,
      CONFIG_KEY_RESUMING,
      CONFIG_KEY_TASK_ID,
      CONFIG_KEY_CALL,
      CONFIG_KEY_RESUME_VALUE,
      CONFIG_KEY_SCRATCHPAD,
      CONFIG_KEY_PREVIOUS_STATE,
      CONFIG_KEY_CHECKPOINT_MAP,
      CONFIG_KEY_CHECKPOINT_NS,
      CONFIG_KEY_CHECKPOINT_ID
    ];
    var CHECKPOINT_NAMESPACE_SEPARATOR = "|";
    var CHECKPOINT_NAMESPACE_END = ":";
    var COMMAND_SYMBOL = Symbol.for("langgraph.command");
    var CommandInstance = class {
      [COMMAND_SYMBOL];
      constructor(args) {
        this[COMMAND_SYMBOL] = args;
      }
    };
    function _isSendInterface(x) {
      const operation = x;
      return operation !== null && operation !== void 0 && typeof operation.node === "string" && operation.args !== void 0;
    }
    var Send = class {
      lg_name = "Send";
      node;
      args;
      constructor(node, args) {
        this.node = node;
        this.args = _deserializeCommandSendObjectGraph(args);
      }
      toJSON() {
        return {
          lg_name: this.lg_name,
          node: this.node,
          args: this.args
        };
      }
    };
    function _isSend(x) {
      return x instanceof Send;
    }
    function isInterrupted(values) {
      if (!values || typeof values !== "object") return false;
      if (!(INTERRUPT in values)) return false;
      return Array.isArray(values[INTERRUPT]);
    }
    var Command = class extends CommandInstance {
      lg_name = "Command";
      lc_direct_tool_output = true;
      /**
      * Graph to send the command to. Supported values are:
      *   - None: the current graph (default)
      *   - The specific name of the graph to send the command to
      *   - {@link Command.PARENT}: closest parent graph (only supported when returned from a node in a subgraph)
      */
      graph;
      /**
      * Update to apply to the graph's state as a result of executing the node that is returning the command.
      * Written to the state as if the node had simply returned this value instead of the Command object.
      */
      update;
      /**
      * Value to resume execution with. To be used together with {@link interrupt}.
      */
      resume;
      /**
      * Can be one of the following:
      *   - name of the node to navigate to next (any node that belongs to the specified `graph`)
      *   - sequence of node names to navigate to next
      *   - {@link Send} object (to execute a node with the exact input provided in the {@link Send} object)
      *   - sequence of {@link Send} objects
      */
      goto = [];
      static PARENT = "__parent__";
      constructor(args) {
        super(args);
        this.resume = args.resume;
        this.graph = args.graph;
        this.update = args.update;
        if (args.goto) this.goto = Array.isArray(args.goto) ? _deserializeCommandSendObjectGraph(args.goto) : [_deserializeCommandSendObjectGraph(args.goto)];
      }
      /**
      * Convert the update field to a list of {@link PendingWrite} tuples
      * @returns List of {@link PendingWrite} tuples of the form `[channelKey, value]`.
      * @internal
      */
      _updateAsTuples() {
        if (this.update && typeof this.update === "object" && !Array.isArray(this.update)) return Object.entries(this.update);
        else if (Array.isArray(this.update) && this.update.every((t) => Array.isArray(t) && t.length === 2 && typeof t[0] === "string")) return this.update;
        else return [["__root__", this.update]];
      }
      toJSON() {
        let serializedGoto;
        if (typeof this.goto === "string") serializedGoto = this.goto;
        else if (_isSend(this.goto)) serializedGoto = this.goto.toJSON();
        else serializedGoto = this.goto?.map((innerGoto) => {
          if (typeof innerGoto === "string") return innerGoto;
          else return innerGoto.toJSON();
        });
        return {
          lg_name: this.lg_name,
          update: this.update,
          resume: this.resume,
          goto: serializedGoto
        };
      }
    };
    function isCommand(x) {
      if (typeof x !== "object") return false;
      if (x === null || x === void 0) return false;
      if ("lg_name" in x && x.lg_name === "Command") return true;
      return false;
    }
    function _deserializeCommandSendObjectGraph(x, seen = /* @__PURE__ */ new Map()) {
      if (x !== void 0 && x !== null && typeof x === "object") {
        if (seen.has(x)) return seen.get(x);
        let result;
        if (Array.isArray(x)) {
          result = [];
          seen.set(x, result);
          x.forEach((item, index) => {
            result[index] = _deserializeCommandSendObjectGraph(item, seen);
          });
        } else if (isCommand(x) && !(x instanceof Command)) {
          result = new Command(x);
          seen.set(x, result);
        } else if (_isSendInterface(x) && !(x instanceof Send)) {
          result = new Send(x.node, x.args);
          seen.set(x, result);
        } else if (isCommand(x) || _isSend(x)) {
          result = x;
          seen.set(x, result);
        } else if ("lc_serializable" in x && x.lc_serializable) {
          result = x;
          seen.set(x, result);
        } else {
          result = {};
          seen.set(x, result);
          for (const [key, value] of Object.entries(x)) result[key] = _deserializeCommandSendObjectGraph(value, seen);
        }
        return result;
      }
      return x;
    }
    exports2.CACHE_NS_WRITES = CACHE_NS_WRITES;
    exports2.CHECKPOINT_NAMESPACE_END = CHECKPOINT_NAMESPACE_END;
    exports2.CHECKPOINT_NAMESPACE_SEPARATOR = CHECKPOINT_NAMESPACE_SEPARATOR;
    exports2.CONFIG_KEY_ABORT_SIGNALS = CONFIG_KEY_ABORT_SIGNALS;
    exports2.CONFIG_KEY_CALL = CONFIG_KEY_CALL;
    exports2.CONFIG_KEY_CHECKPOINTER = CONFIG_KEY_CHECKPOINTER;
    exports2.CONFIG_KEY_CHECKPOINT_ID = CONFIG_KEY_CHECKPOINT_ID;
    exports2.CONFIG_KEY_CHECKPOINT_MAP = CONFIG_KEY_CHECKPOINT_MAP;
    exports2.CONFIG_KEY_CHECKPOINT_NS = CONFIG_KEY_CHECKPOINT_NS;
    exports2.CONFIG_KEY_DURABILITY = CONFIG_KEY_DURABILITY;
    exports2.CONFIG_KEY_NODE_FINISHED = CONFIG_KEY_NODE_FINISHED;
    exports2.CONFIG_KEY_PREVIOUS_STATE = CONFIG_KEY_PREVIOUS_STATE;
    exports2.CONFIG_KEY_READ = CONFIG_KEY_READ;
    exports2.CONFIG_KEY_RESUME_MAP = CONFIG_KEY_RESUME_MAP;
    exports2.CONFIG_KEY_RESUMING = CONFIG_KEY_RESUMING;
    exports2.CONFIG_KEY_SCRATCHPAD = CONFIG_KEY_SCRATCHPAD;
    exports2.CONFIG_KEY_SEND = CONFIG_KEY_SEND;
    exports2.CONFIG_KEY_STREAM = CONFIG_KEY_STREAM;
    exports2.CONFIG_KEY_TASK_ID = CONFIG_KEY_TASK_ID;
    exports2.COPY = COPY;
    exports2.Command = Command;
    exports2.CommandInstance = CommandInstance;
    exports2.END = END;
    exports2.ERROR = ERROR2;
    exports2.INPUT = INPUT;
    exports2.INTERRUPT = INTERRUPT;
    exports2.NO_WRITES = NO_WRITES;
    exports2.NULL_TASK_ID = NULL_TASK_ID;
    exports2.PREVIOUS = PREVIOUS;
    exports2.PULL = PULL;
    exports2.PUSH = PUSH;
    exports2.RESERVED = RESERVED;
    exports2.RESUME = RESUME;
    exports2.RETURN = RETURN;
    exports2.SELF = SELF;
    exports2.START = START;
    exports2.Send = Send;
    exports2.TAG_HIDDEN = TAG_HIDDEN;
    exports2.TAG_NOSTREAM = TAG_NOSTREAM;
    exports2.TASKS = TASKS;
    exports2._isSend = _isSend;
    exports2._isSendInterface = _isSendInterface;
    exports2.isCommand = isCommand;
    exports2.isInterrupted = isInterrupted;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/utils/config.cjs
var require_config2 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/utils/config.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime3();
    var require_constants5 = require_constants4();
    var __langchain_core_singletons = require_rolldown_runtime5.__toESM(require_singletons());
    var COPIABLE_KEYS = [
      "tags",
      "metadata",
      "callbacks",
      "configurable"
    ];
    var CONFIG_KEYS = [
      "tags",
      "metadata",
      "callbacks",
      "runName",
      "maxConcurrency",
      "recursionLimit",
      "configurable",
      "runId",
      "outputKeys",
      "streamMode",
      "store",
      "writer",
      "interrupt",
      "context",
      "interruptBefore",
      "interruptAfter",
      "checkpointDuring",
      "durability",
      "signal"
    ];
    var DEFAULT_RECURSION_LIMIT = 25;
    function ensureLangGraphConfig(...configs) {
      const empty = {
        tags: [],
        metadata: {},
        callbacks: void 0,
        recursionLimit: DEFAULT_RECURSION_LIMIT,
        configurable: {}
      };
      const implicitConfig = __langchain_core_singletons.AsyncLocalStorageProviderSingleton.getRunnableConfig();
      if (implicitConfig !== void 0) {
        for (const [k, v] of Object.entries(implicitConfig)) if (v !== void 0) if (COPIABLE_KEYS.includes(k)) {
          let copiedValue;
          if (Array.isArray(v)) copiedValue = [...v];
          else if (typeof v === "object") if (k === "callbacks" && "copy" in v && typeof v.copy === "function") copiedValue = v.copy();
          else copiedValue = { ...v };
          else copiedValue = v;
          empty[k] = copiedValue;
        } else empty[k] = v;
      }
      for (const config of configs) {
        if (config === void 0) continue;
        for (const [k, v] of Object.entries(config)) if (v !== void 0 && CONFIG_KEYS.includes(k)) empty[k] = v;
      }
      for (const [key, value] of Object.entries(empty.configurable)) {
        empty.metadata = empty.metadata ?? {};
        if (!key.startsWith("__") && (typeof value === "string" || typeof value === "number" || typeof value === "boolean") && !(key in empty.metadata)) empty.metadata[key] = value;
      }
      return empty;
    }
    function getStore(config) {
      const runConfig = config ?? __langchain_core_singletons.AsyncLocalStorageProviderSingleton.getRunnableConfig();
      if (runConfig === void 0) throw new Error(["Config not retrievable. This is likely because you are running in an environment without support for AsyncLocalStorage.", "If you're running `getStore` in such environment, pass the `config` from the node function directly."].join("\n"));
      return runConfig?.store;
    }
    function getWriter(config) {
      const runConfig = config ?? __langchain_core_singletons.AsyncLocalStorageProviderSingleton.getRunnableConfig();
      if (runConfig === void 0) throw new Error(["Config not retrievable. This is likely because you are running in an environment without support for AsyncLocalStorage.", "If you're running `getWriter` in such environment, pass the `config` from the node function directly."].join("\n"));
      return runConfig?.writer || runConfig?.configurable?.writer;
    }
    function getConfig2() {
      return __langchain_core_singletons.AsyncLocalStorageProviderSingleton.getRunnableConfig();
    }
    function getCurrentTaskInput(config) {
      const runConfig = config ?? __langchain_core_singletons.AsyncLocalStorageProviderSingleton.getRunnableConfig();
      if (runConfig === void 0) throw new Error(["Config not retrievable. This is likely because you are running in an environment without support for AsyncLocalStorage.", "If you're running `getCurrentTaskInput` in such environment, pass the `config` from the node function directly."].join("\n"));
      if (runConfig.configurable?.[require_constants5.CONFIG_KEY_SCRATCHPAD]?.currentTaskInput === void 0) throw new Error("BUG: internal scratchpad not initialized.");
      return runConfig.configurable[require_constants5.CONFIG_KEY_SCRATCHPAD].currentTaskInput;
    }
    function recastCheckpointNamespace(namespace) {
      return namespace.split(require_constants5.CHECKPOINT_NAMESPACE_SEPARATOR).filter((part) => !part.match(/^\d+$/)).map((part) => part.split(require_constants5.CHECKPOINT_NAMESPACE_END)[0]).join(require_constants5.CHECKPOINT_NAMESPACE_SEPARATOR);
    }
    function getParentCheckpointNamespace(namespace) {
      const parts = namespace.split(require_constants5.CHECKPOINT_NAMESPACE_SEPARATOR);
      while (parts.length > 1 && parts[parts.length - 1].match(/^\d+$/)) parts.pop();
      return parts.slice(0, -1).join(require_constants5.CHECKPOINT_NAMESPACE_SEPARATOR);
    }
    exports2.ensureLangGraphConfig = ensureLangGraphConfig;
    exports2.getConfig = getConfig2;
    exports2.getCurrentTaskInput = getCurrentTaskInput;
    exports2.getParentCheckpointNamespace = getParentCheckpointNamespace;
    exports2.getStore = getStore;
    exports2.getWriter = getWriter;
    exports2.recastCheckpointNamespace = recastCheckpointNamespace;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/hash.cjs
var require_hash3 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/hash.cjs"(exports2) {
    var n = (n$1) => BigInt(n$1);
    var view = (data, offset = 0) => new DataView(data.buffer, data.byteOffset + offset, data.byteLength - offset);
    var PRIME32_1 = n("0x9E3779B1");
    var PRIME32_2 = n("0x85EBCA77");
    var PRIME32_3 = n("0xC2B2AE3D");
    var PRIME64_1 = n("0x9E3779B185EBCA87");
    var PRIME64_2 = n("0xC2B2AE3D27D4EB4F");
    var PRIME64_3 = n("0x165667B19E3779F9");
    var PRIME64_4 = n("0x85EBCA77C2B2AE63");
    var PRIME64_5 = n("0x27D4EB2F165667C5");
    var PRIME_MX1 = n("0x165667919E3779F9");
    var PRIME_MX2 = n("0x9FB21C651E98DF25");
    var hexToUint8Array = (hex) => {
      const strLen = hex.length;
      if (strLen % 2 !== 0) throw new Error("String should have an even number of characters");
      const maxLength = strLen / 2;
      const bytes = new Uint8Array(maxLength);
      let read = 0;
      let write = 0;
      while (write < maxLength) {
        const slice = hex.slice(read, read += 2);
        bytes[write] = Number.parseInt(slice, 16);
        write += 1;
      }
      return view(bytes);
    };
    var kkey = hexToUint8Array("b8fe6c3923a44bbe7c01812cf721ad1cded46de9839097db7240a4a4b7b3671fcb79e64eccc0e578825ad07dccff7221b8084674f743248ee03590e6813a264c3c2852bb91c300cb88d0658b1b532ea371644897a20df94e3819ef46a9deacd8a8fa763fe39c343ff9dcbbc7c70b4f1d8a51e04bcdb45931c89f7ec9d9787364eac5ac8334d3ebc3c581a0fffa1363eb170ddd51b7f0da49d316552629d4689e2b16be587d47a1fc8ff8b8d17ad031ce45cb3a8f95160428afd7fbcabb4b407e");
    var mask128 = (n(1) << n(128)) - n(1);
    var mask64 = (n(1) << n(64)) - n(1);
    var mask32 = (n(1) << n(32)) - n(1);
    var STRIPE_LEN = 64;
    var ACC_NB = STRIPE_LEN / 8;
    var _U64 = 8;
    var _U32 = 4;
    function assert(a) {
      if (!a) throw new Error("Assert failed");
    }
    function bswap64(a) {
      const scratchbuf = /* @__PURE__ */ new DataView(/* @__PURE__ */ new ArrayBuffer(8));
      scratchbuf.setBigUint64(0, a, true);
      return scratchbuf.getBigUint64(0, false);
    }
    function bswap32(input) {
      let a = input;
      a = (a & n(65535)) << n(16) | (a & n(4294901760)) >> n(16);
      a = (a & n(16711935)) << n(8) | (a & n(4278255360)) >> n(8);
      return a;
    }
    function XXH_mult32to64(a, b) {
      return (a & mask32) * (b & mask32) & mask64;
    }
    function rotl32(a, b) {
      return (a << b | a >> n(32) - b) & mask32;
    }
    function XXH3_accumulate_512(acc, dataView, keyView) {
      for (let i = 0; i < ACC_NB; i += 1) {
        const data_val = dataView.getBigUint64(i * 8, true);
        const data_key = data_val ^ keyView.getBigUint64(i * 8, true);
        acc[i ^ 1] += data_val;
        acc[i] += XXH_mult32to64(data_key, data_key >> n(32));
      }
      return acc;
    }
    function XXH3_accumulate(acc, dataView, keyView, nbStripes) {
      for (let n$1 = 0; n$1 < nbStripes; n$1 += 1) XXH3_accumulate_512(acc, view(dataView, n$1 * STRIPE_LEN), view(keyView, n$1 * 8));
      return acc;
    }
    function XXH3_scrambleAcc(acc, key) {
      for (let i = 0; i < ACC_NB; i += 1) {
        const key64 = key.getBigUint64(i * 8, true);
        let acc64 = acc[i];
        acc64 = xorshift64(acc64, n(47));
        acc64 ^= key64;
        acc64 *= PRIME32_1;
        acc[i] = acc64 & mask64;
      }
      return acc;
    }
    function XXH3_mix2Accs(acc, key) {
      return XXH3_mul128_fold64(acc[0] ^ key.getBigUint64(0, true), acc[1] ^ key.getBigUint64(_U64, true));
    }
    function XXH3_mergeAccs(acc, key, start) {
      let result64 = start;
      result64 += XXH3_mix2Accs(acc.slice(0), view(key, 0 * _U32));
      result64 += XXH3_mix2Accs(acc.slice(2), view(key, 4 * _U32));
      result64 += XXH3_mix2Accs(acc.slice(4), view(key, 8 * _U32));
      result64 += XXH3_mix2Accs(acc.slice(6), view(key, 12 * _U32));
      return XXH3_avalanche(result64 & mask64);
    }
    function XXH3_hashLong(input, data, secret, f_acc, f_scramble) {
      let acc = input;
      const nbStripesPerBlock = Math.floor((secret.byteLength - STRIPE_LEN) / 8);
      const block_len = STRIPE_LEN * nbStripesPerBlock;
      const nb_blocks = Math.floor((data.byteLength - 1) / block_len);
      for (let n$1 = 0; n$1 < nb_blocks; n$1 += 1) {
        acc = XXH3_accumulate(acc, view(data, n$1 * block_len), secret, nbStripesPerBlock);
        acc = f_scramble(acc, view(secret, secret.byteLength - STRIPE_LEN));
      }
      {
        const nbStripes = Math.floor((data.byteLength - 1 - block_len * nb_blocks) / STRIPE_LEN);
        acc = XXH3_accumulate(acc, view(data, nb_blocks * block_len), secret, nbStripes);
        acc = f_acc(acc, view(data, data.byteLength - STRIPE_LEN), view(secret, secret.byteLength - STRIPE_LEN - 7));
      }
      return acc;
    }
    function XXH3_hashLong_128b(data, secret) {
      let acc = new BigUint64Array([
        PRIME32_3,
        PRIME64_1,
        PRIME64_2,
        PRIME64_3,
        PRIME64_4,
        PRIME32_2,
        PRIME64_5,
        PRIME32_1
      ]);
      assert(data.byteLength > 128);
      acc = XXH3_hashLong(acc, data, secret, XXH3_accumulate_512, XXH3_scrambleAcc);
      assert(acc.length * 8 === 64);
      {
        const low64 = XXH3_mergeAccs(acc, view(secret, 11), n(data.byteLength) * PRIME64_1 & mask64);
        const high64 = XXH3_mergeAccs(acc, view(secret, secret.byteLength - STRIPE_LEN - 11), ~(n(data.byteLength) * PRIME64_2) & mask64);
        return high64 << n(64) | low64;
      }
    }
    function XXH3_mul128_fold64(a, b) {
      const lll = a * b & mask128;
      return lll & mask64 ^ lll >> n(64);
    }
    function XXH3_mix16B(dataView, keyView, seed) {
      return XXH3_mul128_fold64((dataView.getBigUint64(0, true) ^ keyView.getBigUint64(0, true) + seed) & mask64, (dataView.getBigUint64(8, true) ^ keyView.getBigUint64(8, true) - seed) & mask64);
    }
    function XXH3_mix32B(acc, data1, data2, key, seed) {
      let accl = acc & mask64;
      let acch = acc >> n(64) & mask64;
      accl += XXH3_mix16B(data1, key, seed);
      accl ^= data2.getBigUint64(0, true) + data2.getBigUint64(8, true);
      accl &= mask64;
      acch += XXH3_mix16B(data2, view(key, 16), seed);
      acch ^= data1.getBigUint64(0, true) + data1.getBigUint64(8, true);
      acch &= mask64;
      return acch << n(64) | accl;
    }
    function XXH3_avalanche(input) {
      let h64 = input;
      h64 ^= h64 >> n(37);
      h64 *= PRIME_MX1;
      h64 &= mask64;
      h64 ^= h64 >> n(32);
      return h64;
    }
    function XXH3_avalanche64(input) {
      let h64 = input;
      h64 ^= h64 >> n(33);
      h64 *= PRIME64_2;
      h64 &= mask64;
      h64 ^= h64 >> n(29);
      h64 *= PRIME64_3;
      h64 &= mask64;
      h64 ^= h64 >> n(32);
      return h64;
    }
    function XXH3_len_1to3_128b(data, key32, seed) {
      const len = data.byteLength;
      assert(len > 0 && len <= 3);
      const combined = n(data.getUint8(len - 1)) | n(len << 8) | n(data.getUint8(0) << 16) | n(data.getUint8(len >> 1) << 24);
      const blow = (n(key32.getUint32(0, true)) ^ n(key32.getUint32(4, true))) + seed;
      const low = (combined ^ blow) & mask64;
      const bhigh = (n(key32.getUint32(8, true)) ^ n(key32.getUint32(12, true))) - seed;
      const high = (rotl32(bswap32(combined), n(13)) ^ bhigh) & mask64;
      return (XXH3_avalanche64(high) & mask64) << n(64) | XXH3_avalanche64(low);
    }
    function xorshift64(b, shift) {
      return b ^ b >> shift;
    }
    function XXH3_len_4to8_128b(data, key32, seed) {
      const len = data.byteLength;
      assert(len >= 4 && len <= 8);
      {
        const l1 = data.getUint32(0, true);
        const l2 = data.getUint32(len - 4, true);
        const l64 = n(l1) | n(l2) << n(32);
        const bitflip = (key32.getBigUint64(16, true) ^ key32.getBigUint64(24, true)) + seed & mask64;
        const keyed = l64 ^ bitflip;
        let m128 = keyed * (PRIME64_1 + (n(len) << n(2))) & mask128;
        m128 += (m128 & mask64) << n(65);
        m128 &= mask128;
        m128 ^= m128 >> n(67);
        return xorshift64(xorshift64(m128 & mask64, n(35)) * PRIME_MX2 & mask64, n(28)) | XXH3_avalanche(m128 >> n(64)) << n(64);
      }
    }
    function XXH3_len_9to16_128b(data, key64, seed) {
      const len = data.byteLength;
      assert(len >= 9 && len <= 16);
      {
        const bitflipl = (key64.getBigUint64(32, true) ^ key64.getBigUint64(40, true)) + seed & mask64;
        const bitfliph = (key64.getBigUint64(48, true) ^ key64.getBigUint64(56, true)) - seed & mask64;
        const ll1 = data.getBigUint64(0, true);
        let ll2 = data.getBigUint64(len - 8, true);
        let m128 = (ll1 ^ ll2 ^ bitflipl) * PRIME64_1;
        const m128_l = (m128 & mask64) + (n(len - 1) << n(54));
        m128 = m128 & (mask128 ^ mask64) | m128_l;
        ll2 ^= bitfliph;
        m128 += ll2 + (ll2 & mask32) * (PRIME32_2 - n(1)) << n(64);
        m128 &= mask128;
        m128 ^= bswap64(m128 >> n(64));
        let h128 = (m128 & mask64) * PRIME64_2;
        h128 += (m128 >> n(64)) * PRIME64_2 << n(64);
        h128 &= mask128;
        return XXH3_avalanche(h128 & mask64) | XXH3_avalanche(h128 >> n(64)) << n(64);
      }
    }
    function XXH3_len_0to16_128b(data, seed) {
      const len = data.byteLength;
      assert(len <= 16);
      if (len > 8) return XXH3_len_9to16_128b(data, kkey, seed);
      if (len >= 4) return XXH3_len_4to8_128b(data, kkey, seed);
      if (len > 0) return XXH3_len_1to3_128b(data, kkey, seed);
      return XXH3_avalanche64(seed ^ kkey.getBigUint64(64, true) ^ kkey.getBigUint64(72, true)) | XXH3_avalanche64(seed ^ kkey.getBigUint64(80, true) ^ kkey.getBigUint64(88, true)) << n(64);
    }
    function inv64(x) {
      return ~x + n(1) & mask64;
    }
    function XXH3_len_17to128_128b(data, secret, seed) {
      let acc = n(data.byteLength) * PRIME64_1 & mask64;
      let i = n(data.byteLength - 1) / n(32);
      while (i >= 0) {
        const ni = Number(i);
        acc = XXH3_mix32B(acc, view(data, 16 * ni), view(data, data.byteLength - 16 * (ni + 1)), view(secret, 32 * ni), seed);
        i -= n(1);
      }
      let h128l = acc + (acc >> n(64)) & mask64;
      h128l = XXH3_avalanche(h128l);
      let h128h = (acc & mask64) * PRIME64_1 + (acc >> n(64)) * PRIME64_4 + (n(data.byteLength) - seed & mask64) * PRIME64_2;
      h128h &= mask64;
      h128h = inv64(XXH3_avalanche(h128h));
      return h128l | h128h << n(64);
    }
    function XXH3_len_129to240_128b(data, secret, seed) {
      let acc = n(data.byteLength) * PRIME64_1 & mask64;
      for (let i = 32; i < 160; i += 32) acc = XXH3_mix32B(acc, view(data, i - 32), view(data, i - 16), view(secret, i - 32), seed);
      acc = XXH3_avalanche(acc & mask64) | XXH3_avalanche(acc >> n(64)) << n(64);
      for (let i = 160; i <= data.byteLength; i += 32) acc = XXH3_mix32B(acc, view(data, i - 32), view(data, i - 16), view(secret, 3 + i - 160), seed);
      acc = XXH3_mix32B(acc, view(data, data.byteLength - 16), view(data, data.byteLength - 32), view(secret, 103), inv64(seed));
      let h128l = acc + (acc >> n(64)) & mask64;
      h128l = XXH3_avalanche(h128l);
      let h128h = (acc & mask64) * PRIME64_1 + (acc >> n(64)) * PRIME64_4 + (n(data.byteLength) - seed & mask64) * PRIME64_2;
      h128h &= mask64;
      h128h = inv64(XXH3_avalanche(h128h));
      return h128l | h128h << n(64);
    }
    function XXH3(input, seed = n(0)) {
      const encoder = new TextEncoder();
      const data = view(typeof input === "string" ? encoder.encode(input) : input);
      const len = data.byteLength;
      const hexDigest = (data$1) => data$1.toString(16).padStart(32, "0");
      if (len <= 16) return hexDigest(XXH3_len_0to16_128b(data, seed));
      if (len <= 128) return hexDigest(XXH3_len_17to128_128b(data, kkey, seed));
      if (len <= 240) return hexDigest(XXH3_len_129to240_128b(data, kkey, seed));
      return hexDigest(XXH3_hashLong_128b(data, kkey));
    }
    function isXXH3(value) {
      return /^[0-9a-f]{32}$/.test(value);
    }
    exports2.XXH3 = XXH3;
    exports2.isXXH3 = isXXH3;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/interrupt.cjs
var require_interrupt = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/interrupt.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime3();
    var require_errors10 = require_errors5();
    var require_constants5 = require_constants4();
    var require_hash4 = require_hash3();
    var __langchain_core_singletons = require_rolldown_runtime5.__toESM(require_singletons());
    function interrupt(value) {
      const config = __langchain_core_singletons.AsyncLocalStorageProviderSingleton.getRunnableConfig();
      if (!config) throw new Error("Called interrupt() outside the context of a graph.");
      const conf = config.configurable;
      if (!conf) throw new Error("No configurable found in config");
      const checkpointer = conf[require_constants5.CONFIG_KEY_CHECKPOINTER];
      if (!checkpointer) throw new require_errors10.GraphValueError("No checkpointer set", { lc_error_code: "MISSING_CHECKPOINTER" });
      const scratchpad = conf[require_constants5.CONFIG_KEY_SCRATCHPAD];
      scratchpad.interruptCounter += 1;
      const idx = scratchpad.interruptCounter;
      if (scratchpad.resume.length > 0 && idx < scratchpad.resume.length) {
        conf[require_constants5.CONFIG_KEY_SEND]?.([[require_constants5.RESUME, scratchpad.resume]]);
        return scratchpad.resume[idx];
      }
      if (scratchpad.nullResume !== void 0) {
        if (scratchpad.resume.length !== idx) throw new Error(`Resume length mismatch: ${scratchpad.resume.length} !== ${idx}`);
        const v = scratchpad.consumeNullResume();
        scratchpad.resume.push(v);
        conf[require_constants5.CONFIG_KEY_SEND]?.([[require_constants5.RESUME, scratchpad.resume]]);
        return v;
      }
      const ns = conf[require_constants5.CONFIG_KEY_CHECKPOINT_NS]?.split(require_constants5.CHECKPOINT_NAMESPACE_SEPARATOR);
      const id = ns ? require_hash4.XXH3(ns.join(require_constants5.CHECKPOINT_NAMESPACE_SEPARATOR)) : void 0;
      throw new require_errors10.GraphInterrupt([{
        id,
        value
      }]);
    }
    exports2.interrupt = interrupt;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/utils.cjs
var require_utils8 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/utils.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime3();
    var require_config3 = require_config2();
    var __langchain_core_singletons = require_rolldown_runtime5.__toESM(require_singletons());
    var __langchain_core_runnables = require_rolldown_runtime5.__toESM(require_runnables());
    var RunnableCallable = class extends __langchain_core_runnables.Runnable {
      lc_namespace = ["langgraph"];
      func;
      tags;
      config;
      trace = true;
      recurse = true;
      constructor(fields) {
        super();
        this.name = fields.name ?? fields.func.name;
        this.func = fields.func;
        this.config = fields.tags ? { tags: fields.tags } : void 0;
        this.trace = fields.trace ?? this.trace;
        this.recurse = fields.recurse ?? this.recurse;
      }
      async _tracedInvoke(input, config, runManager) {
        return new Promise((resolve, reject) => {
          const childConfig = (0, __langchain_core_runnables.patchConfig)(config, { callbacks: runManager?.getChild() });
          __langchain_core_singletons.AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {
            try {
              const output = await this.func(input, childConfig);
              resolve(output);
            } catch (e) {
              reject(e);
            }
          });
        });
      }
      async invoke(input, options) {
        let returnValue;
        const config = require_config3.ensureLangGraphConfig(options);
        const mergedConfig = (0, __langchain_core_runnables.mergeConfigs)(this.config, config);
        if (this.trace) returnValue = await this._callWithConfig(this._tracedInvoke, input, mergedConfig);
        else returnValue = await __langchain_core_singletons.AsyncLocalStorageProviderSingleton.runWithConfig(mergedConfig, async () => this.func(input, mergedConfig));
        if (__langchain_core_runnables.Runnable.isRunnable(returnValue) && this.recurse) return await __langchain_core_singletons.AsyncLocalStorageProviderSingleton.runWithConfig(mergedConfig, async () => returnValue.invoke(input, mergedConfig));
        return returnValue;
      }
    };
    function* prefixGenerator(generator, prefix) {
      if (prefix === void 0) yield* generator;
      else for (const value of generator) yield [prefix, value];
    }
    async function gatherIterator(i) {
      const out = [];
      for await (const item of await i) out.push(item);
      return out;
    }
    function gatherIteratorSync(i) {
      const out = [];
      for (const item of i) out.push(item);
      return out;
    }
    function patchConfigurable(config, patch) {
      if (!config) return { configurable: patch };
      else if (!("configurable" in config)) return {
        ...config,
        configurable: patch
      };
      else return {
        ...config,
        configurable: {
          ...config.configurable,
          ...patch
        }
      };
    }
    function isAsyncGeneratorFunction(val) {
      return val != null && typeof val === "function" && val instanceof Object.getPrototypeOf(async function* () {
      }).constructor;
    }
    function isGeneratorFunction(val) {
      return val != null && typeof val === "function" && val instanceof Object.getPrototypeOf(function* () {
      }).constructor;
    }
    exports2.RunnableCallable = RunnableCallable;
    exports2.gatherIterator = gatherIterator;
    exports2.gatherIteratorSync = gatherIteratorSync;
    exports2.isAsyncGeneratorFunction = isAsyncGeneratorFunction;
    exports2.isGeneratorFunction = isGeneratorFunction;
    exports2.patchConfigurable = patchConfigurable;
    exports2.prefixGenerator = prefixGenerator;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/write.cjs
var require_write = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/write.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime3();
    var require_errors10 = require_errors5();
    var require_constants5 = require_constants4();
    var require_utils10 = require_utils8();
    var __langchain_core_runnables = require_rolldown_runtime5.__toESM(require_runnables());
    var SKIP_WRITE = { [Symbol.for("LG_SKIP_WRITE")]: true };
    function _isSkipWrite(x) {
      return typeof x === "object" && x?.[Symbol.for("LG_SKIP_WRITE")] !== void 0;
    }
    var PASSTHROUGH = { [Symbol.for("LG_PASSTHROUGH")]: true };
    function _isPassthrough(x) {
      return typeof x === "object" && x?.[Symbol.for("LG_PASSTHROUGH")] !== void 0;
    }
    var IS_WRITER = Symbol("IS_WRITER");
    var ChannelWrite = class ChannelWrite2 extends require_utils10.RunnableCallable {
      writes;
      constructor(writes, tags) {
        const name = `ChannelWrite<${writes.map((packet) => {
          if (require_constants5._isSend(packet)) return packet.node;
          else if ("channel" in packet) return packet.channel;
          return "...";
        }).join(",")}>`;
        super({
          writes,
          name,
          tags,
          func: async (input, config) => {
            return this._write(input, config ?? {});
          }
        });
        this.writes = writes;
      }
      async _write(input, config) {
        const writes = this.writes.map((write) => {
          if (_isChannelWriteTupleEntry(write) && _isPassthrough(write.value)) return {
            mapper: write.mapper,
            value: input
          };
          else if (_isChannelWriteEntry(write) && _isPassthrough(write.value)) return {
            channel: write.channel,
            value: input,
            skipNone: write.skipNone,
            mapper: write.mapper
          };
          else return write;
        });
        await ChannelWrite2.doWrite(config, writes);
        return input;
      }
      static async doWrite(config, writes) {
        for (const w of writes) {
          if (_isChannelWriteEntry(w)) {
            if (w.channel === require_constants5.TASKS) throw new require_errors10.InvalidUpdateError("Cannot write to the reserved channel TASKS");
            if (_isPassthrough(w.value)) throw new require_errors10.InvalidUpdateError("PASSTHROUGH value must be replaced");
          }
          if (_isChannelWriteTupleEntry(w)) {
            if (_isPassthrough(w.value)) throw new require_errors10.InvalidUpdateError("PASSTHROUGH value must be replaced");
          }
        }
        const writeEntries = [];
        for (const w of writes) if (require_constants5._isSend(w)) writeEntries.push([require_constants5.TASKS, w]);
        else if (_isChannelWriteTupleEntry(w)) {
          const mappedResult = await w.mapper.invoke(w.value, config);
          if (mappedResult != null && mappedResult.length > 0) writeEntries.push(...mappedResult);
        } else if (_isChannelWriteEntry(w)) {
          const mappedValue = w.mapper !== void 0 ? await w.mapper.invoke(w.value, config) : w.value;
          if (_isSkipWrite(mappedValue)) continue;
          if (w.skipNone && mappedValue === void 0) continue;
          writeEntries.push([w.channel, mappedValue]);
        } else throw new Error(`Invalid write entry: ${JSON.stringify(w)}`);
        const write = config.configurable?.[require_constants5.CONFIG_KEY_SEND];
        write(writeEntries);
      }
      static isWriter(runnable) {
        return runnable instanceof ChannelWrite2 || IS_WRITER in runnable && !!runnable[IS_WRITER];
      }
      static registerWriter(runnable) {
        return Object.defineProperty(runnable, IS_WRITER, { value: true });
      }
    };
    function _isChannelWriteEntry(x) {
      return x !== void 0 && typeof x.channel === "string";
    }
    function _isChannelWriteTupleEntry(x) {
      return x !== void 0 && !_isChannelWriteEntry(x) && __langchain_core_runnables.Runnable.isRunnable(x.mapper);
    }
    exports2.ChannelWrite = ChannelWrite;
    exports2.PASSTHROUGH = PASSTHROUGH;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/read.cjs
var require_read = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/read.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime3();
    var require_constants5 = require_constants4();
    var require_utils10 = require_utils8();
    var require_write2 = require_write();
    var __langchain_core_runnables = require_rolldown_runtime5.__toESM(require_runnables());
    var ChannelRead = class ChannelRead2 extends require_utils10.RunnableCallable {
      lc_graph_name = "ChannelRead";
      channel;
      fresh = false;
      mapper;
      constructor(channel2, mapper, fresh = false) {
        super({ func: (_, config) => ChannelRead2.doRead(config, this.channel, this.fresh, this.mapper) });
        this.fresh = fresh;
        this.mapper = mapper;
        this.channel = channel2;
        this.name = Array.isArray(channel2) ? `ChannelRead<${channel2.join(",")}>` : `ChannelRead<${channel2}>`;
      }
      static doRead(config, channel2, fresh, mapper) {
        const read = config.configurable?.[require_constants5.CONFIG_KEY_READ];
        if (!read) throw new Error("Runnable is not configured with a read function. Make sure to call in the context of a Pregel process");
        if (mapper) return mapper(read(channel2, fresh));
        else return read(channel2, fresh);
      }
    };
    var defaultRunnableBound = /* @__PURE__ */ new __langchain_core_runnables.RunnablePassthrough();
    var PregelNode = class PregelNode2 extends __langchain_core_runnables.RunnableBinding {
      lc_graph_name = "PregelNode";
      channels;
      triggers = [];
      mapper;
      writers = [];
      bound = defaultRunnableBound;
      kwargs = {};
      metadata = {};
      tags = [];
      retryPolicy;
      cachePolicy;
      subgraphs;
      ends;
      constructor(fields) {
        const { channels, triggers, mapper, writers, bound, kwargs, metadata, retryPolicy, cachePolicy, tags, subgraphs, ends } = fields;
        const mergedTags = [...fields.config?.tags ? fields.config.tags : [], ...tags ?? []];
        super({
          ...fields,
          bound: fields.bound ?? defaultRunnableBound,
          config: {
            ...fields.config ? fields.config : {},
            tags: mergedTags
          }
        });
        this.channels = channels;
        this.triggers = triggers;
        this.mapper = mapper;
        this.writers = writers ?? this.writers;
        this.bound = bound ?? this.bound;
        this.kwargs = kwargs ?? this.kwargs;
        this.metadata = metadata ?? this.metadata;
        this.tags = mergedTags;
        this.retryPolicy = retryPolicy;
        this.cachePolicy = cachePolicy;
        this.subgraphs = subgraphs;
        this.ends = ends;
      }
      getWriters() {
        const newWriters = [...this.writers];
        while (newWriters.length > 1 && newWriters[newWriters.length - 1] instanceof require_write2.ChannelWrite && newWriters[newWriters.length - 2] instanceof require_write2.ChannelWrite) {
          const endWriters = newWriters.slice(-2);
          const combinedWrites = endWriters[0].writes.concat(endWriters[1].writes);
          newWriters[newWriters.length - 2] = new require_write2.ChannelWrite(combinedWrites, endWriters[0].config?.tags);
          newWriters.pop();
        }
        return newWriters;
      }
      getNode() {
        const writers = this.getWriters();
        if (this.bound === defaultRunnableBound && writers.length === 0) return void 0;
        else if (this.bound === defaultRunnableBound && writers.length === 1) return writers[0];
        else if (this.bound === defaultRunnableBound) return new __langchain_core_runnables.RunnableSequence({
          first: writers[0],
          middle: writers.slice(1, writers.length - 1),
          last: writers[writers.length - 1],
          omitSequenceTags: true
        });
        else if (writers.length > 0) return new __langchain_core_runnables.RunnableSequence({
          first: this.bound,
          middle: writers.slice(0, writers.length - 1),
          last: writers[writers.length - 1],
          omitSequenceTags: true
        });
        else return this.bound;
      }
      join(channels) {
        if (!Array.isArray(channels)) throw new Error("channels must be a list");
        if (typeof this.channels !== "object") throw new Error("all channels must be named when using .join()");
        return new PregelNode2({
          channels: {
            ...this.channels,
            ...Object.fromEntries(channels.map((chan) => [chan, chan]))
          },
          triggers: this.triggers,
          mapper: this.mapper,
          writers: this.writers,
          bound: this.bound,
          kwargs: this.kwargs,
          config: this.config,
          retryPolicy: this.retryPolicy,
          cachePolicy: this.cachePolicy
        });
      }
      pipe(coerceable) {
        if (require_write2.ChannelWrite.isWriter(coerceable)) return new PregelNode2({
          channels: this.channels,
          triggers: this.triggers,
          mapper: this.mapper,
          writers: [...this.writers, coerceable],
          bound: this.bound,
          config: this.config,
          kwargs: this.kwargs,
          retryPolicy: this.retryPolicy,
          cachePolicy: this.cachePolicy
        });
        else if (this.bound === defaultRunnableBound) return new PregelNode2({
          channels: this.channels,
          triggers: this.triggers,
          mapper: this.mapper,
          writers: this.writers,
          bound: (0, __langchain_core_runnables._coerceToRunnable)(coerceable),
          config: this.config,
          kwargs: this.kwargs,
          retryPolicy: this.retryPolicy,
          cachePolicy: this.cachePolicy
        });
        else return new PregelNode2({
          channels: this.channels,
          triggers: this.triggers,
          mapper: this.mapper,
          writers: this.writers,
          bound: this.bound.pipe(coerceable),
          config: this.config,
          kwargs: this.kwargs,
          retryPolicy: this.retryPolicy,
          cachePolicy: this.cachePolicy
        });
      }
    };
    exports2.ChannelRead = ChannelRead;
    exports2.PregelNode = PregelNode;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/utils/subgraph.cjs
var require_subgraph = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/utils/subgraph.cjs"(exports2) {
    function isRunnableSequence(x) {
      return "steps" in x && Array.isArray(x.steps);
    }
    function isPregelLike(x) {
      return "lg_is_pregel" in x && x.lg_is_pregel === true;
    }
    function findSubgraphPregel(candidate) {
      const candidates = [candidate];
      for (const candidate$1 of candidates) if (isPregelLike(candidate$1)) return candidate$1;
      else if (isRunnableSequence(candidate$1)) candidates.push(...candidate$1.steps);
      return void 0;
    }
    exports2.findSubgraphPregel = findSubgraphPregel;
    exports2.isPregelLike = isPregelLike;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/io.cjs
var require_io = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/io.cjs"(exports2) {
    var require_errors10 = require_errors5();
    var require_constants5 = require_constants4();
    var require_hash4 = require_hash3();
    function readChannel(channels, chan, catchErrors = true, returnException = false) {
      try {
        return channels[chan].get();
      } catch (e) {
        if (e.name === require_errors10.EmptyChannelError.unminifiable_name) {
          if (returnException) return e;
          else if (catchErrors) return null;
        }
        throw e;
      }
    }
    function readChannels(channels, select, skipEmpty = true) {
      if (Array.isArray(select)) {
        const values = {};
        for (const k of select) try {
          values[k] = readChannel(channels, k, !skipEmpty);
        } catch (e) {
          if (e.name === require_errors10.EmptyChannelError.unminifiable_name) continue;
        }
        return values;
      } else return readChannel(channels, select);
    }
    function* mapCommand(cmd, pendingWrites) {
      if (cmd.graph === require_constants5.Command.PARENT) throw new require_errors10.InvalidUpdateError("There is no parent graph.");
      if (cmd.goto) {
        let sends;
        if (Array.isArray(cmd.goto)) sends = cmd.goto;
        else sends = [cmd.goto];
        for (const send of sends) if (require_constants5._isSend(send)) yield [
          require_constants5.NULL_TASK_ID,
          require_constants5.TASKS,
          send
        ];
        else if (typeof send === "string") yield [
          require_constants5.NULL_TASK_ID,
          `branch:to:${send}`,
          "__start__"
        ];
        else throw new Error(`In Command.send, expected Send or string, got ${typeof send}`);
      }
      if (cmd.resume) if (typeof cmd.resume === "object" && Object.keys(cmd.resume).length && Object.keys(cmd.resume).every(require_hash4.isXXH3)) for (const [tid, resume] of Object.entries(cmd.resume)) {
        const existing = pendingWrites.filter((w) => w[0] === tid && w[1] === require_constants5.RESUME).map((w) => w[2]).slice(0, 1) ?? [];
        existing.push(resume);
        yield [
          tid,
          require_constants5.RESUME,
          existing
        ];
      }
      else yield [
        require_constants5.NULL_TASK_ID,
        require_constants5.RESUME,
        cmd.resume
      ];
      if (cmd.update) {
        if (typeof cmd.update !== "object" || !cmd.update) throw new Error("Expected cmd.update to be a dict mapping channel names to update values");
        if (Array.isArray(cmd.update)) for (const [k, v] of cmd.update) yield [
          require_constants5.NULL_TASK_ID,
          k,
          v
        ];
        else for (const [k, v] of Object.entries(cmd.update)) yield [
          require_constants5.NULL_TASK_ID,
          k,
          v
        ];
      }
    }
    function* mapInput(inputChannels, chunk) {
      if (chunk !== void 0 && chunk !== null) if (Array.isArray(inputChannels) && typeof chunk === "object" && !Array.isArray(chunk)) {
        for (const k in chunk) if (inputChannels.includes(k)) yield [k, chunk[k]];
      } else if (Array.isArray(inputChannels)) throw new Error(`Input chunk must be an object when "inputChannels" is an array`);
      else yield [inputChannels, chunk];
    }
    function* mapOutputValues(outputChannels, pendingWrites, channels) {
      if (Array.isArray(outputChannels)) {
        if (pendingWrites === true || pendingWrites.find(([chan, _]) => outputChannels.includes(chan))) yield readChannels(channels, outputChannels);
      } else if (pendingWrites === true || pendingWrites.some(([chan, _]) => chan === outputChannels)) yield readChannel(channels, outputChannels);
    }
    function* mapOutputUpdates(outputChannels, tasks, cached) {
      const outputTasks = tasks.filter(([task, ww]) => {
        return (task.config === void 0 || !task.config.tags?.includes(require_constants5.TAG_HIDDEN)) && ww[0][0] !== require_constants5.ERROR && ww[0][0] !== require_constants5.INTERRUPT;
      });
      if (!outputTasks.length) return;
      let updated;
      if (outputTasks.some(([task]) => task.writes.some(([chan, _]) => chan === require_constants5.RETURN))) updated = outputTasks.flatMap(([task]) => task.writes.filter(([chan, _]) => chan === require_constants5.RETURN).map(([_, value]) => [task.name, value]));
      else if (!Array.isArray(outputChannels)) updated = outputTasks.flatMap(([task]) => task.writes.filter(([chan, _]) => chan === outputChannels).map(([_, value]) => [task.name, value]));
      else updated = outputTasks.flatMap(([task]) => {
        const { writes } = task;
        const counts = {};
        for (const [chan] of writes) if (outputChannels.includes(chan)) counts[chan] = (counts[chan] || 0) + 1;
        if (Object.values(counts).some((count) => count > 1)) return writes.filter(([chan]) => outputChannels.includes(chan)).map(([chan, value]) => [task.name, { [chan]: value }]);
        else return [[task.name, Object.fromEntries(writes.filter(([chan]) => outputChannels.includes(chan)))]];
      });
      const grouped = {};
      for (const [node, value] of updated) {
        if (!(node in grouped)) grouped[node] = [];
        grouped[node].push(value);
      }
      const flattened = {};
      for (const node in grouped) if (grouped[node].length === 1) {
        const [write] = grouped[node];
        flattened[node] = write;
      } else flattened[node] = grouped[node];
      if (cached) flattened["__metadata__"] = { cached };
      yield flattened;
    }
    exports2.mapCommand = mapCommand;
    exports2.mapInput = mapInput;
    exports2.mapOutputUpdates = mapOutputUpdates;
    exports2.mapOutputValues = mapOutputValues;
    exports2.readChannel = readChannel;
    exports2.readChannels = readChannels;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/utils/index.cjs
var require_utils9 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/utils/index.cjs"(exports2) {
    var require_constants5 = require_constants4();
    function getNullChannelVersion(currentVersions) {
      const startVersion = typeof currentVersions[require_constants5.START];
      if (startVersion === "number") return 0;
      if (startVersion === "string") return "";
      for (const key in currentVersions) {
        if (!Object.prototype.hasOwnProperty.call(currentVersions, key)) continue;
        const versionType = typeof currentVersions[key];
        if (versionType === "number") return 0;
        if (versionType === "string") return "";
        break;
      }
      return void 0;
    }
    function getNewChannelVersions(previousVersions, currentVersions) {
      if (Object.keys(previousVersions).length > 0) {
        const nullVersion = getNullChannelVersion(currentVersions);
        return Object.fromEntries(Object.entries(currentVersions).filter(([k, v]) => v > (previousVersions[k] ?? nullVersion)));
      } else return currentVersions;
    }
    function _coerceToDict(value, defaultKey) {
      return value && !Array.isArray(value) && !(value instanceof Date) && typeof value === "object" ? value : { [defaultKey]: value };
    }
    function patchConfigurable(config, patch) {
      if (config === null) return { configurable: patch };
      else if (config?.configurable === void 0) return {
        ...config,
        configurable: patch
      };
      else return {
        ...config,
        configurable: {
          ...config.configurable,
          ...patch
        }
      };
    }
    function patchCheckpointMap(config, metadata) {
      const parents = metadata?.parents ?? {};
      if (Object.keys(parents).length > 0) return patchConfigurable(config, { [require_constants5.CONFIG_KEY_CHECKPOINT_MAP]: {
        ...parents,
        [config.configurable?.checkpoint_ns ?? ""]: config.configurable?.checkpoint_id
      } });
      else return config;
    }
    function combineAbortSignals(...x) {
      const signals = [...new Set(x.filter(Boolean))];
      if (signals.length === 0) return {
        signal: void 0,
        dispose: void 0
      };
      if (signals.length === 1) return {
        signal: signals[0],
        dispose: void 0
      };
      const combinedController = new AbortController();
      const listener = () => {
        const reason = signals.find((s) => s.aborted)?.reason;
        combinedController.abort(reason);
        signals.forEach((s) => s.removeEventListener("abort", listener));
      };
      signals.forEach((s) => s.addEventListener("abort", listener, { once: true }));
      const hasAlreadyAbortedSignal = signals.find((s) => s.aborted);
      if (hasAlreadyAbortedSignal) combinedController.abort(hasAlreadyAbortedSignal.reason);
      return {
        signal: combinedController.signal,
        dispose: () => {
          signals.forEach((s) => s.removeEventListener("abort", listener));
        }
      };
    }
    var combineCallbacks = (callback1, callback2) => {
      if (!callback1 && !callback2) return void 0;
      if (!callback1) return callback2;
      if (!callback2) return callback1;
      if (Array.isArray(callback1) && Array.isArray(callback2)) return [...callback1, ...callback2];
      if (Array.isArray(callback1)) return [...callback1, callback2];
      if (Array.isArray(callback2)) return [callback1, ...callback2];
      return [callback1, callback2];
    };
    exports2._coerceToDict = _coerceToDict;
    exports2.combineAbortSignals = combineAbortSignals;
    exports2.combineCallbacks = combineCallbacks;
    exports2.getNewChannelVersions = getNewChannelVersions;
    exports2.getNullChannelVersion = getNullChannelVersion;
    exports2.patchCheckpointMap = patchCheckpointMap;
    exports2.patchConfigurable = patchConfigurable;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/types.cjs
var require_types7 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/types.cjs"(exports2) {
    var Call = class {
      func;
      name;
      input;
      retry;
      cache;
      callbacks;
      __lg_type = "call";
      constructor({ func, name, input, retry, cache, callbacks }) {
        this.func = func;
        this.name = name;
        this.input = input;
        this.retry = retry;
        this.cache = cache;
        this.callbacks = callbacks;
      }
    };
    function isCall(value) {
      return typeof value === "object" && value !== null && "__lg_type" in value && value.__lg_type === "call";
    }
    exports2.Call = Call;
    exports2.isCall = isCall;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/call.cjs
var require_call = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/call.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime3();
    var require_constants5 = require_constants4();
    var require_utils10 = require_utils8();
    var require_write2 = require_write();
    var __langchain_core_singletons = require_rolldown_runtime5.__toESM(require_singletons());
    var __langchain_core_runnables = require_rolldown_runtime5.__toESM(require_runnables());
    function getRunnableForFunc(name, func) {
      const run = new require_utils10.RunnableCallable({
        func: (input) => func(...input),
        name,
        trace: false,
        recurse: false
      });
      return new __langchain_core_runnables.RunnableSequence({
        name,
        first: run,
        last: new require_write2.ChannelWrite([{
          channel: require_constants5.RETURN,
          value: require_write2.PASSTHROUGH
        }], [require_constants5.TAG_HIDDEN])
      });
    }
    function getRunnableForEntrypoint(name, func) {
      const run = new require_utils10.RunnableCallable({
        func: (input, config) => {
          return func(input, config);
        },
        name,
        trace: false,
        recurse: false
      });
      return run;
    }
    function call({ func, name, cache, retry }, ...args) {
      const config = __langchain_core_singletons.AsyncLocalStorageProviderSingleton.getRunnableConfig();
      if (typeof config.configurable?.[require_constants5.CONFIG_KEY_CALL] === "function") return config.configurable[require_constants5.CONFIG_KEY_CALL](func, name, args, {
        retry,
        cache,
        callbacks: config.callbacks
      });
      throw new Error("Async local storage not initialized. Please call initializeAsyncLocalStorageSingleton() before using this function.");
    }
    exports2.call = call;
    exports2.getRunnableForEntrypoint = getRunnableForEntrypoint;
    exports2.getRunnableForFunc = getRunnableForFunc;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/algo.cjs
var require_algo = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/algo.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime3();
    var require_errors10 = require_errors5();
    var require_base18 = require_base17();
    var require_constants5 = require_constants4();
    var require_hash4 = require_hash3();
    var require_io2 = require_io();
    var require_types10 = require_types7();
    var require_index = require_utils9();
    var require_call2 = require_call();
    var __langchain_langgraph_checkpoint = require_rolldown_runtime5.__toESM(require_dist4());
    var __langchain_core_runnables = require_rolldown_runtime5.__toESM(require_runnables());
    var increment = (current) => {
      return current !== void 0 ? current + 1 : 1;
    };
    function triggersNextStep(updatedChannels, triggerToNodes) {
      if (triggerToNodes == null) return false;
      for (const chan of updatedChannels) if (triggerToNodes[chan]) return true;
      return false;
    }
    function maxChannelMapVersion(channelVersions) {
      let maxVersion;
      for (const chan in channelVersions) {
        if (!Object.prototype.hasOwnProperty.call(channelVersions, chan)) continue;
        if (maxVersion == null) maxVersion = channelVersions[chan];
        else maxVersion = (0, __langchain_langgraph_checkpoint.maxChannelVersion)(maxVersion, channelVersions[chan]);
      }
      return maxVersion;
    }
    function shouldInterrupt(checkpoint, interruptNodes, tasks) {
      const nullVersion = require_index.getNullChannelVersion(checkpoint.channel_versions);
      const seen = checkpoint.versions_seen[require_constants5.INTERRUPT] ?? {};
      let anyChannelUpdated = false;
      if ((checkpoint.channel_versions[require_constants5.START] ?? nullVersion) > (seen[require_constants5.START] ?? nullVersion)) anyChannelUpdated = true;
      else for (const chan in checkpoint.channel_versions) {
        if (!Object.prototype.hasOwnProperty.call(checkpoint.channel_versions, chan)) continue;
        if (checkpoint.channel_versions[chan] > (seen[chan] ?? nullVersion)) {
          anyChannelUpdated = true;
          break;
        }
      }
      const anyTriggeredNodeInInterruptNodes = tasks.some((task) => interruptNodes === "*" ? !task.config?.tags?.includes(require_constants5.TAG_HIDDEN) : interruptNodes.includes(task.name));
      return anyChannelUpdated && anyTriggeredNodeInInterruptNodes;
    }
    function _localRead(checkpoint, channels, task, select, fresh = false) {
      let updated = /* @__PURE__ */ new Set();
      if (!Array.isArray(select)) {
        for (const [c] of task.writes) if (c === select) {
          updated = /* @__PURE__ */ new Set([c]);
          break;
        }
        updated = updated || /* @__PURE__ */ new Set();
      } else updated = new Set(select.filter((c) => task.writes.some(([key, _]) => key === c)));
      let values;
      if (fresh && updated.size > 0) {
        const localChannels = Object.fromEntries(Object.entries(channels).filter(([k, _]) => updated.has(k)));
        const newCheckpoint = require_base18.createCheckpoint(checkpoint, localChannels, -1);
        const newChannels = require_base18.emptyChannels(localChannels, newCheckpoint);
        _applyWrites((0, __langchain_langgraph_checkpoint.copyCheckpoint)(newCheckpoint), newChannels, [task], void 0, void 0);
        values = require_io2.readChannels({
          ...channels,
          ...newChannels
        }, select);
      } else values = require_io2.readChannels(channels, select);
      return values;
    }
    function _localWrite(commit, processes, writes) {
      for (const [chan, value] of writes) if ([require_constants5.PUSH, require_constants5.TASKS].includes(chan) && value != null) {
        if (!require_constants5._isSend(value)) throw new require_errors10.InvalidUpdateError(`Invalid packet type, expected SendProtocol, got ${JSON.stringify(value)}`);
        if (!(value.node in processes)) throw new require_errors10.InvalidUpdateError(`Invalid node name "${value.node}" in Send packet`);
      }
      commit(writes);
    }
    var IGNORE = /* @__PURE__ */ new Set([
      require_constants5.NO_WRITES,
      require_constants5.PUSH,
      require_constants5.RESUME,
      require_constants5.INTERRUPT,
      require_constants5.RETURN,
      require_constants5.ERROR
    ]);
    function _applyWrites(checkpoint, channels, tasks, getNextVersion, triggerToNodes) {
      tasks.sort((a, b) => {
        const aPath = a.path?.slice(0, 3) || [];
        const bPath = b.path?.slice(0, 3) || [];
        for (let i = 0; i < Math.min(aPath.length, bPath.length); i += 1) {
          if (aPath[i] < bPath[i]) return -1;
          if (aPath[i] > bPath[i]) return 1;
        }
        return aPath.length - bPath.length;
      });
      const bumpStep = tasks.some((task) => task.triggers.length > 0);
      const onlyChannels = require_base18.getOnlyChannels(channels);
      for (const task of tasks) {
        checkpoint.versions_seen[task.name] ??= {};
        for (const chan of task.triggers) if (chan in checkpoint.channel_versions) checkpoint.versions_seen[task.name][chan] = checkpoint.channel_versions[chan];
      }
      let maxVersion = maxChannelMapVersion(checkpoint.channel_versions);
      const channelsToConsume = new Set(tasks.flatMap((task) => task.triggers).filter((chan) => !require_constants5.RESERVED.includes(chan)));
      let usedNewVersion = false;
      for (const chan of channelsToConsume) if (chan in onlyChannels && onlyChannels[chan].consume()) {
        if (getNextVersion !== void 0) {
          checkpoint.channel_versions[chan] = getNextVersion(maxVersion);
          usedNewVersion = true;
        }
      }
      const pendingWritesByChannel = {};
      for (const task of tasks) for (const [chan, val] of task.writes) if (IGNORE.has(chan)) {
      } else if (chan in onlyChannels) {
        pendingWritesByChannel[chan] ??= [];
        pendingWritesByChannel[chan].push(val);
      }
      if (maxVersion != null && getNextVersion != null) maxVersion = usedNewVersion ? getNextVersion(maxVersion) : maxVersion;
      const updatedChannels = /* @__PURE__ */ new Set();
      for (const [chan, vals] of Object.entries(pendingWritesByChannel)) if (chan in onlyChannels) {
        const channel2 = onlyChannels[chan];
        let updated;
        try {
          updated = channel2.update(vals);
        } catch (e) {
          if (e.name === require_errors10.InvalidUpdateError.unminifiable_name) {
            const wrappedError = new require_errors10.InvalidUpdateError(`Invalid update for channel "${chan}" with values ${JSON.stringify(vals)}: ${e.message}`);
            wrappedError.lc_error_code = e.lc_error_code;
            throw wrappedError;
          } else throw e;
        }
        if (updated && getNextVersion !== void 0) {
          checkpoint.channel_versions[chan] = getNextVersion(maxVersion);
          if (channel2.isAvailable()) updatedChannels.add(chan);
        }
      }
      if (bumpStep) for (const chan in onlyChannels) {
        if (!Object.prototype.hasOwnProperty.call(onlyChannels, chan)) continue;
        const channel2 = onlyChannels[chan];
        if (channel2.isAvailable() && !updatedChannels.has(chan)) {
          const updated = channel2.update([]);
          if (updated && getNextVersion !== void 0) {
            checkpoint.channel_versions[chan] = getNextVersion(maxVersion);
            if (channel2.isAvailable()) updatedChannels.add(chan);
          }
        }
      }
      if (bumpStep && !triggersNextStep(updatedChannels, triggerToNodes)) for (const chan in onlyChannels) {
        if (!Object.prototype.hasOwnProperty.call(onlyChannels, chan)) continue;
        const channel2 = onlyChannels[chan];
        if (channel2.finish() && getNextVersion !== void 0) {
          checkpoint.channel_versions[chan] = getNextVersion(maxVersion);
          if (channel2.isAvailable()) updatedChannels.add(chan);
        }
      }
      return updatedChannels;
    }
    function* candidateNodes(checkpoint, processes, extra) {
      if (extra.updatedChannels != null && extra.triggerToNodes != null) {
        const triggeredNodes = /* @__PURE__ */ new Set();
        for (const channel2 of extra.updatedChannels) {
          const nodeIds = extra.triggerToNodes[channel2];
          for (const id of nodeIds ?? []) triggeredNodes.add(id);
        }
        yield* [...triggeredNodes].sort();
        return;
      }
      const isEmptyChannelVersions = (() => {
        for (const chan in checkpoint.channel_versions) if (checkpoint.channel_versions[chan] !== null) return false;
        return true;
      })();
      if (isEmptyChannelVersions) return;
      for (const name in processes) {
        if (!Object.prototype.hasOwnProperty.call(processes, name)) continue;
        yield name;
      }
    }
    function _prepareNextTasks(checkpoint, pendingWrites, processes, channels, config, forExecution, extra) {
      const tasks = {};
      const tasksChannel = channels[require_constants5.TASKS];
      if (tasksChannel?.isAvailable()) {
        const len = tasksChannel.get().length;
        for (let i = 0; i < len; i += 1) {
          const task = _prepareSingleTask([require_constants5.PUSH, i], checkpoint, pendingWrites, processes, channels, config, forExecution, extra);
          if (task !== void 0) tasks[task.id] = task;
        }
      }
      for (const name of candidateNodes(checkpoint, processes, extra)) {
        const task = _prepareSingleTask([require_constants5.PULL, name], checkpoint, pendingWrites, processes, channels, config, forExecution, extra);
        if (task !== void 0) tasks[task.id] = task;
      }
      return tasks;
    }
    function _prepareSingleTask(taskPath, checkpoint, pendingWrites, processes, channels, config, forExecution, extra) {
      const { step, checkpointer, manager } = extra;
      const configurable = config.configurable ?? {};
      const parentNamespace = configurable.checkpoint_ns ?? "";
      if (taskPath[0] === require_constants5.PUSH && require_types10.isCall(taskPath[taskPath.length - 1])) {
        const call = taskPath[taskPath.length - 1];
        const proc = require_call2.getRunnableForFunc(call.name, call.func);
        const triggers = [require_constants5.PUSH];
        const checkpointNamespace = parentNamespace === "" ? call.name : `${parentNamespace}${require_constants5.CHECKPOINT_NAMESPACE_SEPARATOR}${call.name}`;
        const id = (0, __langchain_langgraph_checkpoint.uuid5)(JSON.stringify([
          checkpointNamespace,
          step.toString(),
          call.name,
          require_constants5.PUSH,
          taskPath[1],
          taskPath[2]
        ]), checkpoint.id);
        const taskCheckpointNamespace = `${checkpointNamespace}${require_constants5.CHECKPOINT_NAMESPACE_END}${id}`;
        const outputTaskPath = [...taskPath.slice(0, 3), true];
        const metadata = {
          langgraph_step: step,
          langgraph_node: call.name,
          langgraph_triggers: triggers,
          langgraph_path: outputTaskPath,
          langgraph_checkpoint_ns: taskCheckpointNamespace
        };
        if (forExecution) {
          const writes = [];
          const task = {
            name: call.name,
            input: call.input,
            proc,
            writes,
            config: (0, __langchain_core_runnables.patchConfig)((0, __langchain_core_runnables.mergeConfigs)(config, {
              metadata,
              store: extra.store ?? config.store
            }), {
              runName: call.name,
              callbacks: manager?.getChild(`graph:step:${step}`),
              configurable: {
                [require_constants5.CONFIG_KEY_TASK_ID]: id,
                [require_constants5.CONFIG_KEY_SEND]: (writes_) => _localWrite((items) => writes.push(...items), processes, writes_),
                [require_constants5.CONFIG_KEY_READ]: (select_, fresh_ = false) => _localRead(checkpoint, channels, {
                  name: call.name,
                  writes,
                  triggers,
                  path: outputTaskPath
                }, select_, fresh_),
                [require_constants5.CONFIG_KEY_CHECKPOINTER]: checkpointer ?? configurable[require_constants5.CONFIG_KEY_CHECKPOINTER],
                [require_constants5.CONFIG_KEY_CHECKPOINT_MAP]: {
                  ...configurable[require_constants5.CONFIG_KEY_CHECKPOINT_MAP],
                  [parentNamespace]: checkpoint.id
                },
                [require_constants5.CONFIG_KEY_SCRATCHPAD]: _scratchpad({
                  pendingWrites: pendingWrites ?? [],
                  taskId: id,
                  currentTaskInput: call.input,
                  resumeMap: config.configurable?.[require_constants5.CONFIG_KEY_RESUME_MAP],
                  namespaceHash: require_hash4.XXH3(taskCheckpointNamespace)
                }),
                [require_constants5.CONFIG_KEY_PREVIOUS_STATE]: checkpoint.channel_values[require_constants5.PREVIOUS],
                checkpoint_id: void 0,
                checkpoint_ns: taskCheckpointNamespace
              }
            }),
            triggers,
            retry_policy: call.retry,
            cache_key: call.cache ? {
              key: require_hash4.XXH3((call.cache.keyFunc ?? JSON.stringify)([call.input])),
              ns: [require_constants5.CACHE_NS_WRITES, call.name ?? "__dynamic__"],
              ttl: call.cache.ttl
            } : void 0,
            id,
            path: outputTaskPath,
            writers: []
          };
          return task;
        } else return {
          id,
          name: call.name,
          interrupts: [],
          path: outputTaskPath
        };
      } else if (taskPath[0] === require_constants5.PUSH) {
        const index = typeof taskPath[1] === "number" ? taskPath[1] : parseInt(taskPath[1], 10);
        if (!channels[require_constants5.TASKS]?.isAvailable()) return void 0;
        const sends = channels[require_constants5.TASKS].get();
        if (index < 0 || index >= sends.length) return void 0;
        const packet = require_constants5._isSendInterface(sends[index]) && !require_constants5._isSend(sends[index]) ? new require_constants5.Send(sends[index].node, sends[index].args) : sends[index];
        if (!require_constants5._isSendInterface(packet)) {
          console.warn(`Ignoring invalid packet ${JSON.stringify(packet)} in pending sends.`);
          return void 0;
        }
        if (!(packet.node in processes)) {
          console.warn(`Ignoring unknown node name ${packet.node} in pending sends.`);
          return void 0;
        }
        const triggers = [require_constants5.PUSH];
        const checkpointNamespace = parentNamespace === "" ? packet.node : `${parentNamespace}${require_constants5.CHECKPOINT_NAMESPACE_SEPARATOR}${packet.node}`;
        const taskId = (0, __langchain_langgraph_checkpoint.uuid5)(JSON.stringify([
          checkpointNamespace,
          step.toString(),
          packet.node,
          require_constants5.PUSH,
          index.toString()
        ]), checkpoint.id);
        const taskCheckpointNamespace = `${checkpointNamespace}${require_constants5.CHECKPOINT_NAMESPACE_END}${taskId}`;
        let metadata = {
          langgraph_step: step,
          langgraph_node: packet.node,
          langgraph_triggers: triggers,
          langgraph_path: taskPath.slice(0, 3),
          langgraph_checkpoint_ns: taskCheckpointNamespace
        };
        if (forExecution) {
          const proc = processes[packet.node];
          const node = proc.getNode();
          if (node !== void 0) {
            if (proc.metadata !== void 0) metadata = {
              ...metadata,
              ...proc.metadata
            };
            const writes = [];
            return {
              name: packet.node,
              input: packet.args,
              proc: node,
              subgraphs: proc.subgraphs,
              writes,
              config: (0, __langchain_core_runnables.patchConfig)((0, __langchain_core_runnables.mergeConfigs)(config, {
                metadata,
                tags: proc.tags,
                store: extra.store ?? config.store
              }), {
                runName: packet.node,
                callbacks: manager?.getChild(`graph:step:${step}`),
                configurable: {
                  [require_constants5.CONFIG_KEY_TASK_ID]: taskId,
                  [require_constants5.CONFIG_KEY_SEND]: (writes_) => _localWrite((items) => writes.push(...items), processes, writes_),
                  [require_constants5.CONFIG_KEY_READ]: (select_, fresh_ = false) => _localRead(checkpoint, channels, {
                    name: packet.node,
                    writes,
                    triggers,
                    path: taskPath
                  }, select_, fresh_),
                  [require_constants5.CONFIG_KEY_CHECKPOINTER]: checkpointer ?? configurable[require_constants5.CONFIG_KEY_CHECKPOINTER],
                  [require_constants5.CONFIG_KEY_CHECKPOINT_MAP]: {
                    ...configurable[require_constants5.CONFIG_KEY_CHECKPOINT_MAP],
                    [parentNamespace]: checkpoint.id
                  },
                  [require_constants5.CONFIG_KEY_SCRATCHPAD]: _scratchpad({
                    pendingWrites: pendingWrites ?? [],
                    taskId,
                    currentTaskInput: packet.args,
                    resumeMap: config.configurable?.[require_constants5.CONFIG_KEY_RESUME_MAP],
                    namespaceHash: require_hash4.XXH3(taskCheckpointNamespace)
                  }),
                  [require_constants5.CONFIG_KEY_PREVIOUS_STATE]: checkpoint.channel_values[require_constants5.PREVIOUS],
                  checkpoint_id: void 0,
                  checkpoint_ns: taskCheckpointNamespace
                }
              }),
              triggers,
              retry_policy: proc.retryPolicy,
              cache_key: proc.cachePolicy ? {
                key: require_hash4.XXH3((proc.cachePolicy.keyFunc ?? JSON.stringify)([packet.args])),
                ns: [
                  require_constants5.CACHE_NS_WRITES,
                  proc.name ?? "__dynamic__",
                  packet.node
                ],
                ttl: proc.cachePolicy.ttl
              } : void 0,
              id: taskId,
              path: taskPath,
              writers: proc.getWriters()
            };
          }
        } else return {
          id: taskId,
          name: packet.node,
          interrupts: [],
          path: taskPath
        };
      } else if (taskPath[0] === require_constants5.PULL) {
        const name = taskPath[1].toString();
        const proc = processes[name];
        if (proc === void 0) return void 0;
        if (pendingWrites?.length) {
          const checkpointNamespace = parentNamespace === "" ? name : `${parentNamespace}${require_constants5.CHECKPOINT_NAMESPACE_SEPARATOR}${name}`;
          const taskId = (0, __langchain_langgraph_checkpoint.uuid5)(JSON.stringify([
            checkpointNamespace,
            step.toString(),
            name,
            require_constants5.PULL,
            name
          ]), checkpoint.id);
          const hasSuccessfulWrites = pendingWrites.some((w) => w[0] === taskId && w[1] !== require_constants5.ERROR);
          if (hasSuccessfulWrites) return void 0;
        }
        const nullVersion = require_index.getNullChannelVersion(checkpoint.channel_versions);
        if (nullVersion === void 0) return void 0;
        const seen = checkpoint.versions_seen[name] ?? {};
        const trigger = proc.triggers.find((chan) => {
          if (!channels[chan].isAvailable()) return false;
          return (checkpoint.channel_versions[chan] ?? nullVersion) > (seen[chan] ?? nullVersion);
        });
        if (trigger !== void 0) {
          const val = _procInput(proc, channels, forExecution);
          if (val === void 0) return void 0;
          const checkpointNamespace = parentNamespace === "" ? name : `${parentNamespace}${require_constants5.CHECKPOINT_NAMESPACE_SEPARATOR}${name}`;
          const taskId = (0, __langchain_langgraph_checkpoint.uuid5)(JSON.stringify([
            checkpointNamespace,
            step.toString(),
            name,
            require_constants5.PULL,
            [trigger]
          ]), checkpoint.id);
          const taskCheckpointNamespace = `${checkpointNamespace}${require_constants5.CHECKPOINT_NAMESPACE_END}${taskId}`;
          let metadata = {
            langgraph_step: step,
            langgraph_node: name,
            langgraph_triggers: [trigger],
            langgraph_path: taskPath,
            langgraph_checkpoint_ns: taskCheckpointNamespace
          };
          if (forExecution) {
            const node = proc.getNode();
            if (node !== void 0) {
              if (proc.metadata !== void 0) metadata = {
                ...metadata,
                ...proc.metadata
              };
              const writes = [];
              return {
                name,
                input: val,
                proc: node,
                subgraphs: proc.subgraphs,
                writes,
                config: (0, __langchain_core_runnables.patchConfig)((0, __langchain_core_runnables.mergeConfigs)(config, {
                  metadata,
                  tags: proc.tags,
                  store: extra.store ?? config.store
                }), {
                  runName: name,
                  callbacks: manager?.getChild(`graph:step:${step}`),
                  configurable: {
                    [require_constants5.CONFIG_KEY_TASK_ID]: taskId,
                    [require_constants5.CONFIG_KEY_SEND]: (writes_) => _localWrite((items) => {
                      writes.push(...items);
                    }, processes, writes_),
                    [require_constants5.CONFIG_KEY_READ]: (select_, fresh_ = false) => _localRead(checkpoint, channels, {
                      name,
                      writes,
                      triggers: [trigger],
                      path: taskPath
                    }, select_, fresh_),
                    [require_constants5.CONFIG_KEY_CHECKPOINTER]: checkpointer ?? configurable[require_constants5.CONFIG_KEY_CHECKPOINTER],
                    [require_constants5.CONFIG_KEY_CHECKPOINT_MAP]: {
                      ...configurable[require_constants5.CONFIG_KEY_CHECKPOINT_MAP],
                      [parentNamespace]: checkpoint.id
                    },
                    [require_constants5.CONFIG_KEY_SCRATCHPAD]: _scratchpad({
                      pendingWrites: pendingWrites ?? [],
                      taskId,
                      currentTaskInput: val,
                      resumeMap: config.configurable?.[require_constants5.CONFIG_KEY_RESUME_MAP],
                      namespaceHash: require_hash4.XXH3(taskCheckpointNamespace)
                    }),
                    [require_constants5.CONFIG_KEY_PREVIOUS_STATE]: checkpoint.channel_values[require_constants5.PREVIOUS],
                    checkpoint_id: void 0,
                    checkpoint_ns: taskCheckpointNamespace
                  }
                }),
                triggers: [trigger],
                retry_policy: proc.retryPolicy,
                cache_key: proc.cachePolicy ? {
                  key: require_hash4.XXH3((proc.cachePolicy.keyFunc ?? JSON.stringify)([val])),
                  ns: [
                    require_constants5.CACHE_NS_WRITES,
                    proc.name ?? "__dynamic__",
                    name
                  ],
                  ttl: proc.cachePolicy.ttl
                } : void 0,
                id: taskId,
                path: taskPath,
                writers: proc.getWriters()
              };
            }
          } else return {
            id: taskId,
            name,
            interrupts: [],
            path: taskPath
          };
        }
      }
      return void 0;
    }
    function _procInput(proc, channels, forExecution) {
      let val;
      if (typeof proc.channels === "object" && !Array.isArray(proc.channels)) {
        val = {};
        for (const [k, chan] of Object.entries(proc.channels)) if (proc.triggers.includes(chan)) try {
          val[k] = require_io2.readChannel(channels, chan, false);
        } catch (e) {
          if (e.name === require_errors10.EmptyChannelError.unminifiable_name) return void 0;
          else throw e;
        }
        else if (chan in channels) try {
          val[k] = require_io2.readChannel(channels, chan, false);
        } catch (e) {
          if (e.name === require_errors10.EmptyChannelError.unminifiable_name) continue;
          else throw e;
        }
      } else if (Array.isArray(proc.channels)) {
        let successfulRead = false;
        for (const chan of proc.channels) try {
          val = require_io2.readChannel(channels, chan, false);
          successfulRead = true;
          break;
        } catch (e) {
          if (e.name === require_errors10.EmptyChannelError.unminifiable_name) continue;
          else throw e;
        }
        if (!successfulRead) return void 0;
      } else throw new Error(`Invalid channels type, expected list or dict, got ${proc.channels}`);
      if (forExecution && proc.mapper !== void 0) val = proc.mapper(val);
      return val;
    }
    function _scratchpad({ pendingWrites, taskId, currentTaskInput, resumeMap, namespaceHash }) {
      const nullResume = pendingWrites.find(([writeTaskId, chan]) => writeTaskId === require_constants5.NULL_TASK_ID && chan === require_constants5.RESUME)?.[2];
      const resume = (() => {
        const result = pendingWrites.filter(([writeTaskId, chan]) => writeTaskId === taskId && chan === require_constants5.RESUME).flatMap(([_writeTaskId, _chan, resume$1]) => resume$1);
        if (resumeMap != null && namespaceHash in resumeMap) {
          const mappedResume = resumeMap[namespaceHash];
          result.push(mappedResume);
        }
        return result;
      })();
      const scratchpad = {
        callCounter: 0,
        interruptCounter: -1,
        resume,
        nullResume,
        subgraphCounter: 0,
        currentTaskInput,
        consumeNullResume: () => {
          if (scratchpad.nullResume) {
            delete scratchpad.nullResume;
            pendingWrites.splice(pendingWrites.findIndex(([writeTaskId, chan]) => writeTaskId === require_constants5.NULL_TASK_ID && chan === require_constants5.RESUME), 1);
            return nullResume;
          }
          return void 0;
        }
      };
      return scratchpad;
    }
    exports2._applyWrites = _applyWrites;
    exports2._localRead = _localRead;
    exports2._prepareNextTasks = _prepareNextTasks;
    exports2._prepareSingleTask = _prepareSingleTask;
    exports2.increment = increment;
    exports2.shouldInterrupt = shouldInterrupt;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/debug.cjs
var require_debug2 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/debug.cjs"(exports2) {
    var require_constants5 = require_constants4();
    var require_io2 = require_io();
    var require_subgraph2 = require_subgraph();
    var COLORS_MAP = {
      blue: {
        start: "\x1B[34m",
        end: "\x1B[0m"
      },
      green: {
        start: "\x1B[32m",
        end: "\x1B[0m"
      },
      yellow: {
        start: "\x1B[33;1m",
        end: "\x1B[0m"
      }
    };
    var wrap = (color, text) => `${color.start}${text}${color.end}`;
    function* mapDebugTasks(tasks) {
      for (const { id, name, input, config, triggers, writes } of tasks) {
        if (config?.tags?.includes(require_constants5.TAG_HIDDEN)) continue;
        const interrupts = writes.filter(([writeId, n]) => {
          return writeId === id && n === require_constants5.INTERRUPT;
        }).map(([, v]) => {
          return v;
        });
        yield {
          id,
          name,
          input,
          triggers,
          interrupts
        };
      }
    }
    function isMultipleChannelWrite(value) {
      if (typeof value !== "object" || value === null) return false;
      return "$writes" in value && Array.isArray(value.$writes);
    }
    function mapTaskResultWrites(writes) {
      const result = {};
      for (const [channel2, value] of writes) {
        const strChannel = String(channel2);
        if (strChannel in result) {
          const channelWrites = isMultipleChannelWrite(result[strChannel]) ? result[strChannel].$writes : [result[strChannel]];
          channelWrites.push(value);
          result[strChannel] = { $writes: channelWrites };
        } else result[strChannel] = value;
      }
      return result;
    }
    function* mapDebugTaskResults(tasks, streamChannels) {
      for (const [{ id, name, config }, writes] of tasks) {
        if (config?.tags?.includes(require_constants5.TAG_HIDDEN)) continue;
        yield {
          id,
          name,
          result: mapTaskResultWrites(writes.filter(([channel2]) => {
            return Array.isArray(streamChannels) ? streamChannels.includes(channel2) : channel2 === streamChannels;
          })),
          interrupts: writes.filter((w) => w[0] === require_constants5.INTERRUPT).map((w) => w[1])
        };
      }
    }
    function* mapDebugCheckpoint(config, channels, streamChannels, metadata, tasks, pendingWrites, parentConfig, outputKeys) {
      function formatConfig(config$1) {
        const pyConfig = {};
        if (config$1.callbacks != null) pyConfig.callbacks = config$1.callbacks;
        if (config$1.configurable != null) pyConfig.configurable = config$1.configurable;
        if (config$1.maxConcurrency != null) pyConfig.max_concurrency = config$1.maxConcurrency;
        if (config$1.metadata != null) pyConfig.metadata = config$1.metadata;
        if (config$1.recursionLimit != null) pyConfig.recursion_limit = config$1.recursionLimit;
        if (config$1.runId != null) pyConfig.run_id = config$1.runId;
        if (config$1.runName != null) pyConfig.run_name = config$1.runName;
        if (config$1.tags != null) pyConfig.tags = config$1.tags;
        return pyConfig;
      }
      const parentNs = config.configurable?.checkpoint_ns;
      const taskStates = {};
      for (const task of tasks) {
        const candidates = task.subgraphs?.length ? task.subgraphs : [task.proc];
        if (!candidates.find(require_subgraph2.findSubgraphPregel)) continue;
        let taskNs = `${task.name}:${task.id}`;
        if (parentNs) taskNs = `${parentNs}|${taskNs}`;
        taskStates[task.id] = { configurable: {
          thread_id: config.configurable?.thread_id,
          checkpoint_ns: taskNs
        } };
      }
      yield {
        config: formatConfig(config),
        values: require_io2.readChannels(channels, streamChannels),
        metadata,
        next: tasks.map((task) => task.name),
        tasks: tasksWithWrites(tasks, pendingWrites, taskStates, outputKeys),
        parentConfig: parentConfig ? formatConfig(parentConfig) : void 0
      };
    }
    function tasksWithWrites(tasks, pendingWrites, states, outputKeys) {
      return tasks.map((task) => {
        const error = pendingWrites.find(([id, n]) => id === task.id && n === require_constants5.ERROR)?.[2];
        const interrupts = pendingWrites.filter(([id, n]) => id === task.id && n === require_constants5.INTERRUPT).map(([, , v]) => v);
        const result = (() => {
          if (error || interrupts.length || !pendingWrites.length) return void 0;
          const idx = pendingWrites.findIndex(([tid, n]) => tid === task.id && n === require_constants5.RETURN);
          if (idx >= 0) return pendingWrites[idx][2];
          if (typeof outputKeys === "string") return pendingWrites.find(([tid, n]) => tid === task.id && n === outputKeys)?.[2];
          if (Array.isArray(outputKeys)) {
            const results = pendingWrites.filter(([tid, n]) => tid === task.id && outputKeys.includes(n)).map(([, n, v]) => [n, v]);
            if (!results.length) return void 0;
            return mapTaskResultWrites(results);
          }
          return void 0;
        })();
        if (error) return {
          id: task.id,
          name: task.name,
          path: task.path,
          error,
          interrupts,
          result
        };
        const taskState = states?.[task.id];
        return {
          id: task.id,
          name: task.name,
          path: task.path,
          interrupts,
          ...taskState !== void 0 ? { state: taskState } : {},
          result
        };
      });
    }
    function printStepCheckpoint(step, channels, whitelist) {
      console.log([
        `${wrap(COLORS_MAP.blue, `[${step}:checkpoint]`)}`,
        `\x1B[1m State at the end of step ${step}:\x1B[0m
`,
        JSON.stringify(require_io2.readChannels(channels, whitelist), null, 2)
      ].join(""));
    }
    function printStepTasks(step, nextTasks) {
      const nTasks = nextTasks.length;
      console.log([
        `${wrap(COLORS_MAP.blue, `[${step}:tasks]`)}`,
        `\x1B[1m Starting step ${step} with ${nTasks} task${nTasks === 1 ? "" : "s"}:\x1B[0m
`,
        nextTasks.map((task) => `- ${wrap(COLORS_MAP.green, String(task.name))} -> ${JSON.stringify(task.input, null, 2)}`).join("\n")
      ].join(""));
    }
    function printStepWrites(step, writes, whitelist) {
      const byChannel = {};
      for (const [channel2, value] of writes) if (whitelist.includes(channel2)) {
        if (!byChannel[channel2]) byChannel[channel2] = [];
        byChannel[channel2].push(value);
      }
      console.log([
        `${wrap(COLORS_MAP.blue, `[${step}:writes]`)}`,
        `\x1B[1m Finished step ${step} with writes to ${Object.keys(byChannel).length} channel${Object.keys(byChannel).length !== 1 ? "s" : ""}:\x1B[0m
`,
        Object.entries(byChannel).map(([name, vals]) => `- ${wrap(COLORS_MAP.yellow, name)} -> ${vals.map((v) => JSON.stringify(v)).join(", ")}`).join("\n")
      ].join(""));
    }
    exports2.mapDebugCheckpoint = mapDebugCheckpoint;
    exports2.mapDebugTaskResults = mapDebugTaskResults;
    exports2.mapDebugTasks = mapDebugTasks;
    exports2.printStepCheckpoint = printStepCheckpoint;
    exports2.printStepTasks = printStepTasks;
    exports2.printStepWrites = printStepWrites;
    exports2.tasksWithWrites = tasksWithWrites;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/stream.cjs
var require_stream3 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/stream.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime3();
    var __langchain_core_utils_stream = require_rolldown_runtime5.__toESM(require_stream());
    var IterableReadableStreamWithAbortSignal = class extends __langchain_core_utils_stream.IterableReadableStream {
      _abortController;
      _innerReader;
      /**
      * @param readableStream - The stream to wrap.
      * @param abortController - The abort controller to use. Optional. One will be created if not provided.
      */
      constructor(readableStream, abortController) {
        const reader = readableStream.getReader();
        const ac = abortController ?? new AbortController();
        super({ start(controller) {
          return pump();
          function pump() {
            return reader.read().then(({ done, value }) => {
              if (done) {
                controller.close();
                return;
              }
              controller.enqueue(value);
              return pump();
            });
          }
        } });
        this._abortController = ac;
        this._innerReader = reader;
      }
      /**
      * Aborts the stream, abandoning any pending operations in progress. Calling this triggers an
      * {@link AbortSignal} that is propagated to the tasks that are producing the data for this stream.
      * @param reason - The reason for aborting the stream. Optional.
      */
      async cancel(reason) {
        this._abortController.abort(reason);
        this._innerReader.releaseLock();
      }
      /**
      * The {@link AbortSignal} for the stream. Aborted when {@link cancel} is called.
      */
      get signal() {
        return this._abortController.signal;
      }
    };
    var IterableReadableWritableStream = class extends __langchain_core_utils_stream.IterableReadableStream {
      modes;
      controller;
      passthroughFn;
      _closed = false;
      get closed() {
        return this._closed;
      }
      constructor(params) {
        let streamControllerPromiseResolver;
        const streamControllerPromise = new Promise((resolve) => {
          streamControllerPromiseResolver = resolve;
        });
        super({ start: (controller) => {
          streamControllerPromiseResolver(controller);
        } });
        streamControllerPromise.then((controller) => {
          this.controller = controller;
        });
        this.passthroughFn = params.passthroughFn;
        this.modes = params.modes;
      }
      push(chunk) {
        this.passthroughFn?.(chunk);
        this.controller.enqueue(chunk);
      }
      close() {
        try {
          this.controller.close();
        } catch (e) {
        } finally {
          this._closed = true;
        }
      }
      error(e) {
        this.controller.error(e);
      }
    };
    function _stringifyAsDict(obj) {
      return JSON.stringify(obj, function(key, value) {
        const rawValue = this[key];
        if (rawValue != null && typeof rawValue === "object" && "toDict" in rawValue && typeof rawValue.toDict === "function") {
          const { type, data } = rawValue.toDict();
          return {
            ...data,
            type
          };
        }
        return value;
      });
    }
    function _serializeError(error) {
      if (error instanceof Error) return {
        error: error.name,
        message: error.message
      };
      return {
        error: "Error",
        message: JSON.stringify(error)
      };
    }
    function _isRunnableConfig(config) {
      if (typeof config !== "object" || config == null) return false;
      return "configurable" in config && typeof config.configurable === "object" && config.configurable != null;
    }
    function _extractCheckpointFromConfig(config) {
      if (!_isRunnableConfig(config) || !config.configurable.thread_id) return null;
      return {
        thread_id: config.configurable.thread_id,
        checkpoint_ns: config.configurable.checkpoint_ns || "",
        checkpoint_id: config.configurable.checkpoint_id || null,
        checkpoint_map: config.configurable.checkpoint_map || null
      };
    }
    function _serializeConfig(config) {
      if (_isRunnableConfig(config)) {
        const configurable = Object.fromEntries(Object.entries(config.configurable).filter(([key]) => !key.startsWith("__")));
        const newConfig = {
          ...config,
          configurable
        };
        delete newConfig.callbacks;
        return newConfig;
      }
      return config;
    }
    function _serializeCheckpoint(payload) {
      const result = {
        ...payload,
        checkpoint: _extractCheckpointFromConfig(payload.config),
        parent_checkpoint: _extractCheckpointFromConfig(payload.parentConfig),
        config: _serializeConfig(payload.config),
        parent_config: _serializeConfig(payload.parentConfig),
        tasks: payload.tasks.map((task) => {
          if (_isRunnableConfig(task.state)) {
            const checkpoint = _extractCheckpointFromConfig(task.state);
            if (checkpoint != null) {
              const cloneTask = {
                ...task,
                checkpoint
              };
              delete cloneTask.state;
              return cloneTask;
            }
          }
          return task;
        })
      };
      delete result.parentConfig;
      return result;
    }
    function toEventStream(stream) {
      const encoder = new TextEncoder();
      return new ReadableStream({ async start(controller) {
        const enqueueChunk = (sse) => {
          controller.enqueue(encoder.encode(`event: ${sse.event}
data: ${_stringifyAsDict(sse.data)}

`));
        };
        try {
          for await (const payload of stream) {
            const [ns, mode, chunk] = payload;
            let data = chunk;
            if (mode === "debug") {
              const debugChunk = chunk;
              if (debugChunk.type === "checkpoint") data = {
                ...debugChunk,
                payload: _serializeCheckpoint(debugChunk.payload)
              };
            }
            if (mode === "checkpoints") data = _serializeCheckpoint(chunk);
            const event = ns?.length ? `${mode}|${ns.join("|")}` : mode;
            enqueueChunk({
              event,
              data
            });
          }
        } catch (error) {
          enqueueChunk({
            event: "error",
            data: _serializeError(error)
          });
        }
        controller.close();
      } });
    }
    exports2.IterableReadableStreamWithAbortSignal = IterableReadableStreamWithAbortSignal;
    exports2.IterableReadableWritableStream = IterableReadableWritableStream;
    exports2.toEventStream = toEventStream;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/loop.cjs
var require_loop = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/loop.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime3();
    var require_errors10 = require_errors5();
    var require_base18 = require_base17();
    var require_constants5 = require_constants4();
    var require_utils10 = require_utils8();
    var require_hash4 = require_hash3();
    var require_io2 = require_io();
    var require_index = require_utils9();
    var require_algo2 = require_algo();
    var require_debug3 = require_debug2();
    var require_stream5 = require_stream3();
    var __langchain_langgraph_checkpoint = require_rolldown_runtime5.__toESM(require_dist4());
    var INPUT_DONE = Symbol.for("INPUT_DONE");
    var INPUT_RESUMING = Symbol.for("INPUT_RESUMING");
    var DEFAULT_LOOP_LIMIT = 25;
    function createDuplexStream(...streams) {
      return new require_stream5.IterableReadableWritableStream({
        passthroughFn: (value) => {
          for (const stream of streams) if (stream.modes.has(value[1])) stream.push(value);
        },
        modes: new Set(streams.flatMap((s) => Array.from(s.modes)))
      });
    }
    var AsyncBatchedCache = class extends __langchain_langgraph_checkpoint.BaseCache {
      cache;
      queue = Promise.resolve();
      constructor(cache) {
        super();
        this.cache = cache;
      }
      async get(keys) {
        return this.enqueueOperation("get", keys);
      }
      async set(pairs) {
        return this.enqueueOperation("set", pairs);
      }
      async clear(namespaces) {
        return this.enqueueOperation("clear", namespaces);
      }
      async stop() {
        await this.queue;
      }
      enqueueOperation(type, ...args) {
        const newPromise = this.queue.then(() => {
          return this.cache[type](...args);
        });
        this.queue = newPromise.then(() => void 0, () => void 0);
        return newPromise;
      }
    };
    var PregelLoop = class PregelLoop2 {
      input;
      output;
      config;
      checkpointer;
      checkpointerGetNextVersion;
      channels;
      checkpoint;
      checkpointIdSaved;
      checkpointConfig;
      checkpointMetadata;
      checkpointNamespace;
      checkpointPendingWrites = [];
      checkpointPreviousVersions;
      step;
      stop;
      durability;
      outputKeys;
      streamKeys;
      nodes;
      skipDoneTasks;
      prevCheckpointConfig;
      updatedChannels;
      status = "pending";
      tasks = {};
      stream;
      checkpointerPromises = [];
      isNested;
      _checkpointerChainedPromise = Promise.resolve();
      store;
      cache;
      manager;
      interruptAfter;
      interruptBefore;
      toInterrupt = [];
      debug = false;
      triggerToNodes;
      get isResuming() {
        let hasChannelVersions = false;
        if (require_constants5.START in this.checkpoint.channel_versions) hasChannelVersions = true;
        else for (const chan in this.checkpoint.channel_versions) if (Object.prototype.hasOwnProperty.call(this.checkpoint.channel_versions, chan)) {
          hasChannelVersions = true;
          break;
        }
        const configHasResumingFlag = this.config.configurable?.[require_constants5.CONFIG_KEY_RESUMING] !== void 0;
        const configIsResuming = configHasResumingFlag && this.config.configurable?.[require_constants5.CONFIG_KEY_RESUMING];
        const inputIsNullOrUndefined = this.input === null || this.input === void 0;
        const inputIsCommandResuming = require_constants5.isCommand(this.input) && this.input.resume != null;
        const inputIsResuming = this.input === INPUT_RESUMING;
        const runIdMatchesPrevious = !this.isNested && this.config.metadata?.run_id !== void 0 && this.checkpointMetadata?.run_id !== void 0 && this.config.metadata.run_id === this.checkpointMetadata?.run_id;
        return hasChannelVersions && (configIsResuming || inputIsNullOrUndefined || inputIsCommandResuming || inputIsResuming || runIdMatchesPrevious);
      }
      constructor(params) {
        this.input = params.input;
        this.checkpointer = params.checkpointer;
        if (this.checkpointer !== void 0) this.checkpointerGetNextVersion = this.checkpointer.getNextVersion.bind(this.checkpointer);
        else this.checkpointerGetNextVersion = require_algo2.increment;
        this.checkpoint = params.checkpoint;
        this.checkpointMetadata = params.checkpointMetadata;
        this.checkpointPreviousVersions = params.checkpointPreviousVersions;
        this.channels = params.channels;
        this.checkpointPendingWrites = params.checkpointPendingWrites;
        this.step = params.step;
        this.stop = params.stop;
        this.config = params.config;
        this.checkpointConfig = params.checkpointConfig;
        this.isNested = params.isNested;
        this.manager = params.manager;
        this.outputKeys = params.outputKeys;
        this.streamKeys = params.streamKeys;
        this.nodes = params.nodes;
        this.skipDoneTasks = params.skipDoneTasks;
        this.store = params.store;
        this.cache = params.cache ? new AsyncBatchedCache(params.cache) : void 0;
        this.stream = params.stream;
        this.checkpointNamespace = params.checkpointNamespace;
        this.prevCheckpointConfig = params.prevCheckpointConfig;
        this.interruptAfter = params.interruptAfter;
        this.interruptBefore = params.interruptBefore;
        this.durability = params.durability;
        this.debug = params.debug;
        this.triggerToNodes = params.triggerToNodes;
      }
      static async initialize(params) {
        let { config, stream } = params;
        if (stream !== void 0 && config.configurable?.[require_constants5.CONFIG_KEY_STREAM] !== void 0) stream = createDuplexStream(stream, config.configurable[require_constants5.CONFIG_KEY_STREAM]);
        const skipDoneTasks = config.configurable ? !("checkpoint_id" in config.configurable) : true;
        const scratchpad = config.configurable?.[require_constants5.CONFIG_KEY_SCRATCHPAD];
        if (config.configurable && scratchpad) {
          if (scratchpad.subgraphCounter > 0) config = require_index.patchConfigurable(config, { [require_constants5.CONFIG_KEY_CHECKPOINT_NS]: [config.configurable[require_constants5.CONFIG_KEY_CHECKPOINT_NS], scratchpad.subgraphCounter.toString()].join(require_constants5.CHECKPOINT_NAMESPACE_SEPARATOR) });
          scratchpad.subgraphCounter += 1;
        }
        const isNested = require_constants5.CONFIG_KEY_READ in (config.configurable ?? {});
        if (!isNested && config.configurable?.checkpoint_ns !== void 0 && config.configurable?.checkpoint_ns !== "") config = require_index.patchConfigurable(config, {
          checkpoint_ns: "",
          checkpoint_id: void 0
        });
        let checkpointConfig = config;
        if (config.configurable?.[require_constants5.CONFIG_KEY_CHECKPOINT_MAP] !== void 0 && config.configurable?.[require_constants5.CONFIG_KEY_CHECKPOINT_MAP]?.[config.configurable?.checkpoint_ns]) checkpointConfig = require_index.patchConfigurable(config, { checkpoint_id: config.configurable[require_constants5.CONFIG_KEY_CHECKPOINT_MAP][config.configurable?.checkpoint_ns] });
        const checkpointNamespace = config.configurable?.checkpoint_ns?.split(require_constants5.CHECKPOINT_NAMESPACE_SEPARATOR) ?? [];
        const saved = await params.checkpointer?.getTuple(checkpointConfig) ?? {
          config,
          checkpoint: (0, __langchain_langgraph_checkpoint.emptyCheckpoint)(),
          metadata: {
            source: "input",
            step: -2,
            parents: {}
          },
          pendingWrites: []
        };
        checkpointConfig = {
          ...config,
          ...saved.config,
          configurable: {
            checkpoint_ns: "",
            ...config.configurable,
            ...saved.config.configurable
          }
        };
        const prevCheckpointConfig = saved.parentConfig;
        const checkpoint = (0, __langchain_langgraph_checkpoint.copyCheckpoint)(saved.checkpoint);
        const checkpointMetadata = { ...saved.metadata };
        const checkpointPendingWrites = saved.pendingWrites ?? [];
        const channels = require_base18.emptyChannels(params.channelSpecs, checkpoint);
        const step = (checkpointMetadata.step ?? 0) + 1;
        const stop = step + (config.recursionLimit ?? DEFAULT_LOOP_LIMIT) + 1;
        const checkpointPreviousVersions = { ...checkpoint.channel_versions };
        const store = params.store ? new __langchain_langgraph_checkpoint.AsyncBatchedStore(params.store) : void 0;
        if (store) await store.start();
        return new PregelLoop2({
          input: params.input,
          config,
          checkpointer: params.checkpointer,
          checkpoint,
          checkpointMetadata,
          checkpointConfig,
          prevCheckpointConfig,
          checkpointNamespace,
          channels,
          isNested,
          manager: params.manager,
          skipDoneTasks,
          step,
          stop,
          checkpointPreviousVersions,
          checkpointPendingWrites,
          outputKeys: params.outputKeys ?? [],
          streamKeys: params.streamKeys ?? [],
          nodes: params.nodes,
          stream,
          store,
          cache: params.cache,
          interruptAfter: params.interruptAfter,
          interruptBefore: params.interruptBefore,
          durability: params.durability,
          debug: params.debug,
          triggerToNodes: params.triggerToNodes
        });
      }
      _checkpointerPutAfterPrevious(input) {
        this._checkpointerChainedPromise = this._checkpointerChainedPromise.then(() => {
          return this.checkpointer?.put(input.config, input.checkpoint, input.metadata, input.newVersions);
        });
        this.checkpointerPromises.push(this._checkpointerChainedPromise);
      }
      /**
      * Put writes for a task, to be read by the next tick.
      * @param taskId
      * @param writes
      */
      putWrites(taskId, writes) {
        let writesCopy = writes;
        if (writesCopy.length === 0) return;
        if (writesCopy.every(([key]) => key in __langchain_langgraph_checkpoint.WRITES_IDX_MAP)) writesCopy = Array.from(new Map(writesCopy.map((w) => [w[0], w])).values());
        this.checkpointPendingWrites = this.checkpointPendingWrites.filter((w) => w[0] !== taskId);
        for (const [c, v] of writesCopy) this.checkpointPendingWrites.push([
          taskId,
          c,
          v
        ]);
        const config = require_index.patchConfigurable(this.checkpointConfig, {
          [require_constants5.CONFIG_KEY_CHECKPOINT_NS]: this.config.configurable?.checkpoint_ns ?? "",
          [require_constants5.CONFIG_KEY_CHECKPOINT_ID]: this.checkpoint.id
        });
        if (this.durability !== "exit" && this.checkpointer != null) this.checkpointerPromises.push(this.checkpointer.putWrites(config, writesCopy, taskId));
        if (this.tasks) this._outputWrites(taskId, writesCopy);
        if (!writes.length || !this.cache || !this.tasks) return;
        const task = this.tasks[taskId];
        if (task == null || task.cache_key == null) return;
        if (writes[0][0] === require_constants5.ERROR || writes[0][0] === require_constants5.INTERRUPT) return;
        this.cache.set([{
          key: [task.cache_key.ns, task.cache_key.key],
          value: task.writes,
          ttl: task.cache_key.ttl
        }]);
      }
      _outputWrites(taskId, writes, cached = false) {
        const task = this.tasks[taskId];
        if (task !== void 0) {
          if (task.config !== void 0 && (task.config.tags ?? []).includes(require_constants5.TAG_HIDDEN)) return;
          if (writes.length > 0) {
            if (writes[0][0] === require_constants5.INTERRUPT) {
              if (task.path?.[0] === require_constants5.PUSH && task.path?.at(-1) === true) return;
              const interruptWrites = writes.filter((w) => w[0] === require_constants5.INTERRUPT).flatMap((w) => w[1]);
              this._emit([["updates", { [require_constants5.INTERRUPT]: interruptWrites }], ["values", { [require_constants5.INTERRUPT]: interruptWrites }]]);
            } else if (writes[0][0] !== require_constants5.ERROR) this._emit(require_utils10.gatherIteratorSync(require_utils10.prefixGenerator(require_io2.mapOutputUpdates(this.outputKeys, [[task, writes]], cached), "updates")));
          }
          if (!cached) this._emit(require_utils10.gatherIteratorSync(require_utils10.prefixGenerator(require_debug3.mapDebugTaskResults([[task, writes]], this.streamKeys), "tasks")));
        }
      }
      async _matchCachedWrites() {
        if (!this.cache) return [];
        const matched = [];
        const serializeKey = ([ns, key]) => {
          return `ns:${ns.join(",")}|key:${key}`;
        };
        const keys = [];
        const keyMap = {};
        for (const task of Object.values(this.tasks)) if (task.cache_key != null && !task.writes.length) {
          keys.push([task.cache_key.ns, task.cache_key.key]);
          keyMap[serializeKey([task.cache_key.ns, task.cache_key.key])] = task;
        }
        if (keys.length === 0) return [];
        const cache = await this.cache.get(keys);
        for (const { key, value } of cache) {
          const task = keyMap[serializeKey(key)];
          if (task != null) {
            task.writes.push(...value);
            matched.push({
              task,
              result: value
            });
          }
        }
        return matched;
      }
      /**
      * Execute a single iteration of the Pregel loop.
      * Returns true if more iterations are needed.
      * @param params
      */
      async tick(params) {
        if (this.store && !this.store.isRunning) await this.store?.start();
        const { inputKeys = [] } = params;
        if (this.status !== "pending") throw new Error(`Cannot tick when status is no longer "pending". Current status: "${this.status}"`);
        if (![INPUT_DONE, INPUT_RESUMING].includes(this.input)) await this._first(inputKeys);
        else if (this.toInterrupt.length > 0) {
          this.status = "interrupt_before";
          throw new require_errors10.GraphInterrupt();
        } else if (Object.values(this.tasks).every((task) => task.writes.length > 0)) {
          const writes = Object.values(this.tasks).flatMap((t) => t.writes);
          this.updatedChannels = require_algo2._applyWrites(this.checkpoint, this.channels, Object.values(this.tasks), this.checkpointerGetNextVersion, this.triggerToNodes);
          const valuesOutput = await require_utils10.gatherIterator(require_utils10.prefixGenerator(require_io2.mapOutputValues(this.outputKeys, writes, this.channels), "values"));
          this._emit(valuesOutput);
          this.checkpointPendingWrites = [];
          await this._putCheckpoint({ source: "loop" });
          if (require_algo2.shouldInterrupt(this.checkpoint, this.interruptAfter, Object.values(this.tasks))) {
            this.status = "interrupt_after";
            throw new require_errors10.GraphInterrupt();
          }
          if (this.config.configurable?.[require_constants5.CONFIG_KEY_RESUMING] !== void 0) delete this.config.configurable?.[require_constants5.CONFIG_KEY_RESUMING];
        } else return false;
        if (this.step > this.stop) {
          this.status = "out_of_steps";
          return false;
        }
        const nextTasks = require_algo2._prepareNextTasks(this.checkpoint, this.checkpointPendingWrites, this.nodes, this.channels, this.config, true, {
          step: this.step,
          checkpointer: this.checkpointer,
          isResuming: this.isResuming,
          manager: this.manager,
          store: this.store,
          stream: this.stream,
          triggerToNodes: this.triggerToNodes,
          updatedChannels: this.updatedChannels
        });
        this.tasks = nextTasks;
        if (this.checkpointer) this._emit(await require_utils10.gatherIterator(require_utils10.prefixGenerator(require_debug3.mapDebugCheckpoint(this.checkpointConfig, this.channels, this.streamKeys, this.checkpointMetadata, Object.values(this.tasks), this.checkpointPendingWrites, this.prevCheckpointConfig, this.outputKeys), "checkpoints")));
        if (Object.values(this.tasks).length === 0) {
          this.status = "done";
          return false;
        }
        if (this.skipDoneTasks && this.checkpointPendingWrites.length > 0) {
          for (const [tid, k, v] of this.checkpointPendingWrites) {
            if (k === require_constants5.ERROR || k === require_constants5.INTERRUPT || k === require_constants5.RESUME) continue;
            const task = Object.values(this.tasks).find((t) => t.id === tid);
            if (task) task.writes.push([k, v]);
          }
          for (const task of Object.values(this.tasks)) if (task.writes.length > 0) this._outputWrites(task.id, task.writes, true);
        }
        if (Object.values(this.tasks).every((task) => task.writes.length > 0)) return this.tick({ inputKeys });
        if (require_algo2.shouldInterrupt(this.checkpoint, this.interruptBefore, Object.values(this.tasks))) {
          this.status = "interrupt_before";
          throw new require_errors10.GraphInterrupt();
        }
        const debugOutput = await require_utils10.gatherIterator(require_utils10.prefixGenerator(require_debug3.mapDebugTasks(Object.values(this.tasks)), "tasks"));
        this._emit(debugOutput);
        return true;
      }
      async finishAndHandleError(error) {
        if (this.durability === "exit" && (!this.isNested || typeof error !== "undefined" || this.checkpointNamespace.every((part) => !part.includes(require_constants5.CHECKPOINT_NAMESPACE_END)))) {
          this._putCheckpoint(this.checkpointMetadata);
          this._flushPendingWrites();
        }
        const suppress = this._suppressInterrupt(error);
        if (suppress || error === void 0) this.output = require_io2.readChannels(this.channels, this.outputKeys);
        if (suppress) {
          if (this.tasks !== void 0 && this.checkpointPendingWrites.length > 0 && Object.values(this.tasks).some((task) => task.writes.length > 0)) {
            this.updatedChannels = require_algo2._applyWrites(this.checkpoint, this.channels, Object.values(this.tasks), this.checkpointerGetNextVersion, this.triggerToNodes);
            this._emit(require_utils10.gatherIteratorSync(require_utils10.prefixGenerator(require_io2.mapOutputValues(this.outputKeys, Object.values(this.tasks).flatMap((t) => t.writes), this.channels), "values")));
          }
          if (require_errors10.isGraphInterrupt(error) && !error.interrupts.length) this._emit([["updates", { [require_constants5.INTERRUPT]: [] }], ["values", { [require_constants5.INTERRUPT]: [] }]]);
        }
        return suppress;
      }
      async acceptPush(task, writeIdx, call) {
        if (this.interruptAfter?.length > 0 && require_algo2.shouldInterrupt(this.checkpoint, this.interruptAfter, [task])) {
          this.toInterrupt.push(task);
          return;
        }
        const pushed = require_algo2._prepareSingleTask([
          require_constants5.PUSH,
          task.path ?? [],
          writeIdx,
          task.id,
          call
        ], this.checkpoint, this.checkpointPendingWrites, this.nodes, this.channels, task.config ?? {}, true, {
          step: this.step,
          checkpointer: this.checkpointer,
          manager: this.manager,
          store: this.store,
          stream: this.stream
        });
        if (!pushed) return;
        if (this.interruptBefore?.length > 0 && require_algo2.shouldInterrupt(this.checkpoint, this.interruptBefore, [pushed])) {
          this.toInterrupt.push(pushed);
          return;
        }
        this._emit(require_utils10.gatherIteratorSync(require_utils10.prefixGenerator(require_debug3.mapDebugTasks([pushed]), "tasks")));
        if (this.debug) require_debug3.printStepTasks(this.step, [pushed]);
        this.tasks[pushed.id] = pushed;
        if (this.skipDoneTasks) this._matchWrites({ [pushed.id]: pushed });
        const tasks = await this._matchCachedWrites();
        for (const { task: task$1 } of tasks) this._outputWrites(task$1.id, task$1.writes, true);
        return pushed;
      }
      _suppressInterrupt(e) {
        return require_errors10.isGraphInterrupt(e) && !this.isNested;
      }
      async _first(inputKeys) {
        const { configurable } = this.config;
        const scratchpad = configurable?.[require_constants5.CONFIG_KEY_SCRATCHPAD];
        if (scratchpad && scratchpad.nullResume !== void 0) this.putWrites(require_constants5.NULL_TASK_ID, [[require_constants5.RESUME, scratchpad.nullResume]]);
        if (require_constants5.isCommand(this.input)) {
          const hasResume = this.input.resume != null;
          if (this.input.resume != null && typeof this.input.resume === "object" && Object.keys(this.input.resume).every(require_hash4.isXXH3)) {
            this.config.configurable ??= {};
            this.config.configurable[require_constants5.CONFIG_KEY_RESUME_MAP] = this.input.resume;
          }
          if (hasResume && this.checkpointer == null) throw new Error("Cannot use Command(resume=...) without checkpointer");
          const writes = {};
          for (const [tid, key, value] of require_io2.mapCommand(this.input, this.checkpointPendingWrites)) {
            writes[tid] ??= [];
            writes[tid].push([key, value]);
          }
          if (Object.keys(writes).length === 0) throw new require_errors10.EmptyInputError("Received empty Command input");
          for (const [tid, ws] of Object.entries(writes)) this.putWrites(tid, ws);
        }
        const nullWrites = (this.checkpointPendingWrites ?? []).filter((w) => w[0] === require_constants5.NULL_TASK_ID).map((w) => w.slice(1));
        if (nullWrites.length > 0) require_algo2._applyWrites(this.checkpoint, this.channels, [{
          name: require_constants5.INPUT,
          writes: nullWrites,
          triggers: []
        }], this.checkpointerGetNextVersion, this.triggerToNodes);
        const isCommandUpdateOrGoto = require_constants5.isCommand(this.input) && nullWrites.length > 0;
        if (this.isResuming || isCommandUpdateOrGoto) {
          for (const channelName in this.channels) {
            if (!Object.prototype.hasOwnProperty.call(this.channels, channelName)) continue;
            if (this.checkpoint.channel_versions[channelName] !== void 0) {
              const version2 = this.checkpoint.channel_versions[channelName];
              this.checkpoint.versions_seen[require_constants5.INTERRUPT] = {
                ...this.checkpoint.versions_seen[require_constants5.INTERRUPT],
                [channelName]: version2
              };
            }
          }
          const valuesOutput = await require_utils10.gatherIterator(require_utils10.prefixGenerator(require_io2.mapOutputValues(this.outputKeys, true, this.channels), "values"));
          this._emit(valuesOutput);
        }
        if (this.isResuming) this.input = INPUT_RESUMING;
        else if (isCommandUpdateOrGoto) {
          await this._putCheckpoint({ source: "input" });
          this.input = INPUT_DONE;
        } else {
          const inputWrites = await require_utils10.gatherIterator(require_io2.mapInput(inputKeys, this.input));
          if (inputWrites.length > 0) {
            const discardTasks = require_algo2._prepareNextTasks(this.checkpoint, this.checkpointPendingWrites, this.nodes, this.channels, this.config, true, { step: this.step });
            this.updatedChannels = require_algo2._applyWrites(this.checkpoint, this.channels, Object.values(discardTasks).concat([{
              name: require_constants5.INPUT,
              writes: inputWrites,
              triggers: []
            }]), this.checkpointerGetNextVersion, this.triggerToNodes);
            await this._putCheckpoint({ source: "input" });
            this.input = INPUT_DONE;
          } else if (!(require_constants5.CONFIG_KEY_RESUMING in (this.config.configurable ?? {}))) throw new require_errors10.EmptyInputError(`Received no input writes for ${JSON.stringify(inputKeys, null, 2)}`);
          else this.input = INPUT_DONE;
        }
        if (!this.isNested) this.config = require_index.patchConfigurable(this.config, { [require_constants5.CONFIG_KEY_RESUMING]: this.isResuming });
      }
      _emit(values) {
        for (const [mode, payload] of values) {
          if (this.stream.modes.has(mode)) this.stream.push([
            this.checkpointNamespace,
            mode,
            payload
          ]);
          if ((mode === "checkpoints" || mode === "tasks") && this.stream.modes.has("debug")) {
            const step = mode === "checkpoints" ? this.step - 1 : this.step;
            const timestamp = (/* @__PURE__ */ new Date()).toISOString();
            const type = (() => {
              if (mode === "checkpoints") return "checkpoint";
              else if (typeof payload === "object" && payload != null && "result" in payload) return "task_result";
              else return "task";
            })();
            this.stream.push([
              this.checkpointNamespace,
              "debug",
              {
                step,
                type,
                timestamp,
                payload
              }
            ]);
          }
        }
      }
      _putCheckpoint(inputMetadata) {
        const exiting = this.checkpointMetadata === inputMetadata;
        const doCheckpoint = this.checkpointer != null && (this.durability !== "exit" || exiting);
        const storeCheckpoint = (checkpoint) => {
          this.prevCheckpointConfig = this.checkpointConfig?.configurable?.checkpoint_id ? this.checkpointConfig : void 0;
          this.checkpointConfig = require_index.patchConfigurable(this.checkpointConfig, { [require_constants5.CONFIG_KEY_CHECKPOINT_NS]: this.config.configurable?.checkpoint_ns ?? "" });
          const channelVersions = { ...this.checkpoint.channel_versions };
          const newVersions = require_index.getNewChannelVersions(this.checkpointPreviousVersions, channelVersions);
          this.checkpointPreviousVersions = channelVersions;
          this._checkpointerPutAfterPrevious({
            config: { ...this.checkpointConfig },
            checkpoint: (0, __langchain_langgraph_checkpoint.copyCheckpoint)(checkpoint),
            metadata: { ...this.checkpointMetadata },
            newVersions
          });
          this.checkpointConfig = {
            ...this.checkpointConfig,
            configurable: {
              ...this.checkpointConfig.configurable,
              checkpoint_id: this.checkpoint.id
            }
          };
        };
        if (!exiting) this.checkpointMetadata = {
          ...inputMetadata,
          step: this.step,
          parents: this.config.configurable?.[require_constants5.CONFIG_KEY_CHECKPOINT_MAP] ?? {}
        };
        this.checkpoint = require_base18.createCheckpoint(this.checkpoint, doCheckpoint ? this.channels : void 0, this.step, exiting ? { id: this.checkpoint.id } : void 0);
        if (doCheckpoint) storeCheckpoint(this.checkpoint);
        if (!exiting) this.step += 1;
      }
      _flushPendingWrites() {
        if (this.checkpointer == null) return;
        if (this.checkpointPendingWrites.length === 0) return;
        const config = require_index.patchConfigurable(this.checkpointConfig, {
          [require_constants5.CONFIG_KEY_CHECKPOINT_NS]: this.config.configurable?.checkpoint_ns ?? "",
          [require_constants5.CONFIG_KEY_CHECKPOINT_ID]: this.checkpoint.id
        });
        const byTask = {};
        for (const [tid, key, value] of this.checkpointPendingWrites) {
          byTask[tid] ??= [];
          byTask[tid].push([key, value]);
        }
        for (const [tid, ws] of Object.entries(byTask)) this.checkpointerPromises.push(this.checkpointer.putWrites(config, ws, tid));
      }
      _matchWrites(tasks) {
        for (const [tid, k, v] of this.checkpointPendingWrites) {
          if (k === require_constants5.ERROR || k === require_constants5.INTERRUPT || k === require_constants5.RESUME) continue;
          const task = Object.values(tasks).find((t) => t.id === tid);
          if (task) task.writes.push([k, v]);
        }
        for (const task of Object.values(tasks)) if (task.writes.length > 0) this._outputWrites(task.id, task.writes, true);
      }
    };
    exports2.PregelLoop = PregelLoop;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/messages.cjs
var require_messages3 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/messages.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime3();
    var require_constants5 = require_constants4();
    var __langchain_core_callbacks_base = require_rolldown_runtime5.__toESM(require_base2());
    var __langchain_core_messages = require_rolldown_runtime5.__toESM(require_messages2());
    function isChatGenerationChunk(x) {
      return (0, __langchain_core_messages.isBaseMessage)(x?.message);
    }
    var StreamMessagesHandler = class extends __langchain_core_callbacks_base.BaseCallbackHandler {
      name = "StreamMessagesHandler";
      streamFn;
      metadatas = {};
      seen = {};
      emittedChatModelRunIds = {};
      stableMessageIdMap = {};
      lc_prefer_streaming = true;
      constructor(streamFn) {
        super();
        this.streamFn = streamFn;
      }
      _emit(meta, message, runId, dedupe = false) {
        if (dedupe && message.id !== void 0 && this.seen[message.id] !== void 0) return;
        let messageId = message.id;
        if (runId != null) if ((0, __langchain_core_messages.isToolMessage)(message)) messageId ??= `run-${runId}-tool-${message.tool_call_id}`;
        else {
          if (messageId == null || messageId === `run-${runId}`) messageId = this.stableMessageIdMap[runId] ?? messageId ?? `run-${runId}`;
          this.stableMessageIdMap[runId] ??= messageId;
        }
        if (messageId !== message.id) {
          message.id = messageId;
          message.lc_kwargs.id = messageId;
        }
        if (message.id != null) this.seen[message.id] = message;
        this.streamFn([
          meta[0],
          "messages",
          [message, meta[1]]
        ]);
      }
      handleChatModelStart(_llm, _messages, runId, _parentRunId, _extraParams, tags, metadata, name) {
        if (metadata && (!tags || !tags.includes(require_constants5.TAG_NOSTREAM) && !tags.includes("nostream"))) this.metadatas[runId] = [metadata.langgraph_checkpoint_ns.split("|"), {
          tags,
          name,
          ...metadata
        }];
      }
      handleLLMNewToken(token, _idx, runId, _parentRunId, _tags, fields) {
        const chunk = fields?.chunk;
        this.emittedChatModelRunIds[runId] = true;
        if (this.metadatas[runId] !== void 0) if (isChatGenerationChunk(chunk)) this._emit(this.metadatas[runId], chunk.message, runId);
        else this._emit(this.metadatas[runId], new __langchain_core_messages.AIMessageChunk({ content: token }), runId);
      }
      handleLLMEnd(output, runId) {
        if (this.metadatas[runId] === void 0) return;
        if (!this.emittedChatModelRunIds[runId]) {
          const chatGeneration = output.generations?.[0]?.[0];
          if ((0, __langchain_core_messages.isBaseMessage)(chatGeneration?.message)) this._emit(this.metadatas[runId], chatGeneration?.message, runId, true);
          delete this.emittedChatModelRunIds[runId];
        }
        delete this.metadatas[runId];
        delete this.stableMessageIdMap[runId];
      }
      handleLLMError(_err, runId) {
        delete this.metadatas[runId];
      }
      handleChainStart(_chain, inputs, runId, _parentRunId, tags, metadata, _runType, name) {
        if (metadata !== void 0 && name === metadata.langgraph_node && (tags === void 0 || !tags.includes(require_constants5.TAG_HIDDEN))) {
          this.metadatas[runId] = [metadata.langgraph_checkpoint_ns.split("|"), {
            tags,
            name,
            ...metadata
          }];
          if (typeof inputs === "object") {
            for (const value of Object.values(inputs)) if (((0, __langchain_core_messages.isBaseMessage)(value) || (0, __langchain_core_messages.isBaseMessageChunk)(value)) && value.id !== void 0) this.seen[value.id] = value;
            else if (Array.isArray(value)) {
              for (const item of value) if (((0, __langchain_core_messages.isBaseMessage)(item) || (0, __langchain_core_messages.isBaseMessageChunk)(item)) && item.id !== void 0) this.seen[item.id] = item;
            }
          }
        }
      }
      handleChainEnd(outputs, runId) {
        const metadata = this.metadatas[runId];
        delete this.metadatas[runId];
        if (metadata !== void 0) {
          if ((0, __langchain_core_messages.isBaseMessage)(outputs)) this._emit(metadata, outputs, runId, true);
          else if (Array.isArray(outputs)) {
            for (const value of outputs) if ((0, __langchain_core_messages.isBaseMessage)(value)) this._emit(metadata, value, runId, true);
          } else if (outputs != null && typeof outputs === "object") {
            for (const value of Object.values(outputs)) if ((0, __langchain_core_messages.isBaseMessage)(value)) this._emit(metadata, value, runId, true);
            else if (Array.isArray(value)) {
              for (const item of value) if ((0, __langchain_core_messages.isBaseMessage)(item)) this._emit(metadata, item, runId, true);
            }
          }
        }
      }
      handleChainError(_err, runId) {
        delete this.metadatas[runId];
      }
    };
    exports2.StreamMessagesHandler = StreamMessagesHandler;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/retry.cjs
var require_retry3 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/retry.cjs"(exports2) {
    var require_errors10 = require_errors5();
    var require_constants5 = require_constants4();
    var require_config3 = require_config2();
    var require_index = require_utils9();
    var DEFAULT_INITIAL_INTERVAL = 500;
    var DEFAULT_BACKOFF_FACTOR = 2;
    var DEFAULT_MAX_INTERVAL = 128e3;
    var DEFAULT_MAX_RETRIES = 3;
    var DEFAULT_STATUS_NO_RETRY = [
      400,
      401,
      402,
      403,
      404,
      405,
      406,
      407,
      409
    ];
    var DEFAULT_RETRY_ON_HANDLER = (error) => {
      if (error.message.startsWith("Cancel") || error.message.startsWith("AbortError") || error.name === "AbortError") return false;
      if (error.name === "GraphValueError") return false;
      if (error?.code === "ECONNABORTED") return false;
      const status = error?.response?.status ?? error?.status;
      if (status && DEFAULT_STATUS_NO_RETRY.includes(+status)) return false;
      if (error?.error?.code === "insufficient_quota") return false;
      return true;
    };
    async function _runWithRetry(pregelTask, retryPolicy, configurable, signal) {
      const resolvedRetryPolicy = pregelTask.retry_policy ?? retryPolicy;
      let interval = resolvedRetryPolicy !== void 0 ? resolvedRetryPolicy.initialInterval ?? DEFAULT_INITIAL_INTERVAL : 0;
      let attempts = 0;
      let error;
      let result;
      let { config } = pregelTask;
      if (configurable) config = require_index.patchConfigurable(config, configurable);
      config = {
        ...config,
        signal
      };
      while (true) {
        if (signal?.aborted) break;
        pregelTask.writes.splice(0, pregelTask.writes.length);
        error = void 0;
        try {
          result = await pregelTask.proc.invoke(pregelTask.input, config);
          break;
        } catch (e) {
          error = e;
          error.pregelTaskId = pregelTask.id;
          if (require_errors10.isParentCommand(error)) {
            const ns = config?.configurable?.checkpoint_ns;
            const cmd = error.command;
            if (cmd.graph === ns) {
              for (const writer of pregelTask.writers) await writer.invoke(cmd, config);
              error = void 0;
              break;
            } else if (cmd.graph === require_constants5.Command.PARENT) {
              const parentNs = require_config3.getParentCheckpointNamespace(ns);
              error.command = new require_constants5.Command({
                ...error.command,
                graph: parentNs
              });
            }
          }
          if (require_errors10.isGraphBubbleUp(error)) break;
          if (resolvedRetryPolicy === void 0) break;
          attempts += 1;
          if (attempts >= (resolvedRetryPolicy.maxAttempts ?? DEFAULT_MAX_RETRIES)) break;
          const retryOn = resolvedRetryPolicy.retryOn ?? DEFAULT_RETRY_ON_HANDLER;
          if (!retryOn(error)) break;
          interval = Math.min(resolvedRetryPolicy.maxInterval ?? DEFAULT_MAX_INTERVAL, interval * (resolvedRetryPolicy.backoffFactor ?? DEFAULT_BACKOFF_FACTOR));
          const intervalWithJitter = resolvedRetryPolicy.jitter ? Math.floor(interval + Math.random() * 1e3) : interval;
          await new Promise((resolve) => setTimeout(resolve, intervalWithJitter));
          const errorName = error.name ?? error.constructor.unminifiable_name ?? error.constructor.name;
          if (resolvedRetryPolicy?.logWarning ?? true) console.log(`Retrying task "${String(pregelTask.name)}" after ${interval.toFixed(2)}ms (attempt ${attempts}) after ${errorName}: ${error}`);
          config = require_index.patchConfigurable(config, { [require_constants5.CONFIG_KEY_RESUMING]: true });
        }
      }
      return {
        task: pregelTask,
        result,
        error,
        signalAborted: signal?.aborted
      };
    }
    exports2._runWithRetry = _runWithRetry;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/runner.cjs
var require_runner = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/runner.cjs"(exports2) {
    var require_errors10 = require_errors5();
    var require_constants5 = require_constants4();
    var require_types10 = require_types7();
    var require_index = require_utils9();
    var require_retry4 = require_retry3();
    var PROMISE_ADDED_SYMBOL = Symbol.for("promiseAdded");
    function createPromiseBarrier() {
      const barrier = {
        next: () => void 0,
        wait: Promise.resolve(PROMISE_ADDED_SYMBOL)
      };
      function waitHandler(resolve) {
        barrier.next = () => {
          barrier.wait = new Promise(waitHandler);
          resolve(PROMISE_ADDED_SYMBOL);
        };
      }
      barrier.wait = new Promise(waitHandler);
      return barrier;
    }
    var PregelRunner = class {
      nodeFinished;
      loop;
      /**
      * Construct a new PregelRunner, which executes tasks from the provided PregelLoop.
      * @param loop - The PregelLoop that produces tasks for this runner to execute.
      */
      constructor({ loop, nodeFinished }) {
        this.loop = loop;
        this.nodeFinished = nodeFinished;
      }
      /**
      * Execute tasks from the current step of the PregelLoop.
      *
      * Note: this method does NOT call {@link PregelLoop}#tick. That must be handled externally.
      * @param options - Options for the execution.
      */
      async tick(options = {}) {
        const { timeout, retryPolicy, onStepWrite, maxConcurrency } = options;
        const nodeErrors = /* @__PURE__ */ new Set();
        let graphBubbleUp;
        const exceptionSignalController = new AbortController();
        const exceptionSignal = exceptionSignalController.signal;
        const stepTimeoutSignal = timeout ? AbortSignal.timeout(timeout) : void 0;
        const pendingTasks = Object.values(this.loop.tasks).filter((t) => t.writes.length === 0);
        const { signals, disposeCombinedSignal } = this._initializeAbortSignals({
          exceptionSignal,
          stepTimeoutSignal,
          signal: options.signal
        });
        const taskStream = this._executeTasksWithRetry(pendingTasks, {
          signals,
          retryPolicy,
          maxConcurrency
        });
        for await (const { task, error, signalAborted } of taskStream) {
          this._commit(task, error);
          if (require_errors10.isGraphInterrupt(error)) graphBubbleUp = error;
          else if (require_errors10.isGraphBubbleUp(error) && !require_errors10.isGraphInterrupt(graphBubbleUp)) graphBubbleUp = error;
          else if (error && (nodeErrors.size === 0 || !signalAborted)) {
            exceptionSignalController.abort();
            nodeErrors.add(error);
          }
        }
        disposeCombinedSignal?.();
        onStepWrite?.(this.loop.step, Object.values(this.loop.tasks).map((task) => task.writes).flat());
        if (nodeErrors.size === 1) throw Array.from(nodeErrors)[0];
        else if (nodeErrors.size > 1) throw new AggregateError(Array.from(nodeErrors), `Multiple errors occurred during superstep ${this.loop.step}. See the "errors" field of this exception for more details.`);
        if (require_errors10.isGraphInterrupt(graphBubbleUp)) throw graphBubbleUp;
        if (require_errors10.isGraphBubbleUp(graphBubbleUp) && this.loop.isNested) throw graphBubbleUp;
      }
      /**
      * Initializes the current AbortSignals for the PregelRunner, handling the various ways that
      * AbortSignals must be chained together so that the PregelLoop can be interrupted if necessary
      * while still allowing nodes to gracefully exit.
      *
      * This method must only be called once per PregelRunner#tick. It has the side effect of updating
      * the PregelLoop#config with the new AbortSignals so they may be propagated correctly to future
      * ticks and subgraph calls.
      *
      * @param options - Options for the initialization.
      * @returns The current abort signals.
      * @internal
      */
      _initializeAbortSignals({ exceptionSignal, stepTimeoutSignal, signal }) {
        const previousSignals = this.loop.config.configurable?.[require_constants5.CONFIG_KEY_ABORT_SIGNALS] ?? {};
        const externalAbortSignal = previousSignals.externalAbortSignal ?? signal;
        const timeoutAbortSignal = stepTimeoutSignal ?? previousSignals.timeoutAbortSignal;
        const { signal: composedAbortSignal, dispose: disposeCombinedSignal } = require_index.combineAbortSignals(externalAbortSignal, timeoutAbortSignal, exceptionSignal);
        const signals = {
          externalAbortSignal,
          timeoutAbortSignal,
          composedAbortSignal
        };
        this.loop.config = require_index.patchConfigurable(this.loop.config, { [require_constants5.CONFIG_KEY_ABORT_SIGNALS]: signals });
        return {
          signals,
          disposeCombinedSignal
        };
      }
      /**
      * Concurrently executes tasks with the requested retry policy, yielding a {@link SettledPregelTask} for each task as it completes.
      * @param tasks - The tasks to execute.
      * @param options - Options for the execution.
      */
      async *_executeTasksWithRetry(tasks, options) {
        const { retryPolicy, maxConcurrency, signals } = options ?? {};
        const barrier = createPromiseBarrier();
        const executingTasksMap = {};
        const thisCall = {
          executingTasksMap,
          barrier,
          retryPolicy,
          scheduleTask: async (task, writeIdx, call$1) => this.loop.acceptPush(task, writeIdx, call$1)
        };
        if (signals?.composedAbortSignal?.aborted) throw new Error("Abort");
        let startedTasksCount = 0;
        let listener;
        const timeoutOrCancelSignal = require_index.combineAbortSignals(signals?.externalAbortSignal, signals?.timeoutAbortSignal);
        const abortPromise = timeoutOrCancelSignal.signal ? new Promise((_resolve, reject) => {
          listener = () => reject(/* @__PURE__ */ new Error("Abort"));
          timeoutOrCancelSignal.signal?.addEventListener("abort", listener, { once: true });
        }) : void 0;
        while ((startedTasksCount === 0 || Object.keys(executingTasksMap).length > 0) && tasks.length) {
          for (; Object.values(executingTasksMap).length < (maxConcurrency ?? tasks.length) && startedTasksCount < tasks.length; startedTasksCount += 1) {
            const task = tasks[startedTasksCount];
            executingTasksMap[task.id] = require_retry4._runWithRetry(task, retryPolicy, { [require_constants5.CONFIG_KEY_CALL]: call?.bind(thisCall, this, task) }, signals?.composedAbortSignal).catch((error) => {
              return {
                task,
                error,
                signalAborted: signals?.composedAbortSignal?.aborted
              };
            });
          }
          const settledTask = await Promise.race([
            ...Object.values(executingTasksMap),
            ...abortPromise ? [abortPromise] : [],
            barrier.wait
          ]);
          if (settledTask === PROMISE_ADDED_SYMBOL) continue;
          yield settledTask;
          if (listener != null) {
            timeoutOrCancelSignal.signal?.removeEventListener("abort", listener);
            timeoutOrCancelSignal.dispose?.();
          }
          delete executingTasksMap[settledTask.task.id];
        }
      }
      /**
      * Determines what writes to apply based on whether the task completed successfully, and what type of error occurred.
      *
      * Throws an error if the error is a {@link GraphBubbleUp} error and {@link PregelLoop}#isNested is true.
      *
      * @param task - The task to commit.
      * @param error - The error that occurred, if any.
      */
      _commit(task, error) {
        if (error !== void 0) if (require_errors10.isGraphInterrupt(error)) {
          if (error.interrupts.length) {
            const interrupts = error.interrupts.map((interrupt) => [require_constants5.INTERRUPT, interrupt]);
            const resumes = task.writes.filter((w) => w[0] === require_constants5.RESUME);
            if (resumes.length) interrupts.push(...resumes);
            this.loop.putWrites(task.id, interrupts);
          }
        } else if (require_errors10.isGraphBubbleUp(error) && task.writes.length) this.loop.putWrites(task.id, task.writes);
        else this.loop.putWrites(task.id, [[require_constants5.ERROR, {
          message: error.message,
          name: error.name
        }]]);
        else {
          if (this.nodeFinished && (task.config?.tags == null || !task.config.tags.includes(require_constants5.TAG_HIDDEN))) this.nodeFinished(String(task.name));
          if (task.writes.length === 0) task.writes.push([require_constants5.NO_WRITES, null]);
          this.loop.putWrites(task.id, task.writes);
        }
      }
    };
    async function call(runner, task, func, name, input, options = {}) {
      const scratchpad = task.config?.configurable?.[require_constants5.CONFIG_KEY_SCRATCHPAD];
      if (!scratchpad) throw new Error(`BUG: No scratchpad found on task ${task.name}__${task.id}`);
      const cnt = scratchpad.callCounter;
      scratchpad.callCounter += 1;
      const wcall = new require_types10.Call({
        func,
        name,
        input,
        cache: options.cache,
        retry: options.retry,
        callbacks: options.callbacks
      });
      const nextTask = await this.scheduleTask(task, cnt, wcall);
      if (!nextTask) return void 0;
      const existingPromise = this.executingTasksMap[nextTask.id];
      if (existingPromise !== void 0) return existingPromise;
      if (nextTask.writes.length > 0) {
        const returns = nextTask.writes.filter(([c]) => c === require_constants5.RETURN);
        const errors = nextTask.writes.filter(([c]) => c === require_constants5.ERROR);
        if (returns.length > 0) {
          if (returns.length === 1) return Promise.resolve(returns[0][1]);
          throw new Error(`BUG: multiple returns found for task ${nextTask.name}__${nextTask.id}`);
        }
        if (errors.length > 0) {
          if (errors.length === 1) {
            const errorValue = errors[0][1];
            const error = errorValue instanceof Error ? errorValue : new Error(String(errorValue));
            return Promise.reject(error);
          }
          throw new Error(`BUG: multiple errors found for task ${nextTask.name}__${nextTask.id}`);
        }
        return void 0;
      } else {
        const prom = require_retry4._runWithRetry(nextTask, options.retry, { [require_constants5.CONFIG_KEY_CALL]: call.bind(this, runner, nextTask) });
        this.executingTasksMap[nextTask.id] = prom;
        this.barrier.next();
        return prom.then(({ result, error }) => {
          if (error) return Promise.reject(error);
          return result;
        });
      }
    }
    exports2.PregelRunner = PregelRunner;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/validate.cjs
var require_validate2 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/validate.cjs"(exports2) {
    var require_constants5 = require_constants4();
    var require_read2 = require_read();
    var GraphValidationError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "GraphValidationError";
      }
    };
    function validateGraph({ nodes, channels, inputChannels, outputChannels, streamChannels, interruptAfterNodes, interruptBeforeNodes }) {
      if (!channels) throw new GraphValidationError("Channels not provided");
      const subscribedChannels = /* @__PURE__ */ new Set();
      const allOutputChannels = /* @__PURE__ */ new Set();
      for (const [name, node] of Object.entries(nodes)) {
        if (name === require_constants5.INTERRUPT) throw new GraphValidationError(`"Node name ${require_constants5.INTERRUPT} is reserved"`);
        if (node.constructor === require_read2.PregelNode) node.triggers.forEach((trigger) => subscribedChannels.add(trigger));
        else throw new GraphValidationError(`Invalid node type ${typeof node}, expected PregelNode`);
      }
      for (const chan of subscribedChannels) if (!(chan in channels)) throw new GraphValidationError(`Subscribed channel '${String(chan)}' not in channels`);
      if (!Array.isArray(inputChannels)) {
        if (!subscribedChannels.has(inputChannels)) throw new GraphValidationError(`Input channel ${String(inputChannels)} is not subscribed to by any node`);
      } else if (inputChannels.every((channel2) => !subscribedChannels.has(channel2))) throw new GraphValidationError(`None of the input channels ${inputChannels} are subscribed to by any node`);
      if (!Array.isArray(outputChannels)) allOutputChannels.add(outputChannels);
      else outputChannels.forEach((chan) => allOutputChannels.add(chan));
      if (streamChannels && !Array.isArray(streamChannels)) allOutputChannels.add(streamChannels);
      else if (Array.isArray(streamChannels)) streamChannels.forEach((chan) => allOutputChannels.add(chan));
      for (const chan of allOutputChannels) if (!(chan in channels)) throw new GraphValidationError(`Output channel '${String(chan)}' not in channels`);
      if (interruptAfterNodes && interruptAfterNodes !== "*") {
        for (const node of interruptAfterNodes) if (!(node in nodes)) throw new GraphValidationError(`Node ${String(node)} not in nodes`);
      }
      if (interruptBeforeNodes && interruptBeforeNodes !== "*") {
        for (const node of interruptBeforeNodes) if (!(node in nodes)) throw new GraphValidationError(`Node ${String(node)} not in nodes`);
      }
    }
    function validateKeys(keys, channels) {
      if (Array.isArray(keys)) {
        for (const key of keys) if (!(key in channels)) throw new Error(`Key ${String(key)} not found in channels`);
      } else if (!(keys in channels)) throw new Error(`Key ${String(keys)} not found in channels`);
    }
    exports2.validateGraph = validateGraph;
    exports2.validateKeys = validateKeys;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/channels/topic.cjs
var require_topic = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/channels/topic.cjs"(exports2) {
    var require_errors10 = require_errors5();
    var require_base18 = require_base17();
    var Topic = class Topic2 extends require_base18.BaseChannel {
      lc_graph_name = "Topic";
      unique = false;
      accumulate = false;
      seen;
      values;
      constructor(fields) {
        super();
        this.unique = fields?.unique ?? this.unique;
        this.accumulate = fields?.accumulate ?? this.accumulate;
        this.seen = /* @__PURE__ */ new Set();
        this.values = [];
      }
      fromCheckpoint(checkpoint) {
        const empty = new Topic2({
          unique: this.unique,
          accumulate: this.accumulate
        });
        if (typeof checkpoint !== "undefined") {
          empty.seen = new Set(checkpoint[0]);
          empty.values = checkpoint[1];
        }
        return empty;
      }
      update(values) {
        let updated = false;
        if (!this.accumulate) {
          updated = this.values.length > 0;
          this.values = [];
        }
        const flatValues = values.flat();
        if (flatValues.length > 0) if (this.unique) {
          for (const value of flatValues) if (!this.seen.has(value)) {
            updated = true;
            this.seen.add(value);
            this.values.push(value);
          }
        } else {
          updated = true;
          this.values.push(...flatValues);
        }
        return updated;
      }
      get() {
        if (this.values.length === 0) throw new require_errors10.EmptyChannelError();
        return this.values;
      }
      checkpoint() {
        return [[...this.seen], this.values];
      }
      isAvailable() {
        return this.values.length !== 0;
      }
    };
    exports2.Topic = Topic;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/index.cjs
var require_pregel = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/pregel/index.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime3();
    var require_errors10 = require_errors5();
    var require_base18 = require_base17();
    var require_constants5 = require_constants4();
    var require_config3 = require_config2();
    var require_utils10 = require_utils8();
    var require_write2 = require_write();
    var require_read2 = require_read();
    var require_io2 = require_io();
    var require_index = require_utils9();
    var require_algo2 = require_algo();
    var require_subgraph2 = require_subgraph();
    var require_debug3 = require_debug2();
    var require_stream5 = require_stream3();
    var require_loop2 = require_loop();
    var require_messages4 = require_messages3();
    var require_runner2 = require_runner();
    var require_validate4 = require_validate2();
    var require_topic2 = require_topic();
    var require_interrupt2 = require_interrupt();
    var __langchain_langgraph_checkpoint = require_rolldown_runtime5.__toESM(require_dist4());
    var __langchain_core_runnables = require_rolldown_runtime5.__toESM(require_runnables());
    var Channel = class {
      static subscribeTo(channels, options) {
        const { key, tags } = {
          key: void 0,
          tags: void 0,
          ...options ?? {}
        };
        if (Array.isArray(channels) && key !== void 0) throw new Error("Can't specify a key when subscribing to multiple channels");
        let channelMappingOrArray;
        if (typeof channels === "string") if (key) channelMappingOrArray = { [key]: channels };
        else channelMappingOrArray = [channels];
        else channelMappingOrArray = Object.fromEntries(channels.map((chan) => [chan, chan]));
        const triggers = Array.isArray(channels) ? channels : [channels];
        return new require_read2.PregelNode({
          channels: channelMappingOrArray,
          triggers,
          tags
        });
      }
      /**
      * Creates a ChannelWrite that specifies how to write values to channels.
      * This is used to define how nodes send output to channels.
      *
      * @example
      * ```typescript
      * // Write to multiple channels
      * const write = Channel.writeTo(["output", "state"]);
      *
      * // Write with specific values
      * const write = Channel.writeTo(["output"], {
      *   state: "completed",
      *   result: calculateResult()
      * });
      *
      * // Write with a transformation function
      * const write = Channel.writeTo(["output"], {
      *   result: (x) => processResult(x)
      * });
      * ```
      *
      * @param channels - Array of channel names to write to
      * @param writes - Optional map of channel names to values or transformations
      * @returns A ChannelWrite object that can be used to write to the specified channels
      */
      static writeTo(channels, writes) {
        const channelWriteEntries = [];
        for (const channel2 of channels) channelWriteEntries.push({
          channel: channel2,
          value: require_write2.PASSTHROUGH,
          skipNone: false
        });
        for (const [key, value] of Object.entries(writes ?? {})) if (__langchain_core_runnables.Runnable.isRunnable(value) || typeof value === "function") channelWriteEntries.push({
          channel: key,
          value: require_write2.PASSTHROUGH,
          skipNone: true,
          mapper: (0, __langchain_core_runnables._coerceToRunnable)(value)
        });
        else channelWriteEntries.push({
          channel: key,
          value,
          skipNone: false
        });
        return new require_write2.ChannelWrite(channelWriteEntries);
      }
    };
    var PartialRunnable = class extends __langchain_core_runnables.Runnable {
      lc_namespace = ["langgraph", "pregel"];
      invoke(_input, _options) {
        throw new Error("Not implemented");
      }
      withConfig(_config) {
        return super.withConfig(_config);
      }
      stream(input, options) {
        return super.stream(input, options);
      }
    };
    var Pregel = class extends PartialRunnable {
      /**
      * Name of the class when serialized
      * @internal
      */
      static lc_name() {
        return "LangGraph";
      }
      /** @internal LangChain namespace for serialization necessary because Pregel extends Runnable */
      lc_namespace = ["langgraph", "pregel"];
      /** @internal Flag indicating this is a Pregel instance - necessary for serialization */
      lg_is_pregel = true;
      /** The nodes in the graph, mapping node names to their PregelNode instances */
      nodes;
      /** The channels in the graph, mapping channel names to their BaseChannel or ManagedValueSpec instances */
      channels;
      /**
      * The input channels for the graph. These channels receive the initial input when the graph is invoked.
      * Can be a single channel key or an array of channel keys.
      */
      inputChannels;
      /**
      * The output channels for the graph. These channels contain the final output when the graph completes.
      * Can be a single channel key or an array of channel keys.
      */
      outputChannels;
      /** Whether to automatically validate the graph structure when it is compiled. Defaults to true. */
      autoValidate = true;
      /**
      * The streaming modes enabled for this graph. Defaults to ["values"].
      * Supported modes:
      * - "values": Streams the full state after each step
      * - "updates": Streams state updates after each step
      * - "messages": Streams messages from within nodes
      * - "custom": Streams custom events from within nodes
      * - "debug": Streams events related to the execution of the graph - useful for tracing & debugging graph execution
      */
      streamMode = ["values"];
      /**
      * Optional channels to stream. If not specified, all channels will be streamed.
      * Can be a single channel key or an array of channel keys.
      */
      streamChannels;
      /**
      * Optional array of node names or "all" to interrupt after executing these nodes.
      * Used for implementing human-in-the-loop workflows.
      */
      interruptAfter;
      /**
      * Optional array of node names or "all" to interrupt before executing these nodes.
      * Used for implementing human-in-the-loop workflows.
      */
      interruptBefore;
      /** Optional timeout in milliseconds for the execution of each superstep */
      stepTimeout;
      /** Whether to enable debug logging. Defaults to false. */
      debug = false;
      /**
      * Optional checkpointer for persisting graph state.
      * When provided, saves a checkpoint of the graph state at every superstep.
      * When false or undefined, checkpointing is disabled, and the graph will not be able to save or restore state.
      */
      checkpointer;
      /** Optional retry policy for handling failures in node execution */
      retryPolicy;
      /** The default configuration for graph execution, can be overridden on a per-invocation basis */
      config;
      /**
      * Optional long-term memory store for the graph, allows for persistence & retrieval of data across threads
      */
      store;
      /**
      * Optional cache for the graph, useful for caching tasks.
      */
      cache;
      /**
      * Optional interrupt helper function.
      * @internal
      */
      userInterrupt;
      /**
      * The trigger to node mapping for the graph run.
      * @internal
      */
      triggerToNodes = {};
      /**
      * Constructor for Pregel - meant for internal use only.
      *
      * @internal
      */
      constructor(fields) {
        super(fields);
        let { streamMode } = fields;
        if (streamMode != null && !Array.isArray(streamMode)) streamMode = [streamMode];
        this.nodes = fields.nodes;
        this.channels = fields.channels;
        if (require_constants5.TASKS in this.channels && "lc_graph_name" in this.channels[require_constants5.TASKS] && this.channels[require_constants5.TASKS].lc_graph_name !== "Topic") throw new Error(`Channel '${require_constants5.TASKS}' is reserved and cannot be used in the graph.`);
        else this.channels[require_constants5.TASKS] = new require_topic2.Topic({ accumulate: false });
        this.autoValidate = fields.autoValidate ?? this.autoValidate;
        this.streamMode = streamMode ?? this.streamMode;
        this.inputChannels = fields.inputChannels;
        this.outputChannels = fields.outputChannels;
        this.streamChannels = fields.streamChannels ?? this.streamChannels;
        this.interruptAfter = fields.interruptAfter;
        this.interruptBefore = fields.interruptBefore;
        this.stepTimeout = fields.stepTimeout ?? this.stepTimeout;
        this.debug = fields.debug ?? this.debug;
        this.checkpointer = fields.checkpointer;
        this.retryPolicy = fields.retryPolicy;
        this.config = fields.config;
        this.store = fields.store;
        this.cache = fields.cache;
        this.name = fields.name;
        this.triggerToNodes = fields.triggerToNodes ?? this.triggerToNodes;
        this.userInterrupt = fields.userInterrupt;
        if (this.autoValidate) this.validate();
      }
      /**
      * Creates a new instance of the Pregel graph with updated configuration.
      * This method follows the immutable pattern - instead of modifying the current instance,
      * it returns a new instance with the merged configuration.
      *
      * @example
      * ```typescript
      * // Create a new instance with debug enabled
      * const debugGraph = graph.withConfig({ debug: true });
      *
      * // Create a new instance with a specific thread ID
      * const threadGraph = graph.withConfig({
      *   configurable: { thread_id: "123" }
      * });
      * ```
      *
      * @param config - The configuration to merge with the current configuration
      * @returns A new Pregel instance with the merged configuration
      */
      withConfig(config) {
        const mergedConfig = (0, __langchain_core_runnables.mergeConfigs)(this.config, config);
        return new this.constructor({
          ...this,
          config: mergedConfig
        });
      }
      /**
      * Validates the graph structure to ensure it is well-formed.
      * Checks for:
      * - No orphaned nodes
      * - Valid input/output channel configurations
      * - Valid interrupt configurations
      *
      * @returns this - The Pregel instance for method chaining
      * @throws {GraphValidationError} If the graph structure is invalid
      */
      validate() {
        require_validate4.validateGraph({
          nodes: this.nodes,
          channels: this.channels,
          outputChannels: this.outputChannels,
          inputChannels: this.inputChannels,
          streamChannels: this.streamChannels,
          interruptAfterNodes: this.interruptAfter,
          interruptBeforeNodes: this.interruptBefore
        });
        for (const [name, node] of Object.entries(this.nodes)) for (const trigger of node.triggers) {
          this.triggerToNodes[trigger] ??= [];
          this.triggerToNodes[trigger].push(name);
        }
        return this;
      }
      /**
      * Gets a list of all channels that should be streamed.
      * If streamChannels is specified, returns those channels.
      * Otherwise, returns all channels in the graph.
      *
      * @returns Array of channel keys to stream
      */
      get streamChannelsList() {
        if (Array.isArray(this.streamChannels)) return this.streamChannels;
        else if (this.streamChannels) return [this.streamChannels];
        else return Object.keys(this.channels);
      }
      /**
      * Gets the channels to stream in their original format.
      * If streamChannels is specified, returns it as-is (either single key or array).
      * Otherwise, returns all channels in the graph as an array.
      *
      * @returns Channel keys to stream, either as a single key or array
      */
      get streamChannelsAsIs() {
        if (this.streamChannels) return this.streamChannels;
        else return Object.keys(this.channels);
      }
      /**
      * Gets a drawable representation of the graph structure.
      * This is an async version of getGraph() and is the preferred method to use.
      *
      * @param config - Configuration for generating the graph visualization
      * @returns A representation of the graph that can be visualized
      */
      async getGraphAsync(config) {
        return this.getGraph(config);
      }
      /**
      * Gets all subgraphs within this graph.
      * A subgraph is a Pregel instance that is nested within a node of this graph.
      *
      * @deprecated Use getSubgraphsAsync instead. The async method will become the default in the next minor release.
      * @param namespace - Optional namespace to filter subgraphs
      * @param recurse - Whether to recursively get subgraphs of subgraphs
      * @returns Generator yielding tuples of [name, subgraph]
      */
      *getSubgraphs(namespace, recurse) {
        for (const [name, node] of Object.entries(this.nodes)) {
          if (namespace !== void 0) {
            if (!namespace.startsWith(name)) continue;
          }
          const candidates = node.subgraphs?.length ? node.subgraphs : [node.bound];
          for (const candidate of candidates) {
            const graph = require_subgraph2.findSubgraphPregel(candidate);
            if (graph !== void 0) {
              if (name === namespace) {
                yield [name, graph];
                return;
              }
              if (namespace === void 0) yield [name, graph];
              if (recurse) {
                let newNamespace = namespace;
                if (namespace !== void 0) newNamespace = namespace.slice(name.length + 1);
                for (const [subgraphName, subgraph] of graph.getSubgraphs(newNamespace, recurse)) yield [`${name}${require_constants5.CHECKPOINT_NAMESPACE_SEPARATOR}${subgraphName}`, subgraph];
              }
            }
          }
        }
      }
      /**
      * Gets all subgraphs within this graph asynchronously.
      * A subgraph is a Pregel instance that is nested within a node of this graph.
      *
      * @param namespace - Optional namespace to filter subgraphs
      * @param recurse - Whether to recursively get subgraphs of subgraphs
      * @returns AsyncGenerator yielding tuples of [name, subgraph]
      */
      async *getSubgraphsAsync(namespace, recurse) {
        yield* this.getSubgraphs(namespace, recurse);
      }
      /**
      * Prepares a state snapshot from saved checkpoint data.
      * This is an internal method used by getState and getStateHistory.
      *
      * @param config - Configuration for preparing the snapshot
      * @param saved - Optional saved checkpoint data
      * @param subgraphCheckpointer - Optional checkpointer for subgraphs
      * @param applyPendingWrites - Whether to apply pending writes to tasks and then to channels
      * @returns A snapshot of the graph state
      * @internal
      */
      async _prepareStateSnapshot({ config, saved, subgraphCheckpointer, applyPendingWrites = false }) {
        if (saved === void 0) return {
          values: {},
          next: [],
          config,
          tasks: []
        };
        const channels = require_base18.emptyChannels(this.channels, saved.checkpoint);
        if (saved.pendingWrites?.length) {
          const nullWrites = saved.pendingWrites.filter(([taskId, _]) => taskId === require_constants5.NULL_TASK_ID).map(([_, channel2, value]) => [String(channel2), value]);
          if (nullWrites.length > 0) require_algo2._applyWrites(saved.checkpoint, channels, [{
            name: require_constants5.INPUT,
            writes: nullWrites,
            triggers: []
          }], void 0, this.triggerToNodes);
        }
        const nextTasks = Object.values(require_algo2._prepareNextTasks(saved.checkpoint, saved.pendingWrites, this.nodes, channels, saved.config, true, {
          step: (saved.metadata?.step ?? -1) + 1,
          store: this.store
        }));
        const subgraphs = await require_utils10.gatherIterator(this.getSubgraphsAsync());
        const parentNamespace = saved.config.configurable?.checkpoint_ns ?? "";
        const taskStates = {};
        for (const task of nextTasks) {
          const matchingSubgraph = subgraphs.find(([name]) => name === task.name);
          if (!matchingSubgraph) continue;
          let taskNs = `${String(task.name)}${require_constants5.CHECKPOINT_NAMESPACE_END}${task.id}`;
          if (parentNamespace) taskNs = `${parentNamespace}${require_constants5.CHECKPOINT_NAMESPACE_SEPARATOR}${taskNs}`;
          if (subgraphCheckpointer === void 0) {
            const config$1 = { configurable: {
              thread_id: saved.config.configurable?.thread_id,
              checkpoint_ns: taskNs
            } };
            taskStates[task.id] = config$1;
          } else {
            const subgraphConfig = { configurable: {
              [require_constants5.CONFIG_KEY_CHECKPOINTER]: subgraphCheckpointer,
              thread_id: saved.config.configurable?.thread_id,
              checkpoint_ns: taskNs
            } };
            const pregel = matchingSubgraph[1];
            taskStates[task.id] = await pregel.getState(subgraphConfig, { subgraphs: true });
          }
        }
        if (applyPendingWrites && saved.pendingWrites?.length) {
          const nextTaskById = Object.fromEntries(nextTasks.map((task) => [task.id, task]));
          for (const [taskId, channel2, value] of saved.pendingWrites) {
            if ([
              require_constants5.ERROR,
              require_constants5.INTERRUPT,
              __langchain_langgraph_checkpoint.SCHEDULED
            ].includes(channel2)) continue;
            if (!(taskId in nextTaskById)) continue;
            nextTaskById[taskId].writes.push([String(channel2), value]);
          }
          const tasksWithWrites$1 = nextTasks.filter((task) => task.writes.length > 0);
          if (tasksWithWrites$1.length > 0) require_algo2._applyWrites(saved.checkpoint, channels, tasksWithWrites$1, void 0, this.triggerToNodes);
        }
        let metadata = saved?.metadata;
        if (metadata && saved?.config?.configurable?.thread_id) metadata = {
          ...metadata,
          thread_id: saved.config.configurable.thread_id
        };
        const nextList = nextTasks.filter((task) => task.writes.length === 0).map((task) => task.name);
        return {
          values: require_io2.readChannels(channels, this.streamChannelsAsIs),
          next: nextList,
          tasks: require_debug3.tasksWithWrites(nextTasks, saved?.pendingWrites ?? [], taskStates, this.streamChannelsAsIs),
          metadata,
          config: require_index.patchCheckpointMap(saved.config, saved.metadata),
          createdAt: saved.checkpoint.ts,
          parentConfig: saved.parentConfig
        };
      }
      /**
      * Gets the current state of the graph.
      * Requires a checkpointer to be configured.
      *
      * @param config - Configuration for retrieving the state
      * @param options - Additional options
      * @returns A snapshot of the current graph state
      * @throws {GraphValueError} If no checkpointer is configured
      */
      async getState(config, options) {
        const checkpointer = config.configurable?.[require_constants5.CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;
        if (!checkpointer) throw new require_errors10.GraphValueError("No checkpointer set", { lc_error_code: "MISSING_CHECKPOINTER" });
        const checkpointNamespace = config.configurable?.checkpoint_ns ?? "";
        if (checkpointNamespace !== "" && config.configurable?.[require_constants5.CONFIG_KEY_CHECKPOINTER] === void 0) {
          const recastNamespace = require_config3.recastCheckpointNamespace(checkpointNamespace);
          for await (const [name, subgraph] of this.getSubgraphsAsync(recastNamespace, true)) if (name === recastNamespace) return await subgraph.getState(require_utils10.patchConfigurable(config, { [require_constants5.CONFIG_KEY_CHECKPOINTER]: checkpointer }), { subgraphs: options?.subgraphs });
          throw new Error(`Subgraph with namespace "${recastNamespace}" not found.`);
        }
        const mergedConfig = (0, __langchain_core_runnables.mergeConfigs)(this.config, config);
        const saved = await checkpointer.getTuple(config);
        const snapshot = await this._prepareStateSnapshot({
          config: mergedConfig,
          saved,
          subgraphCheckpointer: options?.subgraphs ? checkpointer : void 0,
          applyPendingWrites: !config.configurable?.checkpoint_id
        });
        return snapshot;
      }
      /**
      * Gets the history of graph states.
      * Requires a checkpointer to be configured.
      * Useful for:
      * - Debugging execution history
      * - Implementing time travel
      * - Analyzing graph behavior
      *
      * @param config - Configuration for retrieving the history
      * @param options - Options for filtering the history
      * @returns An async iterator of state snapshots
      * @throws {Error} If no checkpointer is configured
      */
      async *getStateHistory(config, options) {
        const checkpointer = config.configurable?.[require_constants5.CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;
        if (!checkpointer) throw new require_errors10.GraphValueError("No checkpointer set", { lc_error_code: "MISSING_CHECKPOINTER" });
        const checkpointNamespace = config.configurable?.checkpoint_ns ?? "";
        if (checkpointNamespace !== "" && config.configurable?.[require_constants5.CONFIG_KEY_CHECKPOINTER] === void 0) {
          const recastNamespace = require_config3.recastCheckpointNamespace(checkpointNamespace);
          for await (const [name, pregel] of this.getSubgraphsAsync(recastNamespace, true)) if (name === recastNamespace) {
            yield* pregel.getStateHistory(require_utils10.patchConfigurable(config, { [require_constants5.CONFIG_KEY_CHECKPOINTER]: checkpointer }), options);
            return;
          }
          throw new Error(`Subgraph with namespace "${recastNamespace}" not found.`);
        }
        const mergedConfig = (0, __langchain_core_runnables.mergeConfigs)(this.config, config, { configurable: { checkpoint_ns: checkpointNamespace } });
        for await (const checkpointTuple of checkpointer.list(mergedConfig, options)) yield this._prepareStateSnapshot({
          config: checkpointTuple.config,
          saved: checkpointTuple
        });
      }
      /**
      * Apply updates to the graph state in bulk.
      * Requires a checkpointer to be configured.
      *
      * This method is useful for recreating a thread
      * from a list of updates, especially if a checkpoint
      * is created as a result of multiple tasks.
      *
      * @internal The API might change in the future.
      *
      * @param startConfig - Configuration for the update
      * @param updates - The list of updates to apply to graph state
      * @returns Updated configuration
      * @throws {GraphValueError} If no checkpointer is configured
      * @throws {InvalidUpdateError} If the update cannot be attributed to a node or an update can be only applied in sequence.
      */
      async bulkUpdateState(startConfig, supersteps) {
        const checkpointer = startConfig.configurable?.[require_constants5.CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;
        if (!checkpointer) throw new require_errors10.GraphValueError("No checkpointer set", { lc_error_code: "MISSING_CHECKPOINTER" });
        if (supersteps.length === 0) throw new Error("No supersteps provided");
        if (supersteps.some((s) => s.updates.length === 0)) throw new Error("No updates provided");
        const checkpointNamespace = startConfig.configurable?.checkpoint_ns ?? "";
        if (checkpointNamespace !== "" && startConfig.configurable?.[require_constants5.CONFIG_KEY_CHECKPOINTER] === void 0) {
          const recastNamespace = require_config3.recastCheckpointNamespace(checkpointNamespace);
          for await (const [, pregel] of this.getSubgraphsAsync(recastNamespace, true)) return await pregel.bulkUpdateState(require_utils10.patchConfigurable(startConfig, { [require_constants5.CONFIG_KEY_CHECKPOINTER]: checkpointer }), supersteps);
          throw new Error(`Subgraph "${recastNamespace}" not found`);
        }
        const updateSuperStep = async (inputConfig, updates) => {
          const config = this.config ? (0, __langchain_core_runnables.mergeConfigs)(this.config, inputConfig) : inputConfig;
          const saved = await checkpointer.getTuple(config);
          const checkpoint = saved !== void 0 ? (0, __langchain_langgraph_checkpoint.copyCheckpoint)(saved.checkpoint) : (0, __langchain_langgraph_checkpoint.emptyCheckpoint)();
          const checkpointPreviousVersions = { ...saved?.checkpoint.channel_versions };
          const step = saved?.metadata?.step ?? -1;
          let checkpointConfig = require_utils10.patchConfigurable(config, { checkpoint_ns: config.configurable?.checkpoint_ns ?? "" });
          let checkpointMetadata = config.metadata ?? {};
          if (saved?.config.configurable) {
            checkpointConfig = require_utils10.patchConfigurable(config, saved.config.configurable);
            checkpointMetadata = {
              ...saved.metadata,
              ...checkpointMetadata
            };
          }
          const { values, asNode } = updates[0];
          if (values == null && asNode === void 0) {
            if (updates.length > 1) throw new require_errors10.InvalidUpdateError(`Cannot create empty checkpoint with multiple updates`);
            const nextConfig$1 = await checkpointer.put(checkpointConfig, require_base18.createCheckpoint(checkpoint, void 0, step), {
              source: "update",
              step: step + 1,
              parents: saved?.metadata?.parents ?? {}
            }, {});
            return require_index.patchCheckpointMap(nextConfig$1, saved ? saved.metadata : void 0);
          }
          const channels = require_base18.emptyChannels(this.channels, checkpoint);
          if (values === null && asNode === require_constants5.END) {
            if (updates.length > 1) throw new require_errors10.InvalidUpdateError(`Cannot apply multiple updates when clearing state`);
            if (saved) {
              const nextTasks = require_algo2._prepareNextTasks(checkpoint, saved.pendingWrites || [], this.nodes, channels, saved.config, true, {
                step: (saved.metadata?.step ?? -1) + 1,
                checkpointer,
                store: this.store
              });
              const nullWrites = (saved.pendingWrites || []).filter((w) => w[0] === require_constants5.NULL_TASK_ID).map((w) => w.slice(1));
              if (nullWrites.length > 0) require_algo2._applyWrites(checkpoint, channels, [{
                name: require_constants5.INPUT,
                writes: nullWrites,
                triggers: []
              }], checkpointer.getNextVersion.bind(checkpointer), this.triggerToNodes);
              for (const [taskId, k, v] of saved.pendingWrites || []) {
                if ([
                  require_constants5.ERROR,
                  require_constants5.INTERRUPT,
                  __langchain_langgraph_checkpoint.SCHEDULED
                ].includes(k)) continue;
                if (!(taskId in nextTasks)) continue;
                nextTasks[taskId].writes.push([k, v]);
              }
              require_algo2._applyWrites(checkpoint, channels, Object.values(nextTasks), checkpointer.getNextVersion.bind(checkpointer), this.triggerToNodes);
            }
            const nextConfig$1 = await checkpointer.put(checkpointConfig, require_base18.createCheckpoint(checkpoint, channels, step), {
              ...checkpointMetadata,
              source: "update",
              step: step + 1,
              parents: saved?.metadata?.parents ?? {}
            }, require_index.getNewChannelVersions(checkpointPreviousVersions, checkpoint.channel_versions));
            return require_index.patchCheckpointMap(nextConfig$1, saved ? saved.metadata : void 0);
          }
          if (asNode === require_constants5.COPY) {
            if (updates.length > 1) throw new require_errors10.InvalidUpdateError(`Cannot copy checkpoint with multiple updates`);
            if (saved == null) throw new require_errors10.InvalidUpdateError(`Cannot copy a non-existent checkpoint`);
            const isCopyWithUpdates = (values$1) => {
              if (!Array.isArray(values$1)) return false;
              if (values$1.length === 0) return false;
              return values$1.every((v) => Array.isArray(v) && v.length === 2);
            };
            const nextCheckpoint = require_base18.createCheckpoint(checkpoint, void 0, step);
            const nextConfig$1 = await checkpointer.put(saved.parentConfig ?? require_utils10.patchConfigurable(saved.config, { checkpoint_id: void 0 }), nextCheckpoint, {
              source: "fork",
              step: step + 1,
              parents: saved.metadata?.parents ?? {}
            }, {});
            if (isCopyWithUpdates(values)) {
              const nextTasks = require_algo2._prepareNextTasks(nextCheckpoint, saved.pendingWrites, this.nodes, channels, nextConfig$1, false, { step: step + 2 });
              const tasksGroupBy = Object.values(nextTasks).reduce((acc, { name, id }) => {
                acc[name] ??= [];
                acc[name].push({ id });
                return acc;
              }, {});
              const userGroupBy = values.reduce((acc, item) => {
                const [values$1, asNode$1] = item;
                acc[asNode$1] ??= [];
                const targetIdx = acc[asNode$1].length;
                const taskId = tasksGroupBy[asNode$1]?.[targetIdx]?.id;
                acc[asNode$1].push({
                  values: values$1,
                  asNode: asNode$1,
                  taskId
                });
                return acc;
              }, {});
              return updateSuperStep(require_index.patchCheckpointMap(nextConfig$1, saved.metadata), Object.values(userGroupBy).flat());
            }
            return require_index.patchCheckpointMap(nextConfig$1, saved.metadata);
          }
          if (asNode === require_constants5.INPUT) {
            if (updates.length > 1) throw new require_errors10.InvalidUpdateError(`Cannot apply multiple updates when updating as input`);
            const inputWrites = await require_utils10.gatherIterator(require_io2.mapInput(this.inputChannels, values));
            if (inputWrites.length === 0) throw new require_errors10.InvalidUpdateError(`Received no input writes for ${JSON.stringify(this.inputChannels, null, 2)}`);
            require_algo2._applyWrites(checkpoint, channels, [{
              name: require_constants5.INPUT,
              writes: inputWrites,
              triggers: []
            }], checkpointer.getNextVersion.bind(this.checkpointer), this.triggerToNodes);
            const nextStep = saved?.metadata?.step != null ? saved.metadata.step + 1 : -1;
            const nextConfig$1 = await checkpointer.put(checkpointConfig, require_base18.createCheckpoint(checkpoint, channels, nextStep), {
              source: "input",
              step: nextStep,
              parents: saved?.metadata?.parents ?? {}
            }, require_index.getNewChannelVersions(checkpointPreviousVersions, checkpoint.channel_versions));
            await checkpointer.putWrites(nextConfig$1, inputWrites, (0, __langchain_langgraph_checkpoint.uuid5)(require_constants5.INPUT, checkpoint.id));
            return require_index.patchCheckpointMap(nextConfig$1, saved ? saved.metadata : void 0);
          }
          if (config.configurable?.checkpoint_id === void 0 && saved?.pendingWrites !== void 0 && saved.pendingWrites.length > 0) {
            const nextTasks = require_algo2._prepareNextTasks(checkpoint, saved.pendingWrites, this.nodes, channels, saved.config, true, {
              store: this.store,
              checkpointer: this.checkpointer,
              step: (saved.metadata?.step ?? -1) + 1
            });
            const nullWrites = (saved.pendingWrites ?? []).filter((w) => w[0] === require_constants5.NULL_TASK_ID).map((w) => w.slice(1));
            if (nullWrites.length > 0) require_algo2._applyWrites(saved.checkpoint, channels, [{
              name: require_constants5.INPUT,
              writes: nullWrites,
              triggers: []
            }], void 0, this.triggerToNodes);
            for (const [tid, k, v] of saved.pendingWrites) {
              if ([
                require_constants5.ERROR,
                require_constants5.INTERRUPT,
                __langchain_langgraph_checkpoint.SCHEDULED
              ].includes(k) || nextTasks[tid] === void 0) continue;
              nextTasks[tid].writes.push([k, v]);
            }
            const tasks$1 = Object.values(nextTasks).filter((task) => {
              return task.writes.length > 0;
            });
            if (tasks$1.length > 0) require_algo2._applyWrites(checkpoint, channels, tasks$1, void 0, this.triggerToNodes);
          }
          const nonNullVersion = Object.values(checkpoint.versions_seen).map((seenVersions) => {
            return Object.values(seenVersions);
          }).flat().find((v) => !!v);
          const validUpdates = [];
          if (updates.length === 1) {
            let { values: values$1, asNode: asNode$1, taskId } = updates[0];
            if (asNode$1 === void 0 && Object.keys(this.nodes).length === 1) [asNode$1] = Object.keys(this.nodes);
            else if (asNode$1 === void 0 && nonNullVersion === void 0) {
              if (typeof this.inputChannels === "string" && this.nodes[this.inputChannels] !== void 0) asNode$1 = this.inputChannels;
            } else if (asNode$1 === void 0) {
              const lastSeenByNode = Object.entries(checkpoint.versions_seen).map(([n, seen]) => {
                return Object.values(seen).map((v) => {
                  return [v, n];
                });
              }).flat().filter(([_, v]) => v !== require_constants5.INTERRUPT).sort(([aNumber], [bNumber]) => (0, __langchain_langgraph_checkpoint.compareChannelVersions)(aNumber, bNumber));
              if (lastSeenByNode) {
                if (lastSeenByNode.length === 1) asNode$1 = lastSeenByNode[0][1];
                else if (lastSeenByNode[lastSeenByNode.length - 1][0] !== lastSeenByNode[lastSeenByNode.length - 2][0]) asNode$1 = lastSeenByNode[lastSeenByNode.length - 1][1];
              }
            }
            if (asNode$1 === void 0) throw new require_errors10.InvalidUpdateError(`Ambiguous update, specify "asNode"`);
            validUpdates.push({
              values: values$1,
              asNode: asNode$1,
              taskId
            });
          } else for (const { asNode: asNode$1, values: values$1, taskId } of updates) {
            if (asNode$1 == null) throw new require_errors10.InvalidUpdateError(`"asNode" is required when applying multiple updates`);
            validUpdates.push({
              values: values$1,
              asNode: asNode$1,
              taskId
            });
          }
          const tasks = [];
          for (const { asNode: asNode$1, values: values$1, taskId } of validUpdates) {
            if (this.nodes[asNode$1] === void 0) throw new require_errors10.InvalidUpdateError(`Node "${asNode$1.toString()}" does not exist`);
            const writers = this.nodes[asNode$1].getWriters();
            if (!writers.length) throw new require_errors10.InvalidUpdateError(`No writers found for node "${asNode$1.toString()}"`);
            tasks.push({
              name: asNode$1,
              input: values$1,
              proc: writers.length > 1 ? __langchain_core_runnables.RunnableSequence.from(writers, { omitSequenceTags: true }) : writers[0],
              writes: [],
              triggers: [require_constants5.INTERRUPT],
              id: taskId ?? (0, __langchain_langgraph_checkpoint.uuid5)(require_constants5.INTERRUPT, checkpoint.id),
              writers: []
            });
          }
          for (const task of tasks) await task.proc.invoke(task.input, (0, __langchain_core_runnables.patchConfig)({
            ...config,
            store: config?.store ?? this.store
          }, {
            runName: config.runName ?? `${this.getName()}UpdateState`,
            configurable: {
              [require_constants5.CONFIG_KEY_SEND]: (items) => task.writes.push(...items),
              [require_constants5.CONFIG_KEY_READ]: (select_, fresh_ = false) => require_algo2._localRead(checkpoint, channels, task, select_, fresh_)
            }
          }));
          for (const task of tasks) {
            const channelWrites = task.writes.filter((w) => w[0] !== require_constants5.PUSH);
            if (saved !== void 0 && channelWrites.length > 0) await checkpointer.putWrites(checkpointConfig, channelWrites, task.id);
          }
          require_algo2._applyWrites(checkpoint, channels, tasks, checkpointer.getNextVersion.bind(this.checkpointer), this.triggerToNodes);
          const newVersions = require_index.getNewChannelVersions(checkpointPreviousVersions, checkpoint.channel_versions);
          const nextConfig = await checkpointer.put(checkpointConfig, require_base18.createCheckpoint(checkpoint, channels, step + 1), {
            source: "update",
            step: step + 1,
            parents: saved?.metadata?.parents ?? {}
          }, newVersions);
          for (const task of tasks) {
            const pushWrites = task.writes.filter((w) => w[0] === require_constants5.PUSH);
            if (pushWrites.length > 0) await checkpointer.putWrites(nextConfig, pushWrites, task.id);
          }
          return require_index.patchCheckpointMap(nextConfig, saved ? saved.metadata : void 0);
        };
        let currentConfig = startConfig;
        for (const { updates } of supersteps) currentConfig = await updateSuperStep(currentConfig, updates);
        return currentConfig;
      }
      /**
      * Updates the state of the graph with new values.
      * Requires a checkpointer to be configured.
      *
      * This method can be used for:
      * - Implementing human-in-the-loop workflows
      * - Modifying graph state during breakpoints
      * - Integrating external inputs into the graph
      *
      * @param inputConfig - Configuration for the update
      * @param values - The values to update the state with
      * @param asNode - Optional node name to attribute the update to
      * @returns Updated configuration
      * @throws {GraphValueError} If no checkpointer is configured
      * @throws {InvalidUpdateError} If the update cannot be attributed to a node
      */
      async updateState(inputConfig, values, asNode) {
        return this.bulkUpdateState(inputConfig, [{ updates: [{
          values,
          asNode
        }] }]);
      }
      /**
      * Gets the default values for various graph configuration options.
      * This is an internal method used to process and normalize configuration options.
      *
      * @param config - The input configuration options
      * @returns A tuple containing normalized values for:
      * - debug mode
      * - stream modes
      * - input keys
      * - output keys
      * - remaining config
      * - interrupt before nodes
      * - interrupt after nodes
      * - checkpointer
      * - store
      * - whether stream mode is single
      * - node cache
      * - whether checkpoint during is enabled
      * @internal
      */
      _defaults(config) {
        const { debug, streamMode, inputKeys, outputKeys, interruptAfter, interruptBefore, ...rest } = config;
        let streamModeSingle = true;
        const defaultDebug = debug !== void 0 ? debug : this.debug;
        let defaultOutputKeys = outputKeys;
        if (defaultOutputKeys === void 0) defaultOutputKeys = this.streamChannelsAsIs;
        else require_validate4.validateKeys(defaultOutputKeys, this.channels);
        let defaultInputKeys = inputKeys;
        if (defaultInputKeys === void 0) defaultInputKeys = this.inputChannels;
        else require_validate4.validateKeys(defaultInputKeys, this.channels);
        const defaultInterruptBefore = interruptBefore ?? this.interruptBefore ?? [];
        const defaultInterruptAfter = interruptAfter ?? this.interruptAfter ?? [];
        let defaultStreamMode;
        if (streamMode !== void 0) {
          defaultStreamMode = Array.isArray(streamMode) ? streamMode : [streamMode];
          streamModeSingle = typeof streamMode === "string";
        } else {
          if (config.configurable?.[require_constants5.CONFIG_KEY_TASK_ID] !== void 0) defaultStreamMode = ["values"];
          else defaultStreamMode = this.streamMode;
          streamModeSingle = true;
        }
        let defaultCheckpointer;
        if (this.checkpointer === false) defaultCheckpointer = void 0;
        else if (config !== void 0 && config.configurable?.[require_constants5.CONFIG_KEY_CHECKPOINTER] !== void 0) defaultCheckpointer = config.configurable[require_constants5.CONFIG_KEY_CHECKPOINTER];
        else if (this.checkpointer === true) throw new Error("checkpointer: true cannot be used for root graphs.");
        else defaultCheckpointer = this.checkpointer;
        const defaultStore = config.store ?? this.store;
        const defaultCache = config.cache ?? this.cache;
        if (config.durability != null && config.checkpointDuring != null) throw new Error("Cannot use both `durability` and `checkpointDuring` at the same time.");
        const checkpointDuringDurability = (() => {
          if (config.checkpointDuring == null) return void 0;
          if (config.checkpointDuring === false) return "exit";
          return "async";
        })();
        const defaultDurability = config.durability ?? checkpointDuringDurability ?? config?.configurable?.[require_constants5.CONFIG_KEY_DURABILITY] ?? "async";
        return [
          defaultDebug,
          defaultStreamMode,
          defaultInputKeys,
          defaultOutputKeys,
          rest,
          defaultInterruptBefore,
          defaultInterruptAfter,
          defaultCheckpointer,
          defaultStore,
          streamModeSingle,
          defaultCache,
          defaultDurability
        ];
      }
      /**
      * Streams the execution of the graph, emitting state updates as they occur.
      * This is the primary method for observing graph execution in real-time.
      *
      * Stream modes:
      * - "values": Emits complete state after each step
      * - "updates": Emits only state changes after each step
      * - "debug": Emits detailed debug information
      * - "messages": Emits messages from within nodes
      * - "custom": Emits custom events from within nodes
      * - "checkpoints": Emits checkpoints from within nodes
      * - "tasks": Emits tasks from within nodes
      *
      * @param input - The input to start graph execution with
      * @param options - Configuration options for streaming
      * @returns An async iterable stream of graph state updates
      */
      async stream(input, options) {
        const abortController = new AbortController();
        const config = {
          recursionLimit: this.config?.recursionLimit,
          ...options,
          signal: require_index.combineAbortSignals(options?.signal, abortController.signal).signal
        };
        const stream = await super.stream(input, config);
        return new require_stream5.IterableReadableStreamWithAbortSignal(options?.encoding === "text/event-stream" ? require_stream5.toEventStream(stream) : stream, abortController);
      }
      streamEvents(input, options, streamOptions) {
        const abortController = new AbortController();
        const config = {
          recursionLimit: this.config?.recursionLimit,
          ...options,
          callbacks: require_index.combineCallbacks(this.config?.callbacks, options?.callbacks),
          signal: require_index.combineAbortSignals(options?.signal, abortController.signal).signal
        };
        return new require_stream5.IterableReadableStreamWithAbortSignal(super.streamEvents(input, config, streamOptions), abortController);
      }
      /**
      * Validates the input for the graph.
      * @param input - The input to validate
      * @returns The validated input
      * @internal
      */
      async _validateInput(input) {
        return input;
      }
      /**
      * Validates the context options for the graph.
      * @param context - The context options to validate
      * @returns The validated context options
      * @internal
      */
      async _validateContext(context) {
        return context;
      }
      /**
      * Internal iterator used by stream() to generate state updates.
      * This method handles the core logic of graph execution and streaming.
      *
      * @param input - The input to start graph execution with
      * @param options - Configuration options for streaming
      * @returns AsyncGenerator yielding state updates
      * @internal
      */
      async *_streamIterator(input, options) {
        const streamEncoding = "version" in (options ?? {}) ? void 0 : options?.encoding ?? void 0;
        const streamSubgraphs = options?.subgraphs;
        const inputConfig = require_config3.ensureLangGraphConfig(this.config, options);
        if (inputConfig.recursionLimit === void 0 || inputConfig.recursionLimit < 1) throw new Error(`Passed "recursionLimit" must be at least 1.`);
        if (this.checkpointer !== void 0 && this.checkpointer !== false && inputConfig.configurable === void 0) throw new Error(`Checkpointer requires one or more of the following "configurable" keys: "thread_id", "checkpoint_ns", "checkpoint_id"`);
        const validInput = await this._validateInput(input);
        const { runId, ...restConfig } = inputConfig;
        const [debug, streamMode, , outputKeys, config, interruptBefore, interruptAfter, checkpointer, store, streamModeSingle, cache, durability] = this._defaults(restConfig);
        if (typeof config.context !== "undefined") config.context = await this._validateContext(config.context);
        else config.configurable = await this._validateContext(config.configurable);
        const stream = new require_stream5.IterableReadableWritableStream({ modes: new Set(streamMode) });
        if (this.checkpointer === true) {
          config.configurable ??= {};
          const ns = config.configurable[require_constants5.CONFIG_KEY_CHECKPOINT_NS] ?? "";
          config.configurable[require_constants5.CONFIG_KEY_CHECKPOINT_NS] = ns.split(require_constants5.CHECKPOINT_NAMESPACE_SEPARATOR).map((part) => part.split(require_constants5.CHECKPOINT_NAMESPACE_END)[0]).join(require_constants5.CHECKPOINT_NAMESPACE_SEPARATOR);
        }
        if (streamMode.includes("messages")) {
          const messageStreamer = new require_messages4.StreamMessagesHandler((chunk) => stream.push(chunk));
          const { callbacks } = config;
          if (callbacks === void 0) config.callbacks = [messageStreamer];
          else if (Array.isArray(callbacks)) config.callbacks = callbacks.concat(messageStreamer);
          else {
            const copiedCallbacks = callbacks.copy();
            copiedCallbacks.addHandler(messageStreamer, true);
            config.callbacks = copiedCallbacks;
          }
        }
        config.writer ??= (chunk) => {
          if (!streamMode.includes("custom")) return;
          const ns = require_config3.getConfig()?.configurable?.[require_constants5.CONFIG_KEY_CHECKPOINT_NS]?.split(require_constants5.CHECKPOINT_NAMESPACE_SEPARATOR).slice(0, -1);
          stream.push([
            ns ?? [],
            "custom",
            chunk
          ]);
        };
        config.interrupt ??= this.userInterrupt ?? require_interrupt2.interrupt;
        const callbackManager = await (0, __langchain_core_runnables.getCallbackManagerForConfig)(config);
        const runManager = await callbackManager?.handleChainStart(this.toJSON(), require_index._coerceToDict(input, "input"), runId, void 0, void 0, void 0, config?.runName ?? this.getName());
        const channelSpecs = require_base18.getOnlyChannels(this.channels);
        let loop;
        let loopError;
        const createAndRunLoop = async () => {
          try {
            loop = await require_loop2.PregelLoop.initialize({
              input: validInput,
              config,
              checkpointer,
              nodes: this.nodes,
              channelSpecs,
              outputKeys,
              streamKeys: this.streamChannelsAsIs,
              store,
              cache,
              stream,
              interruptAfter,
              interruptBefore,
              manager: runManager,
              debug: this.debug,
              triggerToNodes: this.triggerToNodes,
              durability
            });
            const runner = new require_runner2.PregelRunner({
              loop,
              nodeFinished: config.configurable?.[require_constants5.CONFIG_KEY_NODE_FINISHED]
            });
            if (options?.subgraphs) loop.config.configurable = {
              ...loop.config.configurable,
              [require_constants5.CONFIG_KEY_STREAM]: loop.stream
            };
            await this._runLoop({
              loop,
              runner,
              debug,
              config
            });
            if (durability === "sync") await Promise.all(loop?.checkpointerPromises ?? []);
          } catch (e) {
            loopError = e;
          } finally {
            try {
              if (loop) {
                await loop.store?.stop();
                await loop.cache?.stop();
              }
              await Promise.all(loop?.checkpointerPromises ?? []);
            } catch (e) {
              loopError = loopError ?? e;
            }
            if (loopError) stream.error(loopError);
            else stream.close();
          }
        };
        const runLoopPromise = createAndRunLoop();
        try {
          for await (const chunk of stream) {
            if (chunk === void 0) throw new Error("Data structure error.");
            const [namespace, mode, payload] = chunk;
            if (streamMode.includes(mode)) {
              if (streamEncoding === "text/event-stream") {
                if (streamSubgraphs) yield [
                  namespace,
                  mode,
                  payload
                ];
                else yield [
                  null,
                  mode,
                  payload
                ];
                continue;
              }
              if (streamSubgraphs && !streamModeSingle) yield [
                namespace,
                mode,
                payload
              ];
              else if (!streamModeSingle) yield [mode, payload];
              else if (streamSubgraphs) yield [namespace, payload];
              else yield payload;
            }
          }
        } catch (e) {
          await runManager?.handleChainError(loopError);
          throw e;
        } finally {
          await runLoopPromise;
        }
        await runManager?.handleChainEnd(loop?.output ?? {}, runId, void 0, void 0, void 0);
      }
      /**
      * Run the graph with a single input and config.
      * @param input The input to the graph.
      * @param options The configuration to use for the run.
      */
      async invoke(input, options) {
        const streamMode = options?.streamMode ?? "values";
        const config = {
          ...options,
          outputKeys: options?.outputKeys ?? this.outputChannels,
          streamMode,
          encoding: void 0
        };
        const chunks = [];
        const stream = await this.stream(input, config);
        const interruptChunks = [];
        let latest;
        for await (const chunk of stream) if (streamMode === "values") if (require_constants5.isInterrupted(chunk)) interruptChunks.push(chunk[require_constants5.INTERRUPT]);
        else latest = chunk;
        else chunks.push(chunk);
        if (streamMode === "values") {
          if (interruptChunks.length > 0) {
            const interrupts = interruptChunks.flat(1);
            if (latest == null) return { [require_constants5.INTERRUPT]: interrupts };
            if (typeof latest === "object") return {
              ...latest,
              [require_constants5.INTERRUPT]: interrupts
            };
          }
          return latest;
        }
        return chunks;
      }
      async _runLoop(params) {
        const { loop, runner, debug, config } = params;
        let tickError;
        try {
          while (await loop.tick({ inputKeys: this.inputChannels })) {
            for (const { task } of await loop._matchCachedWrites()) loop._outputWrites(task.id, task.writes, true);
            if (debug) require_debug3.printStepCheckpoint(loop.checkpointMetadata.step, loop.channels, this.streamChannelsList);
            if (debug) require_debug3.printStepTasks(loop.step, Object.values(loop.tasks));
            await runner.tick({
              timeout: this.stepTimeout,
              retryPolicy: this.retryPolicy,
              onStepWrite: (step, writes) => {
                if (debug) require_debug3.printStepWrites(step, writes, this.streamChannelsList);
              },
              maxConcurrency: config.maxConcurrency,
              signal: config.signal
            });
          }
          if (loop.status === "out_of_steps") throw new require_errors10.GraphRecursionError([
            `Recursion limit of ${config.recursionLimit} reached`,
            "without hitting a stop condition. You can increase the",
            `limit by setting the "recursionLimit" config key.`
          ].join(" "), { lc_error_code: "GRAPH_RECURSION_LIMIT" });
        } catch (e) {
          tickError = e;
          const suppress = await loop.finishAndHandleError(tickError);
          if (!suppress) throw e;
        } finally {
          if (tickError === void 0) await loop.finishAndHandleError();
        }
      }
      async clearCache() {
        await this.cache?.clear([]);
      }
    };
    exports2.Channel = Channel;
    exports2.Pregel = Pregel;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/channels/ephemeral_value.cjs
var require_ephemeral_value = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/channels/ephemeral_value.cjs"(exports2) {
    var require_errors10 = require_errors5();
    var require_base18 = require_base17();
    var EphemeralValue = class EphemeralValue2 extends require_base18.BaseChannel {
      lc_graph_name = "EphemeralValue";
      guard;
      value = [];
      constructor(guard = true) {
        super();
        this.guard = guard;
      }
      fromCheckpoint(checkpoint) {
        const empty = new EphemeralValue2(this.guard);
        if (typeof checkpoint !== "undefined") empty.value = [checkpoint];
        return empty;
      }
      update(values) {
        if (values.length === 0) {
          const updated = this.value.length > 0;
          this.value = [];
          return updated;
        }
        if (values.length !== 1 && this.guard) throw new require_errors10.InvalidUpdateError("EphemeralValue can only receive one value per step.");
        this.value = [values[values.length - 1]];
        return true;
      }
      get() {
        if (this.value.length === 0) throw new require_errors10.EmptyChannelError();
        return this.value[0];
      }
      checkpoint() {
        if (this.value.length === 0) throw new require_errors10.EmptyChannelError();
        return this.value[0];
      }
      isAvailable() {
        return this.value.length !== 0;
      }
    };
    exports2.EphemeralValue = EphemeralValue;
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/core.cjs
var require_core4 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/core.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.globalConfig = exports2.$ZodAsyncError = exports2.$brand = exports2.NEVER = void 0;
    exports2.$constructor = $constructor;
    exports2.config = config;
    exports2.NEVER = Object.freeze({
      status: "aborted"
    });
    function $constructor(name, initializer, params) {
      function init(inst, def) {
        var _a;
        Object.defineProperty(inst, "_zod", {
          value: inst._zod ?? {},
          enumerable: false
        });
        (_a = inst._zod).traits ?? (_a.traits = /* @__PURE__ */ new Set());
        inst._zod.traits.add(name);
        initializer(inst, def);
        for (const k in _.prototype) {
          if (!(k in inst))
            Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
        }
        inst._zod.constr = _;
        inst._zod.def = def;
      }
      const Parent = params?.Parent ?? Object;
      class Definition extends Parent {
      }
      Object.defineProperty(Definition, "name", { value: name });
      function _(def) {
        var _a;
        const inst = params?.Parent ? new Definition() : this;
        init(inst, def);
        (_a = inst._zod).deferred ?? (_a.deferred = []);
        for (const fn of inst._zod.deferred) {
          fn();
        }
        return inst;
      }
      Object.defineProperty(_, "init", { value: init });
      Object.defineProperty(_, Symbol.hasInstance, {
        value: (inst) => {
          if (params?.Parent && inst instanceof params.Parent)
            return true;
          return inst?._zod?.traits?.has(name);
        }
      });
      Object.defineProperty(_, "name", { value: name });
      return _;
    }
    exports2.$brand = Symbol("zod_brand");
    var $ZodAsyncError = class extends Error {
      constructor() {
        super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
      }
    };
    exports2.$ZodAsyncError = $ZodAsyncError;
    exports2.globalConfig = {};
    function config(newConfig) {
      if (newConfig)
        Object.assign(exports2.globalConfig, newConfig);
      return exports2.globalConfig;
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/util.cjs
var require_util3 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/util.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Class = exports2.BIGINT_FORMAT_RANGES = exports2.NUMBER_FORMAT_RANGES = exports2.primitiveTypes = exports2.propertyKeyTypes = exports2.getParsedType = exports2.allowsEval = exports2.captureStackTrace = void 0;
    exports2.assertEqual = assertEqual;
    exports2.assertNotEqual = assertNotEqual;
    exports2.assertIs = assertIs;
    exports2.assertNever = assertNever;
    exports2.assert = assert;
    exports2.getEnumValues = getEnumValues;
    exports2.joinValues = joinValues;
    exports2.jsonStringifyReplacer = jsonStringifyReplacer;
    exports2.cached = cached;
    exports2.nullish = nullish;
    exports2.cleanRegex = cleanRegex;
    exports2.floatSafeRemainder = floatSafeRemainder;
    exports2.defineLazy = defineLazy;
    exports2.assignProp = assignProp;
    exports2.getElementAtPath = getElementAtPath;
    exports2.promiseAllObject = promiseAllObject;
    exports2.randomString = randomString;
    exports2.esc = esc;
    exports2.isObject = isObject;
    exports2.isPlainObject = isPlainObject;
    exports2.numKeys = numKeys;
    exports2.escapeRegex = escapeRegex;
    exports2.clone = clone;
    exports2.normalizeParams = normalizeParams;
    exports2.createTransparentProxy = createTransparentProxy;
    exports2.stringifyPrimitive = stringifyPrimitive;
    exports2.optionalKeys = optionalKeys;
    exports2.pick = pick;
    exports2.omit = omit;
    exports2.extend = extend;
    exports2.merge = merge;
    exports2.partial = partial;
    exports2.required = required;
    exports2.aborted = aborted;
    exports2.prefixIssues = prefixIssues;
    exports2.unwrapMessage = unwrapMessage;
    exports2.finalizeIssue = finalizeIssue;
    exports2.getSizableOrigin = getSizableOrigin;
    exports2.getLengthableOrigin = getLengthableOrigin;
    exports2.issue = issue;
    exports2.cleanEnum = cleanEnum;
    function assertEqual(val) {
      return val;
    }
    function assertNotEqual(val) {
      return val;
    }
    function assertIs(_arg) {
    }
    function assertNever(_x) {
      throw new Error();
    }
    function assert(_) {
    }
    function getEnumValues(entries) {
      const numericValues = Object.values(entries).filter((v) => typeof v === "number");
      const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
      return values;
    }
    function joinValues(array, separator = "|") {
      return array.map((val) => stringifyPrimitive(val)).join(separator);
    }
    function jsonStringifyReplacer(_, value) {
      if (typeof value === "bigint")
        return value.toString();
      return value;
    }
    function cached(getter) {
      const set = false;
      return {
        get value() {
          if (!set) {
            const value = getter();
            Object.defineProperty(this, "value", { value });
            return value;
          }
          throw new Error("cached value already set");
        }
      };
    }
    function nullish(input) {
      return input === null || input === void 0;
    }
    function cleanRegex(source) {
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      return source.slice(start, end);
    }
    function floatSafeRemainder(val, step) {
      const valDecCount = (val.toString().split(".")[1] || "").length;
      const stepDecCount = (step.toString().split(".")[1] || "").length;
      const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
      const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
      const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
      return valInt % stepInt / 10 ** decCount;
    }
    function defineLazy(object, key, getter) {
      const set = false;
      Object.defineProperty(object, key, {
        get() {
          if (!set) {
            const value = getter();
            object[key] = value;
            return value;
          }
          throw new Error("cached value already set");
        },
        set(v) {
          Object.defineProperty(object, key, {
            value: v
            // configurable: true,
          });
        },
        configurable: true
      });
    }
    function assignProp(target, prop, value) {
      Object.defineProperty(target, prop, {
        value,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
    function getElementAtPath(obj, path) {
      if (!path)
        return obj;
      return path.reduce((acc, key) => acc?.[key], obj);
    }
    function promiseAllObject(promisesObj) {
      const keys = Object.keys(promisesObj);
      const promises = keys.map((key) => promisesObj[key]);
      return Promise.all(promises).then((results) => {
        const resolvedObj = {};
        for (let i = 0; i < keys.length; i++) {
          resolvedObj[keys[i]] = results[i];
        }
        return resolvedObj;
      });
    }
    function randomString(length = 10) {
      const chars = "abcdefghijklmnopqrstuvwxyz";
      let str = "";
      for (let i = 0; i < length; i++) {
        str += chars[Math.floor(Math.random() * chars.length)];
      }
      return str;
    }
    function esc(str) {
      return JSON.stringify(str);
    }
    exports2.captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {
    };
    function isObject(data) {
      return typeof data === "object" && data !== null && !Array.isArray(data);
    }
    exports2.allowsEval = cached(() => {
      if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
        return false;
      }
      try {
        const F = Function;
        new F("");
        return true;
      } catch (_) {
        return false;
      }
    });
    function isPlainObject(o) {
      if (isObject(o) === false)
        return false;
      const ctor = o.constructor;
      if (ctor === void 0)
        return true;
      const prot = ctor.prototype;
      if (isObject(prot) === false)
        return false;
      if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
        return false;
      }
      return true;
    }
    function numKeys(data) {
      let keyCount = 0;
      for (const key in data) {
        if (Object.prototype.hasOwnProperty.call(data, key)) {
          keyCount++;
        }
      }
      return keyCount;
    }
    var getParsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return "undefined";
        case "string":
          return "string";
        case "number":
          return Number.isNaN(data) ? "nan" : "number";
        case "boolean":
          return "boolean";
        case "function":
          return "function";
        case "bigint":
          return "bigint";
        case "symbol":
          return "symbol";
        case "object":
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return "promise";
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return "map";
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return "set";
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return "date";
          }
          if (typeof File !== "undefined" && data instanceof File) {
            return "file";
          }
          return "object";
        default:
          throw new Error(`Unknown data type: ${t}`);
      }
    };
    exports2.getParsedType = getParsedType;
    exports2.propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
    exports2.primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
    function escapeRegex(str) {
      return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function clone(inst, def, params) {
      const cl = new inst._zod.constr(def ?? inst._zod.def);
      if (!def || params?.parent)
        cl._zod.parent = inst;
      return cl;
    }
    function normalizeParams(_params) {
      const params = _params;
      if (!params)
        return {};
      if (typeof params === "string")
        return { error: () => params };
      if (params?.message !== void 0) {
        if (params?.error !== void 0)
          throw new Error("Cannot specify both `message` and `error` params");
        params.error = params.message;
      }
      delete params.message;
      if (typeof params.error === "string")
        return { ...params, error: () => params.error };
      return params;
    }
    function createTransparentProxy(getter) {
      let target;
      return new Proxy({}, {
        get(_, prop, receiver) {
          target ?? (target = getter());
          return Reflect.get(target, prop, receiver);
        },
        set(_, prop, value, receiver) {
          target ?? (target = getter());
          return Reflect.set(target, prop, value, receiver);
        },
        has(_, prop) {
          target ?? (target = getter());
          return Reflect.has(target, prop);
        },
        deleteProperty(_, prop) {
          target ?? (target = getter());
          return Reflect.deleteProperty(target, prop);
        },
        ownKeys(_) {
          target ?? (target = getter());
          return Reflect.ownKeys(target);
        },
        getOwnPropertyDescriptor(_, prop) {
          target ?? (target = getter());
          return Reflect.getOwnPropertyDescriptor(target, prop);
        },
        defineProperty(_, prop, descriptor) {
          target ?? (target = getter());
          return Reflect.defineProperty(target, prop, descriptor);
        }
      });
    }
    function stringifyPrimitive(value) {
      if (typeof value === "bigint")
        return value.toString() + "n";
      if (typeof value === "string")
        return `"${value}"`;
      return `${value}`;
    }
    function optionalKeys(shape) {
      return Object.keys(shape).filter((k) => {
        return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
      });
    }
    exports2.NUMBER_FORMAT_RANGES = {
      safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
      int32: [-2147483648, 2147483647],
      uint32: [0, 4294967295],
      float32: [-34028234663852886e22, 34028234663852886e22],
      float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
    };
    exports2.BIGINT_FORMAT_RANGES = {
      int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
      uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
    };
    function pick(schema, mask) {
      const newShape = {};
      const currDef = schema._zod.def;
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      return clone(schema, {
        ...schema._zod.def,
        shape: newShape,
        checks: []
      });
    }
    function omit(schema, mask) {
      const newShape = { ...schema._zod.def.shape };
      const currDef = schema._zod.def;
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      return clone(schema, {
        ...schema._zod.def,
        shape: newShape,
        checks: []
      });
    }
    function extend(schema, shape) {
      if (!isPlainObject(shape)) {
        throw new Error("Invalid input to extend: expected a plain object");
      }
      const def = {
        ...schema._zod.def,
        get shape() {
          const _shape = { ...schema._zod.def.shape, ...shape };
          assignProp(this, "shape", _shape);
          return _shape;
        },
        checks: []
        // delete existing checks
      };
      return clone(schema, def);
    }
    function merge(a, b) {
      return clone(a, {
        ...a._zod.def,
        get shape() {
          const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
          assignProp(this, "shape", _shape);
          return _shape;
        },
        catchall: b._zod.def.catchall,
        checks: []
        // delete existing checks
      });
    }
    function partial(Class2, schema, mask) {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      return clone(schema, {
        ...schema._zod.def,
        shape,
        checks: []
      });
    }
    function required(Class2, schema, mask) {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      return clone(schema, {
        ...schema._zod.def,
        shape,
        // optional: [],
        checks: []
      });
    }
    function aborted(x, startIndex = 0) {
      for (let i = startIndex; i < x.issues.length; i++) {
        if (x.issues[i]?.continue !== true)
          return true;
      }
      return false;
    }
    function prefixIssues(path, issues) {
      return issues.map((iss) => {
        var _a;
        (_a = iss).path ?? (_a.path = []);
        iss.path.unshift(path);
        return iss;
      });
    }
    function unwrapMessage(message) {
      return typeof message === "string" ? message : message?.message;
    }
    function finalizeIssue(iss, ctx, config) {
      const full = { ...iss, path: iss.path ?? [] };
      if (!iss.message) {
        const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config.customError?.(iss)) ?? unwrapMessage(config.localeError?.(iss)) ?? "Invalid input";
        full.message = message;
      }
      delete full.inst;
      delete full.continue;
      if (!ctx?.reportInput) {
        delete full.input;
      }
      return full;
    }
    function getSizableOrigin(input) {
      if (input instanceof Set)
        return "set";
      if (input instanceof Map)
        return "map";
      if (input instanceof File)
        return "file";
      return "unknown";
    }
    function getLengthableOrigin(input) {
      if (Array.isArray(input))
        return "array";
      if (typeof input === "string")
        return "string";
      return "unknown";
    }
    function issue(...args) {
      const [iss, input, inst] = args;
      if (typeof iss === "string") {
        return {
          message: iss,
          code: "custom",
          input,
          inst
        };
      }
      return { ...iss };
    }
    function cleanEnum(obj) {
      return Object.entries(obj).filter(([k, _]) => {
        return Number.isNaN(Number.parseInt(k, 10));
      }).map((el) => el[1]);
    }
    var Class = class {
      constructor(..._args) {
      }
    };
    exports2.Class = Class;
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/errors.cjs
var require_errors6 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/errors.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.$ZodRealError = exports2.$ZodError = void 0;
    exports2.flattenError = flattenError;
    exports2.formatError = formatError;
    exports2.treeifyError = treeifyError;
    exports2.toDotPath = toDotPath;
    exports2.prettifyError = prettifyError;
    var core_js_1 = require_core4();
    var util = __importStar(require_util3());
    var initializer = (inst, def) => {
      inst.name = "$ZodError";
      Object.defineProperty(inst, "_zod", {
        value: inst._zod,
        enumerable: false
      });
      Object.defineProperty(inst, "issues", {
        value: def,
        enumerable: false
      });
      Object.defineProperty(inst, "message", {
        get() {
          return JSON.stringify(def, util.jsonStringifyReplacer, 2);
        },
        enumerable: true
        // configurable: false,
      });
      Object.defineProperty(inst, "toString", {
        value: () => inst.message,
        enumerable: false
      });
    };
    exports2.$ZodError = (0, core_js_1.$constructor)("$ZodError", initializer);
    exports2.$ZodRealError = (0, core_js_1.$constructor)("$ZodError", initializer, { Parent: Error });
    function flattenError(error, mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of error.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    function formatError(error, _mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error2) => {
        for (const issue of error2.issues) {
          if (issue.code === "invalid_union" && issue.errors.length) {
            issue.errors.map((issues) => processError({ issues }));
          } else if (issue.code === "invalid_key") {
            processError({ issues: issue.issues });
          } else if (issue.code === "invalid_element") {
            processError({ issues: issue.issues });
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(error);
      return fieldErrors;
    }
    function treeifyError(error, _mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const result = { errors: [] };
      const processError = (error2, path = []) => {
        var _a, _b;
        for (const issue of error2.issues) {
          if (issue.code === "invalid_union" && issue.errors.length) {
            issue.errors.map((issues) => processError({ issues }, issue.path));
          } else if (issue.code === "invalid_key") {
            processError({ issues: issue.issues }, issue.path);
          } else if (issue.code === "invalid_element") {
            processError({ issues: issue.issues }, issue.path);
          } else {
            const fullpath = [...path, ...issue.path];
            if (fullpath.length === 0) {
              result.errors.push(mapper(issue));
              continue;
            }
            let curr = result;
            let i = 0;
            while (i < fullpath.length) {
              const el = fullpath[i];
              const terminal = i === fullpath.length - 1;
              if (typeof el === "string") {
                curr.properties ?? (curr.properties = {});
                (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });
                curr = curr.properties[el];
              } else {
                curr.items ?? (curr.items = []);
                (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
                curr = curr.items[el];
              }
              if (terminal) {
                curr.errors.push(mapper(issue));
              }
              i++;
            }
          }
        }
      };
      processError(error);
      return result;
    }
    function toDotPath(path) {
      const segs = [];
      for (const seg of path) {
        if (typeof seg === "number")
          segs.push(`[${seg}]`);
        else if (typeof seg === "symbol")
          segs.push(`[${JSON.stringify(String(seg))}]`);
        else if (/[^\w$]/.test(seg))
          segs.push(`[${JSON.stringify(seg)}]`);
        else {
          if (segs.length)
            segs.push(".");
          segs.push(seg);
        }
      }
      return segs.join("");
    }
    function prettifyError(error) {
      const lines = [];
      const issues = [...error.issues].sort((a, b) => a.path.length - b.path.length);
      for (const issue of issues) {
        lines.push(`\u2716 ${issue.message}`);
        if (issue.path?.length)
          lines.push(`  \u2192 at ${toDotPath(issue.path)}`);
      }
      return lines.join("\n");
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/parse.cjs
var require_parse4 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/parse.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.safeParseAsync = exports2._safeParseAsync = exports2.safeParse = exports2._safeParse = exports2.parseAsync = exports2._parseAsync = exports2.parse = exports2._parse = void 0;
    var core = __importStar(require_core4());
    var errors = __importStar(require_errors6());
    var util = __importStar(require_util3());
    var _parse = (_Err) => (schema, value, _ctx, _params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
      const result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
        throw new core.$ZodAsyncError();
      }
      if (result.issues.length) {
        const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())));
        util.captureStackTrace(e, _params?.callee);
        throw e;
      }
      return result.value;
    };
    exports2._parse = _parse;
    exports2.parse = (0, exports2._parse)(errors.$ZodRealError);
    var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
        result = await result;
      if (result.issues.length) {
        const e = new (params?.Err ?? _Err)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())));
        util.captureStackTrace(e, params?.callee);
        throw e;
      }
      return result.value;
    };
    exports2._parseAsync = _parseAsync;
    exports2.parseAsync = (0, exports2._parseAsync)(errors.$ZodRealError);
    var _safeParse = (_Err) => (schema, value, _ctx) => {
      const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
      const result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
        throw new core.$ZodAsyncError();
      }
      return result.issues.length ? {
        success: false,
        error: new (_Err ?? errors.$ZodError)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())))
      } : { success: true, data: result.value };
    };
    exports2._safeParse = _safeParse;
    exports2.safeParse = (0, exports2._safeParse)(errors.$ZodRealError);
    var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
        result = await result;
      return result.issues.length ? {
        success: false,
        error: new _Err(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())))
      } : { success: true, data: result.value };
    };
    exports2._safeParseAsync = _safeParseAsync;
    exports2.safeParseAsync = (0, exports2._safeParseAsync)(errors.$ZodRealError);
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/regexes.cjs
var require_regexes2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/regexes.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uppercase = exports2.lowercase = exports2.undefined = exports2.null = exports2.boolean = exports2.number = exports2.integer = exports2.bigint = exports2.string = exports2.date = exports2.e164 = exports2.domain = exports2.hostname = exports2.base64url = exports2.base64 = exports2.cidrv6 = exports2.cidrv4 = exports2.ipv6 = exports2.ipv4 = exports2._emoji = exports2.browserEmail = exports2.unicodeEmail = exports2.rfc5322Email = exports2.html5Email = exports2.email = exports2.uuid7 = exports2.uuid6 = exports2.uuid4 = exports2.uuid = exports2.guid = exports2.extendedDuration = exports2.duration = exports2.nanoid = exports2.ksuid = exports2.xid = exports2.ulid = exports2.cuid2 = exports2.cuid = void 0;
    exports2.emoji = emoji;
    exports2.time = time;
    exports2.datetime = datetime;
    exports2.cuid = /^[cC][^\s-]{8,}$/;
    exports2.cuid2 = /^[0-9a-z]+$/;
    exports2.ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
    exports2.xid = /^[0-9a-vA-V]{20}$/;
    exports2.ksuid = /^[A-Za-z0-9]{27}$/;
    exports2.nanoid = /^[a-zA-Z0-9_-]{21}$/;
    exports2.duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
    exports2.extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    exports2.guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
    var uuid = (version2) => {
      if (!version2)
        return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
      return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
    };
    exports2.uuid = uuid;
    exports2.uuid4 = (0, exports2.uuid)(4);
    exports2.uuid6 = (0, exports2.uuid)(6);
    exports2.uuid7 = (0, exports2.uuid)(7);
    exports2.email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
    exports2.html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    exports2.rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    exports2.unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
    exports2.browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    exports2._emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    function emoji() {
      return new RegExp(exports2._emoji, "u");
    }
    exports2.ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    exports2.ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
    exports2.cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
    exports2.cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    exports2.base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
    exports2.base64url = /^[A-Za-z0-9_-]*$/;
    exports2.hostname = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
    exports2.domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
    exports2.e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
    var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
    exports2.date = new RegExp(`^${dateSource}$`);
    function timeSource(args) {
      const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
      const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
      return regex;
    }
    function time(args) {
      return new RegExp(`^${timeSource(args)}$`);
    }
    function datetime(args) {
      const time2 = timeSource({ precision: args.precision });
      const opts = ["Z"];
      if (args.local)
        opts.push("");
      if (args.offset)
        opts.push(`([+-]\\d{2}:\\d{2})`);
      const timeRegex = `${time2}(?:${opts.join("|")})`;
      return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
    }
    var string = (params) => {
      const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
      return new RegExp(`^${regex}$`);
    };
    exports2.string = string;
    exports2.bigint = /^\d+n?$/;
    exports2.integer = /^\d+$/;
    exports2.number = /^-?\d+(?:\.\d+)?/i;
    exports2.boolean = /true|false/i;
    var _null = /null/i;
    exports2.null = _null;
    var _undefined = /undefined/i;
    exports2.undefined = _undefined;
    exports2.lowercase = /^[^A-Z]*$/;
    exports2.uppercase = /^[^a-z]*$/;
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/checks.cjs
var require_checks3 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/checks.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.$ZodCheckOverwrite = exports2.$ZodCheckMimeType = exports2.$ZodCheckProperty = exports2.$ZodCheckEndsWith = exports2.$ZodCheckStartsWith = exports2.$ZodCheckIncludes = exports2.$ZodCheckUpperCase = exports2.$ZodCheckLowerCase = exports2.$ZodCheckRegex = exports2.$ZodCheckStringFormat = exports2.$ZodCheckLengthEquals = exports2.$ZodCheckMinLength = exports2.$ZodCheckMaxLength = exports2.$ZodCheckSizeEquals = exports2.$ZodCheckMinSize = exports2.$ZodCheckMaxSize = exports2.$ZodCheckBigIntFormat = exports2.$ZodCheckNumberFormat = exports2.$ZodCheckMultipleOf = exports2.$ZodCheckGreaterThan = exports2.$ZodCheckLessThan = exports2.$ZodCheck = void 0;
    var core = __importStar(require_core4());
    var regexes = __importStar(require_regexes2());
    var util = __importStar(require_util3());
    exports2.$ZodCheck = core.$constructor("$ZodCheck", (inst, def) => {
      var _a;
      inst._zod ?? (inst._zod = {});
      inst._zod.def = def;
      (_a = inst._zod).onattach ?? (_a.onattach = []);
    });
    var numericOriginMap = {
      number: "number",
      bigint: "bigint",
      object: "date"
    };
    exports2.$ZodCheckLessThan = core.$constructor("$ZodCheckLessThan", (inst, def) => {
      exports2.$ZodCheck.init(inst, def);
      const origin = numericOriginMap[typeof def.value];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
        if (def.value < curr) {
          if (def.inclusive)
            bag.maximum = def.value;
          else
            bag.exclusiveMaximum = def.value;
        }
      });
      inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
          return;
        }
        payload.issues.push({
          origin,
          code: "too_big",
          maximum: def.value,
          input: payload.value,
          inclusive: def.inclusive,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckGreaterThan = core.$constructor("$ZodCheckGreaterThan", (inst, def) => {
      exports2.$ZodCheck.init(inst, def);
      const origin = numericOriginMap[typeof def.value];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
        if (def.value > curr) {
          if (def.inclusive)
            bag.minimum = def.value;
          else
            bag.exclusiveMinimum = def.value;
        }
      });
      inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
          return;
        }
        payload.issues.push({
          origin,
          code: "too_small",
          minimum: def.value,
          input: payload.value,
          inclusive: def.inclusive,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckMultipleOf = /* @__PURE__ */ core.$constructor("$ZodCheckMultipleOf", (inst, def) => {
      exports2.$ZodCheck.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        var _a;
        (_a = inst2._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
      });
      inst._zod.check = (payload) => {
        if (typeof payload.value !== typeof def.value)
          throw new Error("Cannot mix number and bigint in multiple_of check.");
        const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : util.floatSafeRemainder(payload.value, def.value) === 0;
        if (isMultiple)
          return;
        payload.issues.push({
          origin: typeof payload.value,
          code: "not_multiple_of",
          divisor: def.value,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckNumberFormat = core.$constructor("$ZodCheckNumberFormat", (inst, def) => {
      exports2.$ZodCheck.init(inst, def);
      def.format = def.format || "float64";
      const isInt = def.format?.includes("int");
      const origin = isInt ? "int" : "number";
      const [minimum, maximum] = util.NUMBER_FORMAT_RANGES[def.format];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
        if (isInt)
          bag.pattern = regexes.integer;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        if (isInt) {
          if (!Number.isInteger(input)) {
            payload.issues.push({
              expected: origin,
              format: def.format,
              code: "invalid_type",
              input,
              inst
            });
            return;
          }
          if (!Number.isSafeInteger(input)) {
            if (input > 0) {
              payload.issues.push({
                input,
                code: "too_big",
                maximum: Number.MAX_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst,
                origin,
                continue: !def.abort
              });
            } else {
              payload.issues.push({
                input,
                code: "too_small",
                minimum: Number.MIN_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst,
                origin,
                continue: !def.abort
              });
            }
            return;
          }
        }
        if (input < minimum) {
          payload.issues.push({
            origin: "number",
            input,
            code: "too_small",
            minimum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
        if (input > maximum) {
          payload.issues.push({
            origin: "number",
            input,
            code: "too_big",
            maximum,
            inst
          });
        }
      };
    });
    exports2.$ZodCheckBigIntFormat = core.$constructor("$ZodCheckBigIntFormat", (inst, def) => {
      exports2.$ZodCheck.init(inst, def);
      const [minimum, maximum] = util.BIGINT_FORMAT_RANGES[def.format];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        if (input < minimum) {
          payload.issues.push({
            origin: "bigint",
            input,
            code: "too_small",
            minimum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
        if (input > maximum) {
          payload.issues.push({
            origin: "bigint",
            input,
            code: "too_big",
            maximum,
            inst
          });
        }
      };
    });
    exports2.$ZodCheckMaxSize = core.$constructor("$ZodCheckMaxSize", (inst, def) => {
      var _a;
      exports2.$ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !util.nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (def.maximum < curr)
          inst2._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size <= def.maximum)
          return;
        payload.issues.push({
          origin: util.getSizableOrigin(input),
          code: "too_big",
          maximum: def.maximum,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckMinSize = core.$constructor("$ZodCheckMinSize", (inst, def) => {
      var _a;
      exports2.$ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !util.nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (def.minimum > curr)
          inst2._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size >= def.minimum)
          return;
        payload.issues.push({
          origin: util.getSizableOrigin(input),
          code: "too_small",
          minimum: def.minimum,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckSizeEquals = core.$constructor("$ZodCheckSizeEquals", (inst, def) => {
      var _a;
      exports2.$ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !util.nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.minimum = def.size;
        bag.maximum = def.size;
        bag.size = def.size;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size === def.size)
          return;
        const tooBig = size > def.size;
        payload.issues.push({
          origin: util.getSizableOrigin(input),
          ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
          inclusive: true,
          exact: true,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckMaxLength = core.$constructor("$ZodCheckMaxLength", (inst, def) => {
      var _a;
      exports2.$ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !util.nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (def.maximum < curr)
          inst2._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length <= def.maximum)
          return;
        const origin = util.getLengthableOrigin(input);
        payload.issues.push({
          origin,
          code: "too_big",
          maximum: def.maximum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckMinLength = core.$constructor("$ZodCheckMinLength", (inst, def) => {
      var _a;
      exports2.$ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !util.nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (def.minimum > curr)
          inst2._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length >= def.minimum)
          return;
        const origin = util.getLengthableOrigin(input);
        payload.issues.push({
          origin,
          code: "too_small",
          minimum: def.minimum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckLengthEquals = core.$constructor("$ZodCheckLengthEquals", (inst, def) => {
      var _a;
      exports2.$ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !util.nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.minimum = def.length;
        bag.maximum = def.length;
        bag.length = def.length;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length === def.length)
          return;
        const origin = util.getLengthableOrigin(input);
        const tooBig = length > def.length;
        payload.issues.push({
          origin,
          ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
          inclusive: true,
          exact: true,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckStringFormat = core.$constructor("$ZodCheckStringFormat", (inst, def) => {
      var _a, _b;
      exports2.$ZodCheck.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        if (def.pattern) {
          bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
          bag.patterns.add(def.pattern);
        }
      });
      if (def.pattern)
        (_a = inst._zod).check ?? (_a.check = (payload) => {
          def.pattern.lastIndex = 0;
          if (def.pattern.test(payload.value))
            return;
          payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: def.format,
            input: payload.value,
            ...def.pattern ? { pattern: def.pattern.toString() } : {},
            inst,
            continue: !def.abort
          });
        });
      else
        (_b = inst._zod).check ?? (_b.check = () => {
        });
    });
    exports2.$ZodCheckRegex = core.$constructor("$ZodCheckRegex", (inst, def) => {
      exports2.$ZodCheckStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "regex",
          input: payload.value,
          pattern: def.pattern.toString(),
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckLowerCase = core.$constructor("$ZodCheckLowerCase", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.lowercase);
      exports2.$ZodCheckStringFormat.init(inst, def);
    });
    exports2.$ZodCheckUpperCase = core.$constructor("$ZodCheckUpperCase", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.uppercase);
      exports2.$ZodCheckStringFormat.init(inst, def);
    });
    exports2.$ZodCheckIncludes = core.$constructor("$ZodCheckIncludes", (inst, def) => {
      exports2.$ZodCheck.init(inst, def);
      const escapedRegex = util.escapeRegex(def.includes);
      const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
      def.pattern = pattern;
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.includes(def.includes, def.position))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "includes",
          includes: def.includes,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckStartsWith = core.$constructor("$ZodCheckStartsWith", (inst, def) => {
      exports2.$ZodCheck.init(inst, def);
      const pattern = new RegExp(`^${util.escapeRegex(def.prefix)}.*`);
      def.pattern ?? (def.pattern = pattern);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.startsWith(def.prefix))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "starts_with",
          prefix: def.prefix,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCheckEndsWith = core.$constructor("$ZodCheckEndsWith", (inst, def) => {
      exports2.$ZodCheck.init(inst, def);
      const pattern = new RegExp(`.*${util.escapeRegex(def.suffix)}$`);
      def.pattern ?? (def.pattern = pattern);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.endsWith(def.suffix))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "ends_with",
          suffix: def.suffix,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    function handleCheckPropertyResult(result, payload, property) {
      if (result.issues.length) {
        payload.issues.push(...util.prefixIssues(property, result.issues));
      }
    }
    exports2.$ZodCheckProperty = core.$constructor("$ZodCheckProperty", (inst, def) => {
      exports2.$ZodCheck.init(inst, def);
      inst._zod.check = (payload) => {
        const result = def.schema._zod.run({
          value: payload.value[def.property],
          issues: []
        }, {});
        if (result instanceof Promise) {
          return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
        }
        handleCheckPropertyResult(result, payload, def.property);
        return;
      };
    });
    exports2.$ZodCheckMimeType = core.$constructor("$ZodCheckMimeType", (inst, def) => {
      exports2.$ZodCheck.init(inst, def);
      const mimeSet = new Set(def.mime);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.mime = def.mime;
      });
      inst._zod.check = (payload) => {
        if (mimeSet.has(payload.value.type))
          return;
        payload.issues.push({
          code: "invalid_value",
          values: def.mime,
          input: payload.value.type,
          inst
        });
      };
    });
    exports2.$ZodCheckOverwrite = core.$constructor("$ZodCheckOverwrite", (inst, def) => {
      exports2.$ZodCheck.init(inst, def);
      inst._zod.check = (payload) => {
        payload.value = def.tx(payload.value);
      };
    });
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/doc.cjs
var require_doc2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/doc.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Doc = void 0;
    var Doc = class {
      constructor(args = []) {
        this.content = [];
        this.indent = 0;
        if (this)
          this.args = args;
      }
      indented(fn) {
        this.indent += 1;
        fn(this);
        this.indent -= 1;
      }
      write(arg) {
        if (typeof arg === "function") {
          arg(this, { execution: "sync" });
          arg(this, { execution: "async" });
          return;
        }
        const content = arg;
        const lines = content.split("\n").filter((x) => x);
        const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
        const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
        for (const line of dedented) {
          this.content.push(line);
        }
      }
      compile() {
        const F = Function;
        const args = this?.args;
        const content = this?.content ?? [``];
        const lines = [...content.map((x) => `  ${x}`)];
        return new F(...args, lines.join("\n"));
      }
    };
    exports2.Doc = Doc;
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/versions.cjs
var require_versions2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/versions.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.version = void 0;
    exports2.version = {
      major: 4,
      minor: 0,
      patch: 0
    };
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/schemas.cjs
var require_schemas3 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/schemas.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.$ZodSet = exports2.$ZodMap = exports2.$ZodRecord = exports2.$ZodTuple = exports2.$ZodIntersection = exports2.$ZodDiscriminatedUnion = exports2.$ZodUnion = exports2.$ZodObject = exports2.$ZodArray = exports2.$ZodDate = exports2.$ZodVoid = exports2.$ZodNever = exports2.$ZodUnknown = exports2.$ZodAny = exports2.$ZodNull = exports2.$ZodUndefined = exports2.$ZodSymbol = exports2.$ZodBigIntFormat = exports2.$ZodBigInt = exports2.$ZodBoolean = exports2.$ZodNumberFormat = exports2.$ZodNumber = exports2.$ZodCustomStringFormat = exports2.$ZodJWT = exports2.$ZodE164 = exports2.$ZodBase64URL = exports2.$ZodBase64 = exports2.$ZodCIDRv6 = exports2.$ZodCIDRv4 = exports2.$ZodIPv6 = exports2.$ZodIPv4 = exports2.$ZodISODuration = exports2.$ZodISOTime = exports2.$ZodISODate = exports2.$ZodISODateTime = exports2.$ZodKSUID = exports2.$ZodXID = exports2.$ZodULID = exports2.$ZodCUID2 = exports2.$ZodCUID = exports2.$ZodNanoID = exports2.$ZodEmoji = exports2.$ZodURL = exports2.$ZodEmail = exports2.$ZodUUID = exports2.$ZodGUID = exports2.$ZodStringFormat = exports2.$ZodString = exports2.clone = exports2.$ZodType = void 0;
    exports2.$ZodCustom = exports2.$ZodLazy = exports2.$ZodPromise = exports2.$ZodTemplateLiteral = exports2.$ZodReadonly = exports2.$ZodPipe = exports2.$ZodNaN = exports2.$ZodCatch = exports2.$ZodSuccess = exports2.$ZodNonOptional = exports2.$ZodPrefault = exports2.$ZodDefault = exports2.$ZodNullable = exports2.$ZodOptional = exports2.$ZodTransform = exports2.$ZodFile = exports2.$ZodLiteral = exports2.$ZodEnum = void 0;
    exports2.isValidBase64 = isValidBase64;
    exports2.isValidBase64URL = isValidBase64URL;
    exports2.isValidJWT = isValidJWT;
    var checks = __importStar(require_checks3());
    var core = __importStar(require_core4());
    var doc_js_1 = require_doc2();
    var parse_js_1 = require_parse4();
    var regexes = __importStar(require_regexes2());
    var util = __importStar(require_util3());
    var versions_js_1 = require_versions2();
    exports2.$ZodType = core.$constructor("$ZodType", (inst, def) => {
      var _a;
      inst ?? (inst = {});
      inst._zod.def = def;
      inst._zod.bag = inst._zod.bag || {};
      inst._zod.version = versions_js_1.version;
      const checks2 = [...inst._zod.def.checks ?? []];
      if (inst._zod.traits.has("$ZodCheck")) {
        checks2.unshift(inst);
      }
      for (const ch of checks2) {
        for (const fn of ch._zod.onattach) {
          fn(inst);
        }
      }
      if (checks2.length === 0) {
        (_a = inst._zod).deferred ?? (_a.deferred = []);
        inst._zod.deferred?.push(() => {
          inst._zod.run = inst._zod.parse;
        });
      } else {
        const runChecks = (payload, checks3, ctx) => {
          let isAborted = util.aborted(payload);
          let asyncResult;
          for (const ch of checks3) {
            if (ch._zod.def.when) {
              const shouldRun = ch._zod.def.when(payload);
              if (!shouldRun)
                continue;
            } else if (isAborted) {
              continue;
            }
            const currLen = payload.issues.length;
            const _ = ch._zod.check(payload);
            if (_ instanceof Promise && ctx?.async === false) {
              throw new core.$ZodAsyncError();
            }
            if (asyncResult || _ instanceof Promise) {
              asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
                await _;
                const nextLen = payload.issues.length;
                if (nextLen === currLen)
                  return;
                if (!isAborted)
                  isAborted = util.aborted(payload, currLen);
              });
            } else {
              const nextLen = payload.issues.length;
              if (nextLen === currLen)
                continue;
              if (!isAborted)
                isAborted = util.aborted(payload, currLen);
            }
          }
          if (asyncResult) {
            return asyncResult.then(() => {
              return payload;
            });
          }
          return payload;
        };
        inst._zod.run = (payload, ctx) => {
          const result = inst._zod.parse(payload, ctx);
          if (result instanceof Promise) {
            if (ctx.async === false)
              throw new core.$ZodAsyncError();
            return result.then((result2) => runChecks(result2, checks2, ctx));
          }
          return runChecks(result, checks2, ctx);
        };
      }
      inst["~standard"] = {
        validate: (value) => {
          try {
            const r = (0, parse_js_1.safeParse)(inst, value);
            return r.success ? { value: r.data } : { issues: r.error?.issues };
          } catch (_) {
            return (0, parse_js_1.safeParseAsync)(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
          }
        },
        vendor: "zod",
        version: 1
      };
    });
    var util_js_1 = require_util3();
    Object.defineProperty(exports2, "clone", { enumerable: true, get: function() {
      return util_js_1.clone;
    } });
    exports2.$ZodString = core.$constructor("$ZodString", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? regexes.string(inst._zod.bag);
      inst._zod.parse = (payload, _) => {
        if (def.coerce)
          try {
            payload.value = String(payload.value);
          } catch (_2) {
          }
        if (typeof payload.value === "string")
          return payload;
        payload.issues.push({
          expected: "string",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    exports2.$ZodStringFormat = core.$constructor("$ZodStringFormat", (inst, def) => {
      checks.$ZodCheckStringFormat.init(inst, def);
      exports2.$ZodString.init(inst, def);
    });
    exports2.$ZodGUID = core.$constructor("$ZodGUID", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.guid);
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodUUID = core.$constructor("$ZodUUID", (inst, def) => {
      if (def.version) {
        const versionMap = {
          v1: 1,
          v2: 2,
          v3: 3,
          v4: 4,
          v5: 5,
          v6: 6,
          v7: 7,
          v8: 8
        };
        const v = versionMap[def.version];
        if (v === void 0)
          throw new Error(`Invalid UUID version: "${def.version}"`);
        def.pattern ?? (def.pattern = regexes.uuid(v));
      } else
        def.pattern ?? (def.pattern = regexes.uuid());
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodEmail = core.$constructor("$ZodEmail", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.email);
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodURL = core.$constructor("$ZodURL", (inst, def) => {
      exports2.$ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        try {
          const orig = payload.value;
          const url = new URL(orig);
          const href = url.href;
          if (def.hostname) {
            def.hostname.lastIndex = 0;
            if (!def.hostname.test(url.hostname)) {
              payload.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid hostname",
                pattern: regexes.hostname.source,
                input: payload.value,
                inst,
                continue: !def.abort
              });
            }
          }
          if (def.protocol) {
            def.protocol.lastIndex = 0;
            if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
              payload.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid protocol",
                pattern: def.protocol.source,
                input: payload.value,
                inst,
                continue: !def.abort
              });
            }
          }
          if (!orig.endsWith("/") && href.endsWith("/")) {
            payload.value = href.slice(0, -1);
          } else {
            payload.value = href;
          }
          return;
        } catch (_) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    exports2.$ZodEmoji = core.$constructor("$ZodEmoji", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.emoji());
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodNanoID = core.$constructor("$ZodNanoID", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.nanoid);
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodCUID = core.$constructor("$ZodCUID", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.cuid);
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodCUID2 = core.$constructor("$ZodCUID2", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.cuid2);
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodULID = core.$constructor("$ZodULID", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.ulid);
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodXID = core.$constructor("$ZodXID", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.xid);
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodKSUID = core.$constructor("$ZodKSUID", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.ksuid);
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodISODateTime = core.$constructor("$ZodISODateTime", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.datetime(def));
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodISODate = core.$constructor("$ZodISODate", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.date);
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodISOTime = core.$constructor("$ZodISOTime", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.time(def));
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodISODuration = core.$constructor("$ZodISODuration", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.duration);
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodIPv4 = core.$constructor("$ZodIPv4", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.ipv4);
      exports2.$ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = `ipv4`;
      });
    });
    exports2.$ZodIPv6 = core.$constructor("$ZodIPv6", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.ipv6);
      exports2.$ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = `ipv6`;
      });
      inst._zod.check = (payload) => {
        try {
          new URL(`http://[${payload.value}]`);
        } catch {
          payload.issues.push({
            code: "invalid_format",
            format: "ipv6",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    exports2.$ZodCIDRv4 = core.$constructor("$ZodCIDRv4", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.cidrv4);
      exports2.$ZodStringFormat.init(inst, def);
    });
    exports2.$ZodCIDRv6 = core.$constructor("$ZodCIDRv6", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.cidrv6);
      exports2.$ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        const [address, prefix] = payload.value.split("/");
        try {
          if (!prefix)
            throw new Error();
          const prefixNum = Number(prefix);
          if (`${prefixNum}` !== prefix)
            throw new Error();
          if (prefixNum < 0 || prefixNum > 128)
            throw new Error();
          new URL(`http://[${address}]`);
        } catch {
          payload.issues.push({
            code: "invalid_format",
            format: "cidrv6",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    function isValidBase64(data) {
      if (data === "")
        return true;
      if (data.length % 4 !== 0)
        return false;
      try {
        atob(data);
        return true;
      } catch {
        return false;
      }
    }
    exports2.$ZodBase64 = core.$constructor("$ZodBase64", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.base64);
      exports2.$ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.contentEncoding = "base64";
      });
      inst._zod.check = (payload) => {
        if (isValidBase64(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "base64",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    function isValidBase64URL(data) {
      if (!regexes.base64url.test(data))
        return false;
      const base64 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
      const padded = base64.padEnd(Math.ceil(base64.length / 4) * 4, "=");
      return isValidBase64(padded);
    }
    exports2.$ZodBase64URL = core.$constructor("$ZodBase64URL", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.base64url);
      exports2.$ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.contentEncoding = "base64url";
      });
      inst._zod.check = (payload) => {
        if (isValidBase64URL(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "base64url",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodE164 = core.$constructor("$ZodE164", (inst, def) => {
      def.pattern ?? (def.pattern = regexes.e164);
      exports2.$ZodStringFormat.init(inst, def);
    });
    function isValidJWT(token, algorithm = null) {
      try {
        const tokensParts = token.split(".");
        if (tokensParts.length !== 3)
          return false;
        const [header] = tokensParts;
        if (!header)
          return false;
        const parsedHeader = JSON.parse(atob(header));
        if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
          return false;
        if (!parsedHeader.alg)
          return false;
        if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
          return false;
        return true;
      } catch {
        return false;
      }
    }
    exports2.$ZodJWT = core.$constructor("$ZodJWT", (inst, def) => {
      exports2.$ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        if (isValidJWT(payload.value, def.alg))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "jwt",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodCustomStringFormat = core.$constructor("$ZodCustomStringFormat", (inst, def) => {
      exports2.$ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        if (def.fn(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: def.format,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    exports2.$ZodNumber = core.$constructor("$ZodNumber", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.pattern = inst._zod.bag.pattern ?? regexes.number;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = Number(payload.value);
          } catch (_) {
          }
        const input = payload.value;
        if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
          return payload;
        }
        const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
        payload.issues.push({
          expected: "number",
          code: "invalid_type",
          input,
          inst,
          ...received ? { received } : {}
        });
        return payload;
      };
    });
    exports2.$ZodNumberFormat = core.$constructor("$ZodNumber", (inst, def) => {
      checks.$ZodCheckNumberFormat.init(inst, def);
      exports2.$ZodNumber.init(inst, def);
    });
    exports2.$ZodBoolean = core.$constructor("$ZodBoolean", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.pattern = regexes.boolean;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = Boolean(payload.value);
          } catch (_) {
          }
        const input = payload.value;
        if (typeof input === "boolean")
          return payload;
        payload.issues.push({
          expected: "boolean",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    exports2.$ZodBigInt = core.$constructor("$ZodBigInt", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.pattern = regexes.bigint;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = BigInt(payload.value);
          } catch (_) {
          }
        if (typeof payload.value === "bigint")
          return payload;
        payload.issues.push({
          expected: "bigint",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    exports2.$ZodBigIntFormat = core.$constructor("$ZodBigInt", (inst, def) => {
      checks.$ZodCheckBigIntFormat.init(inst, def);
      exports2.$ZodBigInt.init(inst, def);
    });
    exports2.$ZodSymbol = core.$constructor("$ZodSymbol", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "symbol")
          return payload;
        payload.issues.push({
          expected: "symbol",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    exports2.$ZodUndefined = core.$constructor("$ZodUndefined", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.pattern = regexes.undefined;
      inst._zod.values = /* @__PURE__ */ new Set([void 0]);
      inst._zod.optin = "optional";
      inst._zod.optout = "optional";
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "undefined")
          return payload;
        payload.issues.push({
          expected: "undefined",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    exports2.$ZodNull = core.$constructor("$ZodNull", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.pattern = regexes.null;
      inst._zod.values = /* @__PURE__ */ new Set([null]);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (input === null)
          return payload;
        payload.issues.push({
          expected: "null",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    exports2.$ZodAny = core.$constructor("$ZodAny", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload) => payload;
    });
    exports2.$ZodUnknown = core.$constructor("$ZodUnknown", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload) => payload;
    });
    exports2.$ZodNever = core.$constructor("$ZodNever", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        payload.issues.push({
          expected: "never",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    exports2.$ZodVoid = core.$constructor("$ZodVoid", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "undefined")
          return payload;
        payload.issues.push({
          expected: "void",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    exports2.$ZodDate = core.$constructor("$ZodDate", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce) {
          try {
            payload.value = new Date(payload.value);
          } catch (_err) {
          }
        }
        const input = payload.value;
        const isDate = input instanceof Date;
        const isValidDate = isDate && !Number.isNaN(input.getTime());
        if (isValidDate)
          return payload;
        payload.issues.push({
          expected: "date",
          code: "invalid_type",
          input,
          ...isDate ? { received: "Invalid Date" } : {},
          inst
        });
        return payload;
      };
    });
    function handleArrayResult(result, final, index) {
      if (result.issues.length) {
        final.issues.push(...util.prefixIssues(index, result.issues));
      }
      final.value[index] = result.value;
    }
    exports2.$ZodArray = core.$constructor("$ZodArray", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
          payload.issues.push({
            expected: "array",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        payload.value = Array(input.length);
        const proms = [];
        for (let i = 0; i < input.length; i++) {
          const item = input[i];
          const result = def.element._zod.run({
            value: item,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
          } else {
            handleArrayResult(result, payload, i);
          }
        }
        if (proms.length) {
          return Promise.all(proms).then(() => payload);
        }
        return payload;
      };
    });
    function handleObjectResult(result, final, key) {
      if (result.issues.length) {
        final.issues.push(...util.prefixIssues(key, result.issues));
      }
      final.value[key] = result.value;
    }
    function handleOptionalObjectResult(result, final, key, input) {
      if (result.issues.length) {
        if (input[key] === void 0) {
          if (key in input) {
            final.value[key] = void 0;
          } else {
            final.value[key] = result.value;
          }
        } else {
          final.issues.push(...util.prefixIssues(key, result.issues));
        }
      } else if (result.value === void 0) {
        if (key in input)
          final.value[key] = void 0;
      } else {
        final.value[key] = result.value;
      }
    }
    exports2.$ZodObject = core.$constructor("$ZodObject", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      const _normalized = util.cached(() => {
        const keys = Object.keys(def.shape);
        for (const k of keys) {
          if (!(def.shape[k] instanceof exports2.$ZodType)) {
            throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
          }
        }
        const okeys = util.optionalKeys(def.shape);
        return {
          shape: def.shape,
          keys,
          keySet: new Set(keys),
          numKeys: keys.length,
          optionalKeys: new Set(okeys)
        };
      });
      util.defineLazy(inst._zod, "propValues", () => {
        const shape = def.shape;
        const propValues = {};
        for (const key in shape) {
          const field = shape[key]._zod;
          if (field.values) {
            propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
            for (const v of field.values)
              propValues[key].add(v);
          }
        }
        return propValues;
      });
      const generateFastpass = (shape) => {
        const doc = new doc_js_1.Doc(["shape", "payload", "ctx"]);
        const normalized = _normalized.value;
        const parseStr = (key) => {
          const k = util.esc(key);
          return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
        };
        doc.write(`const input = payload.value;`);
        const ids = /* @__PURE__ */ Object.create(null);
        let counter = 0;
        for (const key of normalized.keys) {
          ids[key] = `key_${counter++}`;
        }
        doc.write(`const newResult = {}`);
        for (const key of normalized.keys) {
          if (normalized.optionalKeys.has(key)) {
            const id = ids[key];
            doc.write(`const ${id} = ${parseStr(key)};`);
            const k = util.esc(key);
            doc.write(`
        if (${id}.issues.length) {
          if (input[${k}] === undefined) {
            if (${k} in input) {
              newResult[${k}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k}, ...iss.path] : [${k}],
              }))
            );
          }
        } else if (${id}.value === undefined) {
          if (${k} in input) newResult[${k}] = undefined;
        } else {
          newResult[${k}] = ${id}.value;
        }
        `);
          } else {
            const id = ids[key];
            doc.write(`const ${id} = ${parseStr(key)};`);
            doc.write(`
          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${util.esc(key)}, ...iss.path] : [${util.esc(key)}]
          })));`);
            doc.write(`newResult[${util.esc(key)}] = ${id}.value`);
          }
        }
        doc.write(`payload.value = newResult;`);
        doc.write(`return payload;`);
        const fn = doc.compile();
        return (payload, ctx) => fn(shape, payload, ctx);
      };
      let fastpass;
      const isObject = util.isObject;
      const jit = !core.globalConfig.jitless;
      const allowsEval = util.allowsEval;
      const fastEnabled = jit && allowsEval.value;
      const catchall = def.catchall;
      let value;
      inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject(input)) {
          payload.issues.push({
            expected: "object",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
          if (!fastpass)
            fastpass = generateFastpass(def.shape);
          payload = fastpass(payload, ctx);
        } else {
          payload.value = {};
          const shape = value.shape;
          for (const key of value.keys) {
            const el = shape[key];
            const r = el._zod.run({ value: input[key], issues: [] }, ctx);
            const isOptional = el._zod.optin === "optional" && el._zod.optout === "optional";
            if (r instanceof Promise) {
              proms.push(r.then((r2) => isOptional ? handleOptionalObjectResult(r2, payload, key, input) : handleObjectResult(r2, payload, key)));
            } else if (isOptional) {
              handleOptionalObjectResult(r, payload, key, input);
            } else {
              handleObjectResult(r, payload, key);
            }
          }
        }
        if (!catchall) {
          return proms.length ? Promise.all(proms).then(() => payload) : payload;
        }
        const unrecognized = [];
        const keySet = value.keySet;
        const _catchall = catchall._zod;
        const t = _catchall.def.type;
        for (const key of Object.keys(input)) {
          if (keySet.has(key))
            continue;
          if (t === "never") {
            unrecognized.push(key);
            continue;
          }
          const r = _catchall.run({ value: input[key], issues: [] }, ctx);
          if (r instanceof Promise) {
            proms.push(r.then((r2) => handleObjectResult(r2, payload, key)));
          } else {
            handleObjectResult(r, payload, key);
          }
        }
        if (unrecognized.length) {
          payload.issues.push({
            code: "unrecognized_keys",
            keys: unrecognized,
            input,
            inst
          });
        }
        if (!proms.length)
          return payload;
        return Promise.all(proms).then(() => {
          return payload;
        });
      };
    });
    function handleUnionResults(results, final, inst, ctx) {
      for (const result of results) {
        if (result.issues.length === 0) {
          final.value = result.value;
          return final;
        }
      }
      final.issues.push({
        code: "invalid_union",
        input: final.value,
        inst,
        errors: results.map((result) => result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())))
      });
      return final;
    }
    exports2.$ZodUnion = core.$constructor("$ZodUnion", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      util.defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
      util.defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
      util.defineLazy(inst._zod, "values", () => {
        if (def.options.every((o) => o._zod.values)) {
          return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
        }
        return void 0;
      });
      util.defineLazy(inst._zod, "pattern", () => {
        if (def.options.every((o) => o._zod.pattern)) {
          const patterns = def.options.map((o) => o._zod.pattern);
          return new RegExp(`^(${patterns.map((p) => util.cleanRegex(p.source)).join("|")})$`);
        }
        return void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        let async = false;
        const results = [];
        for (const option of def.options) {
          const result = option._zod.run({
            value: payload.value,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            results.push(result);
            async = true;
          } else {
            if (result.issues.length === 0)
              return result;
            results.push(result);
          }
        }
        if (!async)
          return handleUnionResults(results, payload, inst, ctx);
        return Promise.all(results).then((results2) => {
          return handleUnionResults(results2, payload, inst, ctx);
        });
      };
    });
    exports2.$ZodDiscriminatedUnion = /* @__PURE__ */ core.$constructor("$ZodDiscriminatedUnion", (inst, def) => {
      exports2.$ZodUnion.init(inst, def);
      const _super = inst._zod.parse;
      util.defineLazy(inst._zod, "propValues", () => {
        const propValues = {};
        for (const option of def.options) {
          const pv = option._zod.propValues;
          if (!pv || Object.keys(pv).length === 0)
            throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
          for (const [k, v] of Object.entries(pv)) {
            if (!propValues[k])
              propValues[k] = /* @__PURE__ */ new Set();
            for (const val of v) {
              propValues[k].add(val);
            }
          }
        }
        return propValues;
      });
      const disc = util.cached(() => {
        const opts = def.options;
        const map = /* @__PURE__ */ new Map();
        for (const o of opts) {
          const values = o._zod.propValues[def.discriminator];
          if (!values || values.size === 0)
            throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
          for (const v of values) {
            if (map.has(v)) {
              throw new Error(`Duplicate discriminator value "${String(v)}"`);
            }
            map.set(v, o);
          }
        }
        return map;
      });
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!util.isObject(input)) {
          payload.issues.push({
            code: "invalid_type",
            expected: "object",
            input,
            inst
          });
          return payload;
        }
        const opt = disc.value.get(input?.[def.discriminator]);
        if (opt) {
          return opt._zod.run(payload, ctx);
        }
        if (def.unionFallback) {
          return _super(payload, ctx);
        }
        payload.issues.push({
          code: "invalid_union",
          errors: [],
          note: "No matching discriminator",
          input,
          path: [def.discriminator],
          inst
        });
        return payload;
      };
    });
    exports2.$ZodIntersection = core.$constructor("$ZodIntersection", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        const left = def.left._zod.run({ value: input, issues: [] }, ctx);
        const right = def.right._zod.run({ value: input, issues: [] }, ctx);
        const async = left instanceof Promise || right instanceof Promise;
        if (async) {
          return Promise.all([left, right]).then(([left2, right2]) => {
            return handleIntersectionResults(payload, left2, right2);
          });
        }
        return handleIntersectionResults(payload, left, right);
      };
    });
    function mergeValues(a, b) {
      if (a === b) {
        return { valid: true, data: a };
      }
      if (a instanceof Date && b instanceof Date && +a === +b) {
        return { valid: true, data: a };
      }
      if (util.isPlainObject(a) && util.isPlainObject(b)) {
        const bKeys = Object.keys(b);
        const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
          const sharedValue = mergeValues(a[key], b[key]);
          if (!sharedValue.valid) {
            return {
              valid: false,
              mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
            };
          }
          newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
      }
      if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
          return { valid: false, mergeErrorPath: [] };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
          const itemA = a[index];
          const itemB = b[index];
          const sharedValue = mergeValues(itemA, itemB);
          if (!sharedValue.valid) {
            return {
              valid: false,
              mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
            };
          }
          newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
      }
      return { valid: false, mergeErrorPath: [] };
    }
    function handleIntersectionResults(result, left, right) {
      if (left.issues.length) {
        result.issues.push(...left.issues);
      }
      if (right.issues.length) {
        result.issues.push(...right.issues);
      }
      if (util.aborted(result))
        return result;
      const merged = mergeValues(left.value, right.value);
      if (!merged.valid) {
        throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
      }
      result.value = merged.data;
      return result;
    }
    exports2.$ZodTuple = core.$constructor("$ZodTuple", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      const items = def.items;
      const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
          payload.issues.push({
            input,
            inst,
            expected: "tuple",
            code: "invalid_type"
          });
          return payload;
        }
        payload.value = [];
        const proms = [];
        if (!def.rest) {
          const tooBig = input.length > items.length;
          const tooSmall = input.length < optStart - 1;
          if (tooBig || tooSmall) {
            payload.issues.push({
              input,
              inst,
              origin: "array",
              ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length }
            });
            return payload;
          }
        }
        let i = -1;
        for (const item of items) {
          i++;
          if (i >= input.length) {
            if (i >= optStart)
              continue;
          }
          const result = item._zod.run({
            value: input[i],
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
          } else {
            handleTupleResult(result, payload, i);
          }
        }
        if (def.rest) {
          const rest = input.slice(items.length);
          for (const el of rest) {
            i++;
            const result = def.rest._zod.run({
              value: el,
              issues: []
            }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
            } else {
              handleTupleResult(result, payload, i);
            }
          }
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    function handleTupleResult(result, final, index) {
      if (result.issues.length) {
        final.issues.push(...util.prefixIssues(index, result.issues));
      }
      final.value[index] = result.value;
    }
    exports2.$ZodRecord = core.$constructor("$ZodRecord", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!util.isPlainObject(input)) {
          payload.issues.push({
            expected: "record",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        if (def.keyType._zod.values) {
          const values = def.keyType._zod.values;
          payload.value = {};
          for (const key of values) {
            if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
              const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
              if (result instanceof Promise) {
                proms.push(result.then((result2) => {
                  if (result2.issues.length) {
                    payload.issues.push(...util.prefixIssues(key, result2.issues));
                  }
                  payload.value[key] = result2.value;
                }));
              } else {
                if (result.issues.length) {
                  payload.issues.push(...util.prefixIssues(key, result.issues));
                }
                payload.value[key] = result.value;
              }
            }
          }
          let unrecognized;
          for (const key in input) {
            if (!values.has(key)) {
              unrecognized = unrecognized ?? [];
              unrecognized.push(key);
            }
          }
          if (unrecognized && unrecognized.length > 0) {
            payload.issues.push({
              code: "unrecognized_keys",
              input,
              inst,
              keys: unrecognized
            });
          }
        } else {
          payload.value = {};
          for (const key of Reflect.ownKeys(input)) {
            if (key === "__proto__")
              continue;
            const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
            if (keyResult instanceof Promise) {
              throw new Error("Async schemas not supported in object keys currently");
            }
            if (keyResult.issues.length) {
              payload.issues.push({
                origin: "record",
                code: "invalid_key",
                issues: keyResult.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),
                input: key,
                path: [key],
                inst
              });
              payload.value[keyResult.value] = keyResult.value;
              continue;
            }
            const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => {
                if (result2.issues.length) {
                  payload.issues.push(...util.prefixIssues(key, result2.issues));
                }
                payload.value[keyResult.value] = result2.value;
              }));
            } else {
              if (result.issues.length) {
                payload.issues.push(...util.prefixIssues(key, result.issues));
              }
              payload.value[keyResult.value] = result.value;
            }
          }
        }
        if (proms.length) {
          return Promise.all(proms).then(() => payload);
        }
        return payload;
      };
    });
    exports2.$ZodMap = core.$constructor("$ZodMap", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Map)) {
          payload.issues.push({
            expected: "map",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        payload.value = /* @__PURE__ */ new Map();
        for (const [key, value] of input) {
          const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
          const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
          if (keyResult instanceof Promise || valueResult instanceof Promise) {
            proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
              handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
            }));
          } else {
            handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
          }
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
      if (keyResult.issues.length) {
        if (util.propertyKeyTypes.has(typeof key)) {
          final.issues.push(...util.prefixIssues(key, keyResult.issues));
        } else {
          final.issues.push({
            origin: "map",
            code: "invalid_key",
            input,
            inst,
            issues: keyResult.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))
          });
        }
      }
      if (valueResult.issues.length) {
        if (util.propertyKeyTypes.has(typeof key)) {
          final.issues.push(...util.prefixIssues(key, valueResult.issues));
        } else {
          final.issues.push({
            origin: "map",
            code: "invalid_element",
            input,
            inst,
            key,
            issues: valueResult.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))
          });
        }
      }
      final.value.set(keyResult.value, valueResult.value);
    }
    exports2.$ZodSet = core.$constructor("$ZodSet", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Set)) {
          payload.issues.push({
            input,
            inst,
            expected: "set",
            code: "invalid_type"
          });
          return payload;
        }
        const proms = [];
        payload.value = /* @__PURE__ */ new Set();
        for (const item of input) {
          const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleSetResult(result2, payload)));
          } else
            handleSetResult(result, payload);
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    function handleSetResult(result, final) {
      if (result.issues.length) {
        final.issues.push(...result.issues);
      }
      final.value.add(result.value);
    }
    exports2.$ZodEnum = core.$constructor("$ZodEnum", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      const values = util.getEnumValues(def.entries);
      inst._zod.values = new Set(values);
      inst._zod.pattern = new RegExp(`^(${values.filter((k) => util.propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? util.escapeRegex(o) : o.toString()).join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (inst._zod.values.has(input)) {
          return payload;
        }
        payload.issues.push({
          code: "invalid_value",
          values,
          input,
          inst
        });
        return payload;
      };
    });
    exports2.$ZodLiteral = core.$constructor("$ZodLiteral", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.values = new Set(def.values);
      inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? util.escapeRegex(o) : o ? o.toString() : String(o)).join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (inst._zod.values.has(input)) {
          return payload;
        }
        payload.issues.push({
          code: "invalid_value",
          values: def.values,
          input,
          inst
        });
        return payload;
      };
    });
    exports2.$ZodFile = core.$constructor("$ZodFile", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (input instanceof File)
          return payload;
        payload.issues.push({
          expected: "file",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    exports2.$ZodTransform = core.$constructor("$ZodTransform", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const _out = def.transform(payload.value, payload);
        if (_ctx.async) {
          const output = _out instanceof Promise ? _out : Promise.resolve(_out);
          return output.then((output2) => {
            payload.value = output2;
            return payload;
          });
        }
        if (_out instanceof Promise) {
          throw new core.$ZodAsyncError();
        }
        payload.value = _out;
        return payload;
      };
    });
    exports2.$ZodOptional = core.$constructor("$ZodOptional", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.optin = "optional";
      inst._zod.optout = "optional";
      util.defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
      });
      util.defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${util.cleanRegex(pattern.source)})?$`) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        if (def.innerType._zod.optin === "optional") {
          return def.innerType._zod.run(payload, ctx);
        }
        if (payload.value === void 0) {
          return payload;
        }
        return def.innerType._zod.run(payload, ctx);
      };
    });
    exports2.$ZodNullable = core.$constructor("$ZodNullable", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      util.defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      util.defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      util.defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${util.cleanRegex(pattern.source)}|null)$`) : void 0;
      });
      util.defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        if (payload.value === null)
          return payload;
        return def.innerType._zod.run(payload, ctx);
      };
    });
    exports2.$ZodDefault = core.$constructor("$ZodDefault", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.optin = "optional";
      util.defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (payload.value === void 0) {
          payload.value = def.defaultValue;
          return payload;
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => handleDefaultResult(result2, def));
        }
        return handleDefaultResult(result, def);
      };
    });
    function handleDefaultResult(payload, def) {
      if (payload.value === void 0) {
        payload.value = def.defaultValue;
      }
      return payload;
    }
    exports2.$ZodPrefault = core.$constructor("$ZodPrefault", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.optin = "optional";
      util.defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (payload.value === void 0) {
          payload.value = def.defaultValue;
        }
        return def.innerType._zod.run(payload, ctx);
      };
    });
    exports2.$ZodNonOptional = core.$constructor("$ZodNonOptional", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      util.defineLazy(inst._zod, "values", () => {
        const v = def.innerType._zod.values;
        return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => handleNonOptionalResult(result2, inst));
        }
        return handleNonOptionalResult(result, inst);
      };
    });
    function handleNonOptionalResult(payload, inst) {
      if (!payload.issues.length && payload.value === void 0) {
        payload.issues.push({
          code: "invalid_type",
          expected: "nonoptional",
          input: payload.value,
          inst
        });
      }
      return payload;
    }
    exports2.$ZodSuccess = core.$constructor("$ZodSuccess", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => {
            payload.value = result2.issues.length === 0;
            return payload;
          });
        }
        payload.value = result.issues.length === 0;
        return payload;
      };
    });
    exports2.$ZodCatch = core.$constructor("$ZodCatch", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.optin = "optional";
      util.defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      util.defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => {
            payload.value = result2.value;
            if (result2.issues.length) {
              payload.value = def.catchValue({
                ...payload,
                error: {
                  issues: result2.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))
                },
                input: payload.value
              });
              payload.issues = [];
            }
            return payload;
          });
        }
        payload.value = result.value;
        if (result.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      };
    });
    exports2.$ZodNaN = core.$constructor("$ZodNaN", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
          payload.issues.push({
            input: payload.value,
            inst,
            expected: "nan",
            code: "invalid_type"
          });
          return payload;
        }
        return payload;
      };
    });
    exports2.$ZodPipe = core.$constructor("$ZodPipe", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      util.defineLazy(inst._zod, "values", () => def.in._zod.values);
      util.defineLazy(inst._zod, "optin", () => def.in._zod.optin);
      util.defineLazy(inst._zod, "optout", () => def.out._zod.optout);
      inst._zod.parse = (payload, ctx) => {
        const left = def.in._zod.run(payload, ctx);
        if (left instanceof Promise) {
          return left.then((left2) => handlePipeResult(left2, def, ctx));
        }
        return handlePipeResult(left, def, ctx);
      };
    });
    function handlePipeResult(left, def, ctx) {
      if (util.aborted(left)) {
        return left;
      }
      return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);
    }
    exports2.$ZodReadonly = core.$constructor("$ZodReadonly", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      util.defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
      util.defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      util.defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      util.defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then(handleReadonlyResult);
        }
        return handleReadonlyResult(result);
      };
    });
    function handleReadonlyResult(payload) {
      payload.value = Object.freeze(payload.value);
      return payload;
    }
    exports2.$ZodTemplateLiteral = core.$constructor("$ZodTemplateLiteral", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      const regexParts = [];
      for (const part of def.parts) {
        if (part instanceof exports2.$ZodType) {
          if (!part._zod.pattern) {
            throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
          }
          const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
          if (!source)
            throw new Error(`Invalid template literal part: ${part._zod.traits}`);
          const start = source.startsWith("^") ? 1 : 0;
          const end = source.endsWith("$") ? source.length - 1 : source.length;
          regexParts.push(source.slice(start, end));
        } else if (part === null || util.primitiveTypes.has(typeof part)) {
          regexParts.push(util.escapeRegex(`${part}`));
        } else {
          throw new Error(`Invalid template literal part: ${part}`);
        }
      }
      inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "string") {
          payload.issues.push({
            input: payload.value,
            inst,
            expected: "template_literal",
            code: "invalid_type"
          });
          return payload;
        }
        inst._zod.pattern.lastIndex = 0;
        if (!inst._zod.pattern.test(payload.value)) {
          payload.issues.push({
            input: payload.value,
            inst,
            code: "invalid_format",
            format: "template_literal",
            pattern: inst._zod.pattern.source
          });
          return payload;
        }
        return payload;
      };
    });
    exports2.$ZodPromise = core.$constructor("$ZodPromise", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
      };
    });
    exports2.$ZodLazy = core.$constructor("$ZodLazy", (inst, def) => {
      exports2.$ZodType.init(inst, def);
      util.defineLazy(inst._zod, "innerType", () => def.getter());
      util.defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
      util.defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
      util.defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin);
      util.defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout);
      inst._zod.parse = (payload, ctx) => {
        const inner = inst._zod.innerType;
        return inner._zod.run(payload, ctx);
      };
    });
    exports2.$ZodCustom = core.$constructor("$ZodCustom", (inst, def) => {
      checks.$ZodCheck.init(inst, def);
      exports2.$ZodType.init(inst, def);
      inst._zod.parse = (payload, _) => {
        return payload;
      };
      inst._zod.check = (payload) => {
        const input = payload.value;
        const r = def.fn(input);
        if (r instanceof Promise) {
          return r.then((r2) => handleRefineResult(r2, payload, input, inst));
        }
        handleRefineResult(r, payload, input, inst);
        return;
      };
    });
    function handleRefineResult(result, payload, input, inst) {
      if (!result) {
        const _iss = {
          code: "custom",
          input,
          inst,
          // incorporates params.error into issue reporting
          path: [...inst._zod.def.path ?? []],
          // incorporates params.error into issue reporting
          continue: !inst._zod.def.abort
          // params: inst._zod.def.params,
        };
        if (inst._zod.def.params)
          _iss.params = inst._zod.def.params;
        payload.issues.push(util.issue(_iss));
      }
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/ar.cjs
var require_ar2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/ar.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0645\u062F\u062E\u0644",
        email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
        url: "\u0631\u0627\u0628\u0637",
        emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
        ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
        cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
        cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
        base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
        base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
        json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
        e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
        jwt: "JWT",
        template_literal: "\u0645\u062F\u062E\u0644"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${issue.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
            return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
          }
          case "not_multiple_of":
            return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue.divisor}`;
          case "unrecognized_keys":
            return `\u0645\u0639\u0631\u0641${issue.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue.keys.length > 1 ? "\u0629" : ""}: ${util.joinValues(issue.keys, "\u060C ")}`;
          case "invalid_key":
            return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue.origin}`;
          case "invalid_union":
            return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
          case "invalid_element":
            return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue.origin}`;
          default:
            return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/az.cjs
var require_az2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/az.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
        file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
        array: { unit: "element", verb: "olmal\u0131d\u0131r" },
        set: { unit: "element", verb: "olmal\u0131d\u0131r" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "email address",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datetime",
        date: "ISO date",
        time: "ISO time",
        duration: "ISO duration",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded string",
        base64url: "base64url-encoded string",
        json_string: "JSON string",
        e164: "E.164 number",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${issue.expected}, daxil olan ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${util.stringifyPrimitive(issue.values[0])}`;
            return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue.origin ?? "d\u0259y\u0259r"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "element"}`;
            return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue.origin ?? "d\u0259y\u0259r"} ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue.origin} ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
            if (_issue.format === "ends_with")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
            if (_issue.format === "includes")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
            if (_issue.format === "regex")
              return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
            return `Yanl\u0131\u015F ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Yanl\u0131\u015F \u0259d\u0259d: ${issue.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan a\xE7ar${issue.keys.length > 1 ? "lar" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `${issue.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
          case "invalid_union":
            return "Yanl\u0131\u015F d\u0259y\u0259r";
          case "invalid_element":
            return `${issue.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
          default:
            return `Yanl\u0131\u015F d\u0259y\u0259r`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/be.cjs
var require_be2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/be.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    function getBelarusianPlural(count, one, few, many) {
      const absCount = Math.abs(count);
      const lastDigit = absCount % 10;
      const lastTwoDigits = absCount % 100;
      if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
        return many;
      }
      if (lastDigit === 1) {
        return one;
      }
      if (lastDigit >= 2 && lastDigit <= 4) {
        return few;
      }
      return many;
    }
    var error = () => {
      const Sizable = {
        string: {
          unit: {
            one: "\u0441\u0456\u043C\u0432\u0430\u043B",
            few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
            many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        array: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        set: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        file: {
          unit: {
            one: "\u0431\u0430\u0439\u0442",
            few: "\u0431\u0430\u0439\u0442\u044B",
            many: "\u0431\u0430\u0439\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u043B\u0456\u043A";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043C\u0430\u0441\u0456\u045E";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0443\u0432\u043E\u0434",
        email: "email \u0430\u0434\u0440\u0430\u0441",
        url: "URL",
        emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0447\u0430\u0441",
        duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
        ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
        cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
        base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
        base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
        json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
        e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0443\u0432\u043E\u0434"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${issue.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              const maxValue = Number(issue.maximum);
              const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue.maximum.toString()} ${unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              const minValue = Number(issue.minimum);
              const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue.minimum.toString()} ${unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue.origin}`;
          case "invalid_union":
            return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
          case "invalid_element":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue.origin}`;
          default:
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/ca.cjs
var require_ca2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/ca.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "car\xE0cters", verb: "contenir" },
        file: { unit: "bytes", verb: "contenir" },
        array: { unit: "elements", verb: "contenir" },
        set: { unit: "elements", verb: "contenir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "entrada",
        email: "adre\xE7a electr\xF2nica",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data i hora ISO",
        date: "data ISO",
        time: "hora ISO",
        duration: "durada ISO",
        ipv4: "adre\xE7a IPv4",
        ipv6: "adre\xE7a IPv6",
        cidrv4: "rang IPv4",
        cidrv6: "rang IPv6",
        base64: "cadena codificada en base64",
        base64url: "cadena codificada en base64url",
        json_string: "cadena JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Tipus inv\xE0lid: s'esperava ${issue.expected}, s'ha rebut ${parsedType(issue.input)}`;
          // return `Tipus invlid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Valor inv\xE0lid: s'esperava ${util.stringifyPrimitive(issue.values[0])}`;
            return `Opci\xF3 inv\xE0lida: s'esperava una de ${util.joinValues(issue.values, " o ")}`;
          case "too_big": {
            const adj = issue.inclusive ? "com a m\xE0xim" : "menys de";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Massa gran: s'esperava que ${issue.origin ?? "el valor"} contingu\xE9s ${adj} ${issue.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `Massa gran: s'esperava que ${issue.origin ?? "el valor"} fos ${adj} ${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? "com a m\xEDnim" : "m\xE9s de";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Massa petit: s'esperava que ${issue.origin} contingu\xE9s ${adj} ${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Massa petit: s'esperava que ${issue.origin} fos ${adj} ${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
            return `Format inv\xE0lid per a ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue.divisor}`;
          case "unrecognized_keys":
            return `Clau${issue.keys.length > 1 ? "s" : ""} no reconeguda${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Clau inv\xE0lida a ${issue.origin}`;
          case "invalid_union":
            return "Entrada inv\xE0lida";
          // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
          case "invalid_element":
            return `Element inv\xE0lid a ${issue.origin}`;
          default:
            return `Entrada inv\xE0lida`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/cs.cjs
var require_cs2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/cs.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "znak\u016F", verb: "m\xEDt" },
        file: { unit: "bajt\u016F", verb: "m\xEDt" },
        array: { unit: "prvk\u016F", verb: "m\xEDt" },
        set: { unit: "prvk\u016F", verb: "m\xEDt" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u010D\xEDslo";
          }
          case "string": {
            return "\u0159et\u011Bzec";
          }
          case "boolean": {
            return "boolean";
          }
          case "bigint": {
            return "bigint";
          }
          case "function": {
            return "funkce";
          }
          case "symbol": {
            return "symbol";
          }
          case "undefined": {
            return "undefined";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "pole";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "regul\xE1rn\xED v\xFDraz",
        email: "e-mailov\xE1 adresa",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "datum a \u010Das ve form\xE1tu ISO",
        date: "datum ve form\xE1tu ISO",
        time: "\u010Das ve form\xE1tu ISO",
        duration: "doba trv\xE1n\xED ISO",
        ipv4: "IPv4 adresa",
        ipv6: "IPv6 adresa",
        cidrv4: "rozsah IPv4",
        cidrv6: "rozsah IPv6",
        base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
        base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
        json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
        e164: "\u010D\xEDslo E.164",
        jwt: "JWT",
        template_literal: "vstup"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${issue.expected}, obdr\u017Eeno ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${util.stringifyPrimitive(issue.values[0])}`;
            return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
            }
            return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
            }
            return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
            return `Neplatn\xFD form\xE1t ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue.divisor}`;
          case "unrecognized_keys":
            return `Nezn\xE1m\xE9 kl\xED\u010De: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Neplatn\xFD kl\xED\u010D v ${issue.origin}`;
          case "invalid_union":
            return "Neplatn\xFD vstup";
          case "invalid_element":
            return `Neplatn\xE1 hodnota v ${issue.origin}`;
          default:
            return `Neplatn\xFD vstup`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/de.cjs
var require_de2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/de.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "Zeichen", verb: "zu haben" },
        file: { unit: "Bytes", verb: "zu haben" },
        array: { unit: "Elemente", verb: "zu haben" },
        set: { unit: "Elemente", verb: "zu haben" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "Zahl";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "Array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "Eingabe",
        email: "E-Mail-Adresse",
        url: "URL",
        emoji: "Emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-Datum und -Uhrzeit",
        date: "ISO-Datum",
        time: "ISO-Uhrzeit",
        duration: "ISO-Dauer",
        ipv4: "IPv4-Adresse",
        ipv6: "IPv6-Adresse",
        cidrv4: "IPv4-Bereich",
        cidrv6: "IPv6-Bereich",
        base64: "Base64-codierter String",
        base64url: "Base64-URL-codierter String",
        json_string: "JSON-String",
        e164: "E.164-Nummer",
        jwt: "JWT",
        template_literal: "Eingabe"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Ung\xFCltige Eingabe: erwartet ${issue.expected}, erhalten ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Ung\xFCltige Eingabe: erwartet ${util.stringifyPrimitive(issue.values[0])}`;
            return `Ung\xFCltige Option: erwartet eine von ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Zu gro\xDF: erwartet, dass ${issue.origin ?? "Wert"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
            return `Zu gro\xDF: erwartet, dass ${issue.origin ?? "Wert"} ${adj}${issue.maximum.toString()} ist`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Zu klein: erwartet, dass ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit} hat`;
            }
            return `Zu klein: erwartet, dass ${issue.origin} ${adj}${issue.minimum.toString()} ist`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
            if (_issue.format === "ends_with")
              return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
            if (_issue.format === "includes")
              return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
            if (_issue.format === "regex")
              return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
            return `Ung\xFCltig: ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue.divisor} sein`;
          case "unrecognized_keys":
            return `${issue.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Ung\xFCltiger Schl\xFCssel in ${issue.origin}`;
          case "invalid_union":
            return "Ung\xFCltige Eingabe";
          case "invalid_element":
            return `Ung\xFCltiger Wert in ${issue.origin}`;
          default:
            return `Ung\xFCltige Eingabe`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/en.cjs
var require_en3 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/en.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parsedType = void 0;
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var parsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    exports2.parsedType = parsedType;
    var error = () => {
      const Sizable = {
        string: { unit: "characters", verb: "to have" },
        file: { unit: "bytes", verb: "to have" },
        array: { unit: "items", verb: "to have" },
        set: { unit: "items", verb: "to have" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "input",
        email: "email address",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datetime",
        date: "ISO date",
        time: "ISO time",
        duration: "ISO duration",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded string",
        base64url: "base64url-encoded string",
        json_string: "JSON string",
        e164: "E.164 number",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Invalid input: expected ${issue.expected}, received ${(0, exports2.parsedType)(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Invalid input: expected ${util.stringifyPrimitive(issue.values[0])}`;
            return `Invalid option: expected one of ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Too big: expected ${issue.origin ?? "value"} to have ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `Too big: expected ${issue.origin ?? "value"} to be ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Too small: expected ${issue.origin} to have ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Too small: expected ${issue.origin} to be ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `Invalid string: must start with "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Invalid string: must end with "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Invalid string: must include "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Invalid string: must match pattern ${_issue.pattern}`;
            return `Invalid ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Invalid number: must be a multiple of ${issue.divisor}`;
          case "unrecognized_keys":
            return `Unrecognized key${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Invalid key in ${issue.origin}`;
          case "invalid_union":
            return "Invalid input";
          case "invalid_element":
            return `Invalid value in ${issue.origin}`;
          default:
            return `Invalid input`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/eo.cjs
var require_eo2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/eo.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parsedType = void 0;
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var parsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "nombro";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "tabelo";
          }
          if (data === null) {
            return "senvalora";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    exports2.parsedType = parsedType;
    var error = () => {
      const Sizable = {
        string: { unit: "karaktrojn", verb: "havi" },
        file: { unit: "bajtojn", verb: "havi" },
        array: { unit: "elementojn", verb: "havi" },
        set: { unit: "elementojn", verb: "havi" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "enigo",
        email: "retadreso",
        url: "URL",
        emoji: "emo\u011Dio",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-datotempo",
        date: "ISO-dato",
        time: "ISO-tempo",
        duration: "ISO-da\u016Dro",
        ipv4: "IPv4-adreso",
        ipv6: "IPv6-adreso",
        cidrv4: "IPv4-rango",
        cidrv6: "IPv6-rango",
        base64: "64-ume kodita karaktraro",
        base64url: "URL-64-ume kodita karaktraro",
        json_string: "JSON-karaktraro",
        e164: "E.164-nombro",
        jwt: "JWT",
        template_literal: "enigo"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Nevalida enigo: atendi\u011Dis ${issue.expected}, ricevi\u011Dis ${(0, exports2.parsedType)(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Nevalida enigo: atendi\u011Dis ${util.stringifyPrimitive(issue.values[0])}`;
            return `Nevalida opcio: atendi\u011Dis unu el ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Tro granda: atendi\u011Dis ke ${issue.origin ?? "valoro"} havu ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
            return `Tro granda: atendi\u011Dis ke ${issue.origin ?? "valoro"} havu ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Tro malgranda: atendi\u011Dis ke ${issue.origin} havu ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Tro malgranda: atendi\u011Dis ke ${issue.origin} estu ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
            return `Nevalida ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Nevalida nombro: devas esti oblo de ${issue.divisor}`;
          case "unrecognized_keys":
            return `Nekonata${issue.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue.keys.length > 1 ? "j" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Nevalida \u015Dlosilo en ${issue.origin}`;
          case "invalid_union":
            return "Nevalida enigo";
          case "invalid_element":
            return `Nevalida valoro en ${issue.origin}`;
          default:
            return `Nevalida enigo`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/es.cjs
var require_es2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/es.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "caracteres", verb: "tener" },
        file: { unit: "bytes", verb: "tener" },
        array: { unit: "elementos", verb: "tener" },
        set: { unit: "elementos", verb: "tener" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "n\xFAmero";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "arreglo";
            }
            if (data === null) {
              return "nulo";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "entrada",
        email: "direcci\xF3n de correo electr\xF3nico",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "fecha y hora ISO",
        date: "fecha ISO",
        time: "hora ISO",
        duration: "duraci\xF3n ISO",
        ipv4: "direcci\xF3n IPv4",
        ipv6: "direcci\xF3n IPv6",
        cidrv4: "rango IPv4",
        cidrv6: "rango IPv6",
        base64: "cadena codificada en base64",
        base64url: "URL codificada en base64",
        json_string: "cadena JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Entrada inv\xE1lida: se esperaba ${issue.expected}, recibido ${parsedType(issue.input)}`;
          // return `Entrada invlida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Entrada inv\xE1lida: se esperaba ${util.stringifyPrimitive(issue.values[0])}`;
            return `Opci\xF3n inv\xE1lida: se esperaba una de ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Demasiado grande: se esperaba que ${issue.origin ?? "valor"} tuviera ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementos"}`;
            return `Demasiado grande: se esperaba que ${issue.origin ?? "valor"} fuera ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Demasiado peque\xF1o: se esperaba que ${issue.origin} tuviera ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Demasiado peque\xF1o: se esperaba que ${issue.origin} fuera ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
            return `Inv\xE1lido ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue.divisor}`;
          case "unrecognized_keys":
            return `Llave${issue.keys.length > 1 ? "s" : ""} desconocida${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Llave inv\xE1lida en ${issue.origin}`;
          case "invalid_union":
            return "Entrada inv\xE1lida";
          case "invalid_element":
            return `Valor inv\xE1lido en ${issue.origin}`;
          default:
            return `Entrada inv\xE1lida`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/fa.cjs
var require_fa2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/fa.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0622\u0631\u0627\u06CC\u0647";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0648\u0631\u0648\u062F\u06CC",
        email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
        url: "URL",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
        time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        ipv4: "IPv4 \u0622\u062F\u0631\u0633",
        ipv6: "IPv6 \u0622\u062F\u0631\u0633",
        cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
        cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
        base64: "base64-encoded \u0631\u0634\u062A\u0647",
        base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
        json_string: "JSON \u0631\u0634\u062A\u0647",
        e164: "E.164 \u0639\u062F\u062F",
        jwt: "JWT",
        template_literal: "\u0648\u0631\u0648\u062F\u06CC"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${issue.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${parsedType(issue.input)} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
          case "invalid_value":
            if (issue.values.length === 1) {
              return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${util.stringifyPrimitive(issue.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
            }
            return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${util.joinValues(issue.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
            }
            return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue.maximum.toString()} \u0628\u0627\u0634\u062F`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue.origin} \u0628\u0627\u06CC\u062F ${adj}${issue.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
            }
            return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue.origin} \u0628\u0627\u06CC\u062F ${adj}${issue.minimum.toString()} \u0628\u0627\u0634\u062F`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
            }
            if (_issue.format === "ends_with") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
            }
            if (_issue.format === "includes") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
            }
            if (_issue.format === "regex") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
            }
            return `${Nouns[_issue.format] ?? issue.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
          }
          case "not_multiple_of":
            return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue.divisor} \u0628\u0627\u0634\u062F`;
          case "unrecognized_keys":
            return `\u06A9\u0644\u06CC\u062F${issue.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue.origin}`;
          case "invalid_union":
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
          case "invalid_element":
            return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue.origin}`;
          default:
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/fi.cjs
var require_fi2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/fi.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "merkki\xE4", subject: "merkkijonon" },
        file: { unit: "tavua", subject: "tiedoston" },
        array: { unit: "alkiota", subject: "listan" },
        set: { unit: "alkiota", subject: "joukon" },
        number: { unit: "", subject: "luvun" },
        bigint: { unit: "", subject: "suuren kokonaisluvun" },
        int: { unit: "", subject: "kokonaisluvun" },
        date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "s\xE4\xE4nn\xF6llinen lauseke",
        email: "s\xE4hk\xF6postiosoite",
        url: "URL-osoite",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-aikaleima",
        date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
        time: "ISO-aika",
        duration: "ISO-kesto",
        ipv4: "IPv4-osoite",
        ipv6: "IPv6-osoite",
        cidrv4: "IPv4-alue",
        cidrv6: "IPv6-alue",
        base64: "base64-koodattu merkkijono",
        base64url: "base64url-koodattu merkkijono",
        json_string: "JSON-merkkijono",
        e164: "E.164-luku",
        jwt: "JWT",
        template_literal: "templaattimerkkijono"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Virheellinen tyyppi: odotettiin ${issue.expected}, oli ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Virheellinen sy\xF6te: t\xE4ytyy olla ${util.stringifyPrimitive(issue.values[0])}`;
            return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue.maximum.toString()} ${sizing.unit}`.trim();
            }
            return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue.minimum.toString()} ${sizing.unit}`.trim();
            }
            return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
            if (_issue.format === "regex") {
              return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
            }
            return `Virheellinen ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Virheellinen luku: t\xE4ytyy olla luvun ${issue.divisor} monikerta`;
          case "unrecognized_keys":
            return `${issue.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return "Virheellinen avain tietueessa";
          case "invalid_union":
            return "Virheellinen unioni";
          case "invalid_element":
            return "Virheellinen arvo joukossa";
          default:
            return `Virheellinen sy\xF6te`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/fr.cjs
var require_fr2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/fr.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "caract\xE8res", verb: "avoir" },
        file: { unit: "octets", verb: "avoir" },
        array: { unit: "\xE9l\xE9ments", verb: "avoir" },
        set: { unit: "\xE9l\xE9ments", verb: "avoir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "nombre";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "tableau";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "entr\xE9e",
        email: "adresse e-mail",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "date et heure ISO",
        date: "date ISO",
        time: "heure ISO",
        duration: "dur\xE9e ISO",
        ipv4: "adresse IPv4",
        ipv6: "adresse IPv6",
        cidrv4: "plage IPv4",
        cidrv6: "plage IPv6",
        base64: "cha\xEEne encod\xE9e en base64",
        base64url: "cha\xEEne encod\xE9e en base64url",
        json_string: "cha\xEEne JSON",
        e164: "num\xE9ro E.164",
        jwt: "JWT",
        template_literal: "entr\xE9e"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Entr\xE9e invalide : ${issue.expected} attendu, ${parsedType(issue.input)} re\xE7u`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Entr\xE9e invalide : ${util.stringifyPrimitive(issue.values[0])} attendu`;
            return `Option invalide : une valeur parmi ${util.joinValues(issue.values, "|")} attendue`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Trop grand : ${issue.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
            return `Trop grand : ${issue.origin ?? "valeur"} doit \xEAtre ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Trop petit : ${issue.origin} doit ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Trop petit : ${issue.origin} doit \xEAtre ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue.format} invalide`;
          }
          case "not_multiple_of":
            return `Nombre invalide : doit \xEAtre un multiple de ${issue.divisor}`;
          case "unrecognized_keys":
            return `Cl\xE9${issue.keys.length > 1 ? "s" : ""} non reconnue${issue.keys.length > 1 ? "s" : ""} : ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Cl\xE9 invalide dans ${issue.origin}`;
          case "invalid_union":
            return "Entr\xE9e invalide";
          case "invalid_element":
            return `Valeur invalide dans ${issue.origin}`;
          default:
            return `Entr\xE9e invalide`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/fr-CA.cjs
var require_fr_CA2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/fr-CA.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "caract\xE8res", verb: "avoir" },
        file: { unit: "octets", verb: "avoir" },
        array: { unit: "\xE9l\xE9ments", verb: "avoir" },
        set: { unit: "\xE9l\xE9ments", verb: "avoir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "entr\xE9e",
        email: "adresse courriel",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "date-heure ISO",
        date: "date ISO",
        time: "heure ISO",
        duration: "dur\xE9e ISO",
        ipv4: "adresse IPv4",
        ipv6: "adresse IPv6",
        cidrv4: "plage IPv4",
        cidrv6: "plage IPv6",
        base64: "cha\xEEne encod\xE9e en base64",
        base64url: "cha\xEEne encod\xE9e en base64url",
        json_string: "cha\xEEne JSON",
        e164: "num\xE9ro E.164",
        jwt: "JWT",
        template_literal: "entr\xE9e"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Entr\xE9e invalide : attendu ${issue.expected}, re\xE7u ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Entr\xE9e invalide : attendu ${util.stringifyPrimitive(issue.values[0])}`;
            return `Option invalide : attendu l'une des valeurs suivantes ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "\u2264" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Trop grand : attendu que ${issue.origin ?? "la valeur"} ait ${adj}${issue.maximum.toString()} ${sizing.unit}`;
            return `Trop grand : attendu que ${issue.origin ?? "la valeur"} soit ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? "\u2265" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Trop petit : attendu que ${issue.origin} ait ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Trop petit : attendu que ${issue.origin} soit ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue.format} invalide`;
          }
          case "not_multiple_of":
            return `Nombre invalide : doit \xEAtre un multiple de ${issue.divisor}`;
          case "unrecognized_keys":
            return `Cl\xE9${issue.keys.length > 1 ? "s" : ""} non reconnue${issue.keys.length > 1 ? "s" : ""} : ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Cl\xE9 invalide dans ${issue.origin}`;
          case "invalid_union":
            return "Entr\xE9e invalide";
          case "invalid_element":
            return `Valeur invalide dans ${issue.origin}`;
          default:
            return `Entr\xE9e invalide`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/he.cjs
var require_he2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/he.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
        file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
        array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
        set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u05E7\u05DC\u05D8",
        email: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC",
        url: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA",
        emoji: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO",
        date: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO",
        time: "\u05D6\u05DE\u05DF ISO",
        duration: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO",
        ipv4: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4",
        ipv6: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6",
        cidrv4: "\u05D8\u05D5\u05D5\u05D7 IPv4",
        cidrv6: "\u05D8\u05D5\u05D5\u05D7 IPv6",
        base64: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64",
        base64url: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA",
        json_string: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON",
        e164: "\u05DE\u05E1\u05E4\u05E8 E.164",
        jwt: "JWT",
        template_literal: "\u05E7\u05DC\u05D8"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${issue.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${parsedType(issue.input)}`;
          // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05D0\u05D7\u05EA \u05DE\u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA  ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1"${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue.format} \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
          }
          case "not_multiple_of":
            return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue.divisor}`;
          case "unrecognized_keys":
            return `\u05DE\u05E4\u05EA\u05D7${issue.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\u05DE\u05E4\u05EA\u05D7 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue.origin}`;
          case "invalid_union":
            return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
          case "invalid_element":
            return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue.origin}`;
          default:
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/hu.cjs
var require_hu2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/hu.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "legyen" },
        file: { unit: "byte", verb: "legyen" },
        array: { unit: "elem", verb: "legyen" },
        set: { unit: "elem", verb: "legyen" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "sz\xE1m";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "t\xF6mb";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "bemenet",
        email: "email c\xEDm",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO id\u0151b\xE9lyeg",
        date: "ISO d\xE1tum",
        time: "ISO id\u0151",
        duration: "ISO id\u0151intervallum",
        ipv4: "IPv4 c\xEDm",
        ipv6: "IPv6 c\xEDm",
        cidrv4: "IPv4 tartom\xE1ny",
        cidrv6: "IPv6 tartom\xE1ny",
        base64: "base64-k\xF3dolt string",
        base64url: "base64url-k\xF3dolt string",
        json_string: "JSON string",
        e164: "E.164 sz\xE1m",
        jwt: "JWT",
        template_literal: "bemenet"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${issue.expected}, a kapott \xE9rt\xE9k ${parsedType(issue.input)}`;
          // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${util.stringifyPrimitive(issue.values[0])}`;
            return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `T\xFAl nagy: ${issue.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elem"}`;
            return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue.origin} m\xE9rete t\xFAl kicsi ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue.origin} t\xFAl kicsi ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
            if (_issue.format === "ends_with")
              return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
            if (_issue.format === "includes")
              return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
            if (_issue.format === "regex")
              return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
            return `\xC9rv\xE9nytelen ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\xC9rv\xE9nytelen sz\xE1m: ${issue.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
          case "unrecognized_keys":
            return `Ismeretlen kulcs${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\xC9rv\xE9nytelen kulcs ${issue.origin}`;
          case "invalid_union":
            return "\xC9rv\xE9nytelen bemenet";
          case "invalid_element":
            return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue.origin}`;
          default:
            return `\xC9rv\xE9nytelen bemenet`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/id.cjs
var require_id3 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/id.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "memiliki" },
        file: { unit: "byte", verb: "memiliki" },
        array: { unit: "item", verb: "memiliki" },
        set: { unit: "item", verb: "memiliki" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "alamat email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "tanggal dan waktu format ISO",
        date: "tanggal format ISO",
        time: "jam format ISO",
        duration: "durasi format ISO",
        ipv4: "alamat IPv4",
        ipv6: "alamat IPv6",
        cidrv4: "rentang alamat IPv4",
        cidrv6: "rentang alamat IPv6",
        base64: "string dengan enkode base64",
        base64url: "string dengan enkode base64url",
        json_string: "string JSON",
        e164: "angka E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Input tidak valid: diharapkan ${issue.expected}, diterima ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Input tidak valid: diharapkan ${util.stringifyPrimitive(issue.values[0])}`;
            return `Pilihan tidak valid: diharapkan salah satu dari ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Terlalu besar: diharapkan ${issue.origin ?? "value"} memiliki ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elemen"}`;
            return `Terlalu besar: diharapkan ${issue.origin ?? "value"} menjadi ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Terlalu kecil: diharapkan ${issue.origin} memiliki ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Terlalu kecil: diharapkan ${issue.origin} menjadi ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `String tidak valid: harus menyertakan "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue.format} tidak valid`;
          }
          case "not_multiple_of":
            return `Angka tidak valid: harus kelipatan dari ${issue.divisor}`;
          case "unrecognized_keys":
            return `Kunci tidak dikenali ${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Kunci tidak valid di ${issue.origin}`;
          case "invalid_union":
            return "Input tidak valid";
          case "invalid_element":
            return `Nilai tidak valid di ${issue.origin}`;
          default:
            return `Input tidak valid`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/it.cjs
var require_it2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/it.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "caratteri", verb: "avere" },
        file: { unit: "byte", verb: "avere" },
        array: { unit: "elementi", verb: "avere" },
        set: { unit: "elementi", verb: "avere" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "numero";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "vettore";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "indirizzo email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data e ora ISO",
        date: "data ISO",
        time: "ora ISO",
        duration: "durata ISO",
        ipv4: "indirizzo IPv4",
        ipv6: "indirizzo IPv6",
        cidrv4: "intervallo IPv4",
        cidrv6: "intervallo IPv6",
        base64: "stringa codificata in base64",
        base64url: "URL codificata in base64",
        json_string: "stringa JSON",
        e164: "numero E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Input non valido: atteso ${issue.expected}, ricevuto ${parsedType(issue.input)}`;
          // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Input non valido: atteso ${util.stringifyPrimitive(issue.values[0])}`;
            return `Opzione non valida: atteso uno tra ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Troppo grande: ${issue.origin ?? "valore"} deve avere ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementi"}`;
            return `Troppo grande: ${issue.origin ?? "valore"} deve essere ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Troppo piccolo: ${issue.origin} deve avere ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Troppo piccolo: ${issue.origin} deve essere ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Stringa non valida: deve includere "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
            return `Invalid ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Numero non valido: deve essere un multiplo di ${issue.divisor}`;
          case "unrecognized_keys":
            return `Chiav${issue.keys.length > 1 ? "i" : "e"} non riconosciut${issue.keys.length > 1 ? "e" : "a"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Chiave non valida in ${issue.origin}`;
          case "invalid_union":
            return "Input non valido";
          case "invalid_element":
            return `Valore non valido in ${issue.origin}`;
          default:
            return `Input non valido`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/ja.cjs
var require_ja2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/ja.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
        file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
        array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
        set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u6570\u5024";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u914D\u5217";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u5165\u529B\u5024",
        email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
        url: "URL",
        emoji: "\u7D75\u6587\u5B57",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO\u65E5\u6642",
        date: "ISO\u65E5\u4ED8",
        time: "ISO\u6642\u523B",
        duration: "ISO\u671F\u9593",
        ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
        ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
        cidrv4: "IPv4\u7BC4\u56F2",
        cidrv6: "IPv6\u7BC4\u56F2",
        base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
        base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
        json_string: "JSON\u6587\u5B57\u5217",
        e164: "E.164\u756A\u53F7",
        jwt: "JWT",
        template_literal: "\u5165\u529B\u5024"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u7121\u52B9\u306A\u5165\u529B: ${issue.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${parsedType(issue.input)}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u7121\u52B9\u306A\u5165\u529B: ${util.stringifyPrimitive(issue.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
            return `\u7121\u52B9\u306A\u9078\u629E: ${util.joinValues(issue.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          case "too_big": {
            const adj = issue.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue.origin ?? "\u5024"}\u306F${issue.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue.origin ?? "\u5024"}\u306F${issue.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          }
          case "too_small": {
            const adj = issue.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue.origin}\u306F${issue.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue.origin}\u306F${issue.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "ends_with")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "includes")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "regex")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u7121\u52B9\u306A${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u7121\u52B9\u306A\u6570\u5024: ${issue.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          case "unrecognized_keys":
            return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue.keys.length > 1 ? "\u7FA4" : ""}: ${util.joinValues(issue.keys, "\u3001")}`;
          case "invalid_key":
            return `${issue.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
          case "invalid_union":
            return "\u7121\u52B9\u306A\u5165\u529B";
          case "invalid_element":
            return `${issue.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
          default:
            return `\u7121\u52B9\u306A\u5165\u529B`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/kh.cjs
var require_kh2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/kh.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u1798\u17B7\u1793\u1798\u17C2\u1793\u1787\u17B6\u179B\u17C1\u1781 (NaN)" : "\u179B\u17C1\u1781";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u17A2\u17B6\u179A\u17C1 (Array)";
            }
            if (data === null) {
              return "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
        email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
        url: "URL",
        emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
        date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
        time: "\u1798\u17C9\u17C4\u1784 ISO",
        duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
        ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
        ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
        cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
        cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
        base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
        base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
        json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
        e164: "\u179B\u17C1\u1781 E.164",
        jwt: "JWT",
        template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
            return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue.origin} ${adj} ${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue.origin} ${adj} ${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
            return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue.divisor}`;
          case "unrecognized_keys":
            return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue.origin}`;
          case "invalid_union":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
          case "invalid_element":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue.origin}`;
          default:
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/ko.cjs
var require_ko2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/ko.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "\uBB38\uC790", verb: "to have" },
        file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
        array: { unit: "\uAC1C", verb: "to have" },
        set: { unit: "\uAC1C", verb: "to have" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\uC785\uB825",
        email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
        url: "URL",
        emoji: "\uC774\uBAA8\uC9C0",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
        date: "ISO \uB0A0\uC9DC",
        time: "ISO \uC2DC\uAC04",
        duration: "ISO \uAE30\uAC04",
        ipv4: "IPv4 \uC8FC\uC18C",
        ipv6: "IPv6 \uC8FC\uC18C",
        cidrv4: "IPv4 \uBC94\uC704",
        cidrv6: "IPv6 \uBC94\uC704",
        base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
        base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
        json_string: "JSON \uBB38\uC790\uC5F4",
        e164: "E.164 \uBC88\uD638",
        jwt: "JWT",
        template_literal: "\uC785\uB825"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${issue.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${parsedType(issue.input)}\uC785\uB2C8\uB2E4`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${util.stringifyPrimitive(issue.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
            return `\uC798\uBABB\uB41C \uC635\uC158: ${util.joinValues(issue.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
          case "too_big": {
            const adj = issue.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
            const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
            const sizing = getSizing(issue.origin);
            const unit = sizing?.unit ?? "\uC694\uC18C";
            if (sizing)
              return `${issue.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue.maximum.toString()}${unit} ${adj}${suffix}`;
            return `${issue.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue.maximum.toString()} ${adj}${suffix}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
            const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
            const sizing = getSizing(issue.origin);
            const unit = sizing?.unit ?? "\uC694\uC18C";
            if (sizing) {
              return `${issue.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue.minimum.toString()}${unit} ${adj}${suffix}`;
            }
            return `${issue.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue.minimum.toString()} ${adj}${suffix}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
            }
            if (_issue.format === "ends_with")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
            if (_issue.format === "includes")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
            if (_issue.format === "regex")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
            return `\uC798\uBABB\uB41C ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
          case "unrecognized_keys":
            return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\uC798\uBABB\uB41C \uD0A4: ${issue.origin}`;
          case "invalid_union":
            return `\uC798\uBABB\uB41C \uC785\uB825`;
          case "invalid_element":
            return `\uC798\uBABB\uB41C \uAC12: ${issue.origin}`;
          default:
            return `\uC798\uBABB\uB41C \uC785\uB825`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/mk.cjs
var require_mk2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/mk.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0431\u0440\u043E\u0458";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043D\u0438\u0437\u0430";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0432\u043D\u0435\u0441",
        email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u045F\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
        date: "ISO \u0434\u0430\u0442\u0443\u043C",
        time: "ISO \u0432\u0440\u0435\u043C\u0435",
        duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
        cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
        cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
        base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
        base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
        json_string: "JSON \u043D\u0438\u0437\u0430",
        e164: "E.164 \u0431\u0440\u043E\u0458",
        jwt: "JWT",
        template_literal: "\u0432\u043D\u0435\u0441"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${parsedType(issue.input)}`;
          // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Invalid input: expected ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
            return `Invalid ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue.divisor}`;
          case "unrecognized_keys":
            return `${issue.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue.origin}`;
          case "invalid_union":
            return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
          case "invalid_element":
            return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue.origin}`;
          default:
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/ms.cjs
var require_ms3 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/ms.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "aksara", verb: "mempunyai" },
        file: { unit: "bait", verb: "mempunyai" },
        array: { unit: "elemen", verb: "mempunyai" },
        set: { unit: "elemen", verb: "mempunyai" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "nombor";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "alamat e-mel",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "tarikh masa ISO",
        date: "tarikh ISO",
        time: "masa ISO",
        duration: "tempoh ISO",
        ipv4: "alamat IPv4",
        ipv6: "alamat IPv6",
        cidrv4: "julat IPv4",
        cidrv6: "julat IPv6",
        base64: "string dikodkan base64",
        base64url: "string dikodkan base64url",
        json_string: "string JSON",
        e164: "nombor E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Input tidak sah: dijangka ${issue.expected}, diterima ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Input tidak sah: dijangka ${util.stringifyPrimitive(issue.values[0])}`;
            return `Pilihan tidak sah: dijangka salah satu daripada ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Terlalu besar: dijangka ${issue.origin ?? "nilai"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elemen"}`;
            return `Terlalu besar: dijangka ${issue.origin ?? "nilai"} adalah ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Terlalu kecil: dijangka ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Terlalu kecil: dijangka ${issue.origin} adalah ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue.format} tidak sah`;
          }
          case "not_multiple_of":
            return `Nombor tidak sah: perlu gandaan ${issue.divisor}`;
          case "unrecognized_keys":
            return `Kunci tidak dikenali: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Kunci tidak sah dalam ${issue.origin}`;
          case "invalid_union":
            return "Input tidak sah";
          case "invalid_element":
            return `Nilai tidak sah dalam ${issue.origin}`;
          default:
            return `Input tidak sah`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/nl.cjs
var require_nl2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/nl.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "tekens" },
        file: { unit: "bytes" },
        array: { unit: "elementen" },
        set: { unit: "elementen" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "getal";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "invoer",
        email: "emailadres",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datum en tijd",
        date: "ISO datum",
        time: "ISO tijd",
        duration: "ISO duur",
        ipv4: "IPv4-adres",
        ipv6: "IPv6-adres",
        cidrv4: "IPv4-bereik",
        cidrv6: "IPv6-bereik",
        base64: "base64-gecodeerde tekst",
        base64url: "base64 URL-gecodeerde tekst",
        json_string: "JSON string",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "invoer"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Ongeldige invoer: verwacht ${issue.expected}, ontving ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Ongeldige invoer: verwacht ${util.stringifyPrimitive(issue.values[0])}`;
            return `Ongeldige optie: verwacht \xE9\xE9n van ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Te lang: verwacht dat ${issue.origin ?? "waarde"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
            return `Te lang: verwacht dat ${issue.origin ?? "waarde"} ${adj}${issue.maximum.toString()} is`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Te kort: verwacht dat ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit} bevat`;
            }
            return `Te kort: verwacht dat ${issue.origin} ${adj}${issue.minimum.toString()} is`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
            }
            if (_issue.format === "ends_with")
              return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
            if (_issue.format === "includes")
              return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
            if (_issue.format === "regex")
              return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
            return `Ongeldig: ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Ongeldig getal: moet een veelvoud van ${issue.divisor} zijn`;
          case "unrecognized_keys":
            return `Onbekende key${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Ongeldige key in ${issue.origin}`;
          case "invalid_union":
            return "Ongeldige invoer";
          case "invalid_element":
            return `Ongeldige waarde in ${issue.origin}`;
          default:
            return `Ongeldige invoer`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/no.cjs
var require_no2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/no.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "tegn", verb: "\xE5 ha" },
        file: { unit: "bytes", verb: "\xE5 ha" },
        array: { unit: "elementer", verb: "\xE5 inneholde" },
        set: { unit: "elementer", verb: "\xE5 inneholde" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "tall";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "liste";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "input",
        email: "e-postadresse",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dato- og klokkeslett",
        date: "ISO-dato",
        time: "ISO-klokkeslett",
        duration: "ISO-varighet",
        ipv4: "IPv4-omr\xE5de",
        ipv6: "IPv6-omr\xE5de",
        cidrv4: "IPv4-spekter",
        cidrv6: "IPv6-spekter",
        base64: "base64-enkodet streng",
        base64url: "base64url-enkodet streng",
        json_string: "JSON-streng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Ugyldig input: forventet ${issue.expected}, fikk ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Ugyldig verdi: forventet ${util.stringifyPrimitive(issue.values[0])}`;
            return `Ugyldig valg: forventet en av ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `For stor(t): forventet ${issue.origin ?? "value"} til \xE5 ha ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementer"}`;
            return `For stor(t): forventet ${issue.origin ?? "value"} til \xE5 ha ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `For lite(n): forventet ${issue.origin} til \xE5 ha ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `For lite(n): forventet ${issue.origin} til \xE5 ha ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
            return `Ugyldig ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue.divisor}`;
          case "unrecognized_keys":
            return `${issue.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Ugyldig n\xF8kkel i ${issue.origin}`;
          case "invalid_union":
            return "Ugyldig input";
          case "invalid_element":
            return `Ugyldig verdi i ${issue.origin}`;
          default:
            return `Ugyldig input`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/ota.cjs
var require_ota2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/ota.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
        file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
        array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
        set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "numara";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "saf";
            }
            if (data === null) {
              return "gayb";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "giren",
        email: "epostag\xE2h",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO heng\xE2m\u0131",
        date: "ISO tarihi",
        time: "ISO zaman\u0131",
        duration: "ISO m\xFCddeti",
        ipv4: "IPv4 ni\u015F\xE2n\u0131",
        ipv6: "IPv6 ni\u015F\xE2n\u0131",
        cidrv4: "IPv4 menzili",
        cidrv6: "IPv6 menzili",
        base64: "base64-\u015Fifreli metin",
        base64url: "base64url-\u015Fifreli metin",
        json_string: "JSON metin",
        e164: "E.164 say\u0131s\u0131",
        jwt: "JWT",
        template_literal: "giren"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `F\xE2sit giren: umulan ${issue.expected}, al\u0131nan ${parsedType(issue.input)}`;
          // return `Fsit giren: umulan ${issue.expected}, alnan ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `F\xE2sit giren: umulan ${util.stringifyPrimitive(issue.values[0])}`;
            return `F\xE2sit tercih: m\xFBteberler ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Fazla b\xFCy\xFCk: ${issue.origin ?? "value"}, ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
            return `Fazla b\xFCy\xFCk: ${issue.origin ?? "value"}, ${adj}${issue.maximum.toString()} olmal\u0131yd\u0131.`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Fazla k\xFC\xE7\xFCk: ${issue.origin}, ${adj}${issue.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
            }
            return `Fazla k\xFC\xE7\xFCk: ${issue.origin}, ${adj}${issue.minimum.toString()} olmal\u0131yd\u0131.`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
            if (_issue.format === "ends_with")
              return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
            if (_issue.format === "includes")
              return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
            if (_issue.format === "regex")
              return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
            return `F\xE2sit ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `F\xE2sit say\u0131: ${issue.divisor} kat\u0131 olmal\u0131yd\u0131.`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan anahtar ${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `${issue.origin} i\xE7in tan\u0131nmayan anahtar var.`;
          case "invalid_union":
            return "Giren tan\u0131namad\u0131.";
          case "invalid_element":
            return `${issue.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
          default:
            return `K\u0131ymet tan\u0131namad\u0131.`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/ps.cjs
var require_ps2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/ps.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
        file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
        array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
        set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0627\u0631\u06D0";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0648\u0631\u0648\u062F\u064A",
        email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
        url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
        date: "\u0646\u06D0\u067C\u0647",
        time: "\u0648\u062E\u062A",
        duration: "\u0645\u0648\u062F\u0647",
        ipv4: "\u062F IPv4 \u067E\u062A\u0647",
        ipv6: "\u062F IPv6 \u067E\u062A\u0647",
        cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
        cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
        base64: "base64-encoded \u0645\u062A\u0646",
        base64url: "base64url-encoded \u0645\u062A\u0646",
        json_string: "JSON \u0645\u062A\u0646",
        e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
        jwt: "JWT",
        template_literal: "\u0648\u0631\u0648\u062F\u064A"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${issue.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${parsedType(issue.input)} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
          case "invalid_value":
            if (issue.values.length === 1) {
              return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${util.stringifyPrimitive(issue.values[0])} \u0648\u0627\u06CC`;
            }
            return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${util.joinValues(issue.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
            }
            return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue.maximum.toString()} \u0648\u064A`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue.origin} \u0628\u0627\u06CC\u062F ${adj}${issue.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
            }
            return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue.origin} \u0628\u0627\u06CC\u062F ${adj}${issue.minimum.toString()} \u0648\u064A`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
            }
            if (_issue.format === "ends_with") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
            }
            if (_issue.format === "includes") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
            }
            if (_issue.format === "regex") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
            }
            return `${Nouns[_issue.format] ?? issue.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
          }
          case "not_multiple_of":
            return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
          case "unrecognized_keys":
            return `\u0646\u0627\u0633\u0645 ${issue.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue.origin} \u06A9\u06D0`;
          case "invalid_union":
            return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
          case "invalid_element":
            return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue.origin} \u06A9\u06D0`;
          default:
            return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/pl.cjs
var require_pl2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/pl.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "znak\xF3w", verb: "mie\u0107" },
        file: { unit: "bajt\xF3w", verb: "mie\u0107" },
        array: { unit: "element\xF3w", verb: "mie\u0107" },
        set: { unit: "element\xF3w", verb: "mie\u0107" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "liczba";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "tablica";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "wyra\u017Cenie",
        email: "adres email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data i godzina w formacie ISO",
        date: "data w formacie ISO",
        time: "godzina w formacie ISO",
        duration: "czas trwania ISO",
        ipv4: "adres IPv4",
        ipv6: "adres IPv6",
        cidrv4: "zakres IPv4",
        cidrv6: "zakres IPv6",
        base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
        base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
        json_string: "ci\u0105g znak\xF3w w formacie JSON",
        e164: "liczba E.164",
        jwt: "JWT",
        template_literal: "wej\u015Bcie"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${issue.expected}, otrzymano ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${util.stringifyPrimitive(issue.values[0])}`;
            return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
            }
            return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
            }
            return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
            return `Nieprawid\u0142ow(y/a/e) ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue.divisor}`;
          case "unrecognized_keys":
            return `Nierozpoznane klucze${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Nieprawid\u0142owy klucz w ${issue.origin}`;
          case "invalid_union":
            return "Nieprawid\u0142owe dane wej\u015Bciowe";
          case "invalid_element":
            return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue.origin}`;
          default:
            return `Nieprawid\u0142owe dane wej\u015Bciowe`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/pt.cjs
var require_pt2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/pt.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "caracteres", verb: "ter" },
        file: { unit: "bytes", verb: "ter" },
        array: { unit: "itens", verb: "ter" },
        set: { unit: "itens", verb: "ter" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "n\xFAmero";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "nulo";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "padr\xE3o",
        email: "endere\xE7o de e-mail",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data e hora ISO",
        date: "data ISO",
        time: "hora ISO",
        duration: "dura\xE7\xE3o ISO",
        ipv4: "endere\xE7o IPv4",
        ipv6: "endere\xE7o IPv6",
        cidrv4: "faixa de IPv4",
        cidrv6: "faixa de IPv6",
        base64: "texto codificado em base64",
        base64url: "URL codificada em base64",
        json_string: "texto JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Tipo inv\xE1lido: esperado ${issue.expected}, recebido ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Entrada inv\xE1lida: esperado ${util.stringifyPrimitive(issue.values[0])}`;
            return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Muito grande: esperado que ${issue.origin ?? "valor"} tivesse ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementos"}`;
            return `Muito grande: esperado que ${issue.origin ?? "valor"} fosse ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Muito pequeno: esperado que ${issue.origin} tivesse ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Muito pequeno: esperado que ${issue.origin} fosse ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue.format} inv\xE1lido`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue.divisor}`;
          case "unrecognized_keys":
            return `Chave${issue.keys.length > 1 ? "s" : ""} desconhecida${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Chave inv\xE1lida em ${issue.origin}`;
          case "invalid_union":
            return "Entrada inv\xE1lida";
          case "invalid_element":
            return `Valor inv\xE1lido em ${issue.origin}`;
          default:
            return `Campo inv\xE1lido`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/ru.cjs
var require_ru2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/ru.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    function getRussianPlural(count, one, few, many) {
      const absCount = Math.abs(count);
      const lastDigit = absCount % 10;
      const lastTwoDigits = absCount % 100;
      if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
        return many;
      }
      if (lastDigit === 1) {
        return one;
      }
      if (lastDigit >= 2 && lastDigit <= 4) {
        return few;
      }
      return many;
    }
    var error = () => {
      const Sizable = {
        string: {
          unit: {
            one: "\u0441\u0438\u043C\u0432\u043E\u043B",
            few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
            many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        file: {
          unit: {
            one: "\u0431\u0430\u0439\u0442",
            few: "\u0431\u0430\u0439\u0442\u0430",
            many: "\u0431\u0430\u0439\u0442"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        array: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        set: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043C\u0430\u0441\u0441\u0438\u0432";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0432\u0432\u043E\u0434",
        email: "email \u0430\u0434\u0440\u0435\u0441",
        url: "URL",
        emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0432\u0440\u0435\u043C\u044F",
        duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
        cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
        base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
        json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
        e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0432\u0432\u043E\u0434"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${issue.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              const maxValue = Number(issue.maximum);
              const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue.maximum.toString()} ${unit}`;
            }
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              const minValue = Number(issue.minimum);
              const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue.minimum.toString()} ${unit}`;
            }
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue.keys.length > 1 ? "\u0438" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
          case "invalid_element":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue.origin}`;
          default:
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/sl.cjs
var require_sl2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/sl.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "znakov", verb: "imeti" },
        file: { unit: "bajtov", verb: "imeti" },
        array: { unit: "elementov", verb: "imeti" },
        set: { unit: "elementov", verb: "imeti" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0161tevilo";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "tabela";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "vnos",
        email: "e-po\u0161tni naslov",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datum in \u010Das",
        date: "ISO datum",
        time: "ISO \u010Das",
        duration: "ISO trajanje",
        ipv4: "IPv4 naslov",
        ipv6: "IPv6 naslov",
        cidrv4: "obseg IPv4",
        cidrv6: "obseg IPv6",
        base64: "base64 kodiran niz",
        base64url: "base64url kodiran niz",
        json_string: "JSON niz",
        e164: "E.164 \u0161tevilka",
        jwt: "JWT",
        template_literal: "vnos"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Neveljaven vnos: pri\u010Dakovano ${issue.expected}, prejeto ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Neveljaven vnos: pri\u010Dakovano ${util.stringifyPrimitive(issue.values[0])}`;
            return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Preveliko: pri\u010Dakovano, da bo ${issue.origin ?? "vrednost"} imelo ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementov"}`;
            return `Preveliko: pri\u010Dakovano, da bo ${issue.origin ?? "vrednost"} ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Premajhno: pri\u010Dakovano, da bo ${issue.origin} imelo ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Premajhno: pri\u010Dakovano, da bo ${issue.origin} ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
            return `Neveljaven ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue.divisor}`;
          case "unrecognized_keys":
            return `Neprepoznan${issue.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Neveljaven klju\u010D v ${issue.origin}`;
          case "invalid_union":
            return "Neveljaven vnos";
          case "invalid_element":
            return `Neveljavna vrednost v ${issue.origin}`;
          default:
            return "Neveljaven vnos";
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/sv.cjs
var require_sv2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/sv.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "tecken", verb: "att ha" },
        file: { unit: "bytes", verb: "att ha" },
        array: { unit: "objekt", verb: "att inneh\xE5lla" },
        set: { unit: "objekt", verb: "att inneh\xE5lla" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "antal";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "lista";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "regulj\xE4rt uttryck",
        email: "e-postadress",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-datum och tid",
        date: "ISO-datum",
        time: "ISO-tid",
        duration: "ISO-varaktighet",
        ipv4: "IPv4-intervall",
        ipv6: "IPv6-intervall",
        cidrv4: "IPv4-spektrum",
        cidrv6: "IPv6-spektrum",
        base64: "base64-kodad str\xE4ng",
        base64url: "base64url-kodad str\xE4ng",
        json_string: "JSON-str\xE4ng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "mall-literal"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Ogiltig inmatning: f\xF6rv\xE4ntat ${issue.expected}, fick ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Ogiltig inmatning: f\xF6rv\xE4ntat ${util.stringifyPrimitive(issue.values[0])}`;
            return `Ogiltigt val: f\xF6rv\xE4ntade en av ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue.origin ?? "v\xE4rdet"} att ha ${adj}${issue.maximum.toString()} ${sizing.unit ?? "element"}`;
            }
            return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue.origin ?? "v\xE4rdet"} att ha ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue.origin ?? "v\xE4rdet"} att ha ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue.origin ?? "v\xE4rdet"} att ha ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
            return `Ogiltig(t) ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue.divisor}`;
          case "unrecognized_keys":
            return `${issue.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Ogiltig nyckel i ${issue.origin ?? "v\xE4rdet"}`;
          case "invalid_union":
            return "Ogiltig input";
          case "invalid_element":
            return `Ogiltigt v\xE4rde i ${issue.origin ?? "v\xE4rdet"}`;
          default:
            return `Ogiltig input`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/ta.cjs
var require_ta2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/ta.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u0B8E\u0BA3\u0BCD \u0B85\u0BB2\u0BCD\u0BB2\u0BBE\u0BA4\u0BA4\u0BC1" : "\u0B8E\u0BA3\u0BCD";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0B85\u0BA3\u0BBF";
            }
            if (data === null) {
              return "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
        email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
        date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
        time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
        duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
        ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
        cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
        base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
        base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
        json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
        e164: "E.164 \u0B8E\u0BA3\u0BCD",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${util.joinValues(issue.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue.origin} ${adj}${issue.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "ends_with")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "includes")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "regex")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          case "unrecognized_keys":
            return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `${issue.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
          case "invalid_union":
            return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
          case "invalid_element":
            return `${issue.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
          default:
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/th.cjs
var require_th2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/th.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02 (NaN)" : "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)";
            }
            if (data === null) {
              return "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
        email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
        url: "URL",
        emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
        time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
        ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
        cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
        cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
        base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
        base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
        json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
        e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
        jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
        template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${issue.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
            return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
            if (_issue.format === "regex")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
            return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
          case "unrecognized_keys":
            return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue.origin}`;
          case "invalid_union":
            return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
          case "invalid_element":
            return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue.origin}`;
          default:
            return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/tr.cjs
var require_tr2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/tr.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parsedType = void 0;
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var parsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t;
    };
    exports2.parsedType = parsedType;
    var error = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "olmal\u0131" },
        file: { unit: "bayt", verb: "olmal\u0131" },
        array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
        set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "girdi",
        email: "e-posta adresi",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO tarih ve saat",
        date: "ISO tarih",
        time: "ISO saat",
        duration: "ISO s\xFCre",
        ipv4: "IPv4 adresi",
        ipv6: "IPv6 adresi",
        cidrv4: "IPv4 aral\u0131\u011F\u0131",
        cidrv6: "IPv6 aral\u0131\u011F\u0131",
        base64: "base64 ile \u015Fifrelenmi\u015F metin",
        base64url: "base64url ile \u015Fifrelenmi\u015F metin",
        json_string: "JSON dizesi",
        e164: "E.164 say\u0131s\u0131",
        jwt: "JWT",
        template_literal: "\u015Eablon dizesi"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `Ge\xE7ersiz de\u011Fer: beklenen ${issue.expected}, al\u0131nan ${(0, exports2.parsedType)(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `Ge\xE7ersiz de\u011Fer: beklenen ${util.stringifyPrimitive(issue.values[0])}`;
            return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\xC7ok b\xFCy\xFCk: beklenen ${issue.origin ?? "de\u011Fer"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
            return `\xC7ok b\xFCy\xFCk: beklenen ${issue.origin ?? "de\u011Fer"} ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue.origin} ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
            if (_issue.format === "ends_with")
              return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
            if (_issue.format === "includes")
              return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
            if (_issue.format === "regex")
              return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
            return `Ge\xE7ersiz ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `Ge\xE7ersiz say\u0131: ${issue.divisor} ile tam b\xF6l\xFCnebilmeli`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan anahtar${issue.keys.length > 1 ? "lar" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `${issue.origin} i\xE7inde ge\xE7ersiz anahtar`;
          case "invalid_union":
            return "Ge\xE7ersiz de\u011Fer";
          case "invalid_element":
            return `${issue.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
          default:
            return `Ge\xE7ersiz de\u011Fer`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/ua.cjs
var require_ua2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/ua.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043C\u0430\u0441\u0438\u0432";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
        email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
        date: "\u0434\u0430\u0442\u0430 ISO",
        time: "\u0447\u0430\u0441 ISO",
        duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
        ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
        ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
        cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
        cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
        base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
        base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
        json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
        e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${issue.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${parsedType(issue.input)}`;
          // return `  :  ${issue.expected},  ${util.getParsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue.origin} \u0431\u0443\u0434\u0435 ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue.keys.length > 1 ? "\u0456" : ""}: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
          case "invalid_element":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue.origin}`;
          default:
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/ur.cjs
var require_ur2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/ur.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
        file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
        array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
        set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0646\u0645\u0628\u0631";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0622\u0631\u06D2";
            }
            if (data === null) {
              return "\u0646\u0644";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0627\u0646 \u067E\u0679",
        email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
        uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
        uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
        nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
        ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
        xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
        ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
        date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
        time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
        duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
        ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
        cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
        base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
        base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
        json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
        e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
        jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
        template_literal: "\u0627\u0646 \u067E\u0679"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${issue.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${parsedType(issue.input)} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${util.stringifyPrimitive(issue.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
            return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${util.joinValues(issue.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
            return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue.origin} \u06A9\u06D2 ${adj}${issue.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
            }
            return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue.origin} \u06A9\u0627 ${adj}${issue.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            }
            if (_issue.format === "ends_with")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            if (_issue.format === "includes")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            if (_issue.format === "regex")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            return `\u063A\u0644\u0637 ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
          case "unrecognized_keys":
            return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue.keys.length > 1 ? "\u0632" : ""}: ${util.joinValues(issue.keys, "\u060C ")}`;
          case "invalid_key":
            return `${issue.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
          case "invalid_union":
            return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
          case "invalid_element":
            return `${issue.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
          default:
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/vi.cjs
var require_vi2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/vi.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
        file: { unit: "byte", verb: "c\xF3" },
        array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
        set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "s\u1ED1";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "m\u1EA3ng";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u0111\u1EA7u v\xE0o",
        email: "\u0111\u1ECBa ch\u1EC9 email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ng\xE0y gi\u1EDD ISO",
        date: "ng\xE0y ISO",
        time: "gi\u1EDD ISO",
        duration: "kho\u1EA3ng th\u1EDDi gian ISO",
        ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
        ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
        cidrv4: "d\u1EA3i IPv4",
        cidrv6: "d\u1EA3i IPv6",
        base64: "chu\u1ED7i m\xE3 h\xF3a base64",
        base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
        json_string: "chu\u1ED7i JSON",
        e164: "s\u1ED1 E.164",
        jwt: "JWT",
        template_literal: "\u0111\u1EA7u v\xE0o"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${issue.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${util.stringifyPrimitive(issue.values[0])}`;
            return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
            return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue.origin} ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue.format} kh\xF4ng h\u1EE3p l\u1EC7`;
          }
          case "not_multiple_of":
            return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue.divisor}`;
          case "unrecognized_keys":
            return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue.origin}`;
          case "invalid_union":
            return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
          case "invalid_element":
            return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue.origin}`;
          default:
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/zh-CN.cjs
var require_zh_CN2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/zh-CN.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
        file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
        array: { unit: "\u9879", verb: "\u5305\u542B" },
        set: { unit: "\u9879", verb: "\u5305\u542B" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "\u975E\u6570\u5B57(NaN)" : "\u6570\u5B57";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u6570\u7EC4";
            }
            if (data === null) {
              return "\u7A7A\u503C(null)";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u8F93\u5165",
        email: "\u7535\u5B50\u90AE\u4EF6",
        url: "URL",
        emoji: "\u8868\u60C5\u7B26\u53F7",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO\u65E5\u671F\u65F6\u95F4",
        date: "ISO\u65E5\u671F",
        time: "ISO\u65F6\u95F4",
        duration: "ISO\u65F6\u957F",
        ipv4: "IPv4\u5730\u5740",
        ipv6: "IPv6\u5730\u5740",
        cidrv4: "IPv4\u7F51\u6BB5",
        cidrv6: "IPv6\u7F51\u6BB5",
        base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
        base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
        json_string: "JSON\u5B57\u7B26\u4E32",
        e164: "E.164\u53F7\u7801",
        jwt: "JWT",
        template_literal: "\u8F93\u5165"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${issue.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue.origin ?? "\u503C"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
            return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue.origin ?? "\u503C"} ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue.origin} ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
            if (_issue.format === "ends_with")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
            if (_issue.format === "includes")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
            return `\u65E0\u6548${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue.divisor} \u7684\u500D\u6570`;
          case "unrecognized_keys":
            return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${util.joinValues(issue.keys, ", ")}`;
          case "invalid_key":
            return `${issue.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
          case "invalid_union":
            return "\u65E0\u6548\u8F93\u5165";
          case "invalid_element":
            return `${issue.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
          default:
            return `\u65E0\u6548\u8F93\u5165`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/zh-TW.cjs
var require_zh_TW2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/zh-TW.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = default_1;
    var util = __importStar(require_util3());
    var error = () => {
      const Sizable = {
        string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
        file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
        array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
        set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t;
      };
      const Nouns = {
        regex: "\u8F38\u5165",
        email: "\u90F5\u4EF6\u5730\u5740",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u65E5\u671F\u6642\u9593",
        date: "ISO \u65E5\u671F",
        time: "ISO \u6642\u9593",
        duration: "ISO \u671F\u9593",
        ipv4: "IPv4 \u4F4D\u5740",
        ipv6: "IPv6 \u4F4D\u5740",
        cidrv4: "IPv4 \u7BC4\u570D",
        cidrv6: "IPv6 \u7BC4\u570D",
        base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
        base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
        json_string: "JSON \u5B57\u4E32",
        e164: "E.164 \u6578\u503C",
        jwt: "JWT",
        template_literal: "\u8F38\u5165"
      };
      return (issue) => {
        switch (issue.code) {
          case "invalid_type":
            return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${issue.expected}\uFF0C\u4F46\u6536\u5230 ${parsedType(issue.input)}`;
          case "invalid_value":
            if (issue.values.length === 1)
              return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${util.stringifyPrimitive(issue.values[0])}`;
            return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${util.joinValues(issue.values, "|")}`;
          case "too_big": {
            const adj = issue.inclusive ? "<=" : "<";
            const sizing = getSizing(issue.origin);
            if (sizing)
              return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
            return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue.inclusive ? ">=" : ">";
            const sizing = getSizing(issue.origin);
            if (sizing) {
              return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue.origin} \u61C9\u70BA ${adj}${issue.minimum.toString()} ${sizing.unit}`;
            }
            return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue.origin} \u61C9\u70BA ${adj}${issue.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue;
            if (_issue.format === "starts_with") {
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
            }
            if (_issue.format === "ends_with")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
            if (_issue.format === "includes")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
            return `\u7121\u6548\u7684 ${Nouns[_issue.format] ?? issue.format}`;
          }
          case "not_multiple_of":
            return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue.divisor} \u7684\u500D\u6578`;
          case "unrecognized_keys":
            return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue.keys.length > 1 ? "\u5011" : ""}\uFF1A${util.joinValues(issue.keys, "\u3001")}`;
          case "invalid_key":
            return `${issue.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
          case "invalid_union":
            return "\u7121\u6548\u7684\u8F38\u5165\u503C";
          case "invalid_element":
            return `${issue.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
          default:
            return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
        }
      };
    };
    function default_1() {
      return {
        localeError: error()
      };
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/index.cjs
var require_locales2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/locales/index.cjs"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.zhTW = exports2.zhCN = exports2.vi = exports2.ur = exports2.ua = exports2.tr = exports2.th = exports2.ta = exports2.sv = exports2.sl = exports2.ru = exports2.pt = exports2.pl = exports2.ps = exports2.ota = exports2.no = exports2.nl = exports2.ms = exports2.mk = exports2.ko = exports2.kh = exports2.ja = exports2.it = exports2.id = exports2.hu = exports2.he = exports2.frCA = exports2.fr = exports2.fi = exports2.fa = exports2.es = exports2.eo = exports2.en = exports2.de = exports2.cs = exports2.ca = exports2.be = exports2.az = exports2.ar = void 0;
    var ar_js_1 = require_ar2();
    Object.defineProperty(exports2, "ar", { enumerable: true, get: function() {
      return __importDefault(ar_js_1).default;
    } });
    var az_js_1 = require_az2();
    Object.defineProperty(exports2, "az", { enumerable: true, get: function() {
      return __importDefault(az_js_1).default;
    } });
    var be_js_1 = require_be2();
    Object.defineProperty(exports2, "be", { enumerable: true, get: function() {
      return __importDefault(be_js_1).default;
    } });
    var ca_js_1 = require_ca2();
    Object.defineProperty(exports2, "ca", { enumerable: true, get: function() {
      return __importDefault(ca_js_1).default;
    } });
    var cs_js_1 = require_cs2();
    Object.defineProperty(exports2, "cs", { enumerable: true, get: function() {
      return __importDefault(cs_js_1).default;
    } });
    var de_js_1 = require_de2();
    Object.defineProperty(exports2, "de", { enumerable: true, get: function() {
      return __importDefault(de_js_1).default;
    } });
    var en_js_1 = require_en3();
    Object.defineProperty(exports2, "en", { enumerable: true, get: function() {
      return __importDefault(en_js_1).default;
    } });
    var eo_js_1 = require_eo2();
    Object.defineProperty(exports2, "eo", { enumerable: true, get: function() {
      return __importDefault(eo_js_1).default;
    } });
    var es_js_1 = require_es2();
    Object.defineProperty(exports2, "es", { enumerable: true, get: function() {
      return __importDefault(es_js_1).default;
    } });
    var fa_js_1 = require_fa2();
    Object.defineProperty(exports2, "fa", { enumerable: true, get: function() {
      return __importDefault(fa_js_1).default;
    } });
    var fi_js_1 = require_fi2();
    Object.defineProperty(exports2, "fi", { enumerable: true, get: function() {
      return __importDefault(fi_js_1).default;
    } });
    var fr_js_1 = require_fr2();
    Object.defineProperty(exports2, "fr", { enumerable: true, get: function() {
      return __importDefault(fr_js_1).default;
    } });
    var fr_CA_js_1 = require_fr_CA2();
    Object.defineProperty(exports2, "frCA", { enumerable: true, get: function() {
      return __importDefault(fr_CA_js_1).default;
    } });
    var he_js_1 = require_he2();
    Object.defineProperty(exports2, "he", { enumerable: true, get: function() {
      return __importDefault(he_js_1).default;
    } });
    var hu_js_1 = require_hu2();
    Object.defineProperty(exports2, "hu", { enumerable: true, get: function() {
      return __importDefault(hu_js_1).default;
    } });
    var id_js_1 = require_id3();
    Object.defineProperty(exports2, "id", { enumerable: true, get: function() {
      return __importDefault(id_js_1).default;
    } });
    var it_js_1 = require_it2();
    Object.defineProperty(exports2, "it", { enumerable: true, get: function() {
      return __importDefault(it_js_1).default;
    } });
    var ja_js_1 = require_ja2();
    Object.defineProperty(exports2, "ja", { enumerable: true, get: function() {
      return __importDefault(ja_js_1).default;
    } });
    var kh_js_1 = require_kh2();
    Object.defineProperty(exports2, "kh", { enumerable: true, get: function() {
      return __importDefault(kh_js_1).default;
    } });
    var ko_js_1 = require_ko2();
    Object.defineProperty(exports2, "ko", { enumerable: true, get: function() {
      return __importDefault(ko_js_1).default;
    } });
    var mk_js_1 = require_mk2();
    Object.defineProperty(exports2, "mk", { enumerable: true, get: function() {
      return __importDefault(mk_js_1).default;
    } });
    var ms_js_1 = require_ms3();
    Object.defineProperty(exports2, "ms", { enumerable: true, get: function() {
      return __importDefault(ms_js_1).default;
    } });
    var nl_js_1 = require_nl2();
    Object.defineProperty(exports2, "nl", { enumerable: true, get: function() {
      return __importDefault(nl_js_1).default;
    } });
    var no_js_1 = require_no2();
    Object.defineProperty(exports2, "no", { enumerable: true, get: function() {
      return __importDefault(no_js_1).default;
    } });
    var ota_js_1 = require_ota2();
    Object.defineProperty(exports2, "ota", { enumerable: true, get: function() {
      return __importDefault(ota_js_1).default;
    } });
    var ps_js_1 = require_ps2();
    Object.defineProperty(exports2, "ps", { enumerable: true, get: function() {
      return __importDefault(ps_js_1).default;
    } });
    var pl_js_1 = require_pl2();
    Object.defineProperty(exports2, "pl", { enumerable: true, get: function() {
      return __importDefault(pl_js_1).default;
    } });
    var pt_js_1 = require_pt2();
    Object.defineProperty(exports2, "pt", { enumerable: true, get: function() {
      return __importDefault(pt_js_1).default;
    } });
    var ru_js_1 = require_ru2();
    Object.defineProperty(exports2, "ru", { enumerable: true, get: function() {
      return __importDefault(ru_js_1).default;
    } });
    var sl_js_1 = require_sl2();
    Object.defineProperty(exports2, "sl", { enumerable: true, get: function() {
      return __importDefault(sl_js_1).default;
    } });
    var sv_js_1 = require_sv2();
    Object.defineProperty(exports2, "sv", { enumerable: true, get: function() {
      return __importDefault(sv_js_1).default;
    } });
    var ta_js_1 = require_ta2();
    Object.defineProperty(exports2, "ta", { enumerable: true, get: function() {
      return __importDefault(ta_js_1).default;
    } });
    var th_js_1 = require_th2();
    Object.defineProperty(exports2, "th", { enumerable: true, get: function() {
      return __importDefault(th_js_1).default;
    } });
    var tr_js_1 = require_tr2();
    Object.defineProperty(exports2, "tr", { enumerable: true, get: function() {
      return __importDefault(tr_js_1).default;
    } });
    var ua_js_1 = require_ua2();
    Object.defineProperty(exports2, "ua", { enumerable: true, get: function() {
      return __importDefault(ua_js_1).default;
    } });
    var ur_js_1 = require_ur2();
    Object.defineProperty(exports2, "ur", { enumerable: true, get: function() {
      return __importDefault(ur_js_1).default;
    } });
    var vi_js_1 = require_vi2();
    Object.defineProperty(exports2, "vi", { enumerable: true, get: function() {
      return __importDefault(vi_js_1).default;
    } });
    var zh_CN_js_1 = require_zh_CN2();
    Object.defineProperty(exports2, "zhCN", { enumerable: true, get: function() {
      return __importDefault(zh_CN_js_1).default;
    } });
    var zh_TW_js_1 = require_zh_TW2();
    Object.defineProperty(exports2, "zhTW", { enumerable: true, get: function() {
      return __importDefault(zh_TW_js_1).default;
    } });
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/registries.cjs
var require_registries2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/registries.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.globalRegistry = exports2.$ZodRegistry = exports2.$input = exports2.$output = void 0;
    exports2.registry = registry;
    exports2.$output = Symbol("ZodOutput");
    exports2.$input = Symbol("ZodInput");
    var $ZodRegistry = class {
      constructor() {
        this._map = /* @__PURE__ */ new Map();
        this._idmap = /* @__PURE__ */ new Map();
      }
      add(schema, ..._meta) {
        const meta = _meta[0];
        this._map.set(schema, meta);
        if (meta && typeof meta === "object" && "id" in meta) {
          if (this._idmap.has(meta.id)) {
            throw new Error(`ID ${meta.id} already exists in the registry`);
          }
          this._idmap.set(meta.id, schema);
        }
        return this;
      }
      clear() {
        this._map = /* @__PURE__ */ new Map();
        this._idmap = /* @__PURE__ */ new Map();
        return this;
      }
      remove(schema) {
        const meta = this._map.get(schema);
        if (meta && typeof meta === "object" && "id" in meta) {
          this._idmap.delete(meta.id);
        }
        this._map.delete(schema);
        return this;
      }
      get(schema) {
        const p = schema._zod.parent;
        if (p) {
          const pm = { ...this.get(p) ?? {} };
          delete pm.id;
          return { ...pm, ...this._map.get(schema) };
        }
        return this._map.get(schema);
      }
      has(schema) {
        return this._map.has(schema);
      }
    };
    exports2.$ZodRegistry = $ZodRegistry;
    function registry() {
      return new $ZodRegistry();
    }
    exports2.globalRegistry = registry();
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/api.cjs
var require_api2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/api.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TimePrecision = void 0;
    exports2._string = _string;
    exports2._coercedString = _coercedString;
    exports2._email = _email;
    exports2._guid = _guid;
    exports2._uuid = _uuid;
    exports2._uuidv4 = _uuidv4;
    exports2._uuidv6 = _uuidv6;
    exports2._uuidv7 = _uuidv7;
    exports2._url = _url;
    exports2._emoji = _emoji;
    exports2._nanoid = _nanoid;
    exports2._cuid = _cuid;
    exports2._cuid2 = _cuid2;
    exports2._ulid = _ulid;
    exports2._xid = _xid;
    exports2._ksuid = _ksuid;
    exports2._ipv4 = _ipv4;
    exports2._ipv6 = _ipv6;
    exports2._cidrv4 = _cidrv4;
    exports2._cidrv6 = _cidrv6;
    exports2._base64 = _base64;
    exports2._base64url = _base64url;
    exports2._e164 = _e164;
    exports2._jwt = _jwt;
    exports2._isoDateTime = _isoDateTime;
    exports2._isoDate = _isoDate;
    exports2._isoTime = _isoTime;
    exports2._isoDuration = _isoDuration;
    exports2._number = _number;
    exports2._coercedNumber = _coercedNumber;
    exports2._int = _int;
    exports2._float32 = _float32;
    exports2._float64 = _float64;
    exports2._int32 = _int32;
    exports2._uint32 = _uint32;
    exports2._boolean = _boolean;
    exports2._coercedBoolean = _coercedBoolean;
    exports2._bigint = _bigint;
    exports2._coercedBigint = _coercedBigint;
    exports2._int64 = _int64;
    exports2._uint64 = _uint64;
    exports2._symbol = _symbol;
    exports2._undefined = _undefined;
    exports2._null = _null;
    exports2._any = _any;
    exports2._unknown = _unknown;
    exports2._never = _never;
    exports2._void = _void;
    exports2._date = _date;
    exports2._coercedDate = _coercedDate;
    exports2._nan = _nan;
    exports2._lt = _lt;
    exports2._lte = _lte;
    exports2._max = _lte;
    exports2._lte = _lte;
    exports2._max = _lte;
    exports2._gt = _gt;
    exports2._gte = _gte;
    exports2._min = _gte;
    exports2._gte = _gte;
    exports2._min = _gte;
    exports2._positive = _positive;
    exports2._negative = _negative;
    exports2._nonpositive = _nonpositive;
    exports2._nonnegative = _nonnegative;
    exports2._multipleOf = _multipleOf;
    exports2._maxSize = _maxSize;
    exports2._minSize = _minSize;
    exports2._size = _size;
    exports2._maxLength = _maxLength;
    exports2._minLength = _minLength;
    exports2._length = _length;
    exports2._regex = _regex;
    exports2._lowercase = _lowercase;
    exports2._uppercase = _uppercase;
    exports2._includes = _includes;
    exports2._startsWith = _startsWith;
    exports2._endsWith = _endsWith;
    exports2._property = _property;
    exports2._mime = _mime;
    exports2._overwrite = _overwrite;
    exports2._normalize = _normalize;
    exports2._trim = _trim;
    exports2._toLowerCase = _toLowerCase;
    exports2._toUpperCase = _toUpperCase;
    exports2._array = _array;
    exports2._union = _union;
    exports2._discriminatedUnion = _discriminatedUnion;
    exports2._intersection = _intersection;
    exports2._tuple = _tuple;
    exports2._record = _record;
    exports2._map = _map;
    exports2._set = _set;
    exports2._enum = _enum;
    exports2._nativeEnum = _nativeEnum;
    exports2._literal = _literal;
    exports2._file = _file;
    exports2._transform = _transform;
    exports2._optional = _optional;
    exports2._nullable = _nullable;
    exports2._default = _default;
    exports2._nonoptional = _nonoptional;
    exports2._success = _success;
    exports2._catch = _catch;
    exports2._pipe = _pipe;
    exports2._readonly = _readonly;
    exports2._templateLiteral = _templateLiteral;
    exports2._lazy = _lazy;
    exports2._promise = _promise;
    exports2._custom = _custom;
    exports2._refine = _refine;
    exports2._stringbool = _stringbool;
    exports2._stringFormat = _stringFormat;
    var checks = __importStar(require_checks3());
    var schemas = __importStar(require_schemas3());
    var util = __importStar(require_util3());
    function _string(Class, params) {
      return new Class({
        type: "string",
        ...util.normalizeParams(params)
      });
    }
    function _coercedString(Class, params) {
      return new Class({
        type: "string",
        coerce: true,
        ...util.normalizeParams(params)
      });
    }
    function _email(Class, params) {
      return new Class({
        type: "string",
        format: "email",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _guid(Class, params) {
      return new Class({
        type: "string",
        format: "guid",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _uuid(Class, params) {
      return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _uuidv4(Class, params) {
      return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        version: "v4",
        ...util.normalizeParams(params)
      });
    }
    function _uuidv6(Class, params) {
      return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        version: "v6",
        ...util.normalizeParams(params)
      });
    }
    function _uuidv7(Class, params) {
      return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        version: "v7",
        ...util.normalizeParams(params)
      });
    }
    function _url(Class, params) {
      return new Class({
        type: "string",
        format: "url",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _emoji(Class, params) {
      return new Class({
        type: "string",
        format: "emoji",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _nanoid(Class, params) {
      return new Class({
        type: "string",
        format: "nanoid",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _cuid(Class, params) {
      return new Class({
        type: "string",
        format: "cuid",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _cuid2(Class, params) {
      return new Class({
        type: "string",
        format: "cuid2",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _ulid(Class, params) {
      return new Class({
        type: "string",
        format: "ulid",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _xid(Class, params) {
      return new Class({
        type: "string",
        format: "xid",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _ksuid(Class, params) {
      return new Class({
        type: "string",
        format: "ksuid",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _ipv4(Class, params) {
      return new Class({
        type: "string",
        format: "ipv4",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _ipv6(Class, params) {
      return new Class({
        type: "string",
        format: "ipv6",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _cidrv4(Class, params) {
      return new Class({
        type: "string",
        format: "cidrv4",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _cidrv6(Class, params) {
      return new Class({
        type: "string",
        format: "cidrv6",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _base64(Class, params) {
      return new Class({
        type: "string",
        format: "base64",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _base64url(Class, params) {
      return new Class({
        type: "string",
        format: "base64url",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _e164(Class, params) {
      return new Class({
        type: "string",
        format: "e164",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    function _jwt(Class, params) {
      return new Class({
        type: "string",
        format: "jwt",
        check: "string_format",
        abort: false,
        ...util.normalizeParams(params)
      });
    }
    exports2.TimePrecision = {
      Any: null,
      Minute: -1,
      Second: 0,
      Millisecond: 3,
      Microsecond: 6
    };
    function _isoDateTime(Class, params) {
      return new Class({
        type: "string",
        format: "datetime",
        check: "string_format",
        offset: false,
        local: false,
        precision: null,
        ...util.normalizeParams(params)
      });
    }
    function _isoDate(Class, params) {
      return new Class({
        type: "string",
        format: "date",
        check: "string_format",
        ...util.normalizeParams(params)
      });
    }
    function _isoTime(Class, params) {
      return new Class({
        type: "string",
        format: "time",
        check: "string_format",
        precision: null,
        ...util.normalizeParams(params)
      });
    }
    function _isoDuration(Class, params) {
      return new Class({
        type: "string",
        format: "duration",
        check: "string_format",
        ...util.normalizeParams(params)
      });
    }
    function _number(Class, params) {
      return new Class({
        type: "number",
        checks: [],
        ...util.normalizeParams(params)
      });
    }
    function _coercedNumber(Class, params) {
      return new Class({
        type: "number",
        coerce: true,
        checks: [],
        ...util.normalizeParams(params)
      });
    }
    function _int(Class, params) {
      return new Class({
        type: "number",
        check: "number_format",
        abort: false,
        format: "safeint",
        ...util.normalizeParams(params)
      });
    }
    function _float32(Class, params) {
      return new Class({
        type: "number",
        check: "number_format",
        abort: false,
        format: "float32",
        ...util.normalizeParams(params)
      });
    }
    function _float64(Class, params) {
      return new Class({
        type: "number",
        check: "number_format",
        abort: false,
        format: "float64",
        ...util.normalizeParams(params)
      });
    }
    function _int32(Class, params) {
      return new Class({
        type: "number",
        check: "number_format",
        abort: false,
        format: "int32",
        ...util.normalizeParams(params)
      });
    }
    function _uint32(Class, params) {
      return new Class({
        type: "number",
        check: "number_format",
        abort: false,
        format: "uint32",
        ...util.normalizeParams(params)
      });
    }
    function _boolean(Class, params) {
      return new Class({
        type: "boolean",
        ...util.normalizeParams(params)
      });
    }
    function _coercedBoolean(Class, params) {
      return new Class({
        type: "boolean",
        coerce: true,
        ...util.normalizeParams(params)
      });
    }
    function _bigint(Class, params) {
      return new Class({
        type: "bigint",
        ...util.normalizeParams(params)
      });
    }
    function _coercedBigint(Class, params) {
      return new Class({
        type: "bigint",
        coerce: true,
        ...util.normalizeParams(params)
      });
    }
    function _int64(Class, params) {
      return new Class({
        type: "bigint",
        check: "bigint_format",
        abort: false,
        format: "int64",
        ...util.normalizeParams(params)
      });
    }
    function _uint64(Class, params) {
      return new Class({
        type: "bigint",
        check: "bigint_format",
        abort: false,
        format: "uint64",
        ...util.normalizeParams(params)
      });
    }
    function _symbol(Class, params) {
      return new Class({
        type: "symbol",
        ...util.normalizeParams(params)
      });
    }
    function _undefined(Class, params) {
      return new Class({
        type: "undefined",
        ...util.normalizeParams(params)
      });
    }
    function _null(Class, params) {
      return new Class({
        type: "null",
        ...util.normalizeParams(params)
      });
    }
    function _any(Class) {
      return new Class({
        type: "any"
      });
    }
    function _unknown(Class) {
      return new Class({
        type: "unknown"
      });
    }
    function _never(Class, params) {
      return new Class({
        type: "never",
        ...util.normalizeParams(params)
      });
    }
    function _void(Class, params) {
      return new Class({
        type: "void",
        ...util.normalizeParams(params)
      });
    }
    function _date(Class, params) {
      return new Class({
        type: "date",
        ...util.normalizeParams(params)
      });
    }
    function _coercedDate(Class, params) {
      return new Class({
        type: "date",
        coerce: true,
        ...util.normalizeParams(params)
      });
    }
    function _nan(Class, params) {
      return new Class({
        type: "nan",
        ...util.normalizeParams(params)
      });
    }
    function _lt(value, params) {
      return new checks.$ZodCheckLessThan({
        check: "less_than",
        ...util.normalizeParams(params),
        value,
        inclusive: false
      });
    }
    function _lte(value, params) {
      return new checks.$ZodCheckLessThan({
        check: "less_than",
        ...util.normalizeParams(params),
        value,
        inclusive: true
      });
    }
    function _gt(value, params) {
      return new checks.$ZodCheckGreaterThan({
        check: "greater_than",
        ...util.normalizeParams(params),
        value,
        inclusive: false
      });
    }
    function _gte(value, params) {
      return new checks.$ZodCheckGreaterThan({
        check: "greater_than",
        ...util.normalizeParams(params),
        value,
        inclusive: true
      });
    }
    function _positive(params) {
      return _gt(0, params);
    }
    function _negative(params) {
      return _lt(0, params);
    }
    function _nonpositive(params) {
      return _lte(0, params);
    }
    function _nonnegative(params) {
      return _gte(0, params);
    }
    function _multipleOf(value, params) {
      return new checks.$ZodCheckMultipleOf({
        check: "multiple_of",
        ...util.normalizeParams(params),
        value
      });
    }
    function _maxSize(maximum, params) {
      return new checks.$ZodCheckMaxSize({
        check: "max_size",
        ...util.normalizeParams(params),
        maximum
      });
    }
    function _minSize(minimum, params) {
      return new checks.$ZodCheckMinSize({
        check: "min_size",
        ...util.normalizeParams(params),
        minimum
      });
    }
    function _size(size, params) {
      return new checks.$ZodCheckSizeEquals({
        check: "size_equals",
        ...util.normalizeParams(params),
        size
      });
    }
    function _maxLength(maximum, params) {
      const ch = new checks.$ZodCheckMaxLength({
        check: "max_length",
        ...util.normalizeParams(params),
        maximum
      });
      return ch;
    }
    function _minLength(minimum, params) {
      return new checks.$ZodCheckMinLength({
        check: "min_length",
        ...util.normalizeParams(params),
        minimum
      });
    }
    function _length(length, params) {
      return new checks.$ZodCheckLengthEquals({
        check: "length_equals",
        ...util.normalizeParams(params),
        length
      });
    }
    function _regex(pattern, params) {
      return new checks.$ZodCheckRegex({
        check: "string_format",
        format: "regex",
        ...util.normalizeParams(params),
        pattern
      });
    }
    function _lowercase(params) {
      return new checks.$ZodCheckLowerCase({
        check: "string_format",
        format: "lowercase",
        ...util.normalizeParams(params)
      });
    }
    function _uppercase(params) {
      return new checks.$ZodCheckUpperCase({
        check: "string_format",
        format: "uppercase",
        ...util.normalizeParams(params)
      });
    }
    function _includes(includes, params) {
      return new checks.$ZodCheckIncludes({
        check: "string_format",
        format: "includes",
        ...util.normalizeParams(params),
        includes
      });
    }
    function _startsWith(prefix, params) {
      return new checks.$ZodCheckStartsWith({
        check: "string_format",
        format: "starts_with",
        ...util.normalizeParams(params),
        prefix
      });
    }
    function _endsWith(suffix, params) {
      return new checks.$ZodCheckEndsWith({
        check: "string_format",
        format: "ends_with",
        ...util.normalizeParams(params),
        suffix
      });
    }
    function _property(property, schema, params) {
      return new checks.$ZodCheckProperty({
        check: "property",
        property,
        schema,
        ...util.normalizeParams(params)
      });
    }
    function _mime(types, params) {
      return new checks.$ZodCheckMimeType({
        check: "mime_type",
        mime: types,
        ...util.normalizeParams(params)
      });
    }
    function _overwrite(tx) {
      return new checks.$ZodCheckOverwrite({
        check: "overwrite",
        tx
      });
    }
    function _normalize(form) {
      return _overwrite((input) => input.normalize(form));
    }
    function _trim() {
      return _overwrite((input) => input.trim());
    }
    function _toLowerCase() {
      return _overwrite((input) => input.toLowerCase());
    }
    function _toUpperCase() {
      return _overwrite((input) => input.toUpperCase());
    }
    function _array(Class, element, params) {
      return new Class({
        type: "array",
        element,
        // get element() {
        //   return element;
        // },
        ...util.normalizeParams(params)
      });
    }
    function _union(Class, options, params) {
      return new Class({
        type: "union",
        options,
        ...util.normalizeParams(params)
      });
    }
    function _discriminatedUnion(Class, discriminator, options, params) {
      return new Class({
        type: "union",
        options,
        discriminator,
        ...util.normalizeParams(params)
      });
    }
    function _intersection(Class, left, right) {
      return new Class({
        type: "intersection",
        left,
        right
      });
    }
    function _tuple(Class, items, _paramsOrRest, _params) {
      const hasRest = _paramsOrRest instanceof schemas.$ZodType;
      const params = hasRest ? _params : _paramsOrRest;
      const rest = hasRest ? _paramsOrRest : null;
      return new Class({
        type: "tuple",
        items,
        rest,
        ...util.normalizeParams(params)
      });
    }
    function _record(Class, keyType, valueType, params) {
      return new Class({
        type: "record",
        keyType,
        valueType,
        ...util.normalizeParams(params)
      });
    }
    function _map(Class, keyType, valueType, params) {
      return new Class({
        type: "map",
        keyType,
        valueType,
        ...util.normalizeParams(params)
      });
    }
    function _set(Class, valueType, params) {
      return new Class({
        type: "set",
        valueType,
        ...util.normalizeParams(params)
      });
    }
    function _enum(Class, values, params) {
      const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
      return new Class({
        type: "enum",
        entries,
        ...util.normalizeParams(params)
      });
    }
    function _nativeEnum(Class, entries, params) {
      return new Class({
        type: "enum",
        entries,
        ...util.normalizeParams(params)
      });
    }
    function _literal(Class, value, params) {
      return new Class({
        type: "literal",
        values: Array.isArray(value) ? value : [value],
        ...util.normalizeParams(params)
      });
    }
    function _file(Class, params) {
      return new Class({
        type: "file",
        ...util.normalizeParams(params)
      });
    }
    function _transform(Class, fn) {
      return new Class({
        type: "transform",
        transform: fn
      });
    }
    function _optional(Class, innerType) {
      return new Class({
        type: "optional",
        innerType
      });
    }
    function _nullable(Class, innerType) {
      return new Class({
        type: "nullable",
        innerType
      });
    }
    function _default(Class, innerType, defaultValue) {
      return new Class({
        type: "default",
        innerType,
        get defaultValue() {
          return typeof defaultValue === "function" ? defaultValue() : defaultValue;
        }
      });
    }
    function _nonoptional(Class, innerType, params) {
      return new Class({
        type: "nonoptional",
        innerType,
        ...util.normalizeParams(params)
      });
    }
    function _success(Class, innerType) {
      return new Class({
        type: "success",
        innerType
      });
    }
    function _catch(Class, innerType, catchValue) {
      return new Class({
        type: "catch",
        innerType,
        catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
      });
    }
    function _pipe(Class, in_, out) {
      return new Class({
        type: "pipe",
        in: in_,
        out
      });
    }
    function _readonly(Class, innerType) {
      return new Class({
        type: "readonly",
        innerType
      });
    }
    function _templateLiteral(Class, parts, params) {
      return new Class({
        type: "template_literal",
        parts,
        ...util.normalizeParams(params)
      });
    }
    function _lazy(Class, getter) {
      return new Class({
        type: "lazy",
        getter
      });
    }
    function _promise(Class, innerType) {
      return new Class({
        type: "promise",
        innerType
      });
    }
    function _custom(Class, fn, _params) {
      const norm = util.normalizeParams(_params);
      norm.abort ?? (norm.abort = true);
      const schema = new Class({
        type: "custom",
        check: "custom",
        fn,
        ...norm
      });
      return schema;
    }
    function _refine(Class, fn, _params) {
      const schema = new Class({
        type: "custom",
        check: "custom",
        fn,
        ...util.normalizeParams(_params)
      });
      return schema;
    }
    function _stringbool(Classes, _params) {
      const params = util.normalizeParams(_params);
      let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
      let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
      if (params.case !== "sensitive") {
        truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
        falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
      }
      const truthySet = new Set(truthyArray);
      const falsySet = new Set(falsyArray);
      const _Pipe = Classes.Pipe ?? schemas.$ZodPipe;
      const _Boolean = Classes.Boolean ?? schemas.$ZodBoolean;
      const _String = Classes.String ?? schemas.$ZodString;
      const _Transform = Classes.Transform ?? schemas.$ZodTransform;
      const tx = new _Transform({
        type: "transform",
        transform: (input, payload) => {
          let data = input;
          if (params.case !== "sensitive")
            data = data.toLowerCase();
          if (truthySet.has(data)) {
            return true;
          } else if (falsySet.has(data)) {
            return false;
          } else {
            payload.issues.push({
              code: "invalid_value",
              expected: "stringbool",
              values: [...truthySet, ...falsySet],
              input: payload.value,
              inst: tx
            });
            return {};
          }
        },
        error: params.error
      });
      const innerPipe = new _Pipe({
        type: "pipe",
        in: new _String({ type: "string", error: params.error }),
        out: tx,
        error: params.error
      });
      const outerPipe = new _Pipe({
        type: "pipe",
        in: innerPipe,
        out: new _Boolean({
          type: "boolean",
          error: params.error
        }),
        error: params.error
      });
      return outerPipe;
    }
    function _stringFormat(Class, format, fnOrRegex, _params = {}) {
      const params = util.normalizeParams(_params);
      const def = {
        ...util.normalizeParams(_params),
        check: "string_format",
        type: "string",
        format,
        fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
        ...params
      };
      if (fnOrRegex instanceof RegExp) {
        def.pattern = fnOrRegex;
      }
      const inst = new Class(def);
      return inst;
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/function.cjs
var require_function2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/function.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.$ZodFunction = void 0;
    exports2.function = _function;
    var api_js_1 = require_api2();
    var parse_js_1 = require_parse4();
    var schemas = __importStar(require_schemas3());
    var schemas_js_1 = require_schemas3();
    var $ZodFunction = class {
      constructor(def) {
        this._def = def;
        this.def = def;
      }
      implement(func) {
        if (typeof func !== "function") {
          throw new Error("implement() must be called with a function");
        }
        const impl = ((...args) => {
          const parsedArgs = this._def.input ? (0, parse_js_1.parse)(this._def.input, args, void 0, { callee: impl }) : args;
          if (!Array.isArray(parsedArgs)) {
            throw new Error("Invalid arguments schema: not an array or tuple schema.");
          }
          const output = func(...parsedArgs);
          return this._def.output ? (0, parse_js_1.parse)(this._def.output, output, void 0, { callee: impl }) : output;
        });
        return impl;
      }
      implementAsync(func) {
        if (typeof func !== "function") {
          throw new Error("implement() must be called with a function");
        }
        const impl = (async (...args) => {
          const parsedArgs = this._def.input ? await (0, parse_js_1.parseAsync)(this._def.input, args, void 0, { callee: impl }) : args;
          if (!Array.isArray(parsedArgs)) {
            throw new Error("Invalid arguments schema: not an array or tuple schema.");
          }
          const output = await func(...parsedArgs);
          return this._def.output ? (0, parse_js_1.parseAsync)(this._def.output, output, void 0, { callee: impl }) : output;
        });
        return impl;
      }
      input(...args) {
        const F = this.constructor;
        if (Array.isArray(args[0])) {
          return new F({
            type: "function",
            input: new schemas_js_1.$ZodTuple({
              type: "tuple",
              items: args[0],
              rest: args[1]
            }),
            output: this._def.output
          });
        }
        return new F({
          type: "function",
          input: args[0],
          output: this._def.output
        });
      }
      output(output) {
        const F = this.constructor;
        return new F({
          type: "function",
          input: this._def.input,
          output
        });
      }
    };
    exports2.$ZodFunction = $ZodFunction;
    function _function(params) {
      return new $ZodFunction({
        type: "function",
        input: Array.isArray(params?.input) ? (0, api_js_1._tuple)(schemas.$ZodTuple, params?.input) : params?.input ?? (0, api_js_1._array)(schemas.$ZodArray, (0, api_js_1._unknown)(schemas.$ZodUnknown)),
        output: params?.output ?? (0, api_js_1._unknown)(schemas.$ZodUnknown)
      });
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/to-json-schema.cjs
var require_to_json_schema2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/to-json-schema.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JSONSchemaGenerator = void 0;
    exports2.toJSONSchema = toJSONSchema;
    var registries_js_1 = require_registries2();
    var util_js_1 = require_util3();
    var JSONSchemaGenerator = class {
      constructor(params) {
        this.counter = 0;
        this.metadataRegistry = params?.metadata ?? registries_js_1.globalRegistry;
        this.target = params?.target ?? "draft-2020-12";
        this.unrepresentable = params?.unrepresentable ?? "throw";
        this.override = params?.override ?? (() => {
        });
        this.io = params?.io ?? "output";
        this.seen = /* @__PURE__ */ new Map();
      }
      process(schema, _params = { path: [], schemaPath: [] }) {
        var _a;
        const def = schema._zod.def;
        const formatMap = {
          guid: "uuid",
          url: "uri",
          datetime: "date-time",
          json_string: "json-string",
          regex: ""
          // do not set
        };
        const seen = this.seen.get(schema);
        if (seen) {
          seen.count++;
          const isCycle = _params.schemaPath.includes(schema);
          if (isCycle) {
            seen.cycle = _params.path;
          }
          return seen.schema;
        }
        const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
        this.seen.set(schema, result);
        const overrideSchema = schema._zod.toJSONSchema?.();
        if (overrideSchema) {
          result.schema = overrideSchema;
        } else {
          const params = {
            ..._params,
            schemaPath: [..._params.schemaPath, schema],
            path: _params.path
          };
          const parent = schema._zod.parent;
          if (parent) {
            result.ref = parent;
            this.process(parent, params);
            this.seen.get(parent).isParent = true;
          } else {
            const _json = result.schema;
            switch (def.type) {
              case "string": {
                const json = _json;
                json.type = "string";
                const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
                if (typeof minimum === "number")
                  json.minLength = minimum;
                if (typeof maximum === "number")
                  json.maxLength = maximum;
                if (format) {
                  json.format = formatMap[format] ?? format;
                  if (json.format === "")
                    delete json.format;
                }
                if (contentEncoding)
                  json.contentEncoding = contentEncoding;
                if (patterns && patterns.size > 0) {
                  const regexes = [...patterns];
                  if (regexes.length === 1)
                    json.pattern = regexes[0].source;
                  else if (regexes.length > 1) {
                    result.schema.allOf = [
                      ...regexes.map((regex) => ({
                        ...this.target === "draft-7" ? { type: "string" } : {},
                        pattern: regex.source
                      }))
                    ];
                  }
                }
                break;
              }
              case "number": {
                const json = _json;
                const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
                if (typeof format === "string" && format.includes("int"))
                  json.type = "integer";
                else
                  json.type = "number";
                if (typeof exclusiveMinimum === "number")
                  json.exclusiveMinimum = exclusiveMinimum;
                if (typeof minimum === "number") {
                  json.minimum = minimum;
                  if (typeof exclusiveMinimum === "number") {
                    if (exclusiveMinimum >= minimum)
                      delete json.minimum;
                    else
                      delete json.exclusiveMinimum;
                  }
                }
                if (typeof exclusiveMaximum === "number")
                  json.exclusiveMaximum = exclusiveMaximum;
                if (typeof maximum === "number") {
                  json.maximum = maximum;
                  if (typeof exclusiveMaximum === "number") {
                    if (exclusiveMaximum <= maximum)
                      delete json.maximum;
                    else
                      delete json.exclusiveMaximum;
                  }
                }
                if (typeof multipleOf === "number")
                  json.multipleOf = multipleOf;
                break;
              }
              case "boolean": {
                const json = _json;
                json.type = "boolean";
                break;
              }
              case "bigint": {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt cannot be represented in JSON Schema");
                }
                break;
              }
              case "symbol": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Symbols cannot be represented in JSON Schema");
                }
                break;
              }
              case "null": {
                _json.type = "null";
                break;
              }
              case "any": {
                break;
              }
              case "unknown": {
                break;
              }
              case "undefined": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Undefined cannot be represented in JSON Schema");
                }
                break;
              }
              case "void": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Void cannot be represented in JSON Schema");
                }
                break;
              }
              case "never": {
                _json.not = {};
                break;
              }
              case "date": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Date cannot be represented in JSON Schema");
                }
                break;
              }
              case "array": {
                const json = _json;
                const { minimum, maximum } = schema._zod.bag;
                if (typeof minimum === "number")
                  json.minItems = minimum;
                if (typeof maximum === "number")
                  json.maxItems = maximum;
                json.type = "array";
                json.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
                break;
              }
              case "object": {
                const json = _json;
                json.type = "object";
                json.properties = {};
                const shape = def.shape;
                for (const key in shape) {
                  json.properties[key] = this.process(shape[key], {
                    ...params,
                    path: [...params.path, "properties", key]
                  });
                }
                const allKeys = new Set(Object.keys(shape));
                const requiredKeys = new Set([...allKeys].filter((key) => {
                  const v = def.shape[key]._zod;
                  if (this.io === "input") {
                    return v.optin === void 0;
                  } else {
                    return v.optout === void 0;
                  }
                }));
                if (requiredKeys.size > 0) {
                  json.required = Array.from(requiredKeys);
                }
                if (def.catchall?._zod.def.type === "never") {
                  json.additionalProperties = false;
                } else if (!def.catchall) {
                  if (this.io === "output")
                    json.additionalProperties = false;
                } else if (def.catchall) {
                  json.additionalProperties = this.process(def.catchall, {
                    ...params,
                    path: [...params.path, "additionalProperties"]
                  });
                }
                break;
              }
              case "union": {
                const json = _json;
                json.anyOf = def.options.map((x, i) => this.process(x, {
                  ...params,
                  path: [...params.path, "anyOf", i]
                }));
                break;
              }
              case "intersection": {
                const json = _json;
                const a = this.process(def.left, {
                  ...params,
                  path: [...params.path, "allOf", 0]
                });
                const b = this.process(def.right, {
                  ...params,
                  path: [...params.path, "allOf", 1]
                });
                const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
                const allOf = [
                  ...isSimpleIntersection(a) ? a.allOf : [a],
                  ...isSimpleIntersection(b) ? b.allOf : [b]
                ];
                json.allOf = allOf;
                break;
              }
              case "tuple": {
                const json = _json;
                json.type = "array";
                const prefixItems = def.items.map((x, i) => this.process(x, { ...params, path: [...params.path, "prefixItems", i] }));
                if (this.target === "draft-2020-12") {
                  json.prefixItems = prefixItems;
                } else {
                  json.items = prefixItems;
                }
                if (def.rest) {
                  const rest = this.process(def.rest, {
                    ...params,
                    path: [...params.path, "items"]
                  });
                  if (this.target === "draft-2020-12") {
                    json.items = rest;
                  } else {
                    json.additionalItems = rest;
                  }
                }
                if (def.rest) {
                  json.items = this.process(def.rest, {
                    ...params,
                    path: [...params.path, "items"]
                  });
                }
                const { minimum, maximum } = schema._zod.bag;
                if (typeof minimum === "number")
                  json.minItems = minimum;
                if (typeof maximum === "number")
                  json.maxItems = maximum;
                break;
              }
              case "record": {
                const json = _json;
                json.type = "object";
                json.propertyNames = this.process(def.keyType, { ...params, path: [...params.path, "propertyNames"] });
                json.additionalProperties = this.process(def.valueType, {
                  ...params,
                  path: [...params.path, "additionalProperties"]
                });
                break;
              }
              case "map": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Map cannot be represented in JSON Schema");
                }
                break;
              }
              case "set": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Set cannot be represented in JSON Schema");
                }
                break;
              }
              case "enum": {
                const json = _json;
                const values = (0, util_js_1.getEnumValues)(def.entries);
                if (values.every((v) => typeof v === "number"))
                  json.type = "number";
                if (values.every((v) => typeof v === "string"))
                  json.type = "string";
                json.enum = values;
                break;
              }
              case "literal": {
                const json = _json;
                const vals = [];
                for (const val of def.values) {
                  if (val === void 0) {
                    if (this.unrepresentable === "throw") {
                      throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                    } else {
                    }
                  } else if (typeof val === "bigint") {
                    if (this.unrepresentable === "throw") {
                      throw new Error("BigInt literals cannot be represented in JSON Schema");
                    } else {
                      vals.push(Number(val));
                    }
                  } else {
                    vals.push(val);
                  }
                }
                if (vals.length === 0) {
                } else if (vals.length === 1) {
                  const val = vals[0];
                  json.type = val === null ? "null" : typeof val;
                  json.const = val;
                } else {
                  if (vals.every((v) => typeof v === "number"))
                    json.type = "number";
                  if (vals.every((v) => typeof v === "string"))
                    json.type = "string";
                  if (vals.every((v) => typeof v === "boolean"))
                    json.type = "string";
                  if (vals.every((v) => v === null))
                    json.type = "null";
                  json.enum = vals;
                }
                break;
              }
              case "file": {
                const json = _json;
                const file = {
                  type: "string",
                  format: "binary",
                  contentEncoding: "binary"
                };
                const { minimum, maximum, mime } = schema._zod.bag;
                if (minimum !== void 0)
                  file.minLength = minimum;
                if (maximum !== void 0)
                  file.maxLength = maximum;
                if (mime) {
                  if (mime.length === 1) {
                    file.contentMediaType = mime[0];
                    Object.assign(json, file);
                  } else {
                    json.anyOf = mime.map((m) => {
                      const mFile = { ...file, contentMediaType: m };
                      return mFile;
                    });
                  }
                } else {
                  Object.assign(json, file);
                }
                break;
              }
              case "transform": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Transforms cannot be represented in JSON Schema");
                }
                break;
              }
              case "nullable": {
                const inner = this.process(def.innerType, params);
                _json.anyOf = [inner, { type: "null" }];
                break;
              }
              case "nonoptional": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                break;
              }
              case "success": {
                const json = _json;
                json.type = "boolean";
                break;
              }
              case "default": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                _json.default = JSON.parse(JSON.stringify(def.defaultValue));
                break;
              }
              case "prefault": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                if (this.io === "input")
                  _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
                break;
              }
              case "catch": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                let catchValue;
                try {
                  catchValue = def.catchValue(void 0);
                } catch {
                  throw new Error("Dynamic catch values are not supported in JSON Schema");
                }
                _json.default = catchValue;
                break;
              }
              case "nan": {
                if (this.unrepresentable === "throw") {
                  throw new Error("NaN cannot be represented in JSON Schema");
                }
                break;
              }
              case "template_literal": {
                const json = _json;
                const pattern = schema._zod.pattern;
                if (!pattern)
                  throw new Error("Pattern not found in template literal");
                json.type = "string";
                json.pattern = pattern.source;
                break;
              }
              case "pipe": {
                const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
                this.process(innerType, params);
                result.ref = innerType;
                break;
              }
              case "readonly": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                _json.readOnly = true;
                break;
              }
              // passthrough types
              case "promise": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                break;
              }
              case "optional": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                break;
              }
              case "lazy": {
                const innerType = schema._zod.innerType;
                this.process(innerType, params);
                result.ref = innerType;
                break;
              }
              case "custom": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Custom types cannot be represented in JSON Schema");
                }
                break;
              }
              default: {
                def;
              }
            }
          }
        }
        const meta = this.metadataRegistry.get(schema);
        if (meta)
          Object.assign(result.schema, meta);
        if (this.io === "input" && isTransforming(schema)) {
          delete result.schema.examples;
          delete result.schema.default;
        }
        if (this.io === "input" && result.schema._prefault)
          (_a = result.schema).default ?? (_a.default = result.schema._prefault);
        delete result.schema._prefault;
        const _result = this.seen.get(schema);
        return _result.schema;
      }
      emit(schema, _params) {
        const params = {
          cycles: _params?.cycles ?? "ref",
          reused: _params?.reused ?? "inline",
          // unrepresentable: _params?.unrepresentable ?? "throw",
          // uri: _params?.uri ?? ((id) => `${id}`),
          external: _params?.external ?? void 0
        };
        const root = this.seen.get(schema);
        if (!root)
          throw new Error("Unprocessed schema. This is a bug in Zod.");
        const makeURI = (entry) => {
          const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
          if (params.external) {
            const externalId = params.external.registry.get(entry[0])?.id;
            const uriGenerator = params.external.uri ?? ((id2) => id2);
            if (externalId) {
              return { ref: uriGenerator(externalId) };
            }
            const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
            entry[1].defId = id;
            return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
          }
          if (entry[1] === root) {
            return { ref: "#" };
          }
          const uriPrefix = `#`;
          const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
          const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
          return { defId, ref: defUriPrefix + defId };
        };
        const extractToDef = (entry) => {
          if (entry[1].schema.$ref) {
            return;
          }
          const seen = entry[1];
          const { ref, defId } = makeURI(entry);
          seen.def = { ...seen.schema };
          if (defId)
            seen.defId = defId;
          const schema2 = seen.schema;
          for (const key in schema2) {
            delete schema2[key];
          }
          schema2.$ref = ref;
        };
        if (params.cycles === "throw") {
          for (const entry of this.seen.entries()) {
            const seen = entry[1];
            if (seen.cycle) {
              throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
            }
          }
        }
        for (const entry of this.seen.entries()) {
          const seen = entry[1];
          if (schema === entry[0]) {
            extractToDef(entry);
            continue;
          }
          if (params.external) {
            const ext = params.external.registry.get(entry[0])?.id;
            if (schema !== entry[0] && ext) {
              extractToDef(entry);
              continue;
            }
          }
          const id = this.metadataRegistry.get(entry[0])?.id;
          if (id) {
            extractToDef(entry);
            continue;
          }
          if (seen.cycle) {
            extractToDef(entry);
            continue;
          }
          if (seen.count > 1) {
            if (params.reused === "ref") {
              extractToDef(entry);
              continue;
            }
          }
        }
        const flattenRef = (zodSchema, params2) => {
          const seen = this.seen.get(zodSchema);
          const schema2 = seen.def ?? seen.schema;
          const _cached = { ...schema2 };
          if (seen.ref === null) {
            return;
          }
          const ref = seen.ref;
          seen.ref = null;
          if (ref) {
            flattenRef(ref, params2);
            const refSchema = this.seen.get(ref).schema;
            if (refSchema.$ref && params2.target === "draft-7") {
              schema2.allOf = schema2.allOf ?? [];
              schema2.allOf.push(refSchema);
            } else {
              Object.assign(schema2, refSchema);
              Object.assign(schema2, _cached);
            }
          }
          if (!seen.isParent)
            this.override({
              zodSchema,
              jsonSchema: schema2,
              path: seen.path ?? []
            });
        };
        for (const entry of [...this.seen.entries()].reverse()) {
          flattenRef(entry[0], { target: this.target });
        }
        const result = {};
        if (this.target === "draft-2020-12") {
          result.$schema = "https://json-schema.org/draft/2020-12/schema";
        } else if (this.target === "draft-7") {
          result.$schema = "http://json-schema.org/draft-07/schema#";
        } else {
          console.warn(`Invalid target: ${this.target}`);
        }
        if (params.external?.uri) {
          const id = params.external.registry.get(schema)?.id;
          if (!id)
            throw new Error("Schema is missing an `id` property");
          result.$id = params.external.uri(id);
        }
        Object.assign(result, root.def);
        const defs = params.external?.defs ?? {};
        for (const entry of this.seen.entries()) {
          const seen = entry[1];
          if (seen.def && seen.defId) {
            defs[seen.defId] = seen.def;
          }
        }
        if (params.external) {
        } else {
          if (Object.keys(defs).length > 0) {
            if (this.target === "draft-2020-12") {
              result.$defs = defs;
            } else {
              result.definitions = defs;
            }
          }
        }
        try {
          return JSON.parse(JSON.stringify(result));
        } catch (_err) {
          throw new Error("Error converting schema to JSON.");
        }
      }
    };
    exports2.JSONSchemaGenerator = JSONSchemaGenerator;
    function toJSONSchema(input, _params) {
      if (input instanceof registries_js_1.$ZodRegistry) {
        const gen2 = new JSONSchemaGenerator(_params);
        const defs = {};
        for (const entry of input._idmap.entries()) {
          const [_, schema] = entry;
          gen2.process(schema);
        }
        const schemas = {};
        const external = {
          registry: input,
          uri: _params?.uri,
          defs
        };
        for (const entry of input._idmap.entries()) {
          const [key, schema] = entry;
          schemas[key] = gen2.emit(schema, {
            ..._params,
            external
          });
        }
        if (Object.keys(defs).length > 0) {
          const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
          schemas.__shared = {
            [defsSegment]: defs
          };
        }
        return { schemas };
      }
      const gen = new JSONSchemaGenerator(_params);
      gen.process(input);
      return gen.emit(input, _params);
    }
    function isTransforming(_schema, _ctx) {
      const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
      if (ctx.seen.has(_schema))
        return false;
      ctx.seen.add(_schema);
      const schema = _schema;
      const def = schema._zod.def;
      switch (def.type) {
        case "string":
        case "number":
        case "bigint":
        case "boolean":
        case "date":
        case "symbol":
        case "undefined":
        case "null":
        case "any":
        case "unknown":
        case "never":
        case "void":
        case "literal":
        case "enum":
        case "nan":
        case "file":
        case "template_literal":
          return false;
        case "array": {
          return isTransforming(def.element, ctx);
        }
        case "object": {
          for (const key in def.shape) {
            if (isTransforming(def.shape[key], ctx))
              return true;
          }
          return false;
        }
        case "union": {
          for (const option of def.options) {
            if (isTransforming(option, ctx))
              return true;
          }
          return false;
        }
        case "intersection": {
          return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
        }
        case "tuple": {
          for (const item of def.items) {
            if (isTransforming(item, ctx))
              return true;
          }
          if (def.rest && isTransforming(def.rest, ctx))
            return true;
          return false;
        }
        case "record": {
          return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
        }
        case "map": {
          return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
        }
        case "set": {
          return isTransforming(def.valueType, ctx);
        }
        // inner types
        case "promise":
        case "optional":
        case "nonoptional":
        case "nullable":
        case "readonly":
          return isTransforming(def.innerType, ctx);
        case "lazy":
          return isTransforming(def.getter(), ctx);
        case "default": {
          return isTransforming(def.innerType, ctx);
        }
        case "prefault": {
          return isTransforming(def.innerType, ctx);
        }
        case "custom": {
          return false;
        }
        case "transform": {
          return true;
        }
        case "pipe": {
          return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
        }
        case "success": {
          return false;
        }
        case "catch": {
          return false;
        }
        default:
          def;
      }
      throw new Error(`Unknown schema type: ${def.type}`);
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/json-schema.cjs
var require_json_schema3 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/json-schema.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/index.cjs
var require_core5 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/core/index.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JSONSchema = exports2.locales = exports2.regexes = exports2.util = void 0;
    __exportStar(require_core4(), exports2);
    __exportStar(require_parse4(), exports2);
    __exportStar(require_errors6(), exports2);
    __exportStar(require_schemas3(), exports2);
    __exportStar(require_checks3(), exports2);
    __exportStar(require_versions2(), exports2);
    exports2.util = __importStar(require_util3());
    exports2.regexes = __importStar(require_regexes2());
    exports2.locales = __importStar(require_locales2());
    __exportStar(require_registries2(), exports2);
    __exportStar(require_doc2(), exports2);
    __exportStar(require_function2(), exports2);
    __exportStar(require_api2(), exports2);
    __exportStar(require_to_json_schema2(), exports2);
    exports2.JSONSchema = __importStar(require_json_schema3());
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/checks.cjs
var require_checks4 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/checks.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toUpperCase = exports2.toLowerCase = exports2.trim = exports2.normalize = exports2.overwrite = exports2.mime = exports2.property = exports2.endsWith = exports2.startsWith = exports2.includes = exports2.uppercase = exports2.lowercase = exports2.regex = exports2.length = exports2.minLength = exports2.maxLength = exports2.size = exports2.minSize = exports2.maxSize = exports2.multipleOf = exports2.nonnegative = exports2.nonpositive = exports2.negative = exports2.positive = exports2.gte = exports2.gt = exports2.lte = exports2.lt = void 0;
    var index_js_1 = require_core5();
    Object.defineProperty(exports2, "lt", { enumerable: true, get: function() {
      return index_js_1._lt;
    } });
    Object.defineProperty(exports2, "lte", { enumerable: true, get: function() {
      return index_js_1._lte;
    } });
    Object.defineProperty(exports2, "gt", { enumerable: true, get: function() {
      return index_js_1._gt;
    } });
    Object.defineProperty(exports2, "gte", { enumerable: true, get: function() {
      return index_js_1._gte;
    } });
    Object.defineProperty(exports2, "positive", { enumerable: true, get: function() {
      return index_js_1._positive;
    } });
    Object.defineProperty(exports2, "negative", { enumerable: true, get: function() {
      return index_js_1._negative;
    } });
    Object.defineProperty(exports2, "nonpositive", { enumerable: true, get: function() {
      return index_js_1._nonpositive;
    } });
    Object.defineProperty(exports2, "nonnegative", { enumerable: true, get: function() {
      return index_js_1._nonnegative;
    } });
    Object.defineProperty(exports2, "multipleOf", { enumerable: true, get: function() {
      return index_js_1._multipleOf;
    } });
    Object.defineProperty(exports2, "maxSize", { enumerable: true, get: function() {
      return index_js_1._maxSize;
    } });
    Object.defineProperty(exports2, "minSize", { enumerable: true, get: function() {
      return index_js_1._minSize;
    } });
    Object.defineProperty(exports2, "size", { enumerable: true, get: function() {
      return index_js_1._size;
    } });
    Object.defineProperty(exports2, "maxLength", { enumerable: true, get: function() {
      return index_js_1._maxLength;
    } });
    Object.defineProperty(exports2, "minLength", { enumerable: true, get: function() {
      return index_js_1._minLength;
    } });
    Object.defineProperty(exports2, "length", { enumerable: true, get: function() {
      return index_js_1._length;
    } });
    Object.defineProperty(exports2, "regex", { enumerable: true, get: function() {
      return index_js_1._regex;
    } });
    Object.defineProperty(exports2, "lowercase", { enumerable: true, get: function() {
      return index_js_1._lowercase;
    } });
    Object.defineProperty(exports2, "uppercase", { enumerable: true, get: function() {
      return index_js_1._uppercase;
    } });
    Object.defineProperty(exports2, "includes", { enumerable: true, get: function() {
      return index_js_1._includes;
    } });
    Object.defineProperty(exports2, "startsWith", { enumerable: true, get: function() {
      return index_js_1._startsWith;
    } });
    Object.defineProperty(exports2, "endsWith", { enumerable: true, get: function() {
      return index_js_1._endsWith;
    } });
    Object.defineProperty(exports2, "property", { enumerable: true, get: function() {
      return index_js_1._property;
    } });
    Object.defineProperty(exports2, "mime", { enumerable: true, get: function() {
      return index_js_1._mime;
    } });
    Object.defineProperty(exports2, "overwrite", { enumerable: true, get: function() {
      return index_js_1._overwrite;
    } });
    Object.defineProperty(exports2, "normalize", { enumerable: true, get: function() {
      return index_js_1._normalize;
    } });
    Object.defineProperty(exports2, "trim", { enumerable: true, get: function() {
      return index_js_1._trim;
    } });
    Object.defineProperty(exports2, "toLowerCase", { enumerable: true, get: function() {
      return index_js_1._toLowerCase;
    } });
    Object.defineProperty(exports2, "toUpperCase", { enumerable: true, get: function() {
      return index_js_1._toUpperCase;
    } });
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/iso.cjs
var require_iso2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/iso.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ZodISODuration = exports2.ZodISOTime = exports2.ZodISODate = exports2.ZodISODateTime = void 0;
    exports2.datetime = datetime;
    exports2.date = date;
    exports2.time = time;
    exports2.duration = duration;
    var core = __importStar(require_core5());
    var schemas = __importStar(require_schemas4());
    exports2.ZodISODateTime = core.$constructor("ZodISODateTime", (inst, def) => {
      core.$ZodISODateTime.init(inst, def);
      schemas.ZodStringFormat.init(inst, def);
    });
    function datetime(params) {
      return core._isoDateTime(exports2.ZodISODateTime, params);
    }
    exports2.ZodISODate = core.$constructor("ZodISODate", (inst, def) => {
      core.$ZodISODate.init(inst, def);
      schemas.ZodStringFormat.init(inst, def);
    });
    function date(params) {
      return core._isoDate(exports2.ZodISODate, params);
    }
    exports2.ZodISOTime = core.$constructor("ZodISOTime", (inst, def) => {
      core.$ZodISOTime.init(inst, def);
      schemas.ZodStringFormat.init(inst, def);
    });
    function time(params) {
      return core._isoTime(exports2.ZodISOTime, params);
    }
    exports2.ZodISODuration = core.$constructor("ZodISODuration", (inst, def) => {
      core.$ZodISODuration.init(inst, def);
      schemas.ZodStringFormat.init(inst, def);
    });
    function duration(params) {
      return core._isoDuration(exports2.ZodISODuration, params);
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/errors.cjs
var require_errors7 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/errors.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ZodRealError = exports2.ZodError = void 0;
    var core = __importStar(require_core5());
    var index_js_1 = require_core5();
    var initializer = (inst, issues) => {
      index_js_1.$ZodError.init(inst, issues);
      inst.name = "ZodError";
      Object.defineProperties(inst, {
        format: {
          value: (mapper) => core.formatError(inst, mapper)
          // enumerable: false,
        },
        flatten: {
          value: (mapper) => core.flattenError(inst, mapper)
          // enumerable: false,
        },
        addIssue: {
          value: (issue) => inst.issues.push(issue)
          // enumerable: false,
        },
        addIssues: {
          value: (issues2) => inst.issues.push(...issues2)
          // enumerable: false,
        },
        isEmpty: {
          get() {
            return inst.issues.length === 0;
          }
          // enumerable: false,
        }
      });
    };
    exports2.ZodError = core.$constructor("ZodError", initializer);
    exports2.ZodRealError = core.$constructor("ZodError", initializer, {
      Parent: Error
    });
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/parse.cjs
var require_parse5 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/parse.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.safeParseAsync = exports2.safeParse = exports2.parseAsync = exports2.parse = void 0;
    var core = __importStar(require_core5());
    var errors_js_1 = require_errors7();
    exports2.parse = core._parse(errors_js_1.ZodRealError);
    exports2.parseAsync = core._parseAsync(errors_js_1.ZodRealError);
    exports2.safeParse = core._safeParse(errors_js_1.ZodRealError);
    exports2.safeParseAsync = core._safeParseAsync(errors_js_1.ZodRealError);
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/schemas.cjs
var require_schemas4 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/schemas.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ZodTransform = exports2.ZodFile = exports2.ZodLiteral = exports2.ZodEnum = exports2.ZodSet = exports2.ZodMap = exports2.ZodRecord = exports2.ZodTuple = exports2.ZodIntersection = exports2.ZodDiscriminatedUnion = exports2.ZodUnion = exports2.ZodObject = exports2.ZodArray = exports2.ZodDate = exports2.ZodVoid = exports2.ZodNever = exports2.ZodUnknown = exports2.ZodAny = exports2.ZodNull = exports2.ZodUndefined = exports2.ZodSymbol = exports2.ZodBigIntFormat = exports2.ZodBigInt = exports2.ZodBoolean = exports2.ZodNumberFormat = exports2.ZodNumber = exports2.ZodCustomStringFormat = exports2.ZodJWT = exports2.ZodE164 = exports2.ZodBase64URL = exports2.ZodBase64 = exports2.ZodCIDRv6 = exports2.ZodCIDRv4 = exports2.ZodIPv6 = exports2.ZodIPv4 = exports2.ZodKSUID = exports2.ZodXID = exports2.ZodULID = exports2.ZodCUID2 = exports2.ZodCUID = exports2.ZodNanoID = exports2.ZodEmoji = exports2.ZodURL = exports2.ZodUUID = exports2.ZodGUID = exports2.ZodEmail = exports2.ZodStringFormat = exports2.ZodString = exports2._ZodString = exports2.ZodType = void 0;
    exports2.stringbool = exports2.ZodCustom = exports2.ZodPromise = exports2.ZodLazy = exports2.ZodTemplateLiteral = exports2.ZodReadonly = exports2.ZodPipe = exports2.ZodNaN = exports2.ZodCatch = exports2.ZodSuccess = exports2.ZodNonOptional = exports2.ZodPrefault = exports2.ZodDefault = exports2.ZodNullable = exports2.ZodOptional = void 0;
    exports2.string = string;
    exports2.email = email;
    exports2.guid = guid;
    exports2.uuid = uuid;
    exports2.uuidv4 = uuidv4;
    exports2.uuidv6 = uuidv6;
    exports2.uuidv7 = uuidv7;
    exports2.url = url;
    exports2.emoji = emoji;
    exports2.nanoid = nanoid;
    exports2.cuid = cuid;
    exports2.cuid2 = cuid2;
    exports2.ulid = ulid;
    exports2.xid = xid;
    exports2.ksuid = ksuid;
    exports2.ipv4 = ipv4;
    exports2.ipv6 = ipv6;
    exports2.cidrv4 = cidrv4;
    exports2.cidrv6 = cidrv6;
    exports2.base64 = base64;
    exports2.base64url = base64url;
    exports2.e164 = e164;
    exports2.jwt = jwt;
    exports2.stringFormat = stringFormat;
    exports2.number = number;
    exports2.int = int;
    exports2.float32 = float32;
    exports2.float64 = float64;
    exports2.int32 = int32;
    exports2.uint32 = uint32;
    exports2.boolean = boolean;
    exports2.bigint = bigint;
    exports2.int64 = int64;
    exports2.uint64 = uint64;
    exports2.symbol = symbol;
    exports2.undefined = _undefined;
    exports2.null = _null;
    exports2.any = any;
    exports2.unknown = unknown;
    exports2.never = never;
    exports2.void = _void;
    exports2.date = date;
    exports2.array = array;
    exports2.keyof = keyof;
    exports2.object = object;
    exports2.strictObject = strictObject;
    exports2.looseObject = looseObject;
    exports2.union = union;
    exports2.discriminatedUnion = discriminatedUnion;
    exports2.intersection = intersection;
    exports2.tuple = tuple;
    exports2.record = record;
    exports2.partialRecord = partialRecord;
    exports2.map = map;
    exports2.set = set;
    exports2.enum = _enum;
    exports2.nativeEnum = nativeEnum;
    exports2.literal = literal;
    exports2.file = file;
    exports2.transform = transform;
    exports2.optional = optional;
    exports2.nullable = nullable;
    exports2.nullish = nullish;
    exports2._default = _default;
    exports2.prefault = prefault;
    exports2.nonoptional = nonoptional;
    exports2.success = success;
    exports2.catch = _catch;
    exports2.nan = nan;
    exports2.pipe = pipe;
    exports2.readonly = readonly;
    exports2.templateLiteral = templateLiteral;
    exports2.lazy = lazy;
    exports2.promise = promise;
    exports2.check = check;
    exports2.custom = custom;
    exports2.refine = refine;
    exports2.superRefine = superRefine;
    exports2.instanceof = _instanceof;
    exports2.json = json;
    exports2.preprocess = preprocess;
    var core = __importStar(require_core5());
    var index_js_1 = require_core5();
    var checks = __importStar(require_checks4());
    var iso = __importStar(require_iso2());
    var parse2 = __importStar(require_parse5());
    exports2.ZodType = core.$constructor("ZodType", (inst, def) => {
      core.$ZodType.init(inst, def);
      inst.def = def;
      Object.defineProperty(inst, "_def", { value: def });
      inst.check = (...checks2) => {
        return inst.clone(
          {
            ...def,
            checks: [
              ...def.checks ?? [],
              ...checks2.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
            ]
          }
          // { parent: true }
        );
      };
      inst.clone = (def2, params) => core.clone(inst, def2, params);
      inst.brand = () => inst;
      inst.register = ((reg, meta) => {
        reg.add(inst, meta);
        return inst;
      });
      inst.parse = (data, params) => parse2.parse(inst, data, params, { callee: inst.parse });
      inst.safeParse = (data, params) => parse2.safeParse(inst, data, params);
      inst.parseAsync = async (data, params) => parse2.parseAsync(inst, data, params, { callee: inst.parseAsync });
      inst.safeParseAsync = async (data, params) => parse2.safeParseAsync(inst, data, params);
      inst.spa = inst.safeParseAsync;
      inst.refine = (check2, params) => inst.check(refine(check2, params));
      inst.superRefine = (refinement) => inst.check(superRefine(refinement));
      inst.overwrite = (fn) => inst.check(checks.overwrite(fn));
      inst.optional = () => optional(inst);
      inst.nullable = () => nullable(inst);
      inst.nullish = () => optional(nullable(inst));
      inst.nonoptional = (params) => nonoptional(inst, params);
      inst.array = () => array(inst);
      inst.or = (arg) => union([inst, arg]);
      inst.and = (arg) => intersection(inst, arg);
      inst.transform = (tx) => pipe(inst, transform(tx));
      inst.default = (def2) => _default(inst, def2);
      inst.prefault = (def2) => prefault(inst, def2);
      inst.catch = (params) => _catch(inst, params);
      inst.pipe = (target) => pipe(inst, target);
      inst.readonly = () => readonly(inst);
      inst.describe = (description) => {
        const cl = inst.clone();
        core.globalRegistry.add(cl, { description });
        return cl;
      };
      Object.defineProperty(inst, "description", {
        get() {
          return core.globalRegistry.get(inst)?.description;
        },
        configurable: true
      });
      inst.meta = (...args) => {
        if (args.length === 0) {
          return core.globalRegistry.get(inst);
        }
        const cl = inst.clone();
        core.globalRegistry.add(cl, args[0]);
        return cl;
      };
      inst.isOptional = () => inst.safeParse(void 0).success;
      inst.isNullable = () => inst.safeParse(null).success;
      return inst;
    });
    exports2._ZodString = core.$constructor("_ZodString", (inst, def) => {
      core.$ZodString.init(inst, def);
      exports2.ZodType.init(inst, def);
      const bag = inst._zod.bag;
      inst.format = bag.format ?? null;
      inst.minLength = bag.minimum ?? null;
      inst.maxLength = bag.maximum ?? null;
      inst.regex = (...args) => inst.check(checks.regex(...args));
      inst.includes = (...args) => inst.check(checks.includes(...args));
      inst.startsWith = (...args) => inst.check(checks.startsWith(...args));
      inst.endsWith = (...args) => inst.check(checks.endsWith(...args));
      inst.min = (...args) => inst.check(checks.minLength(...args));
      inst.max = (...args) => inst.check(checks.maxLength(...args));
      inst.length = (...args) => inst.check(checks.length(...args));
      inst.nonempty = (...args) => inst.check(checks.minLength(1, ...args));
      inst.lowercase = (params) => inst.check(checks.lowercase(params));
      inst.uppercase = (params) => inst.check(checks.uppercase(params));
      inst.trim = () => inst.check(checks.trim());
      inst.normalize = (...args) => inst.check(checks.normalize(...args));
      inst.toLowerCase = () => inst.check(checks.toLowerCase());
      inst.toUpperCase = () => inst.check(checks.toUpperCase());
    });
    exports2.ZodString = core.$constructor("ZodString", (inst, def) => {
      core.$ZodString.init(inst, def);
      exports2._ZodString.init(inst, def);
      inst.email = (params) => inst.check(core._email(exports2.ZodEmail, params));
      inst.url = (params) => inst.check(core._url(exports2.ZodURL, params));
      inst.jwt = (params) => inst.check(core._jwt(exports2.ZodJWT, params));
      inst.emoji = (params) => inst.check(core._emoji(exports2.ZodEmoji, params));
      inst.guid = (params) => inst.check(core._guid(exports2.ZodGUID, params));
      inst.uuid = (params) => inst.check(core._uuid(exports2.ZodUUID, params));
      inst.uuidv4 = (params) => inst.check(core._uuidv4(exports2.ZodUUID, params));
      inst.uuidv6 = (params) => inst.check(core._uuidv6(exports2.ZodUUID, params));
      inst.uuidv7 = (params) => inst.check(core._uuidv7(exports2.ZodUUID, params));
      inst.nanoid = (params) => inst.check(core._nanoid(exports2.ZodNanoID, params));
      inst.guid = (params) => inst.check(core._guid(exports2.ZodGUID, params));
      inst.cuid = (params) => inst.check(core._cuid(exports2.ZodCUID, params));
      inst.cuid2 = (params) => inst.check(core._cuid2(exports2.ZodCUID2, params));
      inst.ulid = (params) => inst.check(core._ulid(exports2.ZodULID, params));
      inst.base64 = (params) => inst.check(core._base64(exports2.ZodBase64, params));
      inst.base64url = (params) => inst.check(core._base64url(exports2.ZodBase64URL, params));
      inst.xid = (params) => inst.check(core._xid(exports2.ZodXID, params));
      inst.ksuid = (params) => inst.check(core._ksuid(exports2.ZodKSUID, params));
      inst.ipv4 = (params) => inst.check(core._ipv4(exports2.ZodIPv4, params));
      inst.ipv6 = (params) => inst.check(core._ipv6(exports2.ZodIPv6, params));
      inst.cidrv4 = (params) => inst.check(core._cidrv4(exports2.ZodCIDRv4, params));
      inst.cidrv6 = (params) => inst.check(core._cidrv6(exports2.ZodCIDRv6, params));
      inst.e164 = (params) => inst.check(core._e164(exports2.ZodE164, params));
      inst.datetime = (params) => inst.check(iso.datetime(params));
      inst.date = (params) => inst.check(iso.date(params));
      inst.time = (params) => inst.check(iso.time(params));
      inst.duration = (params) => inst.check(iso.duration(params));
    });
    function string(params) {
      return core._string(exports2.ZodString, params);
    }
    exports2.ZodStringFormat = core.$constructor("ZodStringFormat", (inst, def) => {
      core.$ZodStringFormat.init(inst, def);
      exports2._ZodString.init(inst, def);
    });
    exports2.ZodEmail = core.$constructor("ZodEmail", (inst, def) => {
      core.$ZodEmail.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function email(params) {
      return core._email(exports2.ZodEmail, params);
    }
    exports2.ZodGUID = core.$constructor("ZodGUID", (inst, def) => {
      core.$ZodGUID.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function guid(params) {
      return core._guid(exports2.ZodGUID, params);
    }
    exports2.ZodUUID = core.$constructor("ZodUUID", (inst, def) => {
      core.$ZodUUID.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function uuid(params) {
      return core._uuid(exports2.ZodUUID, params);
    }
    function uuidv4(params) {
      return core._uuidv4(exports2.ZodUUID, params);
    }
    function uuidv6(params) {
      return core._uuidv6(exports2.ZodUUID, params);
    }
    function uuidv7(params) {
      return core._uuidv7(exports2.ZodUUID, params);
    }
    exports2.ZodURL = core.$constructor("ZodURL", (inst, def) => {
      core.$ZodURL.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function url(params) {
      return core._url(exports2.ZodURL, params);
    }
    exports2.ZodEmoji = core.$constructor("ZodEmoji", (inst, def) => {
      core.$ZodEmoji.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function emoji(params) {
      return core._emoji(exports2.ZodEmoji, params);
    }
    exports2.ZodNanoID = core.$constructor("ZodNanoID", (inst, def) => {
      core.$ZodNanoID.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function nanoid(params) {
      return core._nanoid(exports2.ZodNanoID, params);
    }
    exports2.ZodCUID = core.$constructor("ZodCUID", (inst, def) => {
      core.$ZodCUID.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function cuid(params) {
      return core._cuid(exports2.ZodCUID, params);
    }
    exports2.ZodCUID2 = core.$constructor("ZodCUID2", (inst, def) => {
      core.$ZodCUID2.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function cuid2(params) {
      return core._cuid2(exports2.ZodCUID2, params);
    }
    exports2.ZodULID = core.$constructor("ZodULID", (inst, def) => {
      core.$ZodULID.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function ulid(params) {
      return core._ulid(exports2.ZodULID, params);
    }
    exports2.ZodXID = core.$constructor("ZodXID", (inst, def) => {
      core.$ZodXID.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function xid(params) {
      return core._xid(exports2.ZodXID, params);
    }
    exports2.ZodKSUID = core.$constructor("ZodKSUID", (inst, def) => {
      core.$ZodKSUID.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function ksuid(params) {
      return core._ksuid(exports2.ZodKSUID, params);
    }
    exports2.ZodIPv4 = core.$constructor("ZodIPv4", (inst, def) => {
      core.$ZodIPv4.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function ipv4(params) {
      return core._ipv4(exports2.ZodIPv4, params);
    }
    exports2.ZodIPv6 = core.$constructor("ZodIPv6", (inst, def) => {
      core.$ZodIPv6.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function ipv6(params) {
      return core._ipv6(exports2.ZodIPv6, params);
    }
    exports2.ZodCIDRv4 = core.$constructor("ZodCIDRv4", (inst, def) => {
      core.$ZodCIDRv4.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function cidrv4(params) {
      return core._cidrv4(exports2.ZodCIDRv4, params);
    }
    exports2.ZodCIDRv6 = core.$constructor("ZodCIDRv6", (inst, def) => {
      core.$ZodCIDRv6.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function cidrv6(params) {
      return core._cidrv6(exports2.ZodCIDRv6, params);
    }
    exports2.ZodBase64 = core.$constructor("ZodBase64", (inst, def) => {
      core.$ZodBase64.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function base64(params) {
      return core._base64(exports2.ZodBase64, params);
    }
    exports2.ZodBase64URL = core.$constructor("ZodBase64URL", (inst, def) => {
      core.$ZodBase64URL.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function base64url(params) {
      return core._base64url(exports2.ZodBase64URL, params);
    }
    exports2.ZodE164 = core.$constructor("ZodE164", (inst, def) => {
      core.$ZodE164.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function e164(params) {
      return core._e164(exports2.ZodE164, params);
    }
    exports2.ZodJWT = core.$constructor("ZodJWT", (inst, def) => {
      core.$ZodJWT.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function jwt(params) {
      return core._jwt(exports2.ZodJWT, params);
    }
    exports2.ZodCustomStringFormat = core.$constructor("ZodCustomStringFormat", (inst, def) => {
      core.$ZodCustomStringFormat.init(inst, def);
      exports2.ZodStringFormat.init(inst, def);
    });
    function stringFormat(format, fnOrRegex, _params = {}) {
      return core._stringFormat(exports2.ZodCustomStringFormat, format, fnOrRegex, _params);
    }
    exports2.ZodNumber = core.$constructor("ZodNumber", (inst, def) => {
      core.$ZodNumber.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.gt = (value, params) => inst.check(checks.gt(value, params));
      inst.gte = (value, params) => inst.check(checks.gte(value, params));
      inst.min = (value, params) => inst.check(checks.gte(value, params));
      inst.lt = (value, params) => inst.check(checks.lt(value, params));
      inst.lte = (value, params) => inst.check(checks.lte(value, params));
      inst.max = (value, params) => inst.check(checks.lte(value, params));
      inst.int = (params) => inst.check(int(params));
      inst.safe = (params) => inst.check(int(params));
      inst.positive = (params) => inst.check(checks.gt(0, params));
      inst.nonnegative = (params) => inst.check(checks.gte(0, params));
      inst.negative = (params) => inst.check(checks.lt(0, params));
      inst.nonpositive = (params) => inst.check(checks.lte(0, params));
      inst.multipleOf = (value, params) => inst.check(checks.multipleOf(value, params));
      inst.step = (value, params) => inst.check(checks.multipleOf(value, params));
      inst.finite = () => inst;
      const bag = inst._zod.bag;
      inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
      inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
      inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
      inst.isFinite = true;
      inst.format = bag.format ?? null;
    });
    function number(params) {
      return core._number(exports2.ZodNumber, params);
    }
    exports2.ZodNumberFormat = core.$constructor("ZodNumberFormat", (inst, def) => {
      core.$ZodNumberFormat.init(inst, def);
      exports2.ZodNumber.init(inst, def);
    });
    function int(params) {
      return core._int(exports2.ZodNumberFormat, params);
    }
    function float32(params) {
      return core._float32(exports2.ZodNumberFormat, params);
    }
    function float64(params) {
      return core._float64(exports2.ZodNumberFormat, params);
    }
    function int32(params) {
      return core._int32(exports2.ZodNumberFormat, params);
    }
    function uint32(params) {
      return core._uint32(exports2.ZodNumberFormat, params);
    }
    exports2.ZodBoolean = core.$constructor("ZodBoolean", (inst, def) => {
      core.$ZodBoolean.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function boolean(params) {
      return core._boolean(exports2.ZodBoolean, params);
    }
    exports2.ZodBigInt = core.$constructor("ZodBigInt", (inst, def) => {
      core.$ZodBigInt.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.gte = (value, params) => inst.check(checks.gte(value, params));
      inst.min = (value, params) => inst.check(checks.gte(value, params));
      inst.gt = (value, params) => inst.check(checks.gt(value, params));
      inst.gte = (value, params) => inst.check(checks.gte(value, params));
      inst.min = (value, params) => inst.check(checks.gte(value, params));
      inst.lt = (value, params) => inst.check(checks.lt(value, params));
      inst.lte = (value, params) => inst.check(checks.lte(value, params));
      inst.max = (value, params) => inst.check(checks.lte(value, params));
      inst.positive = (params) => inst.check(checks.gt(BigInt(0), params));
      inst.negative = (params) => inst.check(checks.lt(BigInt(0), params));
      inst.nonpositive = (params) => inst.check(checks.lte(BigInt(0), params));
      inst.nonnegative = (params) => inst.check(checks.gte(BigInt(0), params));
      inst.multipleOf = (value, params) => inst.check(checks.multipleOf(value, params));
      const bag = inst._zod.bag;
      inst.minValue = bag.minimum ?? null;
      inst.maxValue = bag.maximum ?? null;
      inst.format = bag.format ?? null;
    });
    function bigint(params) {
      return core._bigint(exports2.ZodBigInt, params);
    }
    exports2.ZodBigIntFormat = core.$constructor("ZodBigIntFormat", (inst, def) => {
      core.$ZodBigIntFormat.init(inst, def);
      exports2.ZodBigInt.init(inst, def);
    });
    function int64(params) {
      return core._int64(exports2.ZodBigIntFormat, params);
    }
    function uint64(params) {
      return core._uint64(exports2.ZodBigIntFormat, params);
    }
    exports2.ZodSymbol = core.$constructor("ZodSymbol", (inst, def) => {
      core.$ZodSymbol.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function symbol(params) {
      return core._symbol(exports2.ZodSymbol, params);
    }
    exports2.ZodUndefined = core.$constructor("ZodUndefined", (inst, def) => {
      core.$ZodUndefined.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function _undefined(params) {
      return core._undefined(exports2.ZodUndefined, params);
    }
    exports2.ZodNull = core.$constructor("ZodNull", (inst, def) => {
      core.$ZodNull.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function _null(params) {
      return core._null(exports2.ZodNull, params);
    }
    exports2.ZodAny = core.$constructor("ZodAny", (inst, def) => {
      core.$ZodAny.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function any() {
      return core._any(exports2.ZodAny);
    }
    exports2.ZodUnknown = core.$constructor("ZodUnknown", (inst, def) => {
      core.$ZodUnknown.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function unknown() {
      return core._unknown(exports2.ZodUnknown);
    }
    exports2.ZodNever = core.$constructor("ZodNever", (inst, def) => {
      core.$ZodNever.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function never(params) {
      return core._never(exports2.ZodNever, params);
    }
    exports2.ZodVoid = core.$constructor("ZodVoid", (inst, def) => {
      core.$ZodVoid.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function _void(params) {
      return core._void(exports2.ZodVoid, params);
    }
    exports2.ZodDate = core.$constructor("ZodDate", (inst, def) => {
      core.$ZodDate.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.min = (value, params) => inst.check(checks.gte(value, params));
      inst.max = (value, params) => inst.check(checks.lte(value, params));
      const c = inst._zod.bag;
      inst.minDate = c.minimum ? new Date(c.minimum) : null;
      inst.maxDate = c.maximum ? new Date(c.maximum) : null;
    });
    function date(params) {
      return core._date(exports2.ZodDate, params);
    }
    exports2.ZodArray = core.$constructor("ZodArray", (inst, def) => {
      core.$ZodArray.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.element = def.element;
      inst.min = (minLength, params) => inst.check(checks.minLength(minLength, params));
      inst.nonempty = (params) => inst.check(checks.minLength(1, params));
      inst.max = (maxLength, params) => inst.check(checks.maxLength(maxLength, params));
      inst.length = (len, params) => inst.check(checks.length(len, params));
      inst.unwrap = () => inst.element;
    });
    function array(element, params) {
      return core._array(exports2.ZodArray, element, params);
    }
    function keyof(schema) {
      const shape = schema._zod.def.shape;
      return literal(Object.keys(shape));
    }
    exports2.ZodObject = core.$constructor("ZodObject", (inst, def) => {
      core.$ZodObject.init(inst, def);
      exports2.ZodType.init(inst, def);
      index_js_1.util.defineLazy(inst, "shape", () => def.shape);
      inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
      inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
      inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
      inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
      inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
      inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
      inst.extend = (incoming) => {
        return index_js_1.util.extend(inst, incoming);
      };
      inst.merge = (other) => index_js_1.util.merge(inst, other);
      inst.pick = (mask) => index_js_1.util.pick(inst, mask);
      inst.omit = (mask) => index_js_1.util.omit(inst, mask);
      inst.partial = (...args) => index_js_1.util.partial(exports2.ZodOptional, inst, args[0]);
      inst.required = (...args) => index_js_1.util.required(exports2.ZodNonOptional, inst, args[0]);
    });
    function object(shape, params) {
      const def = {
        type: "object",
        get shape() {
          index_js_1.util.assignProp(this, "shape", { ...shape });
          return this.shape;
        },
        ...index_js_1.util.normalizeParams(params)
      };
      return new exports2.ZodObject(def);
    }
    function strictObject(shape, params) {
      return new exports2.ZodObject({
        type: "object",
        get shape() {
          index_js_1.util.assignProp(this, "shape", { ...shape });
          return this.shape;
        },
        catchall: never(),
        ...index_js_1.util.normalizeParams(params)
      });
    }
    function looseObject(shape, params) {
      return new exports2.ZodObject({
        type: "object",
        get shape() {
          index_js_1.util.assignProp(this, "shape", { ...shape });
          return this.shape;
        },
        catchall: unknown(),
        ...index_js_1.util.normalizeParams(params)
      });
    }
    exports2.ZodUnion = core.$constructor("ZodUnion", (inst, def) => {
      core.$ZodUnion.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.options = def.options;
    });
    function union(options, params) {
      return new exports2.ZodUnion({
        type: "union",
        options,
        ...index_js_1.util.normalizeParams(params)
      });
    }
    exports2.ZodDiscriminatedUnion = core.$constructor("ZodDiscriminatedUnion", (inst, def) => {
      exports2.ZodUnion.init(inst, def);
      core.$ZodDiscriminatedUnion.init(inst, def);
    });
    function discriminatedUnion(discriminator, options, params) {
      return new exports2.ZodDiscriminatedUnion({
        type: "union",
        options,
        discriminator,
        ...index_js_1.util.normalizeParams(params)
      });
    }
    exports2.ZodIntersection = core.$constructor("ZodIntersection", (inst, def) => {
      core.$ZodIntersection.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function intersection(left, right) {
      return new exports2.ZodIntersection({
        type: "intersection",
        left,
        right
      });
    }
    exports2.ZodTuple = core.$constructor("ZodTuple", (inst, def) => {
      core.$ZodTuple.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.rest = (rest) => inst.clone({
        ...inst._zod.def,
        rest
      });
    });
    function tuple(items, _paramsOrRest, _params) {
      const hasRest = _paramsOrRest instanceof core.$ZodType;
      const params = hasRest ? _params : _paramsOrRest;
      const rest = hasRest ? _paramsOrRest : null;
      return new exports2.ZodTuple({
        type: "tuple",
        items,
        rest,
        ...index_js_1.util.normalizeParams(params)
      });
    }
    exports2.ZodRecord = core.$constructor("ZodRecord", (inst, def) => {
      core.$ZodRecord.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
    });
    function record(keyType, valueType, params) {
      return new exports2.ZodRecord({
        type: "record",
        keyType,
        valueType,
        ...index_js_1.util.normalizeParams(params)
      });
    }
    function partialRecord(keyType, valueType, params) {
      return new exports2.ZodRecord({
        type: "record",
        keyType: union([keyType, never()]),
        valueType,
        ...index_js_1.util.normalizeParams(params)
      });
    }
    exports2.ZodMap = core.$constructor("ZodMap", (inst, def) => {
      core.$ZodMap.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
    });
    function map(keyType, valueType, params) {
      return new exports2.ZodMap({
        type: "map",
        keyType,
        valueType,
        ...index_js_1.util.normalizeParams(params)
      });
    }
    exports2.ZodSet = core.$constructor("ZodSet", (inst, def) => {
      core.$ZodSet.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.min = (...args) => inst.check(core._minSize(...args));
      inst.nonempty = (params) => inst.check(core._minSize(1, params));
      inst.max = (...args) => inst.check(core._maxSize(...args));
      inst.size = (...args) => inst.check(core._size(...args));
    });
    function set(valueType, params) {
      return new exports2.ZodSet({
        type: "set",
        valueType,
        ...index_js_1.util.normalizeParams(params)
      });
    }
    exports2.ZodEnum = core.$constructor("ZodEnum", (inst, def) => {
      core.$ZodEnum.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.enum = def.entries;
      inst.options = Object.values(def.entries);
      const keys = new Set(Object.keys(def.entries));
      inst.extract = (values, params) => {
        const newEntries = {};
        for (const value of values) {
          if (keys.has(value)) {
            newEntries[value] = def.entries[value];
          } else
            throw new Error(`Key ${value} not found in enum`);
        }
        return new exports2.ZodEnum({
          ...def,
          checks: [],
          ...index_js_1.util.normalizeParams(params),
          entries: newEntries
        });
      };
      inst.exclude = (values, params) => {
        const newEntries = { ...def.entries };
        for (const value of values) {
          if (keys.has(value)) {
            delete newEntries[value];
          } else
            throw new Error(`Key ${value} not found in enum`);
        }
        return new exports2.ZodEnum({
          ...def,
          checks: [],
          ...index_js_1.util.normalizeParams(params),
          entries: newEntries
        });
      };
    });
    function _enum(values, params) {
      const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
      return new exports2.ZodEnum({
        type: "enum",
        entries,
        ...index_js_1.util.normalizeParams(params)
      });
    }
    function nativeEnum(entries, params) {
      return new exports2.ZodEnum({
        type: "enum",
        entries,
        ...index_js_1.util.normalizeParams(params)
      });
    }
    exports2.ZodLiteral = core.$constructor("ZodLiteral", (inst, def) => {
      core.$ZodLiteral.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.values = new Set(def.values);
      Object.defineProperty(inst, "value", {
        get() {
          if (def.values.length > 1) {
            throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
          }
          return def.values[0];
        }
      });
    });
    function literal(value, params) {
      return new exports2.ZodLiteral({
        type: "literal",
        values: Array.isArray(value) ? value : [value],
        ...index_js_1.util.normalizeParams(params)
      });
    }
    exports2.ZodFile = core.$constructor("ZodFile", (inst, def) => {
      core.$ZodFile.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.min = (size, params) => inst.check(core._minSize(size, params));
      inst.max = (size, params) => inst.check(core._maxSize(size, params));
      inst.mime = (types, params) => inst.check(core._mime(Array.isArray(types) ? types : [types], params));
    });
    function file(params) {
      return core._file(exports2.ZodFile, params);
    }
    exports2.ZodTransform = core.$constructor("ZodTransform", (inst, def) => {
      core.$ZodTransform.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        payload.addIssue = (issue) => {
          if (typeof issue === "string") {
            payload.issues.push(index_js_1.util.issue(issue, payload.value, def));
          } else {
            const _issue = issue;
            if (_issue.fatal)
              _issue.continue = false;
            _issue.code ?? (_issue.code = "custom");
            _issue.input ?? (_issue.input = payload.value);
            _issue.inst ?? (_issue.inst = inst);
            _issue.continue ?? (_issue.continue = true);
            payload.issues.push(index_js_1.util.issue(_issue));
          }
        };
        const output = def.transform(payload.value, payload);
        if (output instanceof Promise) {
          return output.then((output2) => {
            payload.value = output2;
            return payload;
          });
        }
        payload.value = output;
        return payload;
      };
    });
    function transform(fn) {
      return new exports2.ZodTransform({
        type: "transform",
        transform: fn
      });
    }
    exports2.ZodOptional = core.$constructor("ZodOptional", (inst, def) => {
      core.$ZodOptional.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    function optional(innerType) {
      return new exports2.ZodOptional({
        type: "optional",
        innerType
      });
    }
    exports2.ZodNullable = core.$constructor("ZodNullable", (inst, def) => {
      core.$ZodNullable.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    function nullable(innerType) {
      return new exports2.ZodNullable({
        type: "nullable",
        innerType
      });
    }
    function nullish(innerType) {
      return optional(nullable(innerType));
    }
    exports2.ZodDefault = core.$constructor("ZodDefault", (inst, def) => {
      core.$ZodDefault.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeDefault = inst.unwrap;
    });
    function _default(innerType, defaultValue) {
      return new exports2.ZodDefault({
        type: "default",
        innerType,
        get defaultValue() {
          return typeof defaultValue === "function" ? defaultValue() : defaultValue;
        }
      });
    }
    exports2.ZodPrefault = core.$constructor("ZodPrefault", (inst, def) => {
      core.$ZodPrefault.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    function prefault(innerType, defaultValue) {
      return new exports2.ZodPrefault({
        type: "prefault",
        innerType,
        get defaultValue() {
          return typeof defaultValue === "function" ? defaultValue() : defaultValue;
        }
      });
    }
    exports2.ZodNonOptional = core.$constructor("ZodNonOptional", (inst, def) => {
      core.$ZodNonOptional.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    function nonoptional(innerType, params) {
      return new exports2.ZodNonOptional({
        type: "nonoptional",
        innerType,
        ...index_js_1.util.normalizeParams(params)
      });
    }
    exports2.ZodSuccess = core.$constructor("ZodSuccess", (inst, def) => {
      core.$ZodSuccess.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    function success(innerType) {
      return new exports2.ZodSuccess({
        type: "success",
        innerType
      });
    }
    exports2.ZodCatch = core.$constructor("ZodCatch", (inst, def) => {
      core.$ZodCatch.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeCatch = inst.unwrap;
    });
    function _catch(innerType, catchValue) {
      return new exports2.ZodCatch({
        type: "catch",
        innerType,
        catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
      });
    }
    exports2.ZodNaN = core.$constructor("ZodNaN", (inst, def) => {
      core.$ZodNaN.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function nan(params) {
      return core._nan(exports2.ZodNaN, params);
    }
    exports2.ZodPipe = core.$constructor("ZodPipe", (inst, def) => {
      core.$ZodPipe.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.in = def.in;
      inst.out = def.out;
    });
    function pipe(in_, out) {
      return new exports2.ZodPipe({
        type: "pipe",
        in: in_,
        out
        // ...util.normalizeParams(params),
      });
    }
    exports2.ZodReadonly = core.$constructor("ZodReadonly", (inst, def) => {
      core.$ZodReadonly.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function readonly(innerType) {
      return new exports2.ZodReadonly({
        type: "readonly",
        innerType
      });
    }
    exports2.ZodTemplateLiteral = core.$constructor("ZodTemplateLiteral", (inst, def) => {
      core.$ZodTemplateLiteral.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function templateLiteral(parts, params) {
      return new exports2.ZodTemplateLiteral({
        type: "template_literal",
        parts,
        ...index_js_1.util.normalizeParams(params)
      });
    }
    exports2.ZodLazy = core.$constructor("ZodLazy", (inst, def) => {
      core.$ZodLazy.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.getter();
    });
    function lazy(getter) {
      return new exports2.ZodLazy({
        type: "lazy",
        getter
      });
    }
    exports2.ZodPromise = core.$constructor("ZodPromise", (inst, def) => {
      core.$ZodPromise.init(inst, def);
      exports2.ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    function promise(innerType) {
      return new exports2.ZodPromise({
        type: "promise",
        innerType
      });
    }
    exports2.ZodCustom = core.$constructor("ZodCustom", (inst, def) => {
      core.$ZodCustom.init(inst, def);
      exports2.ZodType.init(inst, def);
    });
    function check(fn) {
      const ch = new core.$ZodCheck({
        check: "custom"
        // ...util.normalizeParams(params),
      });
      ch._zod.check = fn;
      return ch;
    }
    function custom(fn, _params) {
      return core._custom(exports2.ZodCustom, fn ?? (() => true), _params);
    }
    function refine(fn, _params = {}) {
      return core._refine(exports2.ZodCustom, fn, _params);
    }
    function superRefine(fn) {
      const ch = check((payload) => {
        payload.addIssue = (issue) => {
          if (typeof issue === "string") {
            payload.issues.push(index_js_1.util.issue(issue, payload.value, ch._zod.def));
          } else {
            const _issue = issue;
            if (_issue.fatal)
              _issue.continue = false;
            _issue.code ?? (_issue.code = "custom");
            _issue.input ?? (_issue.input = payload.value);
            _issue.inst ?? (_issue.inst = ch);
            _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
            payload.issues.push(index_js_1.util.issue(_issue));
          }
        };
        return fn(payload.value, payload);
      });
      return ch;
    }
    function _instanceof(cls, params = {
      error: `Input not instance of ${cls.name}`
    }) {
      const inst = new exports2.ZodCustom({
        type: "custom",
        check: "custom",
        fn: (data) => data instanceof cls,
        abort: true,
        ...index_js_1.util.normalizeParams(params)
      });
      inst._zod.bag.Class = cls;
      return inst;
    }
    var stringbool = (...args) => core._stringbool({
      Pipe: exports2.ZodPipe,
      Boolean: exports2.ZodBoolean,
      String: exports2.ZodString,
      Transform: exports2.ZodTransform
    }, ...args);
    exports2.stringbool = stringbool;
    function json(params) {
      const jsonSchema = lazy(() => {
        return union([string(params), number(), boolean(), _null(), array(jsonSchema), record(string(), jsonSchema)]);
      });
      return jsonSchema;
    }
    function preprocess(fn, schema) {
      return pipe(transform(fn), schema);
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/compat.cjs
var require_compat2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/compat.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.config = exports2.$brand = exports2.ZodIssueCode = void 0;
    exports2.setErrorMap = setErrorMap;
    exports2.getErrorMap = getErrorMap;
    var core = __importStar(require_core5());
    exports2.ZodIssueCode = {
      invalid_type: "invalid_type",
      too_big: "too_big",
      too_small: "too_small",
      invalid_format: "invalid_format",
      not_multiple_of: "not_multiple_of",
      unrecognized_keys: "unrecognized_keys",
      invalid_union: "invalid_union",
      invalid_key: "invalid_key",
      invalid_element: "invalid_element",
      invalid_value: "invalid_value",
      custom: "custom"
    };
    var index_js_1 = require_core5();
    Object.defineProperty(exports2, "$brand", { enumerable: true, get: function() {
      return index_js_1.$brand;
    } });
    Object.defineProperty(exports2, "config", { enumerable: true, get: function() {
      return index_js_1.config;
    } });
    function setErrorMap(map) {
      core.config({
        customError: map
      });
    }
    function getErrorMap() {
      return core.config().customError;
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/coerce.cjs
var require_coerce3 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/coerce.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.string = string;
    exports2.number = number;
    exports2.boolean = boolean;
    exports2.bigint = bigint;
    exports2.date = date;
    var core = __importStar(require_core5());
    var schemas = __importStar(require_schemas4());
    function string(params) {
      return core._coercedString(schemas.ZodString, params);
    }
    function number(params) {
      return core._coercedNumber(schemas.ZodNumber, params);
    }
    function boolean(params) {
      return core._coercedBoolean(schemas.ZodBoolean, params);
    }
    function bigint(params) {
      return core._coercedBigint(schemas.ZodBigInt, params);
    }
    function date(params) {
      return core._coercedDate(schemas.ZodDate, params);
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/external.cjs
var require_external3 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/external.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.coerce = exports2.iso = exports2.ZodISODuration = exports2.ZodISOTime = exports2.ZodISODate = exports2.ZodISODateTime = exports2.locales = exports2.NEVER = exports2.TimePrecision = exports2.toJSONSchema = exports2.flattenError = exports2.formatError = exports2.prettifyError = exports2.treeifyError = exports2.regexes = exports2.clone = exports2.$brand = exports2.$input = exports2.$output = exports2.function = exports2.config = exports2.registry = exports2.globalRegistry = exports2.core = void 0;
    exports2.core = __importStar(require_core5());
    __exportStar(require_schemas4(), exports2);
    __exportStar(require_checks4(), exports2);
    __exportStar(require_errors7(), exports2);
    __exportStar(require_parse5(), exports2);
    __exportStar(require_compat2(), exports2);
    var index_js_1 = require_core5();
    var en_js_1 = __importDefault(require_en3());
    (0, index_js_1.config)((0, en_js_1.default)());
    var index_js_2 = require_core5();
    Object.defineProperty(exports2, "globalRegistry", { enumerable: true, get: function() {
      return index_js_2.globalRegistry;
    } });
    Object.defineProperty(exports2, "registry", { enumerable: true, get: function() {
      return index_js_2.registry;
    } });
    Object.defineProperty(exports2, "config", { enumerable: true, get: function() {
      return index_js_2.config;
    } });
    Object.defineProperty(exports2, "function", { enumerable: true, get: function() {
      return index_js_2.function;
    } });
    Object.defineProperty(exports2, "$output", { enumerable: true, get: function() {
      return index_js_2.$output;
    } });
    Object.defineProperty(exports2, "$input", { enumerable: true, get: function() {
      return index_js_2.$input;
    } });
    Object.defineProperty(exports2, "$brand", { enumerable: true, get: function() {
      return index_js_2.$brand;
    } });
    Object.defineProperty(exports2, "clone", { enumerable: true, get: function() {
      return index_js_2.clone;
    } });
    Object.defineProperty(exports2, "regexes", { enumerable: true, get: function() {
      return index_js_2.regexes;
    } });
    Object.defineProperty(exports2, "treeifyError", { enumerable: true, get: function() {
      return index_js_2.treeifyError;
    } });
    Object.defineProperty(exports2, "prettifyError", { enumerable: true, get: function() {
      return index_js_2.prettifyError;
    } });
    Object.defineProperty(exports2, "formatError", { enumerable: true, get: function() {
      return index_js_2.formatError;
    } });
    Object.defineProperty(exports2, "flattenError", { enumerable: true, get: function() {
      return index_js_2.flattenError;
    } });
    Object.defineProperty(exports2, "toJSONSchema", { enumerable: true, get: function() {
      return index_js_2.toJSONSchema;
    } });
    Object.defineProperty(exports2, "TimePrecision", { enumerable: true, get: function() {
      return index_js_2.TimePrecision;
    } });
    Object.defineProperty(exports2, "NEVER", { enumerable: true, get: function() {
      return index_js_2.NEVER;
    } });
    exports2.locales = __importStar(require_locales2());
    var iso_js_1 = require_iso2();
    Object.defineProperty(exports2, "ZodISODateTime", { enumerable: true, get: function() {
      return iso_js_1.ZodISODateTime;
    } });
    Object.defineProperty(exports2, "ZodISODate", { enumerable: true, get: function() {
      return iso_js_1.ZodISODate;
    } });
    Object.defineProperty(exports2, "ZodISOTime", { enumerable: true, get: function() {
      return iso_js_1.ZodISOTime;
    } });
    Object.defineProperty(exports2, "ZodISODuration", { enumerable: true, get: function() {
      return iso_js_1.ZodISODuration;
    } });
    exports2.iso = __importStar(require_iso2());
    exports2.coerce = __importStar(require_coerce3());
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/index.cjs
var require_classic2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/index.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.z = void 0;
    var z = __importStar(require_external3());
    exports2.z = z;
    __exportStar(require_external3(), exports2);
    exports2.default = z;
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/index.cjs
var require_v42 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/index.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var index_js_1 = __importDefault(require_classic2());
    __exportStar(require_classic2(), exports2);
    exports2.default = index_js_1.default;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/graph/graph.cjs
var require_graph2 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/graph/graph.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime3();
    var require_errors10 = require_errors5();
    var require_constants5 = require_constants4();
    var require_utils10 = require_utils8();
    var require_write2 = require_write();
    var require_read2 = require_read();
    var require_subgraph2 = require_subgraph();
    var require_pregel_index = require_pregel();
    var require_ephemeral_value2 = require_ephemeral_value();
    var __langchain_core_runnables = require_rolldown_runtime5.__toESM(require_runnables());
    var __langchain_core_runnables_graph = require_rolldown_runtime5.__toESM(require_graph());
    var zod_v4 = require_rolldown_runtime5.__toESM(require_v42());
    var uuid = require_rolldown_runtime5.__toESM((init_esm_node(), __toCommonJS(esm_node_exports)));
    var Branch = class {
      path;
      ends;
      constructor(options) {
        if (__langchain_core_runnables.Runnable.isRunnable(options.path)) this.path = options.path;
        else this.path = (0, __langchain_core_runnables._coerceToRunnable)(options.path).withConfig({ runName: `Branch` });
        this.ends = Array.isArray(options.pathMap) ? options.pathMap.reduce((acc, n) => {
          acc[n] = n;
          return acc;
        }, {}) : options.pathMap;
      }
      run(writer, reader) {
        return require_write2.ChannelWrite.registerWriter(new require_utils10.RunnableCallable({
          name: "<branch_run>",
          trace: false,
          func: async (input, config) => {
            try {
              return await this._route(input, config, writer, reader);
            } catch (e) {
              if (e.name === require_errors10.NodeInterrupt.unminifiable_name) console.warn("[WARN]: 'NodeInterrupt' thrown in conditional edge. This is likely a bug in your graph implementation.\nNodeInterrupt should only be thrown inside a node, not in edge conditions.");
              throw e;
            }
          }
        }));
      }
      async _route(input, config, writer, reader) {
        let result = await this.path.invoke(reader ? reader(config) : input, config);
        if (!Array.isArray(result)) result = [result];
        let destinations;
        if (this.ends) destinations = result.map((r) => require_constants5._isSend(r) ? r : this.ends[r]);
        else destinations = result;
        if (destinations.some((dest) => !dest)) throw new Error("Branch condition returned unknown or null destination");
        if (destinations.filter(require_constants5._isSend).some((packet) => packet.node === require_constants5.END)) throw new require_errors10.InvalidUpdateError("Cannot send a packet to the END node");
        const writeResult = await writer(destinations, config);
        return writeResult ?? input;
      }
    };
    var Graph = class {
      nodes;
      edges;
      branches;
      entryPoint;
      compiled = false;
      constructor() {
        this.nodes = {};
        this.edges = /* @__PURE__ */ new Set();
        this.branches = {};
      }
      warnIfCompiled(message) {
        if (this.compiled) console.warn(message);
      }
      get allEdges() {
        return this.edges;
      }
      addNode(...args) {
        function isMutlipleNodes(args$1) {
          return args$1.length >= 1 && typeof args$1[0] !== "string";
        }
        const nodes = isMutlipleNodes(args) ? Array.isArray(args[0]) ? args[0] : Object.entries(args[0]) : [[
          args[0],
          args[1],
          args[2]
        ]];
        if (nodes.length === 0) throw new Error("No nodes provided in `addNode`");
        for (const [key, action, options] of nodes) {
          for (const reservedChar of [require_constants5.CHECKPOINT_NAMESPACE_SEPARATOR, require_constants5.CHECKPOINT_NAMESPACE_END]) if (key.includes(reservedChar)) throw new Error(`"${reservedChar}" is a reserved character and is not allowed in node names.`);
          this.warnIfCompiled(`Adding a node to a graph that has already been compiled. This will not be reflected in the compiled graph.`);
          if (key in this.nodes) throw new Error(`Node \`${key}\` already present.`);
          if (key === require_constants5.END) throw new Error(`Node \`${key}\` is reserved.`);
          const runnable = (0, __langchain_core_runnables._coerceToRunnable)(action);
          this.nodes[key] = {
            runnable,
            metadata: options?.metadata,
            subgraphs: require_subgraph2.isPregelLike(runnable) ? [runnable] : options?.subgraphs,
            ends: options?.ends
          };
        }
        return this;
      }
      addEdge(startKey, endKey) {
        this.warnIfCompiled(`Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph.`);
        if (startKey === require_constants5.END) throw new Error("END cannot be a start node");
        if (endKey === require_constants5.START) throw new Error("START cannot be an end node");
        if (Array.from(this.edges).some(([start]) => start === startKey) && !("channels" in this)) throw new Error(`Already found path for ${startKey}. For multiple edges, use StateGraph.`);
        this.edges.add([startKey, endKey]);
        return this;
      }
      addConditionalEdges(source, path, pathMap) {
        const options = typeof source === "object" ? source : {
          source,
          path,
          pathMap
        };
        this.warnIfCompiled("Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph.");
        if (!__langchain_core_runnables.Runnable.isRunnable(options.path)) {
          const pathDisplayValues = Array.isArray(options.pathMap) ? options.pathMap.join(",") : Object.keys(options.pathMap ?? {}).join(",");
          options.path = (0, __langchain_core_runnables._coerceToRunnable)(options.path).withConfig({ runName: `Branch<${options.source}${pathDisplayValues !== "" ? `,${pathDisplayValues}` : ""}>`.slice(0, 63) });
        }
        const name = options.path.getName() === "RunnableLambda" ? "condition" : options.path.getName();
        if (this.branches[options.source] && this.branches[options.source][name]) throw new Error(`Condition \`${name}\` already present for node \`${source}\``);
        this.branches[options.source] ??= {};
        this.branches[options.source][name] = new Branch(options);
        return this;
      }
      /**
      * @deprecated use `addEdge(START, key)` instead
      */
      setEntryPoint(key) {
        this.warnIfCompiled("Setting the entry point of a graph that has already been compiled. This will not be reflected in the compiled graph.");
        return this.addEdge(require_constants5.START, key);
      }
      /**
      * @deprecated use `addEdge(key, END)` instead
      */
      setFinishPoint(key) {
        this.warnIfCompiled("Setting a finish point of a graph that has already been compiled. This will not be reflected in the compiled graph.");
        return this.addEdge(key, require_constants5.END);
      }
      compile({ checkpointer, interruptBefore, interruptAfter, name } = {}) {
        this.validate([...Array.isArray(interruptBefore) ? interruptBefore : [], ...Array.isArray(interruptAfter) ? interruptAfter : []]);
        const compiled = new CompiledGraph({
          builder: this,
          checkpointer,
          interruptAfter,
          interruptBefore,
          autoValidate: false,
          nodes: {},
          channels: {
            [require_constants5.START]: new require_ephemeral_value2.EphemeralValue(),
            [require_constants5.END]: new require_ephemeral_value2.EphemeralValue()
          },
          inputChannels: require_constants5.START,
          outputChannels: require_constants5.END,
          streamChannels: [],
          streamMode: "values",
          name
        });
        for (const [key, node] of Object.entries(this.nodes)) compiled.attachNode(key, node);
        for (const [start, end] of this.edges) compiled.attachEdge(start, end);
        for (const [start, branches] of Object.entries(this.branches)) for (const [name$1, branch] of Object.entries(branches)) compiled.attachBranch(start, name$1, branch);
        return compiled.validate();
      }
      validate(interrupt) {
        const allSources = new Set([...this.allEdges].map(([src, _]) => src));
        for (const [start] of Object.entries(this.branches)) allSources.add(start);
        for (const source of allSources) if (source !== require_constants5.START && !(source in this.nodes)) throw new Error(`Found edge starting at unknown node \`${source}\``);
        const allTargets = new Set([...this.allEdges].map(([_, target]) => target));
        for (const [start, branches] of Object.entries(this.branches)) for (const branch of Object.values(branches)) if (branch.ends != null) for (const end of Object.values(branch.ends)) allTargets.add(end);
        else {
          allTargets.add(require_constants5.END);
          for (const node of Object.keys(this.nodes)) if (node !== start) allTargets.add(node);
        }
        for (const node of Object.values(this.nodes)) for (const target of node.ends ?? []) allTargets.add(target);
        for (const node of Object.keys(this.nodes)) if (!allTargets.has(node)) throw new require_errors10.UnreachableNodeError([
          `Node \`${node}\` is not reachable.`,
          "",
          "If you are returning Command objects from your node,",
          'make sure you are passing names of potential destination nodes as an "ends" array',
          'into ".addNode(..., { ends: ["node1", "node2"] })".'
        ].join("\n"), { lc_error_code: "UNREACHABLE_NODE" });
        for (const target of allTargets) if (target !== require_constants5.END && !(target in this.nodes)) throw new Error(`Found edge ending at unknown node \`${target}\``);
        if (interrupt) {
          for (const node of interrupt) if (!(node in this.nodes)) throw new Error(`Interrupt node \`${node}\` is not present`);
        }
        this.compiled = true;
      }
    };
    var CompiledGraph = class extends require_pregel_index.Pregel {
      builder;
      constructor({ builder, ...rest }) {
        super(rest);
        this.builder = builder;
      }
      attachNode(key, node) {
        this.channels[key] = new require_ephemeral_value2.EphemeralValue();
        this.nodes[key] = new require_read2.PregelNode({
          channels: [],
          triggers: [],
          metadata: node.metadata,
          subgraphs: node.subgraphs,
          ends: node.ends
        }).pipe(node.runnable).pipe(new require_write2.ChannelWrite([{
          channel: key,
          value: require_write2.PASSTHROUGH
        }], [require_constants5.TAG_HIDDEN]));
        this.streamChannels.push(key);
      }
      attachEdge(start, end) {
        if (end === require_constants5.END) {
          if (start === require_constants5.START) throw new Error("Cannot have an edge from START to END");
          this.nodes[start].writers.push(new require_write2.ChannelWrite([{
            channel: require_constants5.END,
            value: require_write2.PASSTHROUGH
          }], [require_constants5.TAG_HIDDEN]));
        } else {
          this.nodes[end].triggers.push(start);
          this.nodes[end].channels.push(start);
        }
      }
      attachBranch(start, name, branch) {
        if (start === require_constants5.START && !this.nodes[require_constants5.START]) this.nodes[require_constants5.START] = require_pregel_index.Channel.subscribeTo(require_constants5.START, { tags: [require_constants5.TAG_HIDDEN] });
        this.nodes[start].pipe(branch.run((dests) => {
          const writes = dests.map((dest) => {
            if (require_constants5._isSend(dest)) return dest;
            return {
              channel: dest === require_constants5.END ? require_constants5.END : `branch:${start}:${name}:${dest}`,
              value: require_write2.PASSTHROUGH
            };
          });
          return new require_write2.ChannelWrite(writes, [require_constants5.TAG_HIDDEN]);
        }));
        const ends = branch.ends ? Object.values(branch.ends) : Object.keys(this.nodes);
        for (const end of ends) if (end !== require_constants5.END) {
          const channelName = `branch:${start}:${name}:${end}`;
          this.channels[channelName] = new require_ephemeral_value2.EphemeralValue();
          this.nodes[end].triggers.push(channelName);
          this.nodes[end].channels.push(channelName);
        }
      }
      /**
      * Returns a drawable representation of the computation graph.
      */
      async getGraphAsync(config) {
        const xray = config?.xray;
        const graph = new __langchain_core_runnables_graph.Graph();
        const startNodes = { [require_constants5.START]: graph.addNode({ schema: zod_v4.z.any() }, require_constants5.START) };
        const endNodes = {};
        let subgraphs = {};
        if (xray) subgraphs = Object.fromEntries((await require_utils10.gatherIterator(this.getSubgraphsAsync())).filter((x) => isCompiledGraph(x[1])));
        function addEdge(start, end, label, conditional = false) {
          if (end === require_constants5.END && endNodes[require_constants5.END] === void 0) endNodes[require_constants5.END] = graph.addNode({ schema: zod_v4.z.any() }, require_constants5.END);
          if (startNodes[start] === void 0) return;
          if (endNodes[end] === void 0) throw new Error(`End node ${end} not found!`);
          return graph.addEdge(startNodes[start], endNodes[end], label !== end ? label : void 0, conditional);
        }
        for (const [key, nodeSpec] of Object.entries(this.builder.nodes)) {
          const displayKey = _escapeMermaidKeywords(key);
          const node = nodeSpec.runnable;
          const metadata = nodeSpec.metadata ?? {};
          if (this.interruptBefore?.includes(key) && this.interruptAfter?.includes(key)) metadata.__interrupt = "before,after";
          else if (this.interruptBefore?.includes(key)) metadata.__interrupt = "before";
          else if (this.interruptAfter?.includes(key)) metadata.__interrupt = "after";
          if (xray) {
            const newXrayValue = typeof xray === "number" ? xray - 1 : xray;
            const drawableSubgraph = subgraphs[key] !== void 0 ? await subgraphs[key].getGraphAsync({
              ...config,
              xray: newXrayValue
            }) : node.getGraph(config);
            drawableSubgraph.trimFirstNode();
            drawableSubgraph.trimLastNode();
            if (Object.keys(drawableSubgraph.nodes).length > 1) {
              let _isRunnableInterface2 = function(thing) {
                return thing ? thing.lc_runnable : false;
              }, _nodeDataStr2 = function(id, data) {
                if (id !== void 0 && !(0, uuid.validate)(id)) return id;
                else if (_isRunnableInterface2(data)) try {
                  let dataStr = data.getName();
                  dataStr = dataStr.startsWith("Runnable") ? dataStr.slice(8) : dataStr;
                  return dataStr;
                } catch (error) {
                  return data.getName();
                }
                else return data.name ?? "UnknownSchema";
              };
              var _isRunnableInterface = _isRunnableInterface2, _nodeDataStr = _nodeDataStr2;
              const [e, s] = graph.extend(drawableSubgraph, displayKey);
              if (e === void 0) throw new Error(`Could not extend subgraph "${key}" due to missing entrypoint.`);
              if (s !== void 0) startNodes[displayKey] = {
                name: _nodeDataStr2(s.id, s.data),
                ...s
              };
              endNodes[displayKey] = {
                name: _nodeDataStr2(e.id, e.data),
                ...e
              };
            } else {
              const newNode = graph.addNode(node, displayKey, metadata);
              startNodes[displayKey] = newNode;
              endNodes[displayKey] = newNode;
            }
          } else {
            const newNode = graph.addNode(node, displayKey, metadata);
            startNodes[displayKey] = newNode;
            endNodes[displayKey] = newNode;
          }
        }
        const sortedEdges = [...this.builder.allEdges].sort(([a], [b]) => {
          if (a < b) return -1;
          else if (b > a) return 1;
          else return 0;
        });
        for (const [start, end] of sortedEdges) addEdge(_escapeMermaidKeywords(start), _escapeMermaidKeywords(end));
        for (const [start, branches] of Object.entries(this.builder.branches)) {
          const defaultEnds = {
            ...Object.fromEntries(Object.keys(this.builder.nodes).filter((k) => k !== start).map((k) => [_escapeMermaidKeywords(k), _escapeMermaidKeywords(k)])),
            [require_constants5.END]: require_constants5.END
          };
          for (const branch of Object.values(branches)) {
            let ends;
            if (branch.ends !== void 0) ends = branch.ends;
            else ends = defaultEnds;
            for (const [label, end] of Object.entries(ends)) addEdge(_escapeMermaidKeywords(start), _escapeMermaidKeywords(end), label, true);
          }
        }
        for (const [key, node] of Object.entries(this.builder.nodes)) if (node.ends !== void 0) for (const end of node.ends) addEdge(_escapeMermaidKeywords(key), _escapeMermaidKeywords(end), void 0, true);
        return graph;
      }
      /**
      * Returns a drawable representation of the computation graph.
      *
      * @deprecated Use getGraphAsync instead. The async method will be the default in the next minor core release.
      */
      getGraph(config) {
        const xray = config?.xray;
        const graph = new __langchain_core_runnables_graph.Graph();
        const startNodes = { [require_constants5.START]: graph.addNode({ schema: zod_v4.z.any() }, require_constants5.START) };
        const endNodes = {};
        let subgraphs = {};
        if (xray) subgraphs = Object.fromEntries(require_utils10.gatherIteratorSync(this.getSubgraphs()).filter((x) => isCompiledGraph(x[1])));
        function addEdge(start, end, label, conditional = false) {
          if (end === require_constants5.END && endNodes[require_constants5.END] === void 0) endNodes[require_constants5.END] = graph.addNode({ schema: zod_v4.z.any() }, require_constants5.END);
          return graph.addEdge(startNodes[start], endNodes[end], label !== end ? label : void 0, conditional);
        }
        for (const [key, nodeSpec] of Object.entries(this.builder.nodes)) {
          const displayKey = _escapeMermaidKeywords(key);
          const node = nodeSpec.runnable;
          const metadata = nodeSpec.metadata ?? {};
          if (this.interruptBefore?.includes(key) && this.interruptAfter?.includes(key)) metadata.__interrupt = "before,after";
          else if (this.interruptBefore?.includes(key)) metadata.__interrupt = "before";
          else if (this.interruptAfter?.includes(key)) metadata.__interrupt = "after";
          if (xray) {
            const newXrayValue = typeof xray === "number" ? xray - 1 : xray;
            const drawableSubgraph = subgraphs[key] !== void 0 ? subgraphs[key].getGraph({
              ...config,
              xray: newXrayValue
            }) : node.getGraph(config);
            drawableSubgraph.trimFirstNode();
            drawableSubgraph.trimLastNode();
            if (Object.keys(drawableSubgraph.nodes).length > 1) {
              let _isRunnableInterface2 = function(thing) {
                return thing ? thing.lc_runnable : false;
              }, _nodeDataStr2 = function(id, data) {
                if (id !== void 0 && !(0, uuid.validate)(id)) return id;
                else if (_isRunnableInterface2(data)) try {
                  let dataStr = data.getName();
                  dataStr = dataStr.startsWith("Runnable") ? dataStr.slice(8) : dataStr;
                  return dataStr;
                } catch (error) {
                  return data.getName();
                }
                else return data.name ?? "UnknownSchema";
              };
              var _isRunnableInterface = _isRunnableInterface2, _nodeDataStr = _nodeDataStr2;
              const [e, s] = graph.extend(drawableSubgraph, displayKey);
              if (e === void 0) throw new Error(`Could not extend subgraph "${key}" due to missing entrypoint.`);
              if (s !== void 0) startNodes[displayKey] = {
                name: _nodeDataStr2(s.id, s.data),
                ...s
              };
              endNodes[displayKey] = {
                name: _nodeDataStr2(e.id, e.data),
                ...e
              };
            } else {
              const newNode = graph.addNode(node, displayKey, metadata);
              startNodes[displayKey] = newNode;
              endNodes[displayKey] = newNode;
            }
          } else {
            const newNode = graph.addNode(node, displayKey, metadata);
            startNodes[displayKey] = newNode;
            endNodes[displayKey] = newNode;
          }
        }
        const sortedEdges = [...this.builder.allEdges].sort(([a], [b]) => {
          if (a < b) return -1;
          else if (b > a) return 1;
          else return 0;
        });
        for (const [start, end] of sortedEdges) addEdge(_escapeMermaidKeywords(start), _escapeMermaidKeywords(end));
        for (const [start, branches] of Object.entries(this.builder.branches)) {
          const defaultEnds = {
            ...Object.fromEntries(Object.keys(this.builder.nodes).filter((k) => k !== start).map((k) => [_escapeMermaidKeywords(k), _escapeMermaidKeywords(k)])),
            [require_constants5.END]: require_constants5.END
          };
          for (const branch of Object.values(branches)) {
            let ends;
            if (branch.ends !== void 0) ends = branch.ends;
            else ends = defaultEnds;
            for (const [label, end] of Object.entries(ends)) addEdge(_escapeMermaidKeywords(start), _escapeMermaidKeywords(end), label, true);
          }
        }
        return graph;
      }
    };
    function isCompiledGraph(x) {
      return typeof x.attachNode === "function" && typeof x.attachEdge === "function";
    }
    function _escapeMermaidKeywords(key) {
      if (key === "subgraph") return `"${key}"`;
      return key;
    }
    exports2.Branch = Branch;
    exports2.CompiledGraph = CompiledGraph;
    exports2.Graph = Graph;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/channels/named_barrier_value.cjs
var require_named_barrier_value = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/channels/named_barrier_value.cjs"(exports2) {
    var require_errors10 = require_errors5();
    var require_base18 = require_base17();
    var areSetsEqual = (a, b) => a.size === b.size && [...a].every((value) => b.has(value));
    var NamedBarrierValue = class NamedBarrierValue2 extends require_base18.BaseChannel {
      lc_graph_name = "NamedBarrierValue";
      names;
      seen;
      constructor(names) {
        super();
        this.names = names;
        this.seen = /* @__PURE__ */ new Set();
      }
      fromCheckpoint(checkpoint) {
        const empty = new NamedBarrierValue2(this.names);
        if (typeof checkpoint !== "undefined") empty.seen = new Set(checkpoint);
        return empty;
      }
      update(values) {
        let updated = false;
        for (const nodeName of values) if (this.names.has(nodeName)) {
          if (!this.seen.has(nodeName)) {
            this.seen.add(nodeName);
            updated = true;
          }
        } else throw new require_errors10.InvalidUpdateError(`Value ${JSON.stringify(nodeName)} not in names ${JSON.stringify(this.names)}`);
        return updated;
      }
      get() {
        if (!areSetsEqual(this.names, this.seen)) throw new require_errors10.EmptyChannelError();
        return void 0;
      }
      checkpoint() {
        return [...this.seen];
      }
      consume() {
        if (this.seen && this.names && areSetsEqual(this.seen, this.names)) {
          this.seen = /* @__PURE__ */ new Set();
          return true;
        }
        return false;
      }
      isAvailable() {
        return !!this.names && areSetsEqual(this.names, this.seen);
      }
    };
    var NamedBarrierValueAfterFinish = class NamedBarrierValueAfterFinish2 extends require_base18.BaseChannel {
      lc_graph_name = "NamedBarrierValueAfterFinish";
      names;
      seen;
      finished;
      constructor(names) {
        super();
        this.names = names;
        this.seen = /* @__PURE__ */ new Set();
        this.finished = false;
      }
      fromCheckpoint(checkpoint) {
        const empty = new NamedBarrierValueAfterFinish2(this.names);
        if (typeof checkpoint !== "undefined") {
          const [seen, finished] = checkpoint;
          empty.seen = new Set(seen);
          empty.finished = finished;
        }
        return empty;
      }
      update(values) {
        let updated = false;
        for (const nodeName of values) if (this.names.has(nodeName) && !this.seen.has(nodeName)) {
          this.seen.add(nodeName);
          updated = true;
        } else if (!this.names.has(nodeName)) throw new require_errors10.InvalidUpdateError(`Value ${JSON.stringify(nodeName)} not in names ${JSON.stringify(this.names)}`);
        return updated;
      }
      get() {
        if (!this.finished || !areSetsEqual(this.names, this.seen)) throw new require_errors10.EmptyChannelError();
        return void 0;
      }
      checkpoint() {
        return [[...this.seen], this.finished];
      }
      consume() {
        if (this.finished && this.seen && this.names && areSetsEqual(this.seen, this.names)) {
          this.seen = /* @__PURE__ */ new Set();
          this.finished = false;
          return true;
        }
        return false;
      }
      finish() {
        if (!this.finished && !!this.names && areSetsEqual(this.names, this.seen)) {
          this.finished = true;
          return true;
        }
        return false;
      }
      isAvailable() {
        return this.finished && !!this.names && areSetsEqual(this.names, this.seen);
      }
    };
    exports2.NamedBarrierValue = NamedBarrierValue;
    exports2.NamedBarrierValueAfterFinish = NamedBarrierValueAfterFinish;
    exports2.areSetsEqual = areSetsEqual;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/graph/zod/meta.cjs
var require_meta = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/graph/zod/meta.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime3();
    var require_binop2 = require_binop();
    var require_last_value2 = require_last_value();
    var __langchain_core_utils_types = require_rolldown_runtime5.__toESM(require_types6());
    var META_EXTRAS_DESCRIPTION_PREFIX = "lg:";
    var SchemaMetaRegistry = class {
      /**
      * Internal map storing schema metadata.
      * @internal
      */
      _map = /* @__PURE__ */ new WeakMap();
      /**
      * Cache for extended schfemas.
      * @internal
      */
      _extensionCache = /* @__PURE__ */ new Map();
      /**
      * Retrieves the metadata associated with a given schema.
      * @template TValue The value type of the schema.
      * @template TUpdate The update type of the schema (defaults to TValue).
      * @param schema The schema to retrieve metadata for.
      * @returns The associated SchemaMeta, or undefined if not present.
      */
      get(schema) {
        return this._map.get(schema);
      }
      /**
      * Extends or sets the metadata for a given schema.
      * @template TValue The value type of the schema.
      * @template TUpdate The update type of the schema (defaults to TValue).
      * @param schema The schema to extend metadata for.
      * @param predicate A function that receives the existing metadata (or undefined) and returns the new metadata.
      */
      extend(schema, predicate) {
        const existingMeta = this.get(schema);
        this._map.set(schema, predicate(existingMeta));
      }
      /**
      * Removes the metadata associated with a given schema.
      * @param schema The schema to remove metadata for.
      * @returns The SchemaMetaRegistry instance (for chaining).
      */
      remove(schema) {
        this._map.delete(schema);
        return this;
      }
      /**
      * Checks if metadata exists for a given schema.
      * @param schema The schema to check.
      * @returns True if metadata exists, false otherwise.
      */
      has(schema) {
        return this._map.has(schema);
      }
      /**
      * Returns a mapping of channel instances for each property in the schema
      * using the associated metadata in the registry.
      *
      * This is used to create the `channels` object that's passed to the `Graph` constructor.
      *
      * @template T The shape of the schema.
      * @param schema The schema to extract channels from.
      * @returns A mapping from property names to channel instances.
      */
      getChannelsForSchema(schema) {
        const channels = {};
        const shape = (0, __langchain_core_utils_types.getInteropZodObjectShape)(schema);
        for (const [key, channelSchema] of Object.entries(shape)) {
          const meta = this.get(channelSchema);
          if (meta?.reducer) channels[key] = new require_binop2.BinaryOperatorAggregate(meta.reducer.fn, meta.default);
          else channels[key] = new require_last_value2.LastValue();
        }
        return channels;
      }
      /**
      * Returns a modified schema that introspectively looks at all keys of the provided
      * object schema, and applies the augmentations based on meta provided with those keys
      * in the registry and the selectors provided in the `effects` parameter.
      *
      * This assumes that the passed in schema is the "root" schema object for a graph where
      * the keys of the schema are the channels of the graph. Because we need to represent
      * the input of a graph in a couple of different ways, the `effects` parameter allows
      * us to apply those augmentations based on pre determined conditions.
      *
      * @param schema The root schema object to extend.
      * @param effects The effects that are being applied.
      * @returns The extended schema.
      */
      getExtendedChannelSchemas(schema, effects) {
        if (Object.keys(effects).length === 0) return schema;
        const cacheKey = Object.entries(effects).filter(([, v]) => v === true).sort(([a], [b]) => a.localeCompare(b)).map(([k, v]) => `${k}:${v}`).join("|");
        const cache = this._extensionCache.get(cacheKey) ?? /* @__PURE__ */ new WeakMap();
        if (cache.has(schema)) return cache.get(schema);
        let modifiedSchema = schema;
        if (effects.withReducerSchema || effects.withJsonSchemaExtrasAsDescription) {
          const newShapeEntries = Object.entries((0, __langchain_core_utils_types.getInteropZodObjectShape)(schema)).map(([key, schema$1]) => {
            const meta = this.get(schema$1);
            let outputSchema = effects.withReducerSchema ? meta?.reducer?.schema ?? schema$1 : schema$1;
            if (effects.withJsonSchemaExtrasAsDescription && meta?.jsonSchemaExtra) {
              const description = (0, __langchain_core_utils_types.getSchemaDescription)(outputSchema) ?? (0, __langchain_core_utils_types.getSchemaDescription)(schema$1);
              const strExtras = JSON.stringify({
                ...meta.jsonSchemaExtra,
                description
              });
              outputSchema = outputSchema.describe(`${META_EXTRAS_DESCRIPTION_PREFIX}${strExtras}`);
            }
            return [key, outputSchema];
          });
          modifiedSchema = (0, __langchain_core_utils_types.extendInteropZodObject)(schema, Object.fromEntries(newShapeEntries));
          if ((0, __langchain_core_utils_types.isZodSchemaV3)(modifiedSchema)) modifiedSchema._def.unknownKeys = "strip";
        }
        if (effects.asPartial) modifiedSchema = (0, __langchain_core_utils_types.interopZodObjectPartial)(modifiedSchema);
        cache.set(schema, modifiedSchema);
        this._extensionCache.set(cacheKey, cache);
        return modifiedSchema;
      }
    };
    var schemaMetaRegistry = new SchemaMetaRegistry();
    function withLangGraph(schema, meta) {
      if (meta.reducer && !meta.default) {
        const defaultValueGetter = (0, __langchain_core_utils_types.getInteropZodDefaultGetter)(schema);
        if (defaultValueGetter != null) meta.default = defaultValueGetter;
      }
      if (meta.reducer) {
        const schemaWithReducer = Object.assign(schema, { lg_reducer_schema: meta.reducer?.schema ?? schema });
        schemaMetaRegistry.extend(schemaWithReducer, () => meta);
        return schemaWithReducer;
      } else {
        schemaMetaRegistry.extend(schema, () => meta);
        return schema;
      }
    }
    exports2.META_EXTRAS_DESCRIPTION_PREFIX = META_EXTRAS_DESCRIPTION_PREFIX;
    exports2.SchemaMetaRegistry = SchemaMetaRegistry;
    exports2.schemaMetaRegistry = schemaMetaRegistry;
    exports2.withLangGraph = withLangGraph;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/graph/state.cjs
var require_state = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/graph/state.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime3();
    var require_errors10 = require_errors5();
    var require_base18 = require_base17();
    var require_last_value2 = require_last_value();
    var require_annotation2 = require_annotation();
    var require_constants5 = require_constants4();
    var require_utils10 = require_utils8();
    var require_write2 = require_write();
    var require_read2 = require_read();
    var require_subgraph2 = require_subgraph();
    var require_ephemeral_value2 = require_ephemeral_value();
    var require_graph4 = require_graph2();
    var require_named_barrier_value2 = require_named_barrier_value();
    var require_meta2 = require_meta();
    var __langchain_core_runnables = require_rolldown_runtime5.__toESM(require_runnables());
    var __langchain_core_utils_types = require_rolldown_runtime5.__toESM(require_types6());
    var ROOT = "__root__";
    var PartialStateSchema = Symbol.for("langgraph.state.partial");
    var StateGraph = class extends require_graph4.Graph {
      channels = {};
      waitingEdges = /* @__PURE__ */ new Set();
      /** @internal */
      _schemaDefinition;
      /** @internal */
      _schemaRuntimeDefinition;
      /** @internal */
      _inputDefinition;
      /** @internal */
      _inputRuntimeDefinition;
      /** @internal */
      _outputDefinition;
      /** @internal */
      _outputRuntimeDefinition;
      /**
      * Map schemas to managed values
      * @internal
      */
      _schemaDefinitions = /* @__PURE__ */ new Map();
      /** @internal */
      _metaRegistry = require_meta2.schemaMetaRegistry;
      /** @internal Used only for typing. */
      _configSchema;
      /** @internal */
      _configRuntimeSchema;
      /** @internal */
      _interrupt;
      /** @internal */
      _writer;
      constructor(fields, contextSchema) {
        super();
        if (isZodStateGraphArgsWithStateSchema(fields)) {
          const stateDef = this._metaRegistry.getChannelsForSchema(fields.state);
          const inputDef = fields.input != null ? this._metaRegistry.getChannelsForSchema(fields.input) : stateDef;
          const outputDef = fields.output != null ? this._metaRegistry.getChannelsForSchema(fields.output) : stateDef;
          this._schemaDefinition = stateDef;
          this._schemaRuntimeDefinition = fields.state;
          this._inputDefinition = inputDef;
          this._inputRuntimeDefinition = fields.input ?? PartialStateSchema;
          this._outputDefinition = outputDef;
          this._outputRuntimeDefinition = fields.output ?? fields.state;
        } else if ((0, __langchain_core_utils_types.isInteropZodObject)(fields)) {
          const stateDef = this._metaRegistry.getChannelsForSchema(fields);
          this._schemaDefinition = stateDef;
          this._schemaRuntimeDefinition = fields;
          this._inputDefinition = stateDef;
          this._inputRuntimeDefinition = PartialStateSchema;
          this._outputDefinition = stateDef;
          this._outputRuntimeDefinition = fields;
        } else if (isStateGraphArgsWithInputOutputSchemas(fields)) {
          this._schemaDefinition = fields.input.spec;
          this._inputDefinition = fields.input.spec;
          this._outputDefinition = fields.output.spec;
        } else if (isStateGraphArgsWithStateSchema(fields)) {
          this._schemaDefinition = fields.stateSchema.spec;
          this._inputDefinition = fields.input?.spec ?? this._schemaDefinition;
          this._outputDefinition = fields.output?.spec ?? this._schemaDefinition;
        } else if (isStateDefinition(fields) || isAnnotationRoot(fields)) {
          const spec = isAnnotationRoot(fields) ? fields.spec : fields;
          this._schemaDefinition = spec;
        } else if (isStateGraphArgs(fields)) {
          const spec = _getChannels(fields.channels);
          this._schemaDefinition = spec;
        } else throw new Error("Invalid StateGraph input. Make sure to pass a valid Annotation.Root or Zod schema.");
        this._inputDefinition ??= this._schemaDefinition;
        this._outputDefinition ??= this._schemaDefinition;
        this._addSchema(this._schemaDefinition);
        this._addSchema(this._inputDefinition);
        this._addSchema(this._outputDefinition);
        function isOptions(options) {
          return typeof options === "object" && options != null && !("spec" in options) && !(0, __langchain_core_utils_types.isInteropZodObject)(options);
        }
        if (isOptions(contextSchema)) {
          if ((0, __langchain_core_utils_types.isInteropZodObject)(contextSchema.context)) this._configRuntimeSchema = contextSchema.context;
          this._interrupt = contextSchema.interrupt;
          this._writer = contextSchema.writer;
        } else if ((0, __langchain_core_utils_types.isInteropZodObject)(contextSchema)) this._configRuntimeSchema = contextSchema;
      }
      get allEdges() {
        return /* @__PURE__ */ new Set([...this.edges, ...Array.from(this.waitingEdges).flatMap(([starts, end]) => starts.map((start) => [start, end]))]);
      }
      _addSchema(stateDefinition) {
        if (this._schemaDefinitions.has(stateDefinition)) return;
        this._schemaDefinitions.set(stateDefinition, stateDefinition);
        for (const [key, val] of Object.entries(stateDefinition)) {
          let channel2;
          if (typeof val === "function") channel2 = val();
          else channel2 = val;
          if (this.channels[key] !== void 0) {
            if (this.channels[key] !== channel2) {
              if (channel2.lc_graph_name !== "LastValue") throw new Error(`Channel "${key}" already exists with a different type.`);
            }
          } else this.channels[key] = channel2;
        }
      }
      addNode(...args) {
        function isMultipleNodes(args$1) {
          return args$1.length >= 1 && typeof args$1[0] !== "string";
        }
        const nodes = isMultipleNodes(args) ? Array.isArray(args[0]) ? args[0] : Object.entries(args[0]).map(([key, action]) => [key, action]) : [[
          args[0],
          args[1],
          args[2]
        ]];
        if (nodes.length === 0) throw new Error("No nodes provided in `addNode`");
        for (const [key, action, options] of nodes) {
          if (key in this.channels) throw new Error(`${key} is already being used as a state attribute (a.k.a. a channel), cannot also be used as a node name.`);
          for (const reservedChar of [require_constants5.CHECKPOINT_NAMESPACE_SEPARATOR, require_constants5.CHECKPOINT_NAMESPACE_END]) if (key.includes(reservedChar)) throw new Error(`"${reservedChar}" is a reserved character and is not allowed in node names.`);
          this.warnIfCompiled(`Adding a node to a graph that has already been compiled. This will not be reflected in the compiled graph.`);
          if (key in this.nodes) throw new Error(`Node \`${key}\` already present.`);
          if (key === require_constants5.END || key === require_constants5.START) throw new Error(`Node \`${key}\` is reserved.`);
          let inputSpec = this._schemaDefinition;
          if (options?.input !== void 0) {
            if ((0, __langchain_core_utils_types.isInteropZodObject)(options.input)) inputSpec = this._metaRegistry.getChannelsForSchema(options.input);
            else if (options.input.spec !== void 0) inputSpec = options.input.spec;
          }
          if (inputSpec !== void 0) this._addSchema(inputSpec);
          let runnable;
          if (__langchain_core_runnables.Runnable.isRunnable(action)) runnable = action;
          else if (typeof action === "function") runnable = new require_utils10.RunnableCallable({
            func: action,
            name: key,
            trace: false
          });
          else runnable = (0, __langchain_core_runnables._coerceToRunnable)(action);
          let cachePolicy = options?.cachePolicy;
          if (typeof cachePolicy === "boolean") cachePolicy = cachePolicy ? {} : void 0;
          const nodeSpec = {
            runnable,
            retryPolicy: options?.retryPolicy,
            cachePolicy,
            metadata: options?.metadata,
            input: inputSpec ?? this._schemaDefinition,
            subgraphs: require_subgraph2.isPregelLike(runnable) ? [runnable] : options?.subgraphs,
            ends: options?.ends,
            defer: options?.defer
          };
          this.nodes[key] = nodeSpec;
        }
        return this;
      }
      addEdge(startKey, endKey) {
        if (typeof startKey === "string") return super.addEdge(startKey, endKey);
        if (this.compiled) console.warn("Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph.");
        for (const start of startKey) {
          if (start === require_constants5.END) throw new Error("END cannot be a start node");
          if (!Object.keys(this.nodes).some((node) => node === start)) throw new Error(`Need to add a node named "${start}" first`);
        }
        if (endKey === require_constants5.END) throw new Error("END cannot be an end node");
        if (!Object.keys(this.nodes).some((node) => node === endKey)) throw new Error(`Need to add a node named "${endKey}" first`);
        this.waitingEdges.add([startKey, endKey]);
        return this;
      }
      addSequence(nodes) {
        const parsedNodes = Array.isArray(nodes) ? nodes : Object.entries(nodes);
        if (parsedNodes.length === 0) throw new Error("Sequence requires at least one node.");
        let previousNode;
        for (const [key, action, options] of parsedNodes) {
          if (key in this.nodes) throw new Error(`Node names must be unique: node with the name "${key}" already exists.`);
          const validKey = key;
          this.addNode(validKey, action, options);
          if (previousNode != null) this.addEdge(previousNode, validKey);
          previousNode = validKey;
        }
        return this;
      }
      compile({ checkpointer, store, cache, interruptBefore, interruptAfter, name, description } = {}) {
        this.validate([...Array.isArray(interruptBefore) ? interruptBefore : [], ...Array.isArray(interruptAfter) ? interruptAfter : []]);
        const outputKeys = Object.keys(this._schemaDefinitions.get(this._outputDefinition));
        const outputChannels = outputKeys.length === 1 && outputKeys[0] === ROOT ? ROOT : outputKeys;
        const streamKeys = Object.keys(this.channels);
        const streamChannels = streamKeys.length === 1 && streamKeys[0] === ROOT ? ROOT : streamKeys;
        const userInterrupt = this._interrupt;
        const compiled = new CompiledStateGraph({
          builder: this,
          checkpointer,
          interruptAfter,
          interruptBefore,
          autoValidate: false,
          nodes: {},
          channels: {
            ...this.channels,
            [require_constants5.START]: new require_ephemeral_value2.EphemeralValue()
          },
          inputChannels: require_constants5.START,
          outputChannels,
          streamChannels,
          streamMode: "updates",
          store,
          cache,
          name,
          description,
          userInterrupt
        });
        compiled.attachNode(require_constants5.START);
        for (const [key, node] of Object.entries(this.nodes)) compiled.attachNode(key, node);
        compiled.attachBranch(require_constants5.START, require_constants5.SELF, _getControlBranch(), { withReader: false });
        for (const [key] of Object.entries(this.nodes)) compiled.attachBranch(key, require_constants5.SELF, _getControlBranch(), { withReader: false });
        for (const [start, end] of this.edges) compiled.attachEdge(start, end);
        for (const [starts, end] of this.waitingEdges) compiled.attachEdge(starts, end);
        for (const [start, branches] of Object.entries(this.branches)) for (const [name$1, branch] of Object.entries(branches)) compiled.attachBranch(start, name$1, branch);
        return compiled.validate();
      }
    };
    function _getChannels(schema) {
      const channels = {};
      for (const [name, val] of Object.entries(schema)) if (name === ROOT) channels[name] = require_annotation2.getChannel(val);
      else channels[name] = require_annotation2.getChannel(val);
      return channels;
    }
    var CompiledStateGraph = class extends require_graph4.CompiledGraph {
      /**
      * The description of the compiled graph.
      * This is used by the supervisor agent to describe the handoff to the agent.
      */
      description;
      /** @internal */
      _metaRegistry = require_meta2.schemaMetaRegistry;
      constructor({ description, ...rest }) {
        super(rest);
        this.description = description;
      }
      attachNode(key, node) {
        let outputKeys;
        if (key === require_constants5.START) outputKeys = Object.entries(this.builder._schemaDefinitions.get(this.builder._inputDefinition)).map(([k]) => k);
        else outputKeys = Object.keys(this.builder.channels);
        function _getRoot(input) {
          if (require_constants5.isCommand(input)) {
            if (input.graph === require_constants5.Command.PARENT) return null;
            return input._updateAsTuples();
          } else if (Array.isArray(input) && input.length > 0 && input.some((i) => require_constants5.isCommand(i))) {
            const updates = [];
            for (const i of input) if (require_constants5.isCommand(i)) {
              if (i.graph === require_constants5.Command.PARENT) continue;
              updates.push(...i._updateAsTuples());
            } else updates.push([ROOT, i]);
            return updates;
          } else if (input != null) return [[ROOT, input]];
          return null;
        }
        const nodeKey = key;
        function _getUpdates(input) {
          if (!input) return null;
          else if (require_constants5.isCommand(input)) {
            if (input.graph === require_constants5.Command.PARENT) return null;
            return input._updateAsTuples().filter(([k]) => outputKeys.includes(k));
          } else if (Array.isArray(input) && input.length > 0 && input.some(require_constants5.isCommand)) {
            const updates = [];
            for (const item of input) if (require_constants5.isCommand(item)) {
              if (item.graph === require_constants5.Command.PARENT) continue;
              updates.push(...item._updateAsTuples().filter(([k]) => outputKeys.includes(k)));
            } else {
              const itemUpdates = _getUpdates(item);
              if (itemUpdates) updates.push(...itemUpdates ?? []);
            }
            return updates;
          } else if (typeof input === "object" && !Array.isArray(input)) return Object.entries(input).filter(([k]) => outputKeys.includes(k));
          else {
            const typeofInput = Array.isArray(input) ? "array" : typeof input;
            throw new require_errors10.InvalidUpdateError(`Expected node "${nodeKey.toString()}" to return an object or an array containing at least one Command object, received ${typeofInput}`, { lc_error_code: "INVALID_GRAPH_NODE_RETURN_VALUE" });
          }
        }
        const stateWriteEntries = [{
          value: require_write2.PASSTHROUGH,
          mapper: new require_utils10.RunnableCallable({
            func: outputKeys.length && outputKeys[0] === ROOT ? _getRoot : _getUpdates,
            trace: false,
            recurse: false
          })
        }];
        if (key === require_constants5.START) this.nodes[key] = new require_read2.PregelNode({
          tags: [require_constants5.TAG_HIDDEN],
          triggers: [require_constants5.START],
          channels: [require_constants5.START],
          writers: [new require_write2.ChannelWrite(stateWriteEntries, [require_constants5.TAG_HIDDEN])]
        });
        else {
          const inputDefinition = node?.input ?? this.builder._schemaDefinition;
          const inputValues = Object.fromEntries(Object.keys(this.builder._schemaDefinitions.get(inputDefinition)).map((k) => [k, k]));
          const isSingleInput = Object.keys(inputValues).length === 1 && ROOT in inputValues;
          const branchChannel = `branch:to:${key}`;
          this.channels[branchChannel] = node?.defer ? new require_last_value2.LastValueAfterFinish() : new require_ephemeral_value2.EphemeralValue(false);
          this.nodes[key] = new require_read2.PregelNode({
            triggers: [branchChannel],
            channels: isSingleInput ? Object.keys(inputValues) : inputValues,
            writers: [new require_write2.ChannelWrite(stateWriteEntries, [require_constants5.TAG_HIDDEN])],
            mapper: isSingleInput ? void 0 : (input) => {
              return Object.fromEntries(Object.entries(input).filter(([k]) => k in inputValues));
            },
            bound: node?.runnable,
            metadata: node?.metadata,
            retryPolicy: node?.retryPolicy,
            cachePolicy: node?.cachePolicy,
            subgraphs: node?.subgraphs,
            ends: node?.ends
          });
        }
      }
      attachEdge(starts, end) {
        if (end === require_constants5.END) return;
        if (typeof starts === "string") this.nodes[starts].writers.push(new require_write2.ChannelWrite([{
          channel: `branch:to:${end}`,
          value: null
        }], [require_constants5.TAG_HIDDEN]));
        else if (Array.isArray(starts)) {
          const channelName = `join:${starts.join("+")}:${end}`;
          this.channels[channelName] = this.builder.nodes[end].defer ? new require_named_barrier_value2.NamedBarrierValueAfterFinish(new Set(starts)) : new require_named_barrier_value2.NamedBarrierValue(new Set(starts));
          this.nodes[end].triggers.push(channelName);
          for (const start of starts) this.nodes[start].writers.push(new require_write2.ChannelWrite([{
            channel: channelName,
            value: start
          }], [require_constants5.TAG_HIDDEN]));
        }
      }
      attachBranch(start, _, branch, options = { withReader: true }) {
        const branchWriter = async (packets, config) => {
          const filteredPackets = packets.filter((p) => p !== require_constants5.END);
          if (!filteredPackets.length) return;
          const writes = filteredPackets.map((p) => {
            if (require_constants5._isSend(p)) return p;
            return {
              channel: p === require_constants5.END ? p : `branch:to:${p}`,
              value: start
            };
          });
          await require_write2.ChannelWrite.doWrite({
            ...config,
            tags: (config.tags ?? []).concat([require_constants5.TAG_HIDDEN])
          }, writes);
        };
        this.nodes[start].writers.push(branch.run(branchWriter, options.withReader ? (config) => require_read2.ChannelRead.doRead(config, this.streamChannels ?? this.outputChannels, true) : void 0));
      }
      async _validateInput(input) {
        if (input == null) return input;
        const schema = (() => {
          const input$1 = this.builder._inputRuntimeDefinition;
          const schema$1 = this.builder._schemaRuntimeDefinition;
          const apply = (schema$2) => {
            if (schema$2 == null) return void 0;
            return this._metaRegistry.getExtendedChannelSchemas(schema$2, { withReducerSchema: true });
          };
          if ((0, __langchain_core_utils_types.isInteropZodObject)(input$1)) return apply(input$1);
          if (input$1 === PartialStateSchema) return (0, __langchain_core_utils_types.interopZodObjectPartial)(apply(schema$1));
          return void 0;
        })();
        if (require_constants5.isCommand(input)) {
          const parsedInput = input;
          if (input.update && schema != null) parsedInput.update = (0, __langchain_core_utils_types.interopParse)(schema, input.update);
          return parsedInput;
        }
        if (schema != null) return (0, __langchain_core_utils_types.interopParse)(schema, input);
        return input;
      }
      isInterrupted(input) {
        return require_constants5.isInterrupted(input);
      }
      async _validateContext(config) {
        const configSchema = this.builder._configRuntimeSchema;
        if ((0, __langchain_core_utils_types.isInteropZodObject)(configSchema)) (0, __langchain_core_utils_types.interopParse)(configSchema, config);
        return config;
      }
    };
    function isStateDefinition(obj) {
      return typeof obj === "object" && obj !== null && !Array.isArray(obj) && Object.keys(obj).length > 0 && Object.values(obj).every((v) => typeof v === "function" || require_base18.isBaseChannel(v));
    }
    function isAnnotationRoot(obj) {
      return typeof obj === "object" && obj !== null && "lc_graph_name" in obj && obj.lc_graph_name === "AnnotationRoot";
    }
    function isStateGraphArgs(obj) {
      return typeof obj === "object" && obj !== null && obj.channels !== void 0;
    }
    function isStateGraphArgsWithStateSchema(obj) {
      return typeof obj === "object" && obj !== null && obj.stateSchema !== void 0;
    }
    function isStateGraphArgsWithInputOutputSchemas(obj) {
      return typeof obj === "object" && obj !== null && obj.stateSchema === void 0 && obj.input !== void 0 && obj.output !== void 0;
    }
    function isZodStateGraphArgsWithStateSchema(value) {
      if (typeof value !== "object" || value == null) return false;
      if (!("state" in value) || !(0, __langchain_core_utils_types.isInteropZodObject)(value.state)) return false;
      if ("input" in value && !(0, __langchain_core_utils_types.isInteropZodObject)(value.input)) return false;
      if ("output" in value && !(0, __langchain_core_utils_types.isInteropZodObject)(value.output)) return false;
      return true;
    }
    function _controlBranch(value) {
      if (require_constants5._isSend(value)) return [value];
      const commands = [];
      if (require_constants5.isCommand(value)) commands.push(value);
      else if (Array.isArray(value)) commands.push(...value.filter(require_constants5.isCommand));
      const destinations = [];
      for (const command of commands) {
        if (command.graph === require_constants5.Command.PARENT) throw new require_errors10.ParentCommand(command);
        if (require_constants5._isSend(command.goto)) destinations.push(command.goto);
        else if (typeof command.goto === "string") destinations.push(command.goto);
        else if (Array.isArray(command.goto)) destinations.push(...command.goto);
      }
      return destinations;
    }
    function _getControlBranch() {
      const CONTROL_BRANCH_PATH = new require_utils10.RunnableCallable({
        func: _controlBranch,
        tags: [require_constants5.TAG_HIDDEN],
        trace: false,
        recurse: false,
        name: "<control_branch>"
      });
      return new require_graph4.Branch({ path: CONTROL_BRANCH_PATH });
    }
    exports2.CompiledStateGraph = CompiledStateGraph;
    exports2.StateGraph = StateGraph;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/graph/message.cjs
var require_message2 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/graph/message.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime3();
    var require_config3 = require_config2();
    var require_state2 = require_state();
    var uuid = require_rolldown_runtime5.__toESM((init_esm_node(), __toCommonJS(esm_node_exports)));
    var __langchain_core_messages = require_rolldown_runtime5.__toESM(require_messages2());
    var REMOVE_ALL_MESSAGES = "__remove_all__";
    function messagesStateReducer(left, right) {
      const leftArray = Array.isArray(left) ? left : [left];
      const rightArray = Array.isArray(right) ? right : [right];
      const leftMessages = leftArray.map(__langchain_core_messages.coerceMessageLikeToMessage);
      const rightMessages = rightArray.map(__langchain_core_messages.coerceMessageLikeToMessage);
      for (const m of leftMessages) if (m.id === null || m.id === void 0) {
        m.id = (0, uuid.v4)();
        m.lc_kwargs.id = m.id;
      }
      let removeAllIdx;
      for (let i = 0; i < rightMessages.length; i += 1) {
        const m = rightMessages[i];
        if (m.id === null || m.id === void 0) {
          m.id = (0, uuid.v4)();
          m.lc_kwargs.id = m.id;
        }
        if (m.getType() === "remove" && m.id === REMOVE_ALL_MESSAGES) removeAllIdx = i;
      }
      if (removeAllIdx != null) return rightMessages.slice(removeAllIdx + 1);
      const merged = [...leftMessages];
      const mergedById = new Map(merged.map((m, i) => [m.id, i]));
      const idsToRemove = /* @__PURE__ */ new Set();
      for (const m of rightMessages) {
        const existingIdx = mergedById.get(m.id);
        if (existingIdx !== void 0) if (m.getType() === "remove") idsToRemove.add(m.id);
        else {
          idsToRemove.delete(m.id);
          merged[existingIdx] = m;
        }
        else {
          if (m.getType() === "remove") throw new Error(`Attempting to delete a message with an ID that doesn't exist ('${m.id}')`);
          mergedById.set(m.id, merged.length);
          merged.push(m);
        }
      }
      return merged.filter((m) => !idsToRemove.has(m.id));
    }
    var MessageGraph = class extends require_state2.StateGraph {
      constructor() {
        super({ channels: { __root__: {
          reducer: messagesStateReducer,
          default: () => []
        } } });
      }
    };
    function pushMessage(message, options) {
      const { stateKey: userStateKey, ...userConfig } = options ?? {};
      const config = require_config3.ensureLangGraphConfig(userConfig);
      let stateKey = userStateKey ?? "messages";
      if (userStateKey === null) stateKey = void 0;
      const validMessage = (0, __langchain_core_messages.coerceMessageLikeToMessage)(message);
      if (!validMessage.id) throw new Error("Message ID is required.");
      const callbacks = (() => {
        if (Array.isArray(config.callbacks)) return config.callbacks;
        if (typeof config.callbacks !== "undefined") return config.callbacks.handlers;
        return [];
      })();
      const messagesHandler = callbacks.find((cb) => "name" in cb && cb.name === "StreamMessagesHandler");
      if (messagesHandler) {
        const metadata = config.metadata ?? {};
        const namespace = (metadata.langgraph_checkpoint_ns ?? "").split("|");
        messagesHandler._emit([namespace, metadata], validMessage, void 0, false);
      }
      if (stateKey) config.configurable?.__pregel_send?.([[stateKey, validMessage]]);
      return validMessage;
    }
    exports2.MessageGraph = MessageGraph;
    exports2.REMOVE_ALL_MESSAGES = REMOVE_ALL_MESSAGES;
    exports2.messagesStateReducer = messagesStateReducer;
    exports2.pushMessage = pushMessage;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/func/index.cjs
var require_func = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/func/index.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime3();
    var require_last_value2 = require_last_value();
    var require_constants5 = require_constants4();
    var require_utils10 = require_utils8();
    var require_write2 = require_write();
    var require_read2 = require_read();
    var require_call2 = require_call();
    var require_pregel_index = require_pregel();
    var require_ephemeral_value2 = require_ephemeral_value();
    var __langchain_core_singletons = require_rolldown_runtime5.__toESM(require_singletons());
    function task(optionsOrName, func) {
      const options = typeof optionsOrName === "string" ? {
        name: optionsOrName,
        retry: void 0,
        cachePolicy: void 0
      } : optionsOrName;
      const { name, retry } = options;
      if (require_utils10.isAsyncGeneratorFunction(func) || require_utils10.isGeneratorFunction(func)) throw new Error("Generators are disallowed as tasks. For streaming responses, use config.write.");
      const cachePolicy = options.cachePolicy ?? ("cache" in options ? options.cache : void 0);
      let cache;
      if (typeof cachePolicy === "boolean") cache = cachePolicy ? {} : void 0;
      else cache = cachePolicy;
      return (...args) => {
        return require_call2.call({
          func,
          name,
          retry,
          cache
        }, ...args);
      };
    }
    var entrypoint = function entrypoint$1(optionsOrName, func) {
      const { name, checkpointer, store, cache } = typeof optionsOrName === "string" ? {
        name: optionsOrName,
        checkpointer: void 0,
        store: void 0
      } : optionsOrName;
      if (require_utils10.isAsyncGeneratorFunction(func) || require_utils10.isGeneratorFunction(func)) throw new Error("Generators are disallowed as entrypoints. For streaming responses, use config.write.");
      const streamMode = "updates";
      const bound = require_call2.getRunnableForEntrypoint(name, func);
      function isEntrypointFinal(value) {
        return typeof value === "object" && value !== null && "__lg_type" in value && value.__lg_type === "__pregel_final";
      }
      const pluckReturnValue = new require_utils10.RunnableCallable({
        name: "pluckReturnValue",
        func: (value) => {
          return isEntrypointFinal(value) ? value.value : value;
        }
      });
      const pluckSaveValue = new require_utils10.RunnableCallable({
        name: "pluckSaveValue",
        func: (value) => {
          return isEntrypointFinal(value) ? value.save : value;
        }
      });
      const entrypointNode = new require_read2.PregelNode({
        bound,
        triggers: [require_constants5.START],
        channels: [require_constants5.START],
        writers: [new require_write2.ChannelWrite([{
          channel: require_constants5.END,
          value: require_write2.PASSTHROUGH,
          mapper: pluckReturnValue
        }, {
          channel: require_constants5.PREVIOUS,
          value: require_write2.PASSTHROUGH,
          mapper: pluckSaveValue
        }], [require_constants5.TAG_HIDDEN])]
      });
      return new require_pregel_index.Pregel({
        name,
        checkpointer,
        nodes: { [name]: entrypointNode },
        channels: {
          [require_constants5.START]: new require_ephemeral_value2.EphemeralValue(),
          [require_constants5.END]: new require_last_value2.LastValue(),
          [require_constants5.PREVIOUS]: new require_last_value2.LastValue()
        },
        inputChannels: require_constants5.START,
        outputChannels: require_constants5.END,
        streamChannels: require_constants5.END,
        streamMode,
        store,
        cache
      });
    };
    entrypoint.final = function final({ value, save }) {
      return {
        value,
        save,
        __lg_type: "__pregel_final"
      };
    };
    function getPreviousState() {
      const config = __langchain_core_singletons.AsyncLocalStorageProviderSingleton.getRunnableConfig();
      return config.configurable?.[require_constants5.CONFIG_KEY_PREVIOUS_STATE];
    }
    exports2.entrypoint = entrypoint;
    exports2.getPreviousState = getPreviousState;
    exports2.task = task;
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/util.cjs
var require_util4 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/util.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getParsedType = exports2.ZodParsedType = exports2.objectUtil = exports2.util = void 0;
    var util;
    (function(util2) {
      util2.assertEqual = (_) => {
      };
      function assertIs(_arg) {
      }
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e) {
          return obj[e];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys = [];
        for (const key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util || (exports2.util = util = {}));
    var objectUtil;
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (exports2.objectUtil = objectUtil = {}));
    exports2.ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    var getParsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return exports2.ZodParsedType.undefined;
        case "string":
          return exports2.ZodParsedType.string;
        case "number":
          return Number.isNaN(data) ? exports2.ZodParsedType.nan : exports2.ZodParsedType.number;
        case "boolean":
          return exports2.ZodParsedType.boolean;
        case "function":
          return exports2.ZodParsedType.function;
        case "bigint":
          return exports2.ZodParsedType.bigint;
        case "symbol":
          return exports2.ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return exports2.ZodParsedType.array;
          }
          if (data === null) {
            return exports2.ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return exports2.ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return exports2.ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return exports2.ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return exports2.ZodParsedType.date;
          }
          return exports2.ZodParsedType.object;
        default:
          return exports2.ZodParsedType.unknown;
      }
    };
    exports2.getParsedType = getParsedType;
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/ZodError.cjs
var require_ZodError2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/ZodError.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ZodError = exports2.quotelessJson = exports2.ZodIssueCode = void 0;
    var util_js_1 = require_util4();
    exports2.ZodIssueCode = util_js_1.util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    var quotelessJson = (obj) => {
      const json = JSON.stringify(obj, null, 2);
      return json.replace(/"([^"]+)":/g, "$1:");
    };
    exports2.quotelessJson = quotelessJson;
    var ZodError = class _ZodError extends Error {
      get errors() {
        return this.issues;
      }
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
          for (const issue of error.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i = 0;
              while (i < issue.path.length) {
                const el = issue.path[i];
                const terminal = i === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      static assert(value) {
        if (!(value instanceof _ZodError)) {
          throw new Error(`Not a ZodError: ${value}`);
        }
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util_js_1.util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            const firstEl = sub.path[0];
            fieldErrors[firstEl] = fieldErrors[firstEl] || [];
            fieldErrors[firstEl].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    exports2.ZodError = ZodError;
    ZodError.create = (issues) => {
      const error = new ZodError(issues);
      return error;
    };
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/locales/en.cjs
var require_en4 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/locales/en.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ZodError_js_1 = require_ZodError2();
    var util_js_1 = require_util4();
    var errorMap = (issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodError_js_1.ZodIssueCode.invalid_type:
          if (issue.received === util_js_1.ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodError_js_1.ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_js_1.util.jsonStringifyReplacer)}`;
          break;
        case ZodError_js_1.ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util_js_1.util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util_js_1.util.joinValues(issue.options)}`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util_js_1.util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util_js_1.util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodError_js_1.ZodIssueCode.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "bigint")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodError_js_1.ZodIssueCode.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodError_js_1.ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodError_js_1.ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodError_js_1.ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodError_js_1.ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util_js_1.util.assertNever(issue);
      }
      return { message };
    };
    exports2.default = errorMap;
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/errors.cjs
var require_errors8 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/errors.cjs"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultErrorMap = void 0;
    exports2.setErrorMap = setErrorMap;
    exports2.getErrorMap = getErrorMap;
    var en_js_1 = __importDefault(require_en4());
    exports2.defaultErrorMap = en_js_1.default;
    var overrideErrorMap = en_js_1.default;
    function setErrorMap(map) {
      overrideErrorMap = map;
    }
    function getErrorMap() {
      return overrideErrorMap;
    }
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/parseUtil.cjs
var require_parseUtil2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/parseUtil.cjs"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAsync = exports2.isValid = exports2.isDirty = exports2.isAborted = exports2.OK = exports2.DIRTY = exports2.INVALID = exports2.ParseStatus = exports2.EMPTY_PATH = exports2.makeIssue = void 0;
    exports2.addIssueToContext = addIssueToContext;
    var errors_js_1 = require_errors8();
    var en_js_1 = __importDefault(require_en4());
    var makeIssue = (params) => {
      const { data, path, errorMaps, issueData } = params;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      if (issueData.message !== void 0) {
        return {
          ...issueData,
          path: fullPath,
          message: issueData.message
        };
      }
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: errorMessage
      };
    };
    exports2.makeIssue = makeIssue;
    exports2.EMPTY_PATH = [];
    function addIssueToContext(ctx, issueData) {
      const overrideMap = (0, errors_js_1.getErrorMap)();
      const issue = (0, exports2.makeIssue)({
        issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          // contextual error map is first priority
          ctx.schemaErrorMap,
          // then schema-bound map if available
          overrideMap,
          // then global override map
          overrideMap === en_js_1.default ? void 0 : en_js_1.default
          // then global default map
        ].filter((x) => !!x)
      });
      ctx.common.issues.push(issue);
    }
    var ParseStatus = class _ParseStatus {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
          if (s.status === "aborted")
            return exports2.INVALID;
          if (s.status === "dirty")
            status.dirty();
          arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return exports2.INVALID;
          if (value.status === "aborted")
            return exports2.INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    exports2.ParseStatus = ParseStatus;
    exports2.INVALID = Object.freeze({
      status: "aborted"
    });
    var DIRTY = (value) => ({ status: "dirty", value });
    exports2.DIRTY = DIRTY;
    var OK = (value) => ({ status: "valid", value });
    exports2.OK = OK;
    var isAborted = (x) => x.status === "aborted";
    exports2.isAborted = isAborted;
    var isDirty = (x) => x.status === "dirty";
    exports2.isDirty = isDirty;
    var isValid = (x) => x.status === "valid";
    exports2.isValid = isValid;
    var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
    exports2.isAsync = isAsync;
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/typeAliases.cjs
var require_typeAliases2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/typeAliases.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/errorUtil.cjs
var require_errorUtil2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/errorUtil.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.errorUtil = void 0;
    var errorUtil;
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
    })(errorUtil || (exports2.errorUtil = errorUtil = {}));
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/types.cjs
var require_types8 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/types.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.discriminatedUnion = exports2.date = exports2.boolean = exports2.bigint = exports2.array = exports2.any = exports2.coerce = exports2.ZodFirstPartyTypeKind = exports2.late = exports2.ZodSchema = exports2.Schema = exports2.ZodReadonly = exports2.ZodPipeline = exports2.ZodBranded = exports2.BRAND = exports2.ZodNaN = exports2.ZodCatch = exports2.ZodDefault = exports2.ZodNullable = exports2.ZodOptional = exports2.ZodTransformer = exports2.ZodEffects = exports2.ZodPromise = exports2.ZodNativeEnum = exports2.ZodEnum = exports2.ZodLiteral = exports2.ZodLazy = exports2.ZodFunction = exports2.ZodSet = exports2.ZodMap = exports2.ZodRecord = exports2.ZodTuple = exports2.ZodIntersection = exports2.ZodDiscriminatedUnion = exports2.ZodUnion = exports2.ZodObject = exports2.ZodArray = exports2.ZodVoid = exports2.ZodNever = exports2.ZodUnknown = exports2.ZodAny = exports2.ZodNull = exports2.ZodUndefined = exports2.ZodSymbol = exports2.ZodDate = exports2.ZodBoolean = exports2.ZodBigInt = exports2.ZodNumber = exports2.ZodString = exports2.ZodType = void 0;
    exports2.NEVER = exports2.void = exports2.unknown = exports2.union = exports2.undefined = exports2.tuple = exports2.transformer = exports2.symbol = exports2.string = exports2.strictObject = exports2.set = exports2.record = exports2.promise = exports2.preprocess = exports2.pipeline = exports2.ostring = exports2.optional = exports2.onumber = exports2.oboolean = exports2.object = exports2.number = exports2.nullable = exports2.null = exports2.never = exports2.nativeEnum = exports2.nan = exports2.map = exports2.literal = exports2.lazy = exports2.intersection = exports2.instanceof = exports2.function = exports2.enum = exports2.effect = void 0;
    exports2.datetimeRegex = datetimeRegex;
    exports2.custom = custom;
    var ZodError_js_1 = require_ZodError2();
    var errors_js_1 = require_errors8();
    var errorUtil_js_1 = require_errorUtil2();
    var parseUtil_js_1 = require_parseUtil2();
    var util_js_1 = require_util4();
    var ParseInputLazyPath = class {
      constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (Array.isArray(this._key)) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    var handleResult = (ctx, result) => {
      if ((0, parseUtil_js_1.isValid)(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error = new ZodError_js_1.ZodError(ctx.common.issues);
            this._error = error;
            return this._error;
          }
        };
      }
    };
    function processCreateParams(params) {
      if (!params)
        return {};
      const { errorMap, invalid_type_error, required_error, description } = params;
      if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
      }
      if (errorMap)
        return { errorMap, description };
      const customMap = (iss, ctx) => {
        const { message } = params;
        if (iss.code === "invalid_enum_value") {
          return { message: message ?? ctx.defaultError };
        }
        if (typeof ctx.data === "undefined") {
          return { message: message ?? required_error ?? ctx.defaultError };
        }
        if (iss.code !== "invalid_type")
          return { message: ctx.defaultError };
        return { message: message ?? invalid_type_error ?? ctx.defaultError };
      };
      return { errorMap: customMap, description };
    }
    var ZodType = class {
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return (0, util_js_1.getParsedType)(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: (0, util_js_1.getParsedType)(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new parseUtil_js_1.ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: (0, util_js_1.getParsedType)(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if ((0, parseUtil_js_1.isAsync)(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        const ctx = {
          common: {
            issues: [],
            async: params?.async ?? false,
            contextualErrorMap: params?.errorMap
          },
          path: params?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_js_1.getParsedType)(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      "~validate"(data) {
        const ctx = {
          common: {
            issues: [],
            async: !!this["~standard"].async
          },
          path: [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_js_1.getParsedType)(data)
        };
        if (!this["~standard"].async) {
          try {
            const result = this._parseSync({ data, path: [], parent: ctx });
            return (0, parseUtil_js_1.isValid)(result) ? {
              value: result.value
            } : {
              issues: ctx.common.issues
            };
          } catch (err) {
            if (err?.message?.toLowerCase()?.includes("encountered")) {
              this["~standard"].async = true;
            }
            ctx.common = {
              issues: [],
              async: true
            };
          }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => (0, parseUtil_js_1.isValid)(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        });
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params?.errorMap,
            async: true
          },
          path: params?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_js_1.getParsedType)(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await ((0, parseUtil_js_1.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check, message) {
        const getIssueProperties = (val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        };
        return this._refinement((val, ctx) => {
          const result = check(val);
          const setError = () => ctx.addIssue({
            code: ZodError_js_1.ZodIssueCode.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
          version: 1,
          vendor: "zod",
          validate: (data) => this["~validate"](data)
        };
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    exports2.ZodType = ZodType;
    exports2.Schema = ZodType;
    exports2.ZodSchema = ZodType;
    var cuidRegex = /^c[^\s-]{8,}$/i;
    var cuid2Regex = /^[0-9a-z]+$/;
    var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
    var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    var nanoidRegex = /^[a-z0-9_-]{21}$/i;
    var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
    var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    var emojiRegex;
    var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
    var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
    var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
    var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
    var dateRegex = new RegExp(`^${dateRegexSource}$`);
    function timeRegexSource(args) {
      let secondsRegexSource = `[0-5]\\d`;
      if (args.precision) {
        secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
      } else if (args.precision == null) {
        secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
      }
      const secondsQuantifier = args.precision ? "+" : "?";
      return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
    }
    function timeRegex(args) {
      return new RegExp(`^${timeRegexSource(args)}$`);
    }
    function datetimeRegex(args) {
      let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
      const opts = [];
      opts.push(args.local ? `Z?` : `Z`);
      if (args.offset)
        opts.push(`([+-]\\d{2}:?\\d{2})`);
      regex = `${regex}(${opts.join("|")})`;
      return new RegExp(`^${regex}$`);
    }
    function isValidIP(ip, version2) {
      if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
        return true;
      }
      if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
        return true;
      }
      return false;
    }
    function isValidJWT(jwt, alg) {
      if (!jwtRegex.test(jwt))
        return false;
      try {
        const [header] = jwt.split(".");
        if (!header)
          return false;
        const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
        const decoded = JSON.parse(atob(base64));
        if (typeof decoded !== "object" || decoded === null)
          return false;
        if ("typ" in decoded && decoded?.typ !== "JWT")
          return false;
        if (!decoded.alg)
          return false;
        if (alg && decoded.alg !== alg)
          return false;
        return true;
      } catch {
        return false;
      }
    }
    function isValidCidr(ip, version2) {
      if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
        return true;
      }
      if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
        return true;
      }
      return false;
    }
    var ZodString = class _ZodString extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx2, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.string,
            received: ctx2.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        const status = new parseUtil_js_1.ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                (0, parseUtil_js_1.addIssueToContext)(ctx, {
                  code: ZodError_js_1.ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                (0, parseUtil_js_1.addIssueToContext)(ctx, {
                  code: ZodError_js_1.ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "email",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "emoji",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "uuid",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "nanoid") {
            if (!nanoidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "nanoid",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "cuid",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "cuid2",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "ulid",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "url",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "regex",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "includes") {
            if (!input.data.includes(check.value, check.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                validation: { includes: check.value, position: check.position },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "date") {
            const regex = dateRegex;
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                validation: "date",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "time") {
            const regex = timeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                validation: "time",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "duration") {
            if (!durationRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "duration",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ip") {
            if (!isValidIP(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "ip",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "jwt") {
            if (!isValidJWT(input.data, check.alg)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "jwt",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cidr") {
            if (!isValidCidr(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "cidr",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64") {
            if (!base64Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "base64",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64url") {
            if (!base64urlRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                validation: "base64url",
                code: ZodError_js_1.ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util_js_1.util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
          validation,
          code: ZodError_js_1.ZodIssueCode.invalid_string,
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      _addCheck(check) {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      base64(message) {
        return this._addCheck({ kind: "base64", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      base64url(message) {
        return this._addCheck({
          kind: "base64url",
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      jwt(options) {
        return this._addCheck({ kind: "jwt", ...errorUtil_js_1.errorUtil.errToObj(options) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil_js_1.errorUtil.errToObj(options) });
      }
      cidr(options) {
        return this._addCheck({ kind: "cidr", ...errorUtil_js_1.errorUtil.errToObj(options) });
      }
      datetime(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          offset: options?.offset ?? false,
          local: options?.local ?? false,
          ...errorUtil_js_1.errorUtil.errToObj(options?.message)
        });
      }
      date(message) {
        return this._addCheck({ kind: "date", message });
      }
      time(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "time",
            precision: null,
            message: options
          });
        }
        return this._addCheck({
          kind: "time",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          ...errorUtil_js_1.errorUtil.errToObj(options?.message)
        });
      }
      duration(message) {
        return this._addCheck({ kind: "duration", ...errorUtil_js_1.errorUtil.errToObj(message) });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options?.position,
          ...errorUtil_js_1.errorUtil.errToObj(options?.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil_js_1.errorUtil.errToObj(message)
        });
      }
      /**
       * Equivalent to `.min(1)`
       */
      nonempty(message) {
        return this.min(1, errorUtil_js_1.errorUtil.errToObj(message));
      }
      trim() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
      }
      get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
      }
      get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
      }
      get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
      }
      get isBase64url() {
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    exports2.ZodString = ZodString;
    ZodString.create = (params) => {
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
      });
    };
    function floatSafeRemainder(val, step) {
      const valDecCount = (val.toString().split(".")[1] || "").length;
      const stepDecCount = (step.toString().split(".")[1] || "").length;
      const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
      const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
      const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
      return valInt % stepInt / 10 ** decCount;
    }
    var ZodNumber = class _ZodNumber extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx2, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.number,
            received: ctx2.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        let ctx = void 0;
        const status = new parseUtil_js_1.ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util_js_1.util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util_js_1.util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_js_1.errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_js_1.errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_js_1.errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_js_1.errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil_js_1.errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil_js_1.errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util_js_1.util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null;
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    };
    exports2.ZodNumber = ZodNumber;
    ZodNumber.create = (params) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
      });
    };
    var ZodBigInt = class _ZodBigInt extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          try {
            input.data = BigInt(input.data);
          } catch {
            return this._getInvalidInput(input);
          }
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.bigint) {
          return this._getInvalidInput(input);
        }
        let ctx = void 0;
        const status = new parseUtil_js_1.ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_small,
                type: "bigint",
                minimum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_big,
                type: "bigint",
                maximum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (input.data % check.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util_js_1.util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.bigint,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_js_1.errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_js_1.errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_js_1.errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_js_1.errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil_js_1.errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    exports2.ZodBigInt = ZodBigInt;
    ZodBigInt.create = (params) => {
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
      });
    };
    var ZodBoolean = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        return (0, parseUtil_js_1.OK)(input.data);
      }
    };
    exports2.ZodBoolean = ZodBoolean;
    ZodBoolean.create = (params) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
      });
    };
    var ZodDate = class _ZodDate extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx2, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.date,
            received: ctx2.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        if (Number.isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx2, {
            code: ZodError_js_1.ZodIssueCode.invalid_date
          });
          return parseUtil_js_1.INVALID;
        }
        const status = new parseUtil_js_1.ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util_js_1.util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil_js_1.errorUtil.toString(message)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    };
    exports2.ZodDate = ZodDate;
    ZodDate.create = (params) => {
      return new ZodDate({
        checks: [],
        coerce: params?.coerce || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    var ZodSymbol = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        return (0, parseUtil_js_1.OK)(input.data);
      }
    };
    exports2.ZodSymbol = ZodSymbol;
    ZodSymbol.create = (params) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    var ZodUndefined = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        return (0, parseUtil_js_1.OK)(input.data);
      }
    };
    exports2.ZodUndefined = ZodUndefined;
    ZodUndefined.create = (params) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    var ZodNull = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.null,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        return (0, parseUtil_js_1.OK)(input.data);
      }
    };
    exports2.ZodNull = ZodNull;
    ZodNull.create = (params) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    var ZodAny = class extends ZodType {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return (0, parseUtil_js_1.OK)(input.data);
      }
    };
    exports2.ZodAny = ZodAny;
    ZodAny.create = (params) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    var ZodUnknown = class extends ZodType {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return (0, parseUtil_js_1.OK)(input.data);
      }
    };
    exports2.ZodUnknown = ZodUnknown;
    ZodUnknown.create = (params) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    var ZodNever = class extends ZodType {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.never,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
    };
    exports2.ZodNever = ZodNever;
    ZodNever.create = (params) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    var ZodVoid = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.void,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        return (0, parseUtil_js_1.OK)(input.data);
      }
    };
    exports2.ZodVoid = ZodVoid;
    ZodVoid.create = (params) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    var ZodArray = class _ZodArray extends ZodType {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== util_js_1.ZodParsedType.array) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.array,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: tooBig ? ZodError_js_1.ZodIssueCode.too_big : ZodError_js_1.ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          })).then((result2) => {
            return parseUtil_js_1.ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return parseUtil_js_1.ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil_js_1.errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil_js_1.errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil_js_1.errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    exports2.ZodArray = ZodArray;
    ZodArray.create = (schema, params) => {
      return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    function deepPartialify(schema) {
      if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
          const fieldSchema = schema.shape[key];
          newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
          ...schema._def,
          shape: () => newShape
        });
      } else if (schema instanceof ZodArray) {
        return new ZodArray({
          ...schema._def,
          type: deepPartialify(schema.element)
        });
      } else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
      } else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
      } else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
      } else {
        return schema;
      }
    }
    var ZodObject = class _ZodObject extends ZodType {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util_js_1.util.objectKeys(shape);
        this._cached = { shape, keys };
        return this._cached;
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx2, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.object,
            received: ctx2.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip") {
          } else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              syncPairs.push({
                key,
                value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return parseUtil_js_1.ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return parseUtil_js_1.ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil_js_1.errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: (issue, ctx) => {
              const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: errorUtil_js_1.errorUtil.errToObj(message).message ?? defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key, schema) {
        return this.augment({ [key]: schema });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index) {
        return new _ZodObject({
          ...this._def,
          catchall: index
        });
      }
      pick(mask) {
        const shape = {};
        for (const key of util_js_1.util.objectKeys(mask)) {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        for (const key of util_js_1.util.objectKeys(this.shape)) {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        for (const key of util_js_1.util.objectKeys(this.shape)) {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        for (const key of util_js_1.util.objectKeys(this.shape)) {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util_js_1.util.objectKeys(this.shape));
      }
    };
    exports2.ZodObject = ZodObject;
    ZodObject.create = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.strictCreate = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.lazycreate = (shape, params) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    var ZodUnion = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError_js_1.ZodError(result.ctx.common.issues));
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_union,
            unionErrors
          });
          return parseUtil_js_1.INVALID;
        }
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError_js_1.ZodError(issues2));
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_union,
            unionErrors
          });
          return parseUtil_js_1.INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    exports2.ZodUnion = ZodUnion;
    ZodUnion.create = (types, params) => {
      return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    var getDiscriminator = (type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return util_js_1.util.objectValues(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else if (type instanceof ZodOptional) {
        return [void 0, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
      } else {
        return [];
      }
    };
    var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.object) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.object,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return parseUtil_js_1.INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues.length) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    };
    exports2.ZodDiscriminatedUnion = ZodDiscriminatedUnion;
    function mergeValues(a, b) {
      const aType = (0, util_js_1.getParsedType)(a);
      const bType = (0, util_js_1.getParsedType)(b);
      if (a === b) {
        return { valid: true, data: a };
      } else if (aType === util_js_1.ZodParsedType.object && bType === util_js_1.ZodParsedType.object) {
        const bKeys = util_js_1.util.objectKeys(b);
        const sharedKeys = util_js_1.util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
          const sharedValue = mergeValues(a[key], b[key]);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
      } else if (aType === util_js_1.ZodParsedType.array && bType === util_js_1.ZodParsedType.array) {
        if (a.length !== b.length) {
          return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
          const itemA = a[index];
          const itemB = b[index];
          const sharedValue = mergeValues(itemA, itemB);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
      } else if (aType === util_js_1.ZodParsedType.date && bType === util_js_1.ZodParsedType.date && +a === +b) {
        return { valid: true, data: a };
      } else {
        return { valid: false };
      }
    }
    var ZodIntersection = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if ((0, parseUtil_js_1.isAborted)(parsedLeft) || (0, parseUtil_js_1.isAborted)(parsedRight)) {
            return parseUtil_js_1.INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.invalid_intersection_types
            });
            return parseUtil_js_1.INVALID;
          }
          if ((0, parseUtil_js_1.isDirty)(parsedLeft) || (0, parseUtil_js_1.isDirty)(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    exports2.ZodIntersection = ZodIntersection;
    ZodIntersection.create = (left, right, params) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    var ZodTuple = class _ZodTuple extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.array) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.array,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return parseUtil_js_1.INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return parseUtil_js_1.ParseStatus.mergeArray(status, results);
          });
        } else {
          return parseUtil_js_1.ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    exports2.ZodTuple = ZodTuple;
    ZodTuple.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    var ZodRecord = class _ZodRecord extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.object) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.object,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (ctx.common.async) {
          return parseUtil_js_1.ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return parseUtil_js_1.ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new _ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new _ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    exports2.ZodRecord = ZodRecord;
    var ZodMap = class extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.map) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.map,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return parseUtil_js_1.INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return parseUtil_js_1.INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    exports2.ZodMap = ZodMap;
    ZodMap.create = (keyType, valueType, params) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    var ZodSet = class _ZodSet extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.set) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.set,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return parseUtil_js_1.INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil_js_1.errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil_js_1.errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    exports2.ZodSet = ZodSet;
    ZodSet.create = (valueType, params) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    var ZodFunction = class _ZodFunction extends ZodType {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.function) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.function,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        function makeArgsIssue(args, error) {
          return (0, parseUtil_js_1.makeIssue)({
            data: args,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, (0, errors_js_1.getErrorMap)(), errors_js_1.defaultErrorMap].filter((x) => !!x),
            issueData: {
              code: ZodError_js_1.ZodIssueCode.invalid_arguments,
              argumentsError: error
            }
          });
        }
        function makeReturnsIssue(returns, error) {
          return (0, parseUtil_js_1.makeIssue)({
            data: returns,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, (0, errors_js_1.getErrorMap)(), errors_js_1.defaultErrorMap].filter((x) => !!x),
            issueData: {
              code: ZodError_js_1.ZodIssueCode.invalid_return_type,
              returnTypeError: error
            }
          });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          const me = this;
          return (0, parseUtil_js_1.OK)(async function(...args) {
            const error = new ZodError_js_1.ZodError([]);
            const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
              error.addIssue(makeArgsIssue(args, e));
              throw error;
            });
            const result = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
              error.addIssue(makeReturnsIssue(result, e));
              throw error;
            });
            return parsedReturns;
          });
        } else {
          const me = this;
          return (0, parseUtil_js_1.OK)(function(...args) {
            const parsedArgs = me._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError_js_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError_js_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new _ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    };
    exports2.ZodFunction = ZodFunction;
    var ZodLazy = class extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    exports2.ZodLazy = ZodLazy;
    ZodLazy.create = (getter, params) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    var ZodLiteral = class extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_js_1.ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return parseUtil_js_1.INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    exports2.ZodLiteral = ZodLiteral;
    ZodLiteral.create = (value, params) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    function createZodEnum(values, params) {
      return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params)
      });
    }
    var ZodEnum = class _ZodEnum extends ZodType {
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            expected: util_js_1.util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodError_js_1.ZodIssueCode.invalid_type
          });
          return parseUtil_js_1.INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(this._def.values);
        }
        if (!this._cache.has(input.data)) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_js_1.ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return parseUtil_js_1.INVALID;
        }
        return (0, parseUtil_js_1.OK)(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values, newDef = this._def) {
        return _ZodEnum.create(values, {
          ...this._def,
          ...newDef
        });
      }
      exclude(values, newDef = this._def) {
        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
          ...this._def,
          ...newDef
        });
      }
    };
    exports2.ZodEnum = ZodEnum;
    ZodEnum.create = createZodEnum;
    var ZodNativeEnum = class extends ZodType {
      _parse(input) {
        const nativeEnumValues = util_js_1.util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.string && ctx.parsedType !== util_js_1.ZodParsedType.number) {
          const expectedValues = util_js_1.util.objectValues(nativeEnumValues);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            expected: util_js_1.util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodError_js_1.ZodIssueCode.invalid_type
          });
          return parseUtil_js_1.INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(util_js_1.util.getValidEnumValues(this._def.values));
        }
        if (!this._cache.has(input.data)) {
          const expectedValues = util_js_1.util.objectValues(nativeEnumValues);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_js_1.ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return parseUtil_js_1.INVALID;
        }
        return (0, parseUtil_js_1.OK)(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    exports2.ZodNativeEnum = ZodNativeEnum;
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    var ZodPromise = class extends ZodType {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_js_1.ZodParsedType.promise && ctx.common.async === false) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.promise,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        const promisified = ctx.parsedType === util_js_1.ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return (0, parseUtil_js_1.OK)(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    exports2.ZodPromise = ZodPromise;
    ZodPromise.create = (schema, params) => {
      return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    var ZodEffects = class extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: (arg) => {
            (0, parseUtil_js_1.addIssueToContext)(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(processed).then(async (processed2) => {
              if (status.value === "aborted")
                return parseUtil_js_1.INVALID;
              const result = await this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
              if (result.status === "aborted")
                return parseUtil_js_1.INVALID;
              if (result.status === "dirty")
                return (0, parseUtil_js_1.DIRTY)(result.value);
              if (status.value === "dirty")
                return (0, parseUtil_js_1.DIRTY)(result.value);
              return result;
            });
          } else {
            if (status.value === "aborted")
              return parseUtil_js_1.INVALID;
            const result = this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return parseUtil_js_1.INVALID;
            if (result.status === "dirty")
              return (0, parseUtil_js_1.DIRTY)(result.value);
            if (status.value === "dirty")
              return (0, parseUtil_js_1.DIRTY)(result.value);
            return result;
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return parseUtil_js_1.INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return parseUtil_js_1.INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!(0, parseUtil_js_1.isValid)(base))
              return parseUtil_js_1.INVALID;
            const result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!(0, parseUtil_js_1.isValid)(base))
                return parseUtil_js_1.INVALID;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
                status: status.value,
                value: result
              }));
            });
          }
        }
        util_js_1.util.assertNever(effect);
      }
    };
    exports2.ZodEffects = ZodEffects;
    exports2.ZodTransformer = ZodEffects;
    ZodEffects.create = (schema, effect, params) => {
      return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
      return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    var ZodOptional = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_js_1.ZodParsedType.undefined) {
          return (0, parseUtil_js_1.OK)(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    exports2.ZodOptional = ZodOptional;
    ZodOptional.create = (type, params) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    var ZodNullable = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_js_1.ZodParsedType.null) {
          return (0, parseUtil_js_1.OK)(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    exports2.ZodNullable = ZodNullable;
    ZodNullable.create = (type, params) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    var ZodDefault = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === util_js_1.ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    exports2.ZodDefault = ZodDefault;
    ZodDefault.create = (type, params) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    var ZodCatch = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if ((0, parseUtil_js_1.isAsync)(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError_js_1.ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError_js_1.ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    exports2.ZodCatch = ZodCatch;
    ZodCatch.create = (type, params) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params)
      });
    };
    var ZodNaN = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_js_1.ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_type,
            expected: util_js_1.ZodParsedType.nan,
            received: ctx.parsedType
          });
          return parseUtil_js_1.INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    exports2.ZodNaN = ZodNaN;
    ZodNaN.create = (params) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    exports2.BRAND = Symbol("zod_brand");
    var ZodBranded = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    exports2.ZodBranded = ZodBranded;
    var ZodPipeline = class _ZodPipeline extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return parseUtil_js_1.INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return (0, parseUtil_js_1.DIRTY)(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return parseUtil_js_1.INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b) {
        return new _ZodPipeline({
          in: a,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    exports2.ZodPipeline = ZodPipeline;
    var ZodReadonly = class extends ZodType {
      _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data) => {
          if ((0, parseUtil_js_1.isValid)(data)) {
            data.value = Object.freeze(data.value);
          }
          return data;
        };
        return (0, parseUtil_js_1.isAsync)(result) ? result.then((data) => freeze(data)) : freeze(result);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    exports2.ZodReadonly = ZodReadonly;
    ZodReadonly.create = (type, params) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
      });
    };
    function cleanParams(params, data) {
      const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
      const p2 = typeof p === "string" ? { message: p } : p;
      return p2;
    }
    function custom(check, _params = {}, fatal) {
      if (check)
        return ZodAny.create().superRefine((data, ctx) => {
          const r = check(data);
          if (r instanceof Promise) {
            return r.then((r2) => {
              if (!r2) {
                const params = cleanParams(_params, data);
                const _fatal = params.fatal ?? fatal ?? true;
                ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
              }
            });
          }
          if (!r) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
          return;
        });
      return ZodAny.create();
    }
    exports2.late = {
      object: ZodObject.lazycreate
    };
    var ZodFirstPartyTypeKind;
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (exports2.ZodFirstPartyTypeKind = ZodFirstPartyTypeKind = {}));
    var instanceOfType = (cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data) => data instanceof cls, params);
    exports2.instanceof = instanceOfType;
    var stringType = ZodString.create;
    exports2.string = stringType;
    var numberType = ZodNumber.create;
    exports2.number = numberType;
    var nanType = ZodNaN.create;
    exports2.nan = nanType;
    var bigIntType = ZodBigInt.create;
    exports2.bigint = bigIntType;
    var booleanType = ZodBoolean.create;
    exports2.boolean = booleanType;
    var dateType = ZodDate.create;
    exports2.date = dateType;
    var symbolType = ZodSymbol.create;
    exports2.symbol = symbolType;
    var undefinedType = ZodUndefined.create;
    exports2.undefined = undefinedType;
    var nullType = ZodNull.create;
    exports2.null = nullType;
    var anyType = ZodAny.create;
    exports2.any = anyType;
    var unknownType = ZodUnknown.create;
    exports2.unknown = unknownType;
    var neverType = ZodNever.create;
    exports2.never = neverType;
    var voidType = ZodVoid.create;
    exports2.void = voidType;
    var arrayType = ZodArray.create;
    exports2.array = arrayType;
    var objectType = ZodObject.create;
    exports2.object = objectType;
    var strictObjectType = ZodObject.strictCreate;
    exports2.strictObject = strictObjectType;
    var unionType = ZodUnion.create;
    exports2.union = unionType;
    var discriminatedUnionType = ZodDiscriminatedUnion.create;
    exports2.discriminatedUnion = discriminatedUnionType;
    var intersectionType = ZodIntersection.create;
    exports2.intersection = intersectionType;
    var tupleType = ZodTuple.create;
    exports2.tuple = tupleType;
    var recordType = ZodRecord.create;
    exports2.record = recordType;
    var mapType = ZodMap.create;
    exports2.map = mapType;
    var setType = ZodSet.create;
    exports2.set = setType;
    var functionType = ZodFunction.create;
    exports2.function = functionType;
    var lazyType = ZodLazy.create;
    exports2.lazy = lazyType;
    var literalType = ZodLiteral.create;
    exports2.literal = literalType;
    var enumType = ZodEnum.create;
    exports2.enum = enumType;
    var nativeEnumType = ZodNativeEnum.create;
    exports2.nativeEnum = nativeEnumType;
    var promiseType = ZodPromise.create;
    exports2.promise = promiseType;
    var effectsType = ZodEffects.create;
    exports2.effect = effectsType;
    exports2.transformer = effectsType;
    var optionalType = ZodOptional.create;
    exports2.optional = optionalType;
    var nullableType = ZodNullable.create;
    exports2.nullable = nullableType;
    var preprocessType = ZodEffects.createWithPreprocess;
    exports2.preprocess = preprocessType;
    var pipelineType = ZodPipeline.create;
    exports2.pipeline = pipelineType;
    var ostring = () => stringType().optional();
    exports2.ostring = ostring;
    var onumber = () => numberType().optional();
    exports2.onumber = onumber;
    var oboolean = () => booleanType().optional();
    exports2.oboolean = oboolean;
    exports2.coerce = {
      string: ((arg) => ZodString.create({ ...arg, coerce: true })),
      number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
      boolean: ((arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      })),
      bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
      date: ((arg) => ZodDate.create({ ...arg, coerce: true }))
    };
    exports2.NEVER = parseUtil_js_1.INVALID;
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/external.cjs
var require_external4 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/external.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_errors8(), exports2);
    __exportStar(require_parseUtil2(), exports2);
    __exportStar(require_typeAliases2(), exports2);
    __exportStar(require_util4(), exports2);
    __exportStar(require_types8(), exports2);
    __exportStar(require_ZodError2(), exports2);
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/index.cjs
var require_v32 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/index.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.z = void 0;
    var z = __importStar(require_external4());
    exports2.z = z;
    __exportStar(require_external4(), exports2);
    exports2.default = z;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/graph/messages_annotation.cjs
var require_messages_annotation = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/graph/messages_annotation.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime3();
    var require_annotation2 = require_annotation();
    var require_meta2 = require_meta();
    var require_message3 = require_message2();
    var zod_v3 = require_rolldown_runtime5.__toESM(require_v32());
    var MessagesAnnotation = require_annotation2.Annotation.Root({ messages: require_annotation2.Annotation({
      reducer: require_message3.messagesStateReducer,
      default: () => []
    }) });
    var MessagesZodMeta = {
      reducer: { fn: require_message3.messagesStateReducer },
      jsonSchemaExtra: { langgraph_type: "messages" },
      default: () => []
    };
    var MessagesZodState = zod_v3.z.object({ messages: require_meta2.withLangGraph(zod_v3.z.custom(), MessagesZodMeta) });
    exports2.MessagesAnnotation = MessagesAnnotation;
    exports2.MessagesZodMeta = MessagesZodMeta;
    exports2.MessagesZodState = MessagesZodState;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/graph/index.cjs
var require_graph3 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/graph/index.cjs"() {
    var require_annotation2 = require_annotation();
    var require_constants5 = require_constants4();
    var require_graph4 = require_graph2();
    var require_state2 = require_state();
    var require_message3 = require_message2();
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/channels/any_value.cjs
var require_any_value = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/channels/any_value.cjs"(exports2) {
    var require_errors10 = require_errors5();
    var require_base18 = require_base17();
    var AnyValue = class AnyValue2 extends require_base18.BaseChannel {
      lc_graph_name = "AnyValue";
      value = [];
      constructor() {
        super();
      }
      fromCheckpoint(checkpoint) {
        const empty = new AnyValue2();
        if (typeof checkpoint !== "undefined") empty.value = [checkpoint];
        return empty;
      }
      update(values) {
        if (values.length === 0) {
          const updated = this.value.length > 0;
          this.value = [];
          return updated;
        }
        this.value = [values[values.length - 1]];
        return false;
      }
      get() {
        if (this.value.length === 0) throw new require_errors10.EmptyChannelError();
        return this.value[0];
      }
      checkpoint() {
        if (this.value.length === 0) throw new require_errors10.EmptyChannelError();
        return this.value[0];
      }
      isAvailable() {
        return this.value.length !== 0;
      }
    };
    exports2.AnyValue = AnyValue;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/channels/dynamic_barrier_value.cjs
var require_dynamic_barrier_value = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/channels/dynamic_barrier_value.cjs"(exports2) {
    var require_errors10 = require_errors5();
    var require_base18 = require_base17();
    var require_named_barrier_value2 = require_named_barrier_value();
    function isWaitForNames(v) {
      return v.__names !== void 0;
    }
    var DynamicBarrierValue = class DynamicBarrierValue2 extends require_base18.BaseChannel {
      lc_graph_name = "DynamicBarrierValue";
      names;
      seen;
      constructor() {
        super();
        this.names = void 0;
        this.seen = /* @__PURE__ */ new Set();
      }
      fromCheckpoint(checkpoint) {
        const empty = new DynamicBarrierValue2();
        if (typeof checkpoint !== "undefined") {
          empty.names = new Set(checkpoint[0]);
          empty.seen = new Set(checkpoint[1]);
        }
        return empty;
      }
      update(values) {
        const waitForNames = values.filter(isWaitForNames);
        if (waitForNames.length > 0) {
          if (waitForNames.length > 1) throw new require_errors10.InvalidUpdateError("Received multiple WaitForNames updates in the same step.");
          this.names = new Set(waitForNames[0].__names);
          return true;
        } else if (this.names !== void 0) {
          let updated = false;
          for (const value of values) {
            if (isWaitForNames(value)) throw new Error("Assertion Error: Received unexpected WaitForNames instance.");
            if (this.names.has(value) && !this.seen.has(value)) {
              this.seen.add(value);
              updated = true;
            }
          }
          return updated;
        }
        return false;
      }
      consume() {
        if (this.seen && this.names && require_named_barrier_value2.areSetsEqual(this.seen, this.names)) {
          this.seen = /* @__PURE__ */ new Set();
          this.names = void 0;
          return true;
        }
        return false;
      }
      get() {
        if (!this.names || !require_named_barrier_value2.areSetsEqual(this.names, this.seen)) throw new require_errors10.EmptyChannelError();
        return void 0;
      }
      checkpoint() {
        return [this.names ? [...this.names] : void 0, [...this.seen]];
      }
      isAvailable() {
        return !!this.names && require_named_barrier_value2.areSetsEqual(this.names, this.seen);
      }
    };
    exports2.DynamicBarrierValue = DynamicBarrierValue;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/channels/index.cjs
var require_channels = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/channels/index.cjs"(exports2) {
    var require_base18 = require_base17();
    var require_binop2 = require_binop();
    var require_last_value2 = require_last_value();
    var require_topic2 = require_topic();
    var require_ephemeral_value2 = require_ephemeral_value();
    var require_named_barrier_value2 = require_named_barrier_value();
    var require_any_value2 = require_any_value();
    var require_dynamic_barrier_value2 = require_dynamic_barrier_value();
    exports2.AnyValue = require_any_value2.AnyValue;
    exports2.BaseChannel = require_base18.BaseChannel;
    exports2.BinaryOperatorAggregate = require_binop2.BinaryOperatorAggregate;
    exports2.DynamicBarrierValue = require_dynamic_barrier_value2.DynamicBarrierValue;
    exports2.EphemeralValue = require_ephemeral_value2.EphemeralValue;
    exports2.LastValue = require_last_value2.LastValue;
    exports2.LastValueAfterFinish = require_last_value2.LastValueAfterFinish;
    exports2.NamedBarrierValue = require_named_barrier_value2.NamedBarrierValue;
    exports2.NamedBarrierValueAfterFinish = require_named_barrier_value2.NamedBarrierValueAfterFinish;
    exports2.Topic = require_topic2.Topic;
    exports2.createCheckpoint = require_base18.createCheckpoint;
    exports2.empty = require_base18.emptyChannels;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/web.cjs
var require_web = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/web.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime3();
    var require_errors10 = require_errors5();
    var require_base18 = require_base17();
    var require_binop2 = require_binop();
    var require_annotation2 = require_annotation();
    var require_constants5 = require_constants4();
    var require_graph4 = require_graph2();
    var require_state2 = require_state();
    var require_message3 = require_message2();
    require_graph3();
    require_channels();
    var require_index$1 = require_func();
    var require_messages_annotation2 = require_messages_annotation();
    var __langchain_langgraph_checkpoint = require_rolldown_runtime5.__toESM(require_dist4());
    exports2.Annotation = require_annotation2.Annotation;
    Object.defineProperty(exports2, "AsyncBatchedStore", {
      enumerable: true,
      get: function() {
        return __langchain_langgraph_checkpoint.AsyncBatchedStore;
      }
    });
    exports2.BaseChannel = require_base18.BaseChannel;
    Object.defineProperty(exports2, "BaseCheckpointSaver", {
      enumerable: true,
      get: function() {
        return __langchain_langgraph_checkpoint.BaseCheckpointSaver;
      }
    });
    exports2.BaseLangGraphError = require_errors10.BaseLangGraphError;
    Object.defineProperty(exports2, "BaseStore", {
      enumerable: true,
      get: function() {
        return __langchain_langgraph_checkpoint.BaseStore;
      }
    });
    exports2.BinaryOperatorAggregate = require_binop2.BinaryOperatorAggregate;
    exports2.Command = require_constants5.Command;
    exports2.CompiledStateGraph = require_state2.CompiledStateGraph;
    exports2.END = require_constants5.END;
    exports2.EmptyChannelError = require_errors10.EmptyChannelError;
    exports2.EmptyInputError = require_errors10.EmptyInputError;
    exports2.Graph = require_graph4.Graph;
    exports2.GraphBubbleUp = require_errors10.GraphBubbleUp;
    exports2.GraphInterrupt = require_errors10.GraphInterrupt;
    exports2.GraphRecursionError = require_errors10.GraphRecursionError;
    exports2.GraphValueError = require_errors10.GraphValueError;
    exports2.INTERRUPT = require_constants5.INTERRUPT;
    Object.defineProperty(exports2, "InMemoryStore", {
      enumerable: true,
      get: function() {
        return __langchain_langgraph_checkpoint.InMemoryStore;
      }
    });
    exports2.InvalidUpdateError = require_errors10.InvalidUpdateError;
    Object.defineProperty(exports2, "MemorySaver", {
      enumerable: true,
      get: function() {
        return __langchain_langgraph_checkpoint.MemorySaver;
      }
    });
    exports2.MessageGraph = require_message3.MessageGraph;
    exports2.MessagesAnnotation = require_messages_annotation2.MessagesAnnotation;
    exports2.MessagesZodMeta = require_messages_annotation2.MessagesZodMeta;
    exports2.MessagesZodState = require_messages_annotation2.MessagesZodState;
    exports2.MultipleSubgraphsError = require_errors10.MultipleSubgraphsError;
    exports2.NodeInterrupt = require_errors10.NodeInterrupt;
    exports2.ParentCommand = require_errors10.ParentCommand;
    exports2.REMOVE_ALL_MESSAGES = require_message3.REMOVE_ALL_MESSAGES;
    exports2.RemoteException = require_errors10.RemoteException;
    exports2.START = require_constants5.START;
    exports2.Send = require_constants5.Send;
    exports2.StateGraph = require_state2.StateGraph;
    exports2.UnreachableNodeError = require_errors10.UnreachableNodeError;
    exports2.addMessages = require_message3.messagesStateReducer;
    Object.defineProperty(exports2, "copyCheckpoint", {
      enumerable: true,
      get: function() {
        return __langchain_langgraph_checkpoint.copyCheckpoint;
      }
    });
    Object.defineProperty(exports2, "emptyCheckpoint", {
      enumerable: true,
      get: function() {
        return __langchain_langgraph_checkpoint.emptyCheckpoint;
      }
    });
    exports2.entrypoint = require_index$1.entrypoint;
    exports2.getSubgraphsSeenSet = require_errors10.getSubgraphsSeenSet;
    exports2.isCommand = require_constants5.isCommand;
    exports2.isGraphBubbleUp = require_errors10.isGraphBubbleUp;
    exports2.isGraphInterrupt = require_errors10.isGraphInterrupt;
    exports2.isInterrupted = require_constants5.isInterrupted;
    exports2.isParentCommand = require_errors10.isParentCommand;
    exports2.messagesStateReducer = require_message3.messagesStateReducer;
    exports2.task = require_index$1.task;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/writer.cjs
var require_writer = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/writer.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime3();
    var __langchain_core_singletons = require_rolldown_runtime5.__toESM(require_singletons());
    function writer(chunk) {
      const config = __langchain_core_singletons.AsyncLocalStorageProviderSingleton.getRunnableConfig();
      if (!config) throw new Error("Called interrupt() outside the context of a graph.");
      const conf = config.configurable;
      if (!conf) throw new Error("No configurable found in config");
      return conf.writer?.(chunk);
    }
    exports2.writer = writer;
  }
});

// node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/index.cjs
var require_dist5 = __commonJS({
  "node_modules/.pnpm/@langchain+langgraph@1.0.1__6de110badde811f961cdcbe43691af61/node_modules/@langchain/langgraph/dist/index.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime3();
    var require_async_local_storage3 = require_async_local_storage2();
    var require_errors10 = require_errors5();
    var require_base18 = require_base17();
    var require_binop2 = require_binop();
    var require_annotation2 = require_annotation();
    var require_constants5 = require_constants4();
    var require_config3 = require_config2();
    var require_interrupt2 = require_interrupt();
    var require_graph4 = require_graph2();
    var require_state2 = require_state();
    var require_message3 = require_message2();
    var require_index = require_func();
    var require_messages_annotation2 = require_messages_annotation();
    require_web();
    var require_writer2 = require_writer();
    var __langchain_langgraph_checkpoint = require_rolldown_runtime5.__toESM(require_dist4());
    require_async_local_storage3.initializeAsyncLocalStorageSingleton();
    exports2.Annotation = require_annotation2.Annotation;
    Object.defineProperty(exports2, "AsyncBatchedStore", {
      enumerable: true,
      get: function() {
        return __langchain_langgraph_checkpoint.AsyncBatchedStore;
      }
    });
    exports2.BaseChannel = require_base18.BaseChannel;
    Object.defineProperty(exports2, "BaseCheckpointSaver", {
      enumerable: true,
      get: function() {
        return __langchain_langgraph_checkpoint.BaseCheckpointSaver;
      }
    });
    exports2.BaseLangGraphError = require_errors10.BaseLangGraphError;
    Object.defineProperty(exports2, "BaseStore", {
      enumerable: true,
      get: function() {
        return __langchain_langgraph_checkpoint.BaseStore;
      }
    });
    exports2.BinaryOperatorAggregate = require_binop2.BinaryOperatorAggregate;
    exports2.Command = require_constants5.Command;
    exports2.CompiledStateGraph = require_state2.CompiledStateGraph;
    exports2.END = require_constants5.END;
    exports2.EmptyChannelError = require_errors10.EmptyChannelError;
    exports2.EmptyInputError = require_errors10.EmptyInputError;
    exports2.Graph = require_graph4.Graph;
    exports2.GraphBubbleUp = require_errors10.GraphBubbleUp;
    exports2.GraphInterrupt = require_errors10.GraphInterrupt;
    exports2.GraphRecursionError = require_errors10.GraphRecursionError;
    exports2.GraphValueError = require_errors10.GraphValueError;
    exports2.INTERRUPT = require_constants5.INTERRUPT;
    Object.defineProperty(exports2, "InMemoryStore", {
      enumerable: true,
      get: function() {
        return __langchain_langgraph_checkpoint.InMemoryStore;
      }
    });
    exports2.InvalidUpdateError = require_errors10.InvalidUpdateError;
    Object.defineProperty(exports2, "MemorySaver", {
      enumerable: true,
      get: function() {
        return __langchain_langgraph_checkpoint.MemorySaver;
      }
    });
    exports2.MessageGraph = require_message3.MessageGraph;
    exports2.MessagesAnnotation = require_messages_annotation2.MessagesAnnotation;
    exports2.MessagesZodMeta = require_messages_annotation2.MessagesZodMeta;
    exports2.MessagesZodState = require_messages_annotation2.MessagesZodState;
    exports2.MultipleSubgraphsError = require_errors10.MultipleSubgraphsError;
    exports2.NodeInterrupt = require_errors10.NodeInterrupt;
    exports2.ParentCommand = require_errors10.ParentCommand;
    exports2.REMOVE_ALL_MESSAGES = require_message3.REMOVE_ALL_MESSAGES;
    exports2.RemoteException = require_errors10.RemoteException;
    exports2.START = require_constants5.START;
    exports2.Send = require_constants5.Send;
    exports2.StateGraph = require_state2.StateGraph;
    exports2.UnreachableNodeError = require_errors10.UnreachableNodeError;
    exports2.addMessages = require_message3.messagesStateReducer;
    Object.defineProperty(exports2, "copyCheckpoint", {
      enumerable: true,
      get: function() {
        return __langchain_langgraph_checkpoint.copyCheckpoint;
      }
    });
    Object.defineProperty(exports2, "emptyCheckpoint", {
      enumerable: true,
      get: function() {
        return __langchain_langgraph_checkpoint.emptyCheckpoint;
      }
    });
    exports2.entrypoint = require_index.entrypoint;
    exports2.getConfig = require_config3.getConfig;
    exports2.getCurrentTaskInput = require_config3.getCurrentTaskInput;
    exports2.getPreviousState = require_index.getPreviousState;
    exports2.getStore = require_config3.getStore;
    exports2.getSubgraphsSeenSet = require_errors10.getSubgraphsSeenSet;
    exports2.getWriter = require_config3.getWriter;
    exports2.interrupt = require_interrupt2.interrupt;
    exports2.isCommand = require_constants5.isCommand;
    exports2.isGraphBubbleUp = require_errors10.isGraphBubbleUp;
    exports2.isGraphInterrupt = require_errors10.isGraphInterrupt;
    exports2.isInterrupted = require_constants5.isInterrupted;
    exports2.isParentCommand = require_errors10.isParentCommand;
    exports2.messagesStateReducer = require_message3.messagesStateReducer;
    exports2.pushMessage = require_message3.pushMessage;
    exports2.task = require_index.task;
    exports2.writer = require_writer2.writer;
  }
});

// node_modules/.pnpm/@langchain+mcp-adapters@1.0_422fcda27cc657832245d1643c939873/node_modules/@langchain/mcp-adapters/dist/tools.cjs
var require_tools4 = __commonJS({
  "node_modules/.pnpm/@langchain+mcp-adapters@1.0_422fcda27cc657832245d1643c939873/node_modules/@langchain/mcp-adapters/dist/tools.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime();
    var require_types10 = require_types2();
    var require_logging2 = require_logging();
    var zod_v3 = require_rolldown_runtime5.__toESM(require_v3());
    var zod_v4 = require_rolldown_runtime5.__toESM(require_v4());
    var __langchain_core_tools = require_rolldown_runtime5.__toESM(require_tools());
    var __langchain_core_messages = require_rolldown_runtime5.__toESM(require_messages2());
    var __langchain_langgraph = require_rolldown_runtime5.__toESM(require_dist5());
    var debugLog = require_logging2.getDebugLog("tools");
    var ToolException = class extends Error {
      constructor(message, cause) {
        super(message);
        this.name = "ToolException";
        if (cause && (cause instanceof zod_v4.ZodError || cause instanceof zod_v3.ZodError)) {
          const minifiedZodError = new Error(zod_v4.z.prettifyError(cause));
          const stackByLine = cause.stack?.split("\n") || [];
          minifiedZodError.stack = cause.stack?.split("\n").slice(stackByLine.findIndex((l) => l.includes("    at"))).join("\n");
          this.cause = minifiedZodError;
        } else if (cause) this.cause = cause;
      }
    };
    function isToolException(error) {
      return typeof error === "object" && error !== null && "name" in error && error.name === "ToolException";
    }
    function isResourceReference(resource) {
      return typeof resource === "object" && resource !== null && resource.uri != null && resource.blob == null && resource.text == null;
    }
    async function* _embeddedResourceToStandardFileBlocks(resource, client) {
      if (isResourceReference(resource)) {
        const response = await client.readResource({ uri: resource.uri });
        for (const content of response.contents) yield* _embeddedResourceToStandardFileBlocks(content, client);
        return;
      }
      if (resource.blob != null) yield {
        type: "file",
        source_type: "base64",
        data: resource.blob,
        mime_type: resource.mimeType,
        ...resource.uri != null ? { metadata: { uri: resource.uri } } : {}
      };
      if (resource.text != null) yield {
        type: "file",
        source_type: "text",
        mime_type: resource.mimeType,
        text: resource.text,
        ...resource.uri != null ? { metadata: { uri: resource.uri } } : {}
      };
    }
    async function _toolOutputToContentBlocks(content, useStandardContentBlocks, client, toolName, serverName) {
      const blocks = [];
      switch (content.type) {
        case "text":
          return [{
            type: "text",
            ...useStandardContentBlocks ? { source_type: "text" } : {},
            text: content.text
          }];
        case "image":
          if (useStandardContentBlocks) return [{
            type: "image",
            source_type: "base64",
            data: content.data,
            mime_type: content.mimeType
          }];
          return [{
            type: "image_url",
            image_url: { url: `data:${content.mimeType};base64,${content.data}` }
          }];
        case "audio":
          return [{
            type: "audio",
            source_type: "base64",
            data: content.data,
            mime_type: content.mimeType
          }];
        case "resource":
          for await (const block of _embeddedResourceToStandardFileBlocks(content.resource, client)) blocks.push(block);
          return blocks;
        default:
          throw new ToolException(`MCP tool '${toolName}' on server '${serverName}' returned a content block with unexpected type "${content.type}." Expected one of "text", "image", or "audio".`);
      }
    }
    async function _embeddedResourceToArtifact(resource, useStandardContentBlocks, client, toolName, serverName) {
      if (useStandardContentBlocks) return _toolOutputToContentBlocks(resource, useStandardContentBlocks, client, toolName, serverName);
      if (!resource.blob && !resource.text && resource.uri) {
        const response = await client.readResource({ uri: resource.resource.uri });
        return response.contents.map((content) => ({
          type: "resource",
          resource: { ...content }
        }));
      }
      return [resource];
    }
    function _getOutputTypeForContentType(contentType, outputHandling) {
      if (outputHandling === "content" || outputHandling === "artifact") return outputHandling;
      const resolved = require_types10._resolveDetailedOutputHandling(outputHandling);
      return resolved[contentType] ?? (contentType === "resource" ? "artifact" : "content");
    }
    async function _convertCallToolResult({ serverName, toolName, result, client, useStandardContentBlocks, outputHandling }) {
      if (!result) throw new ToolException(`MCP tool '${toolName}' on server '${serverName}' returned an invalid result - tool call response was undefined`);
      if (!Array.isArray(result.content)) throw new ToolException(`MCP tool '${toolName}' on server '${serverName}' returned an invalid result - expected an array of content, but was ${typeof result.content}`);
      if (result.isError) throw new ToolException(`MCP tool '${toolName}' on server '${serverName}' returned an error: ${result.content.map((content) => content.text).join("\n")}`);
      const convertedContent = (await Promise.all(result.content.filter((content) => _getOutputTypeForContentType(content.type, outputHandling) === "content").map((content) => _toolOutputToContentBlocks(content, useStandardContentBlocks, client, toolName, serverName)))).flat();
      const artifacts = (await Promise.all(result.content.filter((content) => _getOutputTypeForContentType(content.type, outputHandling) === "artifact").map((content) => {
        return _embeddedResourceToArtifact(content, useStandardContentBlocks, client, toolName, serverName);
      }))).flat();
      if (convertedContent.length === 1 && convertedContent[0].type === "text") return [convertedContent[0].text, artifacts];
      return [convertedContent, artifacts];
    }
    async function _callTool({ serverName, toolName, client, args, config, useStandardContentBlocks, outputHandling, onProgress, beforeToolCall, afterToolCall }) {
      try {
        debugLog(`INFO: Calling tool ${toolName}(${JSON.stringify(args)})`);
        const requestOptions = {
          ...config?.timeout ? { timeout: config.timeout } : {},
          ...config?.signal ? { signal: config.signal } : {},
          ...onProgress ? { onprogress: (progress) => {
            onProgress?.(progress, {
              type: "tool",
              name: toolName,
              args,
              server: serverName
            });
          } } : {}
        };
        let state = {};
        try {
          state = (0, __langchain_langgraph.getCurrentTaskInput)(config);
        } catch (error) {
          debugLog(`State can't be derrived as LangGraph is not used: ${String(error)}`);
        }
        const beforeToolCallInterception = await beforeToolCall?.({
          name: toolName,
          args,
          serverName
        }, state, config ?? {});
        const finalArgs = Object.assign(args, beforeToolCallInterception?.args || {});
        const headers = beforeToolCallInterception?.headers || {};
        const hasHeaderChanges = Object.entries(headers).length > 0;
        if (hasHeaderChanges && typeof client.fork !== "function") throw new ToolException(`MCP client for server "${serverName}" does not support header changes`);
        const finalClient = hasHeaderChanges && typeof client.fork === "function" ? await client.fork(headers) : client;
        const callToolArgs = [{
          name: toolName,
          arguments: finalArgs
        }];
        if (Object.keys(requestOptions).length > 0) {
          callToolArgs.push(void 0);
          callToolArgs.push(requestOptions);
        }
        const result = await finalClient.callTool(...callToolArgs);
        const [content, artifacts] = await _convertCallToolResult({
          serverName,
          toolName,
          result,
          client: finalClient,
          useStandardContentBlocks,
          outputHandling
        });
        const interceptedResult = await afterToolCall?.({
          name: toolName,
          args: finalArgs,
          result: [content, artifacts],
          serverName
        }, state, config ?? {});
        if (!interceptedResult) return [content, artifacts];
        if (typeof interceptedResult.result === "string") return [interceptedResult.result, []];
        if (Array.isArray(interceptedResult.result)) return interceptedResult.result;
        if (__langchain_core_messages.ToolMessage.isInstance(interceptedResult.result)) return [interceptedResult.result.contentBlocks, []];
        if (interceptedResult?.result instanceof __langchain_langgraph.Command) return interceptedResult.result;
        throw new Error(`Unexpected result value type from afterToolCall: expected either a Command, a ToolMessage or a tuple of ContentBlock and Artifact, but got ${interceptedResult.result}`);
      } catch (error) {
        if (error instanceof zod_v4.ZodError || error instanceof zod_v3.ZodError) throw new ToolException(zod_v4.z.prettifyError(error), error);
        debugLog(`Error calling tool ${toolName}: ${String(error)}`);
        if (isToolException(error)) throw error;
        throw new ToolException(`Error calling tool ${toolName}: ${String(error)}`);
      }
    }
    var defaultLoadMcpToolsOptions = {
      throwOnLoadError: true,
      prefixToolNameWithServerName: false,
      additionalToolNamePrefix: "",
      useStandardContentBlocks: false
    };
    async function loadMcpTools(serverName, client, options) {
      const { throwOnLoadError, prefixToolNameWithServerName, additionalToolNamePrefix, useStandardContentBlocks, outputHandling, defaultToolTimeout } = {
        ...defaultLoadMcpToolsOptions,
        ...options ?? {}
      };
      const mcpTools = [];
      let toolsResponse;
      do {
        toolsResponse = await client.listTools({ ...toolsResponse?.nextCursor ? { cursor: toolsResponse.nextCursor } : {} });
        mcpTools.push(...toolsResponse.tools || []);
      } while (toolsResponse.nextCursor);
      debugLog(`INFO: Found ${mcpTools.length} MCP tools`);
      const initialPrefix = additionalToolNamePrefix ? `${additionalToolNamePrefix}__` : "";
      const serverPrefix = prefixToolNameWithServerName ? `${serverName}__` : "";
      const toolNamePrefix = `${initialPrefix}${serverPrefix}`;
      return (await Promise.all(mcpTools.filter((tool) => !!tool.name).map(async (tool) => {
        try {
          if (!tool.inputSchema.properties) tool.inputSchema.properties = {};
          const dst = new __langchain_core_tools.DynamicStructuredTool({
            name: `${toolNamePrefix}${tool.name}`,
            description: tool.description || "",
            schema: tool.inputSchema,
            responseFormat: "content_and_artifact",
            metadata: { annotations: tool.annotations },
            defaultConfig: defaultToolTimeout ? { timeout: defaultToolTimeout } : void 0,
            func: async (args, _runManager, config) => {
              return _callTool({
                serverName,
                toolName: tool.name,
                client,
                args,
                config,
                useStandardContentBlocks,
                outputHandling,
                onProgress: options?.onProgress,
                beforeToolCall: options?.beforeToolCall,
                afterToolCall: options?.afterToolCall
              });
            }
          });
          debugLog(`INFO: Successfully loaded tool: ${dst.name}`);
          return dst;
        } catch (error) {
          debugLog(`ERROR: Failed to load tool "${tool.name}":`, error);
          if (throwOnLoadError) throw error;
          return null;
        }
      }))).filter(Boolean);
    }
    exports2.loadMcpTools = loadMcpTools;
  }
});

// node_modules/.pnpm/@langchain+mcp-adapters@1.0_422fcda27cc657832245d1643c939873/node_modules/@langchain/mcp-adapters/dist/package.cjs
var require_package = __commonJS({
  "node_modules/.pnpm/@langchain+mcp-adapters@1.0_422fcda27cc657832245d1643c939873/node_modules/@langchain/mcp-adapters/dist/package.cjs"(exports2) {
    var name = "@langchain/mcp-adapters";
    var version2 = "0.6.0";
    var description = "LangChain.js adapters for Model Context Protocol (MCP)";
    var author = "LangChain";
    var license = "MIT";
    var type = "module";
    var packageManager = "pnpm@10.14.0";
    var repository = {
      "type": "git",
      "url": "git@github.com:langchain-ai/langchainjs.git"
    };
    var homepage = "https://github.com/langchain-ai/langchainjs/tree/main/libs/langchain-mcp-adapters/";
    var bugs = { "url": "https://github.com/langchain-ai/langchainjs/issues" };
    var scripts = {
      "build": "run-s build:main build:examples",
      "build:main": "pnpm --filter @langchain/build compile @langchain/mcp-adapters",
      "build:examples": "tsc -p ./examples/tsconfig.json",
      "clean": "rm -rf dist/ dist-cjs/ .turbo/",
      "format": 'prettier --config .prettierrc --write "src/**/*.ts" "examples/**/*.ts"',
      "format:check": 'prettier --config .prettierrc --check "src" "examples/**/*.ts"',
      "lint": "run-s lint:eslint lint:dpdm",
      "lint:dpdm": "dpdm --skip-dynamic-imports circular --exit-code circular:1 --no-warning --no-tree src/**/*.ts examples/**/*.ts",
      "lint:eslint": "eslint --cache src/ examples/",
      "lint:fix": "pnpm lint:eslint --fix && pnpm lint:dpdm",
      "test": "vitest run",
      "test:coverage": "vitest run --coverage",
      "test:watch": "vitest"
    };
    var keywords = [
      "langchain",
      "mcp",
      "model-context-protocol",
      "ai",
      "tools"
    ];
    var dependencies = {
      "@modelcontextprotocol/sdk": "^1.18.2",
      "debug": "^4.4.3",
      "zod": "^3.25.76 || ^4"
    };
    var peerDependencies = {
      "@langchain/core": "^1.0.0",
      "@langchain/langgraph": "^1.0.0"
    };
    var peerDependenciesMeta = {
      "@langchain/core": { "optional": false },
      "@langchain/langgraph": { "optional": false }
    };
    var optionalDependencies = { "extended-eventsource": "^1.7.0" };
    var devDependencies = {
      "@eslint/js": "^9.36.0",
      "@langchain/core": "workspace:*",
      "@langchain/eslint": "workspace:*",
      "@langchain/langgraph": "^1.0.0",
      "@langchain/openai": "workspace:*",
      "@tsconfig/recommended": "^1.0.10",
      "@types/debug": "^4.1.12",
      "@types/express": "^5.0.3",
      "@types/node": "^22.18.8",
      "@vitest/coverage-v8": "^3.2.4",
      "dotenv": "^16.6.1",
      "dpdm": "^3.14.0",
      "eslint": "^9.36.0",
      "eventsource": "^3.0.7",
      "express": "^5.1.0",
      "langchain": "workspace:*",
      "npm-run-all2": "^8.0.4",
      "prettier": "^3.6.2",
      "rollup": "^4.52.3",
      "ts-node": "^10.9.2",
      "typescript": "~5.8.3",
      "typescript-eslint": "^8.45.0",
      "vitest": "^3.2.4"
    };
    var engines = { "node": ">=20.10.0" };
    var directories = { "example": "examples" };
    var main = "dist/index.js";
    var types = "dist/index.d.ts";
    var exports$1 = {
      ".": {
        "input": "./src/index.ts",
        "import": {
          "types": "./dist/index.d.ts",
          "default": "./dist/index.js"
        },
        "require": {
          "types": "./dist/index.d.cts",
          "default": "./dist/index.cjs"
        }
      },
      "./package.json": "./package.json"
    };
    var files = [
      "dist/",
      "CHANGELOG.md",
      "README.md",
      "LICENSE"
    ];
    var package_default = {
      name,
      version: version2,
      description,
      author,
      license,
      type,
      packageManager,
      repository,
      homepage,
      bugs,
      scripts,
      keywords,
      dependencies,
      peerDependencies,
      peerDependenciesMeta,
      optionalDependencies,
      devDependencies,
      engines,
      directories,
      main,
      types,
      exports: exports$1,
      files
    };
    Object.defineProperty(exports2, "default", {
      enumerable: true,
      get: function() {
        return package_default;
      }
    });
  }
});

// node_modules/.pnpm/eventsource-parser@3.0.6/node_modules/eventsource-parser/dist/index.cjs
var require_dist6 = __commonJS({
  "node_modules/.pnpm/eventsource-parser@3.0.6/node_modules/eventsource-parser/dist/index.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ParseError = class extends Error {
      constructor(message, options) {
        super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
      }
    };
    function noop(_arg) {
    }
    function createParser(callbacks) {
      if (typeof callbacks == "function")
        throw new TypeError(
          "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
        );
      const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
      let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
      function feed(newChunk) {
        const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
        for (const line of complete)
          parseLine(line);
        incompleteLine = incomplete, isFirstChunk = false;
      }
      function parseLine(line) {
        if (line === "") {
          dispatchEvent();
          return;
        }
        if (line.startsWith(":")) {
          onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
          return;
        }
        const fieldSeparatorIndex = line.indexOf(":");
        if (fieldSeparatorIndex !== -1) {
          const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
          processField(field, value, line);
          return;
        }
        processField(line, "", line);
      }
      function processField(field, value, line) {
        switch (field) {
          case "event":
            eventType = value;
            break;
          case "data":
            data = `${data}${value}
`;
            break;
          case "id":
            id = value.includes("\0") ? void 0 : value;
            break;
          case "retry":
            /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
              new ParseError(`Invalid \`retry\` value: "${value}"`, {
                type: "invalid-retry",
                value,
                line
              })
            );
            break;
          default:
            onError(
              new ParseError(
                `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
                { type: "unknown-field", field, value, line }
              )
            );
            break;
        }
      }
      function dispatchEvent() {
        data.length > 0 && onEvent({
          id,
          event: eventType || void 0,
          // If the data buffer's last character is a U+000A LINE FEED (LF) character,
          // then remove the last character from the data buffer.
          data: data.endsWith(`
`) ? data.slice(0, -1) : data
        }), id = void 0, data = "", eventType = "";
      }
      function reset(options = {}) {
        incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
      }
      return { feed, reset };
    }
    function splitLines(chunk) {
      const lines = [];
      let incompleteLine = "", searchIndex = 0;
      for (; searchIndex < chunk.length; ) {
        const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
        let lineEnd = -1;
        if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
          incompleteLine = chunk.slice(searchIndex);
          break;
        } else {
          const line = chunk.slice(searchIndex, lineEnd);
          lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
        }
      }
      return [lines, incompleteLine];
    }
    exports2.ParseError = ParseError;
    exports2.createParser = createParser;
  }
});

// node_modules/.pnpm/eventsource@3.0.7/node_modules/eventsource/dist/index.cjs
var require_dist7 = __commonJS({
  "node_modules/.pnpm/eventsource@3.0.7/node_modules/eventsource/dist/index.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var eventsourceParser = require_dist6();
    var ErrorEvent = class extends Event {
      /**
       * Constructs a new `ErrorEvent` instance. This is typically not called directly,
       * but rather emitted by the `EventSource` object when an error occurs.
       *
       * @param type - The type of the event (should be "error")
       * @param errorEventInitDict - Optional properties to include in the error event
       */
      constructor(type, errorEventInitDict) {
        var _a, _b;
        super(type), this.code = (_a = errorEventInitDict == null ? void 0 : errorEventInitDict.code) != null ? _a : void 0, this.message = (_b = errorEventInitDict == null ? void 0 : errorEventInitDict.message) != null ? _b : void 0;
      }
      /**
       * Node.js "hides" the `message` and `code` properties of the `ErrorEvent` instance,
       * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
       * we explicitly include the properties in the `inspect` method.
       *
       * This is automatically called by Node.js when you `console.log` an instance of this class.
       *
       * @param _depth - The current depth
       * @param options - The options passed to `util.inspect`
       * @param inspect - The inspect function to use (prevents having to import it from `util`)
       * @returns A string representation of the error
       */
      [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        return inspect(inspectableError(this), options);
      }
      /**
       * Deno "hides" the `message` and `code` properties of the `ErrorEvent` instance,
       * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
       * we explicitly include the properties in the `inspect` method.
       *
       * This is automatically called by Deno when you `console.log` an instance of this class.
       *
       * @param inspect - The inspect function to use (prevents having to import it from `util`)
       * @param options - The options passed to `Deno.inspect`
       * @returns A string representation of the error
       */
      [Symbol.for("Deno.customInspect")](inspect, options) {
        return inspect(inspectableError(this), options);
      }
    };
    function syntaxError(message) {
      const DomException = globalThis.DOMException;
      return typeof DomException == "function" ? new DomException(message, "SyntaxError") : new SyntaxError(message);
    }
    function flattenError(err) {
      return err instanceof Error ? "errors" in err && Array.isArray(err.errors) ? err.errors.map(flattenError).join(", ") : "cause" in err && err.cause instanceof Error ? `${err}: ${flattenError(err.cause)}` : err.message : `${err}`;
    }
    function inspectableError(err) {
      return {
        type: err.type,
        message: err.message,
        code: err.code,
        defaultPrevented: err.defaultPrevented,
        cancelable: err.cancelable,
        timeStamp: err.timeStamp
      };
    }
    var __typeError = (msg) => {
      throw TypeError(msg);
    };
    var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
    var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
    var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
    var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value), value);
    var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
    var _readyState;
    var _url;
    var _redirectUrl;
    var _withCredentials;
    var _fetch;
    var _reconnectInterval;
    var _reconnectTimer;
    var _lastEventId;
    var _controller;
    var _parser;
    var _onError;
    var _onMessage;
    var _onOpen;
    var _EventSource_instances;
    var connect_fn;
    var _onFetchResponse;
    var _onFetchError;
    var getRequestOptions_fn;
    var _onEvent;
    var _onRetryChange;
    var failConnection_fn;
    var scheduleReconnect_fn;
    var _reconnect;
    var EventSource = class extends EventTarget {
      constructor(url, eventSourceInitDict) {
        var _a, _b;
        super(), __privateAdd(this, _EventSource_instances), this.CONNECTING = 0, this.OPEN = 1, this.CLOSED = 2, __privateAdd(this, _readyState), __privateAdd(this, _url), __privateAdd(this, _redirectUrl), __privateAdd(this, _withCredentials), __privateAdd(this, _fetch), __privateAdd(this, _reconnectInterval), __privateAdd(this, _reconnectTimer), __privateAdd(this, _lastEventId, null), __privateAdd(this, _controller), __privateAdd(this, _parser), __privateAdd(this, _onError, null), __privateAdd(this, _onMessage, null), __privateAdd(this, _onOpen, null), __privateAdd(this, _onFetchResponse, async (response) => {
          var _a2;
          __privateGet(this, _parser).reset();
          const { body, redirected, status, headers } = response;
          if (status === 204) {
            __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, "Server sent HTTP 204, not reconnecting", 204), this.close();
            return;
          }
          if (redirected ? __privateSet(this, _redirectUrl, new URL(response.url)) : __privateSet(this, _redirectUrl, void 0), status !== 200) {
            __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, `Non-200 status code (${status})`, status);
            return;
          }
          if (!(headers.get("content-type") || "").startsWith("text/event-stream")) {
            __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, 'Invalid content type, expected "text/event-stream"', status);
            return;
          }
          if (__privateGet(this, _readyState) === this.CLOSED)
            return;
          __privateSet(this, _readyState, this.OPEN);
          const openEvent = new Event("open");
          if ((_a2 = __privateGet(this, _onOpen)) == null || _a2.call(this, openEvent), this.dispatchEvent(openEvent), typeof body != "object" || !body || !("getReader" in body)) {
            __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, "Invalid response body, expected a web ReadableStream", status), this.close();
            return;
          }
          const decoder = new TextDecoder(), reader = body.getReader();
          let open = true;
          do {
            const { done, value } = await reader.read();
            value && __privateGet(this, _parser).feed(decoder.decode(value, { stream: !done })), done && (open = false, __privateGet(this, _parser).reset(), __privateMethod(this, _EventSource_instances, scheduleReconnect_fn).call(this));
          } while (open);
        }), __privateAdd(this, _onFetchError, (err) => {
          __privateSet(this, _controller, void 0), !(err.name === "AbortError" || err.type === "aborted") && __privateMethod(this, _EventSource_instances, scheduleReconnect_fn).call(this, flattenError(err));
        }), __privateAdd(this, _onEvent, (event) => {
          typeof event.id == "string" && __privateSet(this, _lastEventId, event.id);
          const messageEvent = new MessageEvent(event.event || "message", {
            data: event.data,
            origin: __privateGet(this, _redirectUrl) ? __privateGet(this, _redirectUrl).origin : __privateGet(this, _url).origin,
            lastEventId: event.id || ""
          });
          __privateGet(this, _onMessage) && (!event.event || event.event === "message") && __privateGet(this, _onMessage).call(this, messageEvent), this.dispatchEvent(messageEvent);
        }), __privateAdd(this, _onRetryChange, (value) => {
          __privateSet(this, _reconnectInterval, value);
        }), __privateAdd(this, _reconnect, () => {
          __privateSet(this, _reconnectTimer, void 0), __privateGet(this, _readyState) === this.CONNECTING && __privateMethod(this, _EventSource_instances, connect_fn).call(this);
        });
        try {
          if (url instanceof URL)
            __privateSet(this, _url, url);
          else if (typeof url == "string")
            __privateSet(this, _url, new URL(url, getBaseURL()));
          else
            throw new Error("Invalid URL");
        } catch {
          throw syntaxError("An invalid or illegal string was specified");
        }
        __privateSet(this, _parser, eventsourceParser.createParser({
          onEvent: __privateGet(this, _onEvent),
          onRetry: __privateGet(this, _onRetryChange)
        })), __privateSet(this, _readyState, this.CONNECTING), __privateSet(this, _reconnectInterval, 3e3), __privateSet(this, _fetch, (_a = eventSourceInitDict == null ? void 0 : eventSourceInitDict.fetch) != null ? _a : globalThis.fetch), __privateSet(this, _withCredentials, (_b = eventSourceInitDict == null ? void 0 : eventSourceInitDict.withCredentials) != null ? _b : false), __privateMethod(this, _EventSource_instances, connect_fn).call(this);
      }
      /**
       * Returns the state of this EventSource object's connection. It can have the values described below.
       *
       * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/readyState)
       *
       * Note: typed as `number` instead of `0 | 1 | 2` for compatibility with the `EventSource` interface,
       * defined in the TypeScript `dom` library.
       *
       * @public
       */
      get readyState() {
        return __privateGet(this, _readyState);
      }
      /**
       * Returns the URL providing the event stream.
       *
       * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/url)
       *
       * @public
       */
      get url() {
        return __privateGet(this, _url).href;
      }
      /**
       * Returns true if the credentials mode for connection requests to the URL providing the event stream is set to "include", and false otherwise.
       *
       * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/withCredentials)
       */
      get withCredentials() {
        return __privateGet(this, _withCredentials);
      }
      /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/error_event) */
      get onerror() {
        return __privateGet(this, _onError);
      }
      set onerror(value) {
        __privateSet(this, _onError, value);
      }
      /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/message_event) */
      get onmessage() {
        return __privateGet(this, _onMessage);
      }
      set onmessage(value) {
        __privateSet(this, _onMessage, value);
      }
      /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/open_event) */
      get onopen() {
        return __privateGet(this, _onOpen);
      }
      set onopen(value) {
        __privateSet(this, _onOpen, value);
      }
      addEventListener(type, listener, options) {
        const listen = listener;
        super.addEventListener(type, listen, options);
      }
      removeEventListener(type, listener, options) {
        const listen = listener;
        super.removeEventListener(type, listen, options);
      }
      /**
       * Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED.
       *
       * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/close)
       *
       * @public
       */
      close() {
        __privateGet(this, _reconnectTimer) && clearTimeout(__privateGet(this, _reconnectTimer)), __privateGet(this, _readyState) !== this.CLOSED && (__privateGet(this, _controller) && __privateGet(this, _controller).abort(), __privateSet(this, _readyState, this.CLOSED), __privateSet(this, _controller, void 0));
      }
    };
    _readyState = /* @__PURE__ */ new WeakMap(), _url = /* @__PURE__ */ new WeakMap(), _redirectUrl = /* @__PURE__ */ new WeakMap(), _withCredentials = /* @__PURE__ */ new WeakMap(), _fetch = /* @__PURE__ */ new WeakMap(), _reconnectInterval = /* @__PURE__ */ new WeakMap(), _reconnectTimer = /* @__PURE__ */ new WeakMap(), _lastEventId = /* @__PURE__ */ new WeakMap(), _controller = /* @__PURE__ */ new WeakMap(), _parser = /* @__PURE__ */ new WeakMap(), _onError = /* @__PURE__ */ new WeakMap(), _onMessage = /* @__PURE__ */ new WeakMap(), _onOpen = /* @__PURE__ */ new WeakMap(), _EventSource_instances = /* @__PURE__ */ new WeakSet(), /**
    * Connect to the given URL and start receiving events
    *
    * @internal
    */
    connect_fn = function() {
      __privateSet(this, _readyState, this.CONNECTING), __privateSet(this, _controller, new AbortController()), __privateGet(this, _fetch)(__privateGet(this, _url), __privateMethod(this, _EventSource_instances, getRequestOptions_fn).call(this)).then(__privateGet(this, _onFetchResponse)).catch(__privateGet(this, _onFetchError));
    }, _onFetchResponse = /* @__PURE__ */ new WeakMap(), _onFetchError = /* @__PURE__ */ new WeakMap(), /**
    * Get request options for the `fetch()` request
    *
    * @returns The request options
    * @internal
    */
    getRequestOptions_fn = function() {
      var _a;
      const init = {
        // [spec] Let `corsAttributeState` be `Anonymous`
        // [spec] will have their mode set to "cors"
        mode: "cors",
        redirect: "follow",
        headers: { Accept: "text/event-stream", ...__privateGet(this, _lastEventId) ? { "Last-Event-ID": __privateGet(this, _lastEventId) } : void 0 },
        cache: "no-store",
        signal: (_a = __privateGet(this, _controller)) == null ? void 0 : _a.signal
      };
      return "window" in globalThis && (init.credentials = this.withCredentials ? "include" : "same-origin"), init;
    }, _onEvent = /* @__PURE__ */ new WeakMap(), _onRetryChange = /* @__PURE__ */ new WeakMap(), /**
    * Handles the process referred to in the EventSource specification as "failing a connection".
    *
    * @param error - The error causing the connection to fail
    * @param code - The HTTP status code, if available
    * @internal
    */
    failConnection_fn = function(message, code) {
      var _a;
      __privateGet(this, _readyState) !== this.CLOSED && __privateSet(this, _readyState, this.CLOSED);
      const errorEvent = new ErrorEvent("error", { code, message });
      (_a = __privateGet(this, _onError)) == null || _a.call(this, errorEvent), this.dispatchEvent(errorEvent);
    }, /**
    * Schedules a reconnection attempt against the EventSource endpoint.
    *
    * @param message - The error causing the connection to fail
    * @param code - The HTTP status code, if available
    * @internal
    */
    scheduleReconnect_fn = function(message, code) {
      var _a;
      if (__privateGet(this, _readyState) === this.CLOSED)
        return;
      __privateSet(this, _readyState, this.CONNECTING);
      const errorEvent = new ErrorEvent("error", { code, message });
      (_a = __privateGet(this, _onError)) == null || _a.call(this, errorEvent), this.dispatchEvent(errorEvent), __privateSet(this, _reconnectTimer, setTimeout(__privateGet(this, _reconnect), __privateGet(this, _reconnectInterval)));
    }, _reconnect = /* @__PURE__ */ new WeakMap(), /**
    * ReadyState representing an EventSource currently trying to connect
    *
    * @public
    */
    EventSource.CONNECTING = 0, /**
    * ReadyState representing an EventSource connection that is open (eg connected)
    *
    * @public
    */
    EventSource.OPEN = 1, /**
    * ReadyState representing an EventSource connection that is closed (eg disconnected)
    *
    * @public
    */
    EventSource.CLOSED = 2;
    function getBaseURL() {
      const doc = "document" in globalThis ? globalThis.document : void 0;
      return doc && typeof doc == "object" && "baseURI" in doc && typeof doc.baseURI == "string" ? doc.baseURI : void 0;
    }
    exports2.ErrorEvent = ErrorEvent;
    exports2.EventSource = EventSource;
  }
});

// node_modules/.pnpm/zod@3.25.76/node_modules/zod/index.cjs
var require_zod2 = __commonJS({
  "node_modules/.pnpm/zod@3.25.76/node_modules/zod/index.cjs"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.z = void 0;
    var z = __importStar(require_external4());
    exports2.z = z;
    __exportStar(require_external4(), exports2);
    exports2.default = z;
  }
});

// node_modules/.pnpm/@modelcontextprotocol+sdk@1.20.2/node_modules/@modelcontextprotocol/sdk/dist/cjs/types.js
var require_types9 = __commonJS({
  "node_modules/.pnpm/@modelcontextprotocol+sdk@1.20.2/node_modules/@modelcontextprotocol/sdk/dist/cjs/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ResourceListChangedNotificationSchema = exports2.ReadResourceResultSchema = exports2.ReadResourceRequestSchema = exports2.ListResourceTemplatesResultSchema = exports2.ListResourceTemplatesRequestSchema = exports2.ListResourcesResultSchema = exports2.ListResourcesRequestSchema = exports2.ResourceTemplateSchema = exports2.ResourceSchema = exports2.BlobResourceContentsSchema = exports2.TextResourceContentsSchema = exports2.ResourceContentsSchema = exports2.PaginatedResultSchema = exports2.PaginatedRequestSchema = exports2.ProgressNotificationSchema = exports2.ProgressSchema = exports2.PingRequestSchema = exports2.isInitializedNotification = exports2.InitializedNotificationSchema = exports2.InitializeResultSchema = exports2.ServerCapabilitiesSchema = exports2.isInitializeRequest = exports2.InitializeRequestSchema = exports2.ClientCapabilitiesSchema = exports2.ImplementationSchema = exports2.BaseMetadataSchema = exports2.IconsSchema = exports2.IconSchema = exports2.CancelledNotificationSchema = exports2.EmptyResultSchema = exports2.JSONRPCMessageSchema = exports2.isJSONRPCError = exports2.JSONRPCErrorSchema = exports2.ErrorCode = exports2.isJSONRPCResponse = exports2.JSONRPCResponseSchema = exports2.isJSONRPCNotification = exports2.JSONRPCNotificationSchema = exports2.isJSONRPCRequest = exports2.JSONRPCRequestSchema = exports2.RequestIdSchema = exports2.ResultSchema = exports2.NotificationSchema = exports2.RequestSchema = exports2.CursorSchema = exports2.ProgressTokenSchema = exports2.JSONRPC_VERSION = exports2.SUPPORTED_PROTOCOL_VERSIONS = exports2.DEFAULT_NEGOTIATED_PROTOCOL_VERSION = exports2.LATEST_PROTOCOL_VERSION = void 0;
    exports2.ClientRequestSchema = exports2.RootsListChangedNotificationSchema = exports2.ListRootsResultSchema = exports2.ListRootsRequestSchema = exports2.RootSchema = exports2.CompleteResultSchema = exports2.CompleteRequestSchema = exports2.PromptReferenceSchema = exports2.ResourceReferenceSchema = exports2.ResourceTemplateReferenceSchema = exports2.ElicitResultSchema = exports2.ElicitRequestSchema = exports2.PrimitiveSchemaDefinitionSchema = exports2.EnumSchemaSchema = exports2.NumberSchemaSchema = exports2.StringSchemaSchema = exports2.BooleanSchemaSchema = exports2.CreateMessageResultSchema = exports2.CreateMessageRequestSchema = exports2.SamplingMessageSchema = exports2.ModelPreferencesSchema = exports2.ModelHintSchema = exports2.LoggingMessageNotificationSchema = exports2.SetLevelRequestSchema = exports2.LoggingLevelSchema = exports2.ToolListChangedNotificationSchema = exports2.CallToolRequestSchema = exports2.CompatibilityCallToolResultSchema = exports2.CallToolResultSchema = exports2.ListToolsResultSchema = exports2.ListToolsRequestSchema = exports2.ToolSchema = exports2.ToolAnnotationsSchema = exports2.PromptListChangedNotificationSchema = exports2.GetPromptResultSchema = exports2.PromptMessageSchema = exports2.ContentBlockSchema = exports2.ResourceLinkSchema = exports2.EmbeddedResourceSchema = exports2.AudioContentSchema = exports2.ImageContentSchema = exports2.TextContentSchema = exports2.GetPromptRequestSchema = exports2.ListPromptsResultSchema = exports2.ListPromptsRequestSchema = exports2.PromptSchema = exports2.PromptArgumentSchema = exports2.ResourceUpdatedNotificationSchema = exports2.UnsubscribeRequestSchema = exports2.SubscribeRequestSchema = void 0;
    exports2.McpError = exports2.ServerResultSchema = exports2.ServerNotificationSchema = exports2.ServerRequestSchema = exports2.ClientResultSchema = exports2.ClientNotificationSchema = void 0;
    var zod_1 = require_zod2();
    exports2.LATEST_PROTOCOL_VERSION = "2025-06-18";
    exports2.DEFAULT_NEGOTIATED_PROTOCOL_VERSION = "2025-03-26";
    exports2.SUPPORTED_PROTOCOL_VERSIONS = [exports2.LATEST_PROTOCOL_VERSION, "2025-03-26", "2024-11-05", "2024-10-07"];
    exports2.JSONRPC_VERSION = "2.0";
    exports2.ProgressTokenSchema = zod_1.z.union([zod_1.z.string(), zod_1.z.number().int()]);
    exports2.CursorSchema = zod_1.z.string();
    var RequestMetaSchema = zod_1.z.object({
      /**
       * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
       */
      progressToken: zod_1.z.optional(exports2.ProgressTokenSchema)
    }).passthrough();
    var BaseRequestParamsSchema = zod_1.z.object({
      _meta: zod_1.z.optional(RequestMetaSchema)
    }).passthrough();
    exports2.RequestSchema = zod_1.z.object({
      method: zod_1.z.string(),
      params: zod_1.z.optional(BaseRequestParamsSchema)
    });
    var BaseNotificationParamsSchema = zod_1.z.object({
      /**
       * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
       * for notes on _meta usage.
       */
      _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
    }).passthrough();
    exports2.NotificationSchema = zod_1.z.object({
      method: zod_1.z.string(),
      params: zod_1.z.optional(BaseNotificationParamsSchema)
    });
    exports2.ResultSchema = zod_1.z.object({
      /**
       * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
       * for notes on _meta usage.
       */
      _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
    }).passthrough();
    exports2.RequestIdSchema = zod_1.z.union([zod_1.z.string(), zod_1.z.number().int()]);
    exports2.JSONRPCRequestSchema = zod_1.z.object({
      jsonrpc: zod_1.z.literal(exports2.JSONRPC_VERSION),
      id: exports2.RequestIdSchema
    }).merge(exports2.RequestSchema).strict();
    var isJSONRPCRequest = (value) => exports2.JSONRPCRequestSchema.safeParse(value).success;
    exports2.isJSONRPCRequest = isJSONRPCRequest;
    exports2.JSONRPCNotificationSchema = zod_1.z.object({
      jsonrpc: zod_1.z.literal(exports2.JSONRPC_VERSION)
    }).merge(exports2.NotificationSchema).strict();
    var isJSONRPCNotification = (value) => exports2.JSONRPCNotificationSchema.safeParse(value).success;
    exports2.isJSONRPCNotification = isJSONRPCNotification;
    exports2.JSONRPCResponseSchema = zod_1.z.object({
      jsonrpc: zod_1.z.literal(exports2.JSONRPC_VERSION),
      id: exports2.RequestIdSchema,
      result: exports2.ResultSchema
    }).strict();
    var isJSONRPCResponse = (value) => exports2.JSONRPCResponseSchema.safeParse(value).success;
    exports2.isJSONRPCResponse = isJSONRPCResponse;
    var ErrorCode;
    (function(ErrorCode2) {
      ErrorCode2[ErrorCode2["ConnectionClosed"] = -32e3] = "ConnectionClosed";
      ErrorCode2[ErrorCode2["RequestTimeout"] = -32001] = "RequestTimeout";
      ErrorCode2[ErrorCode2["ParseError"] = -32700] = "ParseError";
      ErrorCode2[ErrorCode2["InvalidRequest"] = -32600] = "InvalidRequest";
      ErrorCode2[ErrorCode2["MethodNotFound"] = -32601] = "MethodNotFound";
      ErrorCode2[ErrorCode2["InvalidParams"] = -32602] = "InvalidParams";
      ErrorCode2[ErrorCode2["InternalError"] = -32603] = "InternalError";
    })(ErrorCode || (exports2.ErrorCode = ErrorCode = {}));
    exports2.JSONRPCErrorSchema = zod_1.z.object({
      jsonrpc: zod_1.z.literal(exports2.JSONRPC_VERSION),
      id: exports2.RequestIdSchema,
      error: zod_1.z.object({
        /**
         * The error type that occurred.
         */
        code: zod_1.z.number().int(),
        /**
         * A short description of the error. The message SHOULD be limited to a concise single sentence.
         */
        message: zod_1.z.string(),
        /**
         * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
         */
        data: zod_1.z.optional(zod_1.z.unknown())
      })
    }).strict();
    var isJSONRPCError = (value) => exports2.JSONRPCErrorSchema.safeParse(value).success;
    exports2.isJSONRPCError = isJSONRPCError;
    exports2.JSONRPCMessageSchema = zod_1.z.union([exports2.JSONRPCRequestSchema, exports2.JSONRPCNotificationSchema, exports2.JSONRPCResponseSchema, exports2.JSONRPCErrorSchema]);
    exports2.EmptyResultSchema = exports2.ResultSchema.strict();
    exports2.CancelledNotificationSchema = exports2.NotificationSchema.extend({
      method: zod_1.z.literal("notifications/cancelled"),
      params: BaseNotificationParamsSchema.extend({
        /**
         * The ID of the request to cancel.
         *
         * This MUST correspond to the ID of a request previously issued in the same direction.
         */
        requestId: exports2.RequestIdSchema,
        /**
         * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
         */
        reason: zod_1.z.string().optional()
      })
    });
    exports2.IconSchema = zod_1.z.object({
      /**
       * URL or data URI for the icon.
       */
      src: zod_1.z.string(),
      /**
       * Optional MIME type for the icon.
       */
      mimeType: zod_1.z.optional(zod_1.z.string()),
      /**
       * Optional array of strings that specify sizes at which the icon can be used.
       * Each string should be in WxH format (e.g., `"48x48"`, `"96x96"`) or `"any"` for scalable formats like SVG.
       *
       * If not provided, the client should assume that the icon can be used at any size.
       */
      sizes: zod_1.z.optional(zod_1.z.array(zod_1.z.string()))
    }).passthrough();
    exports2.IconsSchema = zod_1.z.object({
      /**
       * Optional set of sized icons that the client can display in a user interface.
       *
       * Clients that support rendering icons MUST support at least the following MIME types:
       * - `image/png` - PNG images (safe, universal compatibility)
       * - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)
       *
       * Clients that support rendering icons SHOULD also support:
       * - `image/svg+xml` - SVG images (scalable but requires security precautions)
       * - `image/webp` - WebP images (modern, efficient format)
       */
      icons: zod_1.z.array(exports2.IconSchema).optional()
    }).passthrough();
    exports2.BaseMetadataSchema = zod_1.z.object({
      /** Intended for programmatic or logical use, but used as a display name in past specs or fallback */
      name: zod_1.z.string(),
      /**
       * Intended for UI and end-user contexts  optimized to be human-readable and easily understood,
       * even by those unfamiliar with domain-specific terminology.
       *
       * If not provided, the name should be used for display (except for Tool,
       * where `annotations.title` should be given precedence over using `name`,
       * if present).
       */
      title: zod_1.z.optional(zod_1.z.string())
    }).passthrough();
    exports2.ImplementationSchema = exports2.BaseMetadataSchema.extend({
      version: zod_1.z.string(),
      /**
       * An optional URL of the website for this implementation.
       */
      websiteUrl: zod_1.z.optional(zod_1.z.string())
    }).merge(exports2.IconsSchema);
    exports2.ClientCapabilitiesSchema = zod_1.z.object({
      /**
       * Experimental, non-standard capabilities that the client supports.
       */
      experimental: zod_1.z.optional(zod_1.z.object({}).passthrough()),
      /**
       * Present if the client supports sampling from an LLM.
       */
      sampling: zod_1.z.optional(zod_1.z.object({}).passthrough()),
      /**
       * Present if the client supports eliciting user input.
       */
      elicitation: zod_1.z.optional(zod_1.z.object({}).passthrough()),
      /**
       * Present if the client supports listing roots.
       */
      roots: zod_1.z.optional(zod_1.z.object({
        /**
         * Whether the client supports issuing notifications for changes to the roots list.
         */
        listChanged: zod_1.z.optional(zod_1.z.boolean())
      }).passthrough())
    }).passthrough();
    exports2.InitializeRequestSchema = exports2.RequestSchema.extend({
      method: zod_1.z.literal("initialize"),
      params: BaseRequestParamsSchema.extend({
        /**
         * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.
         */
        protocolVersion: zod_1.z.string(),
        capabilities: exports2.ClientCapabilitiesSchema,
        clientInfo: exports2.ImplementationSchema
      })
    });
    var isInitializeRequest = (value) => exports2.InitializeRequestSchema.safeParse(value).success;
    exports2.isInitializeRequest = isInitializeRequest;
    exports2.ServerCapabilitiesSchema = zod_1.z.object({
      /**
       * Experimental, non-standard capabilities that the server supports.
       */
      experimental: zod_1.z.optional(zod_1.z.object({}).passthrough()),
      /**
       * Present if the server supports sending log messages to the client.
       */
      logging: zod_1.z.optional(zod_1.z.object({}).passthrough()),
      /**
       * Present if the server supports sending completions to the client.
       */
      completions: zod_1.z.optional(zod_1.z.object({}).passthrough()),
      /**
       * Present if the server offers any prompt templates.
       */
      prompts: zod_1.z.optional(zod_1.z.object({
        /**
         * Whether this server supports issuing notifications for changes to the prompt list.
         */
        listChanged: zod_1.z.optional(zod_1.z.boolean())
      }).passthrough()),
      /**
       * Present if the server offers any resources to read.
       */
      resources: zod_1.z.optional(zod_1.z.object({
        /**
         * Whether this server supports clients subscribing to resource updates.
         */
        subscribe: zod_1.z.optional(zod_1.z.boolean()),
        /**
         * Whether this server supports issuing notifications for changes to the resource list.
         */
        listChanged: zod_1.z.optional(zod_1.z.boolean())
      }).passthrough()),
      /**
       * Present if the server offers any tools to call.
       */
      tools: zod_1.z.optional(zod_1.z.object({
        /**
         * Whether this server supports issuing notifications for changes to the tool list.
         */
        listChanged: zod_1.z.optional(zod_1.z.boolean())
      }).passthrough())
    }).passthrough();
    exports2.InitializeResultSchema = exports2.ResultSchema.extend({
      /**
       * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
       */
      protocolVersion: zod_1.z.string(),
      capabilities: exports2.ServerCapabilitiesSchema,
      serverInfo: exports2.ImplementationSchema,
      /**
       * Instructions describing how to use the server and its features.
       *
       * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
       */
      instructions: zod_1.z.optional(zod_1.z.string())
    });
    exports2.InitializedNotificationSchema = exports2.NotificationSchema.extend({
      method: zod_1.z.literal("notifications/initialized")
    });
    var isInitializedNotification = (value) => exports2.InitializedNotificationSchema.safeParse(value).success;
    exports2.isInitializedNotification = isInitializedNotification;
    exports2.PingRequestSchema = exports2.RequestSchema.extend({
      method: zod_1.z.literal("ping")
    });
    exports2.ProgressSchema = zod_1.z.object({
      /**
       * The progress thus far. This should increase every time progress is made, even if the total is unknown.
       */
      progress: zod_1.z.number(),
      /**
       * Total number of items to process (or total progress required), if known.
       */
      total: zod_1.z.optional(zod_1.z.number()),
      /**
       * An optional message describing the current progress.
       */
      message: zod_1.z.optional(zod_1.z.string())
    }).passthrough();
    exports2.ProgressNotificationSchema = exports2.NotificationSchema.extend({
      method: zod_1.z.literal("notifications/progress"),
      params: BaseNotificationParamsSchema.merge(exports2.ProgressSchema).extend({
        /**
         * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
         */
        progressToken: exports2.ProgressTokenSchema
      })
    });
    exports2.PaginatedRequestSchema = exports2.RequestSchema.extend({
      params: BaseRequestParamsSchema.extend({
        /**
         * An opaque token representing the current pagination position.
         * If provided, the server should return results starting after this cursor.
         */
        cursor: zod_1.z.optional(exports2.CursorSchema)
      }).optional()
    });
    exports2.PaginatedResultSchema = exports2.ResultSchema.extend({
      /**
       * An opaque token representing the pagination position after the last returned result.
       * If present, there may be more results available.
       */
      nextCursor: zod_1.z.optional(exports2.CursorSchema)
    });
    exports2.ResourceContentsSchema = zod_1.z.object({
      /**
       * The URI of this resource.
       */
      uri: zod_1.z.string(),
      /**
       * The MIME type of this resource, if known.
       */
      mimeType: zod_1.z.optional(zod_1.z.string()),
      /**
       * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
       * for notes on _meta usage.
       */
      _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
    }).passthrough();
    exports2.TextResourceContentsSchema = exports2.ResourceContentsSchema.extend({
      /**
       * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
       */
      text: zod_1.z.string()
    });
    var Base64Schema = zod_1.z.string().refine((val) => {
      try {
        atob(val);
        return true;
      } catch (_a) {
        return false;
      }
    }, { message: "Invalid Base64 string" });
    exports2.BlobResourceContentsSchema = exports2.ResourceContentsSchema.extend({
      /**
       * A base64-encoded string representing the binary data of the item.
       */
      blob: Base64Schema
    });
    exports2.ResourceSchema = exports2.BaseMetadataSchema.extend({
      /**
       * The URI of this resource.
       */
      uri: zod_1.z.string(),
      /**
       * A description of what this resource represents.
       *
       * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
       */
      description: zod_1.z.optional(zod_1.z.string()),
      /**
       * The MIME type of this resource, if known.
       */
      mimeType: zod_1.z.optional(zod_1.z.string()),
      /**
       * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
       * for notes on _meta usage.
       */
      _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
    }).merge(exports2.IconsSchema);
    exports2.ResourceTemplateSchema = exports2.BaseMetadataSchema.extend({
      /**
       * A URI template (according to RFC 6570) that can be used to construct resource URIs.
       */
      uriTemplate: zod_1.z.string(),
      /**
       * A description of what this template is for.
       *
       * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
       */
      description: zod_1.z.optional(zod_1.z.string()),
      /**
       * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
       */
      mimeType: zod_1.z.optional(zod_1.z.string()),
      /**
       * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
       * for notes on _meta usage.
       */
      _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
    }).merge(exports2.IconsSchema);
    exports2.ListResourcesRequestSchema = exports2.PaginatedRequestSchema.extend({
      method: zod_1.z.literal("resources/list")
    });
    exports2.ListResourcesResultSchema = exports2.PaginatedResultSchema.extend({
      resources: zod_1.z.array(exports2.ResourceSchema)
    });
    exports2.ListResourceTemplatesRequestSchema = exports2.PaginatedRequestSchema.extend({
      method: zod_1.z.literal("resources/templates/list")
    });
    exports2.ListResourceTemplatesResultSchema = exports2.PaginatedResultSchema.extend({
      resourceTemplates: zod_1.z.array(exports2.ResourceTemplateSchema)
    });
    exports2.ReadResourceRequestSchema = exports2.RequestSchema.extend({
      method: zod_1.z.literal("resources/read"),
      params: BaseRequestParamsSchema.extend({
        /**
         * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.
         */
        uri: zod_1.z.string()
      })
    });
    exports2.ReadResourceResultSchema = exports2.ResultSchema.extend({
      contents: zod_1.z.array(zod_1.z.union([exports2.TextResourceContentsSchema, exports2.BlobResourceContentsSchema]))
    });
    exports2.ResourceListChangedNotificationSchema = exports2.NotificationSchema.extend({
      method: zod_1.z.literal("notifications/resources/list_changed")
    });
    exports2.SubscribeRequestSchema = exports2.RequestSchema.extend({
      method: zod_1.z.literal("resources/subscribe"),
      params: BaseRequestParamsSchema.extend({
        /**
         * The URI of the resource to subscribe to. The URI can use any protocol; it is up to the server how to interpret it.
         */
        uri: zod_1.z.string()
      })
    });
    exports2.UnsubscribeRequestSchema = exports2.RequestSchema.extend({
      method: zod_1.z.literal("resources/unsubscribe"),
      params: BaseRequestParamsSchema.extend({
        /**
         * The URI of the resource to unsubscribe from.
         */
        uri: zod_1.z.string()
      })
    });
    exports2.ResourceUpdatedNotificationSchema = exports2.NotificationSchema.extend({
      method: zod_1.z.literal("notifications/resources/updated"),
      params: BaseNotificationParamsSchema.extend({
        /**
         * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
         */
        uri: zod_1.z.string()
      })
    });
    exports2.PromptArgumentSchema = zod_1.z.object({
      /**
       * The name of the argument.
       */
      name: zod_1.z.string(),
      /**
       * A human-readable description of the argument.
       */
      description: zod_1.z.optional(zod_1.z.string()),
      /**
       * Whether this argument must be provided.
       */
      required: zod_1.z.optional(zod_1.z.boolean())
    }).passthrough();
    exports2.PromptSchema = exports2.BaseMetadataSchema.extend({
      /**
       * An optional description of what this prompt provides
       */
      description: zod_1.z.optional(zod_1.z.string()),
      /**
       * A list of arguments to use for templating the prompt.
       */
      arguments: zod_1.z.optional(zod_1.z.array(exports2.PromptArgumentSchema)),
      /**
       * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
       * for notes on _meta usage.
       */
      _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
    }).merge(exports2.IconsSchema);
    exports2.ListPromptsRequestSchema = exports2.PaginatedRequestSchema.extend({
      method: zod_1.z.literal("prompts/list")
    });
    exports2.ListPromptsResultSchema = exports2.PaginatedResultSchema.extend({
      prompts: zod_1.z.array(exports2.PromptSchema)
    });
    exports2.GetPromptRequestSchema = exports2.RequestSchema.extend({
      method: zod_1.z.literal("prompts/get"),
      params: BaseRequestParamsSchema.extend({
        /**
         * The name of the prompt or prompt template.
         */
        name: zod_1.z.string(),
        /**
         * Arguments to use for templating the prompt.
         */
        arguments: zod_1.z.optional(zod_1.z.record(zod_1.z.string()))
      })
    });
    exports2.TextContentSchema = zod_1.z.object({
      type: zod_1.z.literal("text"),
      /**
       * The text content of the message.
       */
      text: zod_1.z.string(),
      /**
       * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
       * for notes on _meta usage.
       */
      _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
    }).passthrough();
    exports2.ImageContentSchema = zod_1.z.object({
      type: zod_1.z.literal("image"),
      /**
       * The base64-encoded image data.
       */
      data: Base64Schema,
      /**
       * The MIME type of the image. Different providers may support different image types.
       */
      mimeType: zod_1.z.string(),
      /**
       * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
       * for notes on _meta usage.
       */
      _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
    }).passthrough();
    exports2.AudioContentSchema = zod_1.z.object({
      type: zod_1.z.literal("audio"),
      /**
       * The base64-encoded audio data.
       */
      data: Base64Schema,
      /**
       * The MIME type of the audio. Different providers may support different audio types.
       */
      mimeType: zod_1.z.string(),
      /**
       * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
       * for notes on _meta usage.
       */
      _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
    }).passthrough();
    exports2.EmbeddedResourceSchema = zod_1.z.object({
      type: zod_1.z.literal("resource"),
      resource: zod_1.z.union([exports2.TextResourceContentsSchema, exports2.BlobResourceContentsSchema]),
      /**
       * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
       * for notes on _meta usage.
       */
      _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
    }).passthrough();
    exports2.ResourceLinkSchema = exports2.ResourceSchema.extend({
      type: zod_1.z.literal("resource_link")
    });
    exports2.ContentBlockSchema = zod_1.z.union([
      exports2.TextContentSchema,
      exports2.ImageContentSchema,
      exports2.AudioContentSchema,
      exports2.ResourceLinkSchema,
      exports2.EmbeddedResourceSchema
    ]);
    exports2.PromptMessageSchema = zod_1.z.object({
      role: zod_1.z.enum(["user", "assistant"]),
      content: exports2.ContentBlockSchema
    }).passthrough();
    exports2.GetPromptResultSchema = exports2.ResultSchema.extend({
      /**
       * An optional description for the prompt.
       */
      description: zod_1.z.optional(zod_1.z.string()),
      messages: zod_1.z.array(exports2.PromptMessageSchema)
    });
    exports2.PromptListChangedNotificationSchema = exports2.NotificationSchema.extend({
      method: zod_1.z.literal("notifications/prompts/list_changed")
    });
    exports2.ToolAnnotationsSchema = zod_1.z.object({
      /**
       * A human-readable title for the tool.
       */
      title: zod_1.z.optional(zod_1.z.string()),
      /**
       * If true, the tool does not modify its environment.
       *
       * Default: false
       */
      readOnlyHint: zod_1.z.optional(zod_1.z.boolean()),
      /**
       * If true, the tool may perform destructive updates to its environment.
       * If false, the tool performs only additive updates.
       *
       * (This property is meaningful only when `readOnlyHint == false`)
       *
       * Default: true
       */
      destructiveHint: zod_1.z.optional(zod_1.z.boolean()),
      /**
       * If true, calling the tool repeatedly with the same arguments
       * will have no additional effect on the its environment.
       *
       * (This property is meaningful only when `readOnlyHint == false`)
       *
       * Default: false
       */
      idempotentHint: zod_1.z.optional(zod_1.z.boolean()),
      /**
       * If true, this tool may interact with an "open world" of external
       * entities. If false, the tool's domain of interaction is closed.
       * For example, the world of a web search tool is open, whereas that
       * of a memory tool is not.
       *
       * Default: true
       */
      openWorldHint: zod_1.z.optional(zod_1.z.boolean())
    }).passthrough();
    exports2.ToolSchema = exports2.BaseMetadataSchema.extend({
      /**
       * A human-readable description of the tool.
       */
      description: zod_1.z.optional(zod_1.z.string()),
      /**
       * A JSON Schema object defining the expected parameters for the tool.
       */
      inputSchema: zod_1.z.object({
        type: zod_1.z.literal("object"),
        properties: zod_1.z.optional(zod_1.z.object({}).passthrough()),
        required: zod_1.z.optional(zod_1.z.array(zod_1.z.string()))
      }).passthrough(),
      /**
       * An optional JSON Schema object defining the structure of the tool's output returned in
       * the structuredContent field of a CallToolResult.
       */
      outputSchema: zod_1.z.optional(zod_1.z.object({
        type: zod_1.z.literal("object"),
        properties: zod_1.z.optional(zod_1.z.object({}).passthrough()),
        required: zod_1.z.optional(zod_1.z.array(zod_1.z.string()))
      }).passthrough()),
      /**
       * Optional additional tool information.
       */
      annotations: zod_1.z.optional(exports2.ToolAnnotationsSchema),
      /**
       * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
       * for notes on _meta usage.
       */
      _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
    }).merge(exports2.IconsSchema);
    exports2.ListToolsRequestSchema = exports2.PaginatedRequestSchema.extend({
      method: zod_1.z.literal("tools/list")
    });
    exports2.ListToolsResultSchema = exports2.PaginatedResultSchema.extend({
      tools: zod_1.z.array(exports2.ToolSchema)
    });
    exports2.CallToolResultSchema = exports2.ResultSchema.extend({
      /**
       * A list of content objects that represent the result of the tool call.
       *
       * If the Tool does not define an outputSchema, this field MUST be present in the result.
       * For backwards compatibility, this field is always present, but it may be empty.
       */
      content: zod_1.z.array(exports2.ContentBlockSchema).default([]),
      /**
       * An object containing structured tool output.
       *
       * If the Tool defines an outputSchema, this field MUST be present in the result, and contain a JSON object that matches the schema.
       */
      structuredContent: zod_1.z.object({}).passthrough().optional(),
      /**
       * Whether the tool call ended in an error.
       *
       * If not set, this is assumed to be false (the call was successful).
       *
       * Any errors that originate from the tool SHOULD be reported inside the result
       * object, with `isError` set to true, _not_ as an MCP protocol-level error
       * response. Otherwise, the LLM would not be able to see that an error occurred
       * and self-correct.
       *
       * However, any errors in _finding_ the tool, an error indicating that the
       * server does not support tool calls, or any other exceptional conditions,
       * should be reported as an MCP error response.
       */
      isError: zod_1.z.optional(zod_1.z.boolean())
    });
    exports2.CompatibilityCallToolResultSchema = exports2.CallToolResultSchema.or(exports2.ResultSchema.extend({
      toolResult: zod_1.z.unknown()
    }));
    exports2.CallToolRequestSchema = exports2.RequestSchema.extend({
      method: zod_1.z.literal("tools/call"),
      params: BaseRequestParamsSchema.extend({
        name: zod_1.z.string(),
        arguments: zod_1.z.optional(zod_1.z.record(zod_1.z.unknown()))
      })
    });
    exports2.ToolListChangedNotificationSchema = exports2.NotificationSchema.extend({
      method: zod_1.z.literal("notifications/tools/list_changed")
    });
    exports2.LoggingLevelSchema = zod_1.z.enum(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]);
    exports2.SetLevelRequestSchema = exports2.RequestSchema.extend({
      method: zod_1.z.literal("logging/setLevel"),
      params: BaseRequestParamsSchema.extend({
        /**
         * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.
         */
        level: exports2.LoggingLevelSchema
      })
    });
    exports2.LoggingMessageNotificationSchema = exports2.NotificationSchema.extend({
      method: zod_1.z.literal("notifications/message"),
      params: BaseNotificationParamsSchema.extend({
        /**
         * The severity of this log message.
         */
        level: exports2.LoggingLevelSchema,
        /**
         * An optional name of the logger issuing this message.
         */
        logger: zod_1.z.optional(zod_1.z.string()),
        /**
         * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
         */
        data: zod_1.z.unknown()
      })
    });
    exports2.ModelHintSchema = zod_1.z.object({
      /**
       * A hint for a model name.
       */
      name: zod_1.z.string().optional()
    }).passthrough();
    exports2.ModelPreferencesSchema = zod_1.z.object({
      /**
       * Optional hints to use for model selection.
       */
      hints: zod_1.z.optional(zod_1.z.array(exports2.ModelHintSchema)),
      /**
       * How much to prioritize cost when selecting a model.
       */
      costPriority: zod_1.z.optional(zod_1.z.number().min(0).max(1)),
      /**
       * How much to prioritize sampling speed (latency) when selecting a model.
       */
      speedPriority: zod_1.z.optional(zod_1.z.number().min(0).max(1)),
      /**
       * How much to prioritize intelligence and capabilities when selecting a model.
       */
      intelligencePriority: zod_1.z.optional(zod_1.z.number().min(0).max(1))
    }).passthrough();
    exports2.SamplingMessageSchema = zod_1.z.object({
      role: zod_1.z.enum(["user", "assistant"]),
      content: zod_1.z.union([exports2.TextContentSchema, exports2.ImageContentSchema, exports2.AudioContentSchema])
    }).passthrough();
    exports2.CreateMessageRequestSchema = exports2.RequestSchema.extend({
      method: zod_1.z.literal("sampling/createMessage"),
      params: BaseRequestParamsSchema.extend({
        messages: zod_1.z.array(exports2.SamplingMessageSchema),
        /**
         * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
         */
        systemPrompt: zod_1.z.optional(zod_1.z.string()),
        /**
         * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt. The client MAY ignore this request.
         */
        includeContext: zod_1.z.optional(zod_1.z.enum(["none", "thisServer", "allServers"])),
        temperature: zod_1.z.optional(zod_1.z.number()),
        /**
         * The maximum number of tokens to sample, as requested by the server. The client MAY choose to sample fewer tokens than requested.
         */
        maxTokens: zod_1.z.number().int(),
        stopSequences: zod_1.z.optional(zod_1.z.array(zod_1.z.string())),
        /**
         * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
         */
        metadata: zod_1.z.optional(zod_1.z.object({}).passthrough()),
        /**
         * The server's preferences for which model to select.
         */
        modelPreferences: zod_1.z.optional(exports2.ModelPreferencesSchema)
      })
    });
    exports2.CreateMessageResultSchema = exports2.ResultSchema.extend({
      /**
       * The name of the model that generated the message.
       */
      model: zod_1.z.string(),
      /**
       * The reason why sampling stopped.
       */
      stopReason: zod_1.z.optional(zod_1.z.enum(["endTurn", "stopSequence", "maxTokens"]).or(zod_1.z.string())),
      role: zod_1.z.enum(["user", "assistant"]),
      content: zod_1.z.discriminatedUnion("type", [exports2.TextContentSchema, exports2.ImageContentSchema, exports2.AudioContentSchema])
    });
    exports2.BooleanSchemaSchema = zod_1.z.object({
      type: zod_1.z.literal("boolean"),
      title: zod_1.z.optional(zod_1.z.string()),
      description: zod_1.z.optional(zod_1.z.string()),
      default: zod_1.z.optional(zod_1.z.boolean())
    }).passthrough();
    exports2.StringSchemaSchema = zod_1.z.object({
      type: zod_1.z.literal("string"),
      title: zod_1.z.optional(zod_1.z.string()),
      description: zod_1.z.optional(zod_1.z.string()),
      minLength: zod_1.z.optional(zod_1.z.number()),
      maxLength: zod_1.z.optional(zod_1.z.number()),
      format: zod_1.z.optional(zod_1.z.enum(["email", "uri", "date", "date-time"]))
    }).passthrough();
    exports2.NumberSchemaSchema = zod_1.z.object({
      type: zod_1.z.enum(["number", "integer"]),
      title: zod_1.z.optional(zod_1.z.string()),
      description: zod_1.z.optional(zod_1.z.string()),
      minimum: zod_1.z.optional(zod_1.z.number()),
      maximum: zod_1.z.optional(zod_1.z.number())
    }).passthrough();
    exports2.EnumSchemaSchema = zod_1.z.object({
      type: zod_1.z.literal("string"),
      title: zod_1.z.optional(zod_1.z.string()),
      description: zod_1.z.optional(zod_1.z.string()),
      enum: zod_1.z.array(zod_1.z.string()),
      enumNames: zod_1.z.optional(zod_1.z.array(zod_1.z.string()))
    }).passthrough();
    exports2.PrimitiveSchemaDefinitionSchema = zod_1.z.union([exports2.BooleanSchemaSchema, exports2.StringSchemaSchema, exports2.NumberSchemaSchema, exports2.EnumSchemaSchema]);
    exports2.ElicitRequestSchema = exports2.RequestSchema.extend({
      method: zod_1.z.literal("elicitation/create"),
      params: BaseRequestParamsSchema.extend({
        /**
         * The message to present to the user.
         */
        message: zod_1.z.string(),
        /**
         * The schema for the requested user input.
         */
        requestedSchema: zod_1.z.object({
          type: zod_1.z.literal("object"),
          properties: zod_1.z.record(zod_1.z.string(), exports2.PrimitiveSchemaDefinitionSchema),
          required: zod_1.z.optional(zod_1.z.array(zod_1.z.string()))
        }).passthrough()
      })
    });
    exports2.ElicitResultSchema = exports2.ResultSchema.extend({
      /**
       * The user's response action.
       */
      action: zod_1.z.enum(["accept", "decline", "cancel"]),
      /**
       * The collected user input content (only present if action is "accept").
       */
      content: zod_1.z.optional(zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()))
    });
    exports2.ResourceTemplateReferenceSchema = zod_1.z.object({
      type: zod_1.z.literal("ref/resource"),
      /**
       * The URI or URI template of the resource.
       */
      uri: zod_1.z.string()
    }).passthrough();
    exports2.ResourceReferenceSchema = exports2.ResourceTemplateReferenceSchema;
    exports2.PromptReferenceSchema = zod_1.z.object({
      type: zod_1.z.literal("ref/prompt"),
      /**
       * The name of the prompt or prompt template
       */
      name: zod_1.z.string()
    }).passthrough();
    exports2.CompleteRequestSchema = exports2.RequestSchema.extend({
      method: zod_1.z.literal("completion/complete"),
      params: BaseRequestParamsSchema.extend({
        ref: zod_1.z.union([exports2.PromptReferenceSchema, exports2.ResourceTemplateReferenceSchema]),
        /**
         * The argument's information
         */
        argument: zod_1.z.object({
          /**
           * The name of the argument
           */
          name: zod_1.z.string(),
          /**
           * The value of the argument to use for completion matching.
           */
          value: zod_1.z.string()
        }).passthrough(),
        context: zod_1.z.optional(zod_1.z.object({
          /**
           * Previously-resolved variables in a URI template or prompt.
           */
          arguments: zod_1.z.optional(zod_1.z.record(zod_1.z.string(), zod_1.z.string()))
        }))
      })
    });
    exports2.CompleteResultSchema = exports2.ResultSchema.extend({
      completion: zod_1.z.object({
        /**
         * An array of completion values. Must not exceed 100 items.
         */
        values: zod_1.z.array(zod_1.z.string()).max(100),
        /**
         * The total number of completion options available. This can exceed the number of values actually sent in the response.
         */
        total: zod_1.z.optional(zod_1.z.number().int()),
        /**
         * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
         */
        hasMore: zod_1.z.optional(zod_1.z.boolean())
      }).passthrough()
    });
    exports2.RootSchema = zod_1.z.object({
      /**
       * The URI identifying the root. This *must* start with file:// for now.
       */
      uri: zod_1.z.string().startsWith("file://"),
      /**
       * An optional name for the root.
       */
      name: zod_1.z.optional(zod_1.z.string()),
      /**
       * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
       * for notes on _meta usage.
       */
      _meta: zod_1.z.optional(zod_1.z.object({}).passthrough())
    }).passthrough();
    exports2.ListRootsRequestSchema = exports2.RequestSchema.extend({
      method: zod_1.z.literal("roots/list")
    });
    exports2.ListRootsResultSchema = exports2.ResultSchema.extend({
      roots: zod_1.z.array(exports2.RootSchema)
    });
    exports2.RootsListChangedNotificationSchema = exports2.NotificationSchema.extend({
      method: zod_1.z.literal("notifications/roots/list_changed")
    });
    exports2.ClientRequestSchema = zod_1.z.union([
      exports2.PingRequestSchema,
      exports2.InitializeRequestSchema,
      exports2.CompleteRequestSchema,
      exports2.SetLevelRequestSchema,
      exports2.GetPromptRequestSchema,
      exports2.ListPromptsRequestSchema,
      exports2.ListResourcesRequestSchema,
      exports2.ListResourceTemplatesRequestSchema,
      exports2.ReadResourceRequestSchema,
      exports2.SubscribeRequestSchema,
      exports2.UnsubscribeRequestSchema,
      exports2.CallToolRequestSchema,
      exports2.ListToolsRequestSchema
    ]);
    exports2.ClientNotificationSchema = zod_1.z.union([
      exports2.CancelledNotificationSchema,
      exports2.ProgressNotificationSchema,
      exports2.InitializedNotificationSchema,
      exports2.RootsListChangedNotificationSchema
    ]);
    exports2.ClientResultSchema = zod_1.z.union([exports2.EmptyResultSchema, exports2.CreateMessageResultSchema, exports2.ElicitResultSchema, exports2.ListRootsResultSchema]);
    exports2.ServerRequestSchema = zod_1.z.union([exports2.PingRequestSchema, exports2.CreateMessageRequestSchema, exports2.ElicitRequestSchema, exports2.ListRootsRequestSchema]);
    exports2.ServerNotificationSchema = zod_1.z.union([
      exports2.CancelledNotificationSchema,
      exports2.ProgressNotificationSchema,
      exports2.LoggingMessageNotificationSchema,
      exports2.ResourceUpdatedNotificationSchema,
      exports2.ResourceListChangedNotificationSchema,
      exports2.ToolListChangedNotificationSchema,
      exports2.PromptListChangedNotificationSchema
    ]);
    exports2.ServerResultSchema = zod_1.z.union([
      exports2.EmptyResultSchema,
      exports2.InitializeResultSchema,
      exports2.CompleteResultSchema,
      exports2.GetPromptResultSchema,
      exports2.ListPromptsResultSchema,
      exports2.ListResourcesResultSchema,
      exports2.ListResourceTemplatesResultSchema,
      exports2.ReadResourceResultSchema,
      exports2.CallToolResultSchema,
      exports2.ListToolsResultSchema
    ]);
    var McpError = class extends Error {
      constructor(code, message, data) {
        super(`MCP error ${code}: ${message}`);
        this.code = code;
        this.data = data;
        this.name = "McpError";
      }
    };
    exports2.McpError = McpError;
  }
});

// node_modules/.pnpm/pkce-challenge@5.0.0/node_modules/pkce-challenge/dist/index.node.cjs
var require_index_node = __commonJS({
  "node_modules/.pnpm/pkce-challenge@5.0.0/node_modules/pkce-challenge/dist/index.node.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateChallenge = generateChallenge;
    exports2.default = pkceChallenge;
    exports2.verifyChallenge = verifyChallenge;
    var crypto5;
    crypto5 = globalThis.crypto?.webcrypto ?? // Node.js [18-16] REPL
    globalThis.crypto ?? // Node.js >18
    import("node:crypto").then((m) => m.webcrypto);
    async function getRandomValues(size) {
      return (await crypto5).getRandomValues(new Uint8Array(size));
    }
    async function random(size) {
      const mask = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~";
      let result = "";
      const randomUints = await getRandomValues(size);
      for (let i = 0; i < size; i++) {
        const randomIndex = randomUints[i] % mask.length;
        result += mask[randomIndex];
      }
      return result;
    }
    async function generateVerifier(length) {
      return await random(length);
    }
    async function generateChallenge(code_verifier) {
      const buffer = await (await crypto5).subtle.digest("SHA-256", new TextEncoder().encode(code_verifier));
      return btoa(String.fromCharCode(...new Uint8Array(buffer))).replace(/\//g, "_").replace(/\+/g, "-").replace(/=/g, "");
    }
    async function pkceChallenge(length) {
      if (!length)
        length = 43;
      if (length < 43 || length > 128) {
        throw `Expected a length between 43 and 128. Received ${length}.`;
      }
      const verifier = await generateVerifier(length);
      const challenge = await generateChallenge(verifier);
      return {
        code_verifier: verifier,
        code_challenge: challenge
      };
    }
    async function verifyChallenge(code_verifier, expectedChallenge) {
      const actualChallenge = await generateChallenge(code_verifier);
      return actualChallenge === expectedChallenge;
    }
  }
});

// node_modules/.pnpm/@modelcontextprotocol+sdk@1.20.2/node_modules/@modelcontextprotocol/sdk/dist/cjs/shared/auth.js
var require_auth = __commonJS({
  "node_modules/.pnpm/@modelcontextprotocol+sdk@1.20.2/node_modules/@modelcontextprotocol/sdk/dist/cjs/shared/auth.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OAuthTokenRevocationRequestSchema = exports2.OAuthClientRegistrationErrorSchema = exports2.OAuthClientInformationFullSchema = exports2.OAuthClientInformationSchema = exports2.OAuthClientMetadataSchema = exports2.OptionalSafeUrlSchema = exports2.OAuthErrorResponseSchema = exports2.OAuthTokensSchema = exports2.OpenIdProviderDiscoveryMetadataSchema = exports2.OpenIdProviderMetadataSchema = exports2.OAuthMetadataSchema = exports2.OAuthProtectedResourceMetadataSchema = exports2.SafeUrlSchema = void 0;
    var zod_1 = require_zod2();
    exports2.SafeUrlSchema = zod_1.z.string().url().superRefine((val, ctx) => {
      if (!URL.canParse(val)) {
        ctx.addIssue({
          code: zod_1.z.ZodIssueCode.custom,
          message: "URL must be parseable",
          fatal: true
        });
        return zod_1.z.NEVER;
      }
    }).refine((url) => {
      const u = new URL(url);
      return u.protocol !== "javascript:" && u.protocol !== "data:" && u.protocol !== "vbscript:";
    }, { message: "URL cannot use javascript:, data:, or vbscript: scheme" });
    exports2.OAuthProtectedResourceMetadataSchema = zod_1.z.object({
      resource: zod_1.z.string().url(),
      authorization_servers: zod_1.z.array(exports2.SafeUrlSchema).optional(),
      jwks_uri: zod_1.z.string().url().optional(),
      scopes_supported: zod_1.z.array(zod_1.z.string()).optional(),
      bearer_methods_supported: zod_1.z.array(zod_1.z.string()).optional(),
      resource_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
      resource_name: zod_1.z.string().optional(),
      resource_documentation: zod_1.z.string().optional(),
      resource_policy_uri: zod_1.z.string().url().optional(),
      resource_tos_uri: zod_1.z.string().url().optional(),
      tls_client_certificate_bound_access_tokens: zod_1.z.boolean().optional(),
      authorization_details_types_supported: zod_1.z.array(zod_1.z.string()).optional(),
      dpop_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
      dpop_bound_access_tokens_required: zod_1.z.boolean().optional()
    }).passthrough();
    exports2.OAuthMetadataSchema = zod_1.z.object({
      issuer: zod_1.z.string(),
      authorization_endpoint: exports2.SafeUrlSchema,
      token_endpoint: exports2.SafeUrlSchema,
      registration_endpoint: exports2.SafeUrlSchema.optional(),
      scopes_supported: zod_1.z.array(zod_1.z.string()).optional(),
      response_types_supported: zod_1.z.array(zod_1.z.string()),
      response_modes_supported: zod_1.z.array(zod_1.z.string()).optional(),
      grant_types_supported: zod_1.z.array(zod_1.z.string()).optional(),
      token_endpoint_auth_methods_supported: zod_1.z.array(zod_1.z.string()).optional(),
      token_endpoint_auth_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
      service_documentation: exports2.SafeUrlSchema.optional(),
      revocation_endpoint: exports2.SafeUrlSchema.optional(),
      revocation_endpoint_auth_methods_supported: zod_1.z.array(zod_1.z.string()).optional(),
      revocation_endpoint_auth_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
      introspection_endpoint: zod_1.z.string().optional(),
      introspection_endpoint_auth_methods_supported: zod_1.z.array(zod_1.z.string()).optional(),
      introspection_endpoint_auth_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
      code_challenge_methods_supported: zod_1.z.array(zod_1.z.string()).optional()
    }).passthrough();
    exports2.OpenIdProviderMetadataSchema = zod_1.z.object({
      issuer: zod_1.z.string(),
      authorization_endpoint: exports2.SafeUrlSchema,
      token_endpoint: exports2.SafeUrlSchema,
      userinfo_endpoint: exports2.SafeUrlSchema.optional(),
      jwks_uri: exports2.SafeUrlSchema,
      registration_endpoint: exports2.SafeUrlSchema.optional(),
      scopes_supported: zod_1.z.array(zod_1.z.string()).optional(),
      response_types_supported: zod_1.z.array(zod_1.z.string()),
      response_modes_supported: zod_1.z.array(zod_1.z.string()).optional(),
      grant_types_supported: zod_1.z.array(zod_1.z.string()).optional(),
      acr_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
      subject_types_supported: zod_1.z.array(zod_1.z.string()),
      id_token_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()),
      id_token_encryption_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
      id_token_encryption_enc_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
      userinfo_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
      userinfo_encryption_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
      userinfo_encryption_enc_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
      request_object_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
      request_object_encryption_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
      request_object_encryption_enc_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
      token_endpoint_auth_methods_supported: zod_1.z.array(zod_1.z.string()).optional(),
      token_endpoint_auth_signing_alg_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
      display_values_supported: zod_1.z.array(zod_1.z.string()).optional(),
      claim_types_supported: zod_1.z.array(zod_1.z.string()).optional(),
      claims_supported: zod_1.z.array(zod_1.z.string()).optional(),
      service_documentation: zod_1.z.string().optional(),
      claims_locales_supported: zod_1.z.array(zod_1.z.string()).optional(),
      ui_locales_supported: zod_1.z.array(zod_1.z.string()).optional(),
      claims_parameter_supported: zod_1.z.boolean().optional(),
      request_parameter_supported: zod_1.z.boolean().optional(),
      request_uri_parameter_supported: zod_1.z.boolean().optional(),
      require_request_uri_registration: zod_1.z.boolean().optional(),
      op_policy_uri: exports2.SafeUrlSchema.optional(),
      op_tos_uri: exports2.SafeUrlSchema.optional()
    }).passthrough();
    exports2.OpenIdProviderDiscoveryMetadataSchema = exports2.OpenIdProviderMetadataSchema.merge(exports2.OAuthMetadataSchema.pick({
      code_challenge_methods_supported: true
    }));
    exports2.OAuthTokensSchema = zod_1.z.object({
      access_token: zod_1.z.string(),
      id_token: zod_1.z.string().optional(),
      // Optional for OAuth 2.1, but necessary in OpenID Connect
      token_type: zod_1.z.string(),
      expires_in: zod_1.z.number().optional(),
      scope: zod_1.z.string().optional(),
      refresh_token: zod_1.z.string().optional()
    }).strip();
    exports2.OAuthErrorResponseSchema = zod_1.z.object({
      error: zod_1.z.string(),
      error_description: zod_1.z.string().optional(),
      error_uri: zod_1.z.string().optional()
    });
    exports2.OptionalSafeUrlSchema = exports2.SafeUrlSchema.optional().or(zod_1.z.literal("").transform(() => void 0));
    exports2.OAuthClientMetadataSchema = zod_1.z.object({
      redirect_uris: zod_1.z.array(exports2.SafeUrlSchema),
      token_endpoint_auth_method: zod_1.z.string().optional(),
      grant_types: zod_1.z.array(zod_1.z.string()).optional(),
      response_types: zod_1.z.array(zod_1.z.string()).optional(),
      client_name: zod_1.z.string().optional(),
      client_uri: exports2.SafeUrlSchema.optional(),
      logo_uri: exports2.OptionalSafeUrlSchema,
      scope: zod_1.z.string().optional(),
      contacts: zod_1.z.array(zod_1.z.string()).optional(),
      tos_uri: exports2.OptionalSafeUrlSchema,
      policy_uri: zod_1.z.string().optional(),
      jwks_uri: exports2.SafeUrlSchema.optional(),
      jwks: zod_1.z.any().optional(),
      software_id: zod_1.z.string().optional(),
      software_version: zod_1.z.string().optional(),
      software_statement: zod_1.z.string().optional()
    }).strip();
    exports2.OAuthClientInformationSchema = zod_1.z.object({
      client_id: zod_1.z.string(),
      client_secret: zod_1.z.string().optional(),
      client_id_issued_at: zod_1.z.number().optional(),
      client_secret_expires_at: zod_1.z.number().optional()
    }).strip();
    exports2.OAuthClientInformationFullSchema = exports2.OAuthClientMetadataSchema.merge(exports2.OAuthClientInformationSchema);
    exports2.OAuthClientRegistrationErrorSchema = zod_1.z.object({
      error: zod_1.z.string(),
      error_description: zod_1.z.string().optional()
    }).strip();
    exports2.OAuthTokenRevocationRequestSchema = zod_1.z.object({
      token: zod_1.z.string(),
      token_type_hint: zod_1.z.string().optional()
    }).strip();
  }
});

// node_modules/.pnpm/@modelcontextprotocol+sdk@1.20.2/node_modules/@modelcontextprotocol/sdk/dist/cjs/shared/auth-utils.js
var require_auth_utils = __commonJS({
  "node_modules/.pnpm/@modelcontextprotocol+sdk@1.20.2/node_modules/@modelcontextprotocol/sdk/dist/cjs/shared/auth-utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resourceUrlFromServerUrl = resourceUrlFromServerUrl;
    exports2.checkResourceAllowed = checkResourceAllowed;
    function resourceUrlFromServerUrl(url) {
      const resourceURL = typeof url === "string" ? new URL(url) : new URL(url.href);
      resourceURL.hash = "";
      return resourceURL;
    }
    function checkResourceAllowed({ requestedResource, configuredResource }) {
      const requested = typeof requestedResource === "string" ? new URL(requestedResource) : new URL(requestedResource.href);
      const configured = typeof configuredResource === "string" ? new URL(configuredResource) : new URL(configuredResource.href);
      if (requested.origin !== configured.origin) {
        return false;
      }
      if (requested.pathname.length < configured.pathname.length) {
        return false;
      }
      const requestedPath = requested.pathname.endsWith("/") ? requested.pathname : requested.pathname + "/";
      const configuredPath = configured.pathname.endsWith("/") ? configured.pathname : configured.pathname + "/";
      return requestedPath.startsWith(configuredPath);
    }
  }
});

// node_modules/.pnpm/@modelcontextprotocol+sdk@1.20.2/node_modules/@modelcontextprotocol/sdk/dist/cjs/server/auth/errors.js
var require_errors9 = __commonJS({
  "node_modules/.pnpm/@modelcontextprotocol+sdk@1.20.2/node_modules/@modelcontextprotocol/sdk/dist/cjs/server/auth/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OAUTH_ERRORS = exports2.CustomOAuthError = exports2.InsufficientScopeError = exports2.InvalidClientMetadataError = exports2.TooManyRequestsError = exports2.MethodNotAllowedError = exports2.InvalidTokenError = exports2.UnsupportedTokenTypeError = exports2.UnsupportedResponseTypeError = exports2.TemporarilyUnavailableError = exports2.ServerError = exports2.AccessDeniedError = exports2.InvalidScopeError = exports2.UnsupportedGrantTypeError = exports2.UnauthorizedClientError = exports2.InvalidGrantError = exports2.InvalidClientError = exports2.InvalidRequestError = exports2.OAuthError = void 0;
    var OAuthError = class extends Error {
      constructor(message, errorUri) {
        super(message);
        this.errorUri = errorUri;
        this.name = this.constructor.name;
      }
      /**
       * Converts the error to a standard OAuth error response object
       */
      toResponseObject() {
        const response = {
          error: this.errorCode,
          error_description: this.message
        };
        if (this.errorUri) {
          response.error_uri = this.errorUri;
        }
        return response;
      }
      get errorCode() {
        return this.constructor.errorCode;
      }
    };
    exports2.OAuthError = OAuthError;
    var InvalidRequestError = class extends OAuthError {
    };
    exports2.InvalidRequestError = InvalidRequestError;
    InvalidRequestError.errorCode = "invalid_request";
    var InvalidClientError = class extends OAuthError {
    };
    exports2.InvalidClientError = InvalidClientError;
    InvalidClientError.errorCode = "invalid_client";
    var InvalidGrantError = class extends OAuthError {
    };
    exports2.InvalidGrantError = InvalidGrantError;
    InvalidGrantError.errorCode = "invalid_grant";
    var UnauthorizedClientError = class extends OAuthError {
    };
    exports2.UnauthorizedClientError = UnauthorizedClientError;
    UnauthorizedClientError.errorCode = "unauthorized_client";
    var UnsupportedGrantTypeError = class extends OAuthError {
    };
    exports2.UnsupportedGrantTypeError = UnsupportedGrantTypeError;
    UnsupportedGrantTypeError.errorCode = "unsupported_grant_type";
    var InvalidScopeError = class extends OAuthError {
    };
    exports2.InvalidScopeError = InvalidScopeError;
    InvalidScopeError.errorCode = "invalid_scope";
    var AccessDeniedError = class extends OAuthError {
    };
    exports2.AccessDeniedError = AccessDeniedError;
    AccessDeniedError.errorCode = "access_denied";
    var ServerError = class extends OAuthError {
    };
    exports2.ServerError = ServerError;
    ServerError.errorCode = "server_error";
    var TemporarilyUnavailableError = class extends OAuthError {
    };
    exports2.TemporarilyUnavailableError = TemporarilyUnavailableError;
    TemporarilyUnavailableError.errorCode = "temporarily_unavailable";
    var UnsupportedResponseTypeError = class extends OAuthError {
    };
    exports2.UnsupportedResponseTypeError = UnsupportedResponseTypeError;
    UnsupportedResponseTypeError.errorCode = "unsupported_response_type";
    var UnsupportedTokenTypeError = class extends OAuthError {
    };
    exports2.UnsupportedTokenTypeError = UnsupportedTokenTypeError;
    UnsupportedTokenTypeError.errorCode = "unsupported_token_type";
    var InvalidTokenError = class extends OAuthError {
    };
    exports2.InvalidTokenError = InvalidTokenError;
    InvalidTokenError.errorCode = "invalid_token";
    var MethodNotAllowedError = class extends OAuthError {
    };
    exports2.MethodNotAllowedError = MethodNotAllowedError;
    MethodNotAllowedError.errorCode = "method_not_allowed";
    var TooManyRequestsError = class extends OAuthError {
    };
    exports2.TooManyRequestsError = TooManyRequestsError;
    TooManyRequestsError.errorCode = "too_many_requests";
    var InvalidClientMetadataError = class extends OAuthError {
    };
    exports2.InvalidClientMetadataError = InvalidClientMetadataError;
    InvalidClientMetadataError.errorCode = "invalid_client_metadata";
    var InsufficientScopeError = class extends OAuthError {
    };
    exports2.InsufficientScopeError = InsufficientScopeError;
    InsufficientScopeError.errorCode = "insufficient_scope";
    var CustomOAuthError = class extends OAuthError {
      constructor(customErrorCode, message, errorUri) {
        super(message, errorUri);
        this.customErrorCode = customErrorCode;
      }
      get errorCode() {
        return this.customErrorCode;
      }
    };
    exports2.CustomOAuthError = CustomOAuthError;
    exports2.OAUTH_ERRORS = {
      [InvalidRequestError.errorCode]: InvalidRequestError,
      [InvalidClientError.errorCode]: InvalidClientError,
      [InvalidGrantError.errorCode]: InvalidGrantError,
      [UnauthorizedClientError.errorCode]: UnauthorizedClientError,
      [UnsupportedGrantTypeError.errorCode]: UnsupportedGrantTypeError,
      [InvalidScopeError.errorCode]: InvalidScopeError,
      [AccessDeniedError.errorCode]: AccessDeniedError,
      [ServerError.errorCode]: ServerError,
      [TemporarilyUnavailableError.errorCode]: TemporarilyUnavailableError,
      [UnsupportedResponseTypeError.errorCode]: UnsupportedResponseTypeError,
      [UnsupportedTokenTypeError.errorCode]: UnsupportedTokenTypeError,
      [InvalidTokenError.errorCode]: InvalidTokenError,
      [MethodNotAllowedError.errorCode]: MethodNotAllowedError,
      [TooManyRequestsError.errorCode]: TooManyRequestsError,
      [InvalidClientMetadataError.errorCode]: InvalidClientMetadataError,
      [InsufficientScopeError.errorCode]: InsufficientScopeError
    };
  }
});

// node_modules/.pnpm/@modelcontextprotocol+sdk@1.20.2/node_modules/@modelcontextprotocol/sdk/dist/cjs/client/auth.js
var require_auth2 = __commonJS({
  "node_modules/.pnpm/@modelcontextprotocol+sdk@1.20.2/node_modules/@modelcontextprotocol/sdk/dist/cjs/client/auth.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnauthorizedError = void 0;
    exports2.parseErrorResponse = parseErrorResponse;
    exports2.auth = auth;
    exports2.selectResourceURL = selectResourceURL;
    exports2.extractResourceMetadataUrl = extractResourceMetadataUrl;
    exports2.discoverOAuthProtectedResourceMetadata = discoverOAuthProtectedResourceMetadata;
    exports2.discoverOAuthMetadata = discoverOAuthMetadata;
    exports2.buildDiscoveryUrls = buildDiscoveryUrls;
    exports2.discoverAuthorizationServerMetadata = discoverAuthorizationServerMetadata;
    exports2.startAuthorization = startAuthorization;
    exports2.exchangeAuthorization = exchangeAuthorization;
    exports2.refreshAuthorization = refreshAuthorization;
    exports2.registerClient = registerClient;
    var pkce_challenge_1 = __importDefault(require_index_node());
    var types_js_1 = require_types9();
    var auth_js_1 = require_auth();
    var auth_js_2 = require_auth();
    var auth_utils_js_1 = require_auth_utils();
    var errors_js_1 = require_errors9();
    var UnauthorizedError = class extends Error {
      constructor(message) {
        super(message !== null && message !== void 0 ? message : "Unauthorized");
      }
    };
    exports2.UnauthorizedError = UnauthorizedError;
    var AUTHORIZATION_CODE_RESPONSE_TYPE = "code";
    var AUTHORIZATION_CODE_CHALLENGE_METHOD = "S256";
    function selectClientAuthMethod(clientInformation, supportedMethods) {
      const hasClientSecret = clientInformation.client_secret !== void 0;
      if (supportedMethods.length === 0) {
        return hasClientSecret ? "client_secret_post" : "none";
      }
      if (hasClientSecret && supportedMethods.includes("client_secret_basic")) {
        return "client_secret_basic";
      }
      if (hasClientSecret && supportedMethods.includes("client_secret_post")) {
        return "client_secret_post";
      }
      if (supportedMethods.includes("none")) {
        return "none";
      }
      return hasClientSecret ? "client_secret_post" : "none";
    }
    function applyClientAuthentication(method, clientInformation, headers, params) {
      const { client_id, client_secret } = clientInformation;
      switch (method) {
        case "client_secret_basic":
          applyBasicAuth(client_id, client_secret, headers);
          return;
        case "client_secret_post":
          applyPostAuth(client_id, client_secret, params);
          return;
        case "none":
          applyPublicAuth(client_id, params);
          return;
        default:
          throw new Error(`Unsupported client authentication method: ${method}`);
      }
    }
    function applyBasicAuth(clientId, clientSecret, headers) {
      if (!clientSecret) {
        throw new Error("client_secret_basic authentication requires a client_secret");
      }
      const credentials = btoa(`${clientId}:${clientSecret}`);
      headers.set("Authorization", `Basic ${credentials}`);
    }
    function applyPostAuth(clientId, clientSecret, params) {
      params.set("client_id", clientId);
      if (clientSecret) {
        params.set("client_secret", clientSecret);
      }
    }
    function applyPublicAuth(clientId, params) {
      params.set("client_id", clientId);
    }
    async function parseErrorResponse(input) {
      const statusCode = input instanceof Response ? input.status : void 0;
      const body = input instanceof Response ? await input.text() : input;
      try {
        const result = auth_js_1.OAuthErrorResponseSchema.parse(JSON.parse(body));
        const { error, error_description, error_uri } = result;
        const errorClass = errors_js_1.OAUTH_ERRORS[error] || errors_js_1.ServerError;
        return new errorClass(error_description || "", error_uri);
      } catch (error) {
        const errorMessage = `${statusCode ? `HTTP ${statusCode}: ` : ""}Invalid OAuth error response: ${error}. Raw body: ${body}`;
        return new errors_js_1.ServerError(errorMessage);
      }
    }
    async function auth(provider, options) {
      var _a, _b;
      try {
        return await authInternal(provider, options);
      } catch (error) {
        if (error instanceof errors_js_1.InvalidClientError || error instanceof errors_js_1.UnauthorizedClientError) {
          await ((_a = provider.invalidateCredentials) === null || _a === void 0 ? void 0 : _a.call(provider, "all"));
          return await authInternal(provider, options);
        } else if (error instanceof errors_js_1.InvalidGrantError) {
          await ((_b = provider.invalidateCredentials) === null || _b === void 0 ? void 0 : _b.call(provider, "tokens"));
          return await authInternal(provider, options);
        }
        throw error;
      }
    }
    async function authInternal(provider, { serverUrl, authorizationCode, scope, resourceMetadataUrl, fetchFn }) {
      let resourceMetadata;
      let authorizationServerUrl;
      try {
        resourceMetadata = await discoverOAuthProtectedResourceMetadata(serverUrl, { resourceMetadataUrl }, fetchFn);
        if (resourceMetadata.authorization_servers && resourceMetadata.authorization_servers.length > 0) {
          authorizationServerUrl = resourceMetadata.authorization_servers[0];
        }
      } catch (_a) {
      }
      if (!authorizationServerUrl) {
        authorizationServerUrl = serverUrl;
      }
      const resource = await selectResourceURL(serverUrl, provider, resourceMetadata);
      const metadata = await discoverAuthorizationServerMetadata(authorizationServerUrl, {
        fetchFn
      });
      let clientInformation = await Promise.resolve(provider.clientInformation());
      if (!clientInformation) {
        if (authorizationCode !== void 0) {
          throw new Error("Existing OAuth client information is required when exchanging an authorization code");
        }
        if (!provider.saveClientInformation) {
          throw new Error("OAuth client information must be saveable for dynamic registration");
        }
        const fullInformation = await registerClient(authorizationServerUrl, {
          metadata,
          clientMetadata: provider.clientMetadata,
          fetchFn
        });
        await provider.saveClientInformation(fullInformation);
        clientInformation = fullInformation;
      }
      if (authorizationCode !== void 0) {
        const codeVerifier2 = await provider.codeVerifier();
        const tokens2 = await exchangeAuthorization(authorizationServerUrl, {
          metadata,
          clientInformation,
          authorizationCode,
          codeVerifier: codeVerifier2,
          redirectUri: provider.redirectUrl,
          resource,
          addClientAuthentication: provider.addClientAuthentication,
          fetchFn
        });
        await provider.saveTokens(tokens2);
        return "AUTHORIZED";
      }
      const tokens = await provider.tokens();
      if (tokens === null || tokens === void 0 ? void 0 : tokens.refresh_token) {
        try {
          const newTokens = await refreshAuthorization(authorizationServerUrl, {
            metadata,
            clientInformation,
            refreshToken: tokens.refresh_token,
            resource,
            addClientAuthentication: provider.addClientAuthentication,
            fetchFn
          });
          await provider.saveTokens(newTokens);
          return "AUTHORIZED";
        } catch (error) {
          if (!(error instanceof errors_js_1.OAuthError) || error instanceof errors_js_1.ServerError) {
          } else {
            throw error;
          }
        }
      }
      const state = provider.state ? await provider.state() : void 0;
      const { authorizationUrl, codeVerifier } = await startAuthorization(authorizationServerUrl, {
        metadata,
        clientInformation,
        state,
        redirectUrl: provider.redirectUrl,
        scope: scope || provider.clientMetadata.scope,
        resource
      });
      await provider.saveCodeVerifier(codeVerifier);
      await provider.redirectToAuthorization(authorizationUrl);
      return "REDIRECT";
    }
    async function selectResourceURL(serverUrl, provider, resourceMetadata) {
      const defaultResource = (0, auth_utils_js_1.resourceUrlFromServerUrl)(serverUrl);
      if (provider.validateResourceURL) {
        return await provider.validateResourceURL(defaultResource, resourceMetadata === null || resourceMetadata === void 0 ? void 0 : resourceMetadata.resource);
      }
      if (!resourceMetadata) {
        return void 0;
      }
      if (!(0, auth_utils_js_1.checkResourceAllowed)({ requestedResource: defaultResource, configuredResource: resourceMetadata.resource })) {
        throw new Error(`Protected resource ${resourceMetadata.resource} does not match expected ${defaultResource} (or origin)`);
      }
      return new URL(resourceMetadata.resource);
    }
    function extractResourceMetadataUrl(res) {
      const authenticateHeader = res.headers.get("WWW-Authenticate");
      if (!authenticateHeader) {
        return void 0;
      }
      const [type, scheme] = authenticateHeader.split(" ");
      if (type.toLowerCase() !== "bearer" || !scheme) {
        return void 0;
      }
      const regex = /resource_metadata="([^"]*)"/;
      const match = regex.exec(authenticateHeader);
      if (!match) {
        return void 0;
      }
      try {
        return new URL(match[1]);
      } catch (_a) {
        return void 0;
      }
    }
    async function discoverOAuthProtectedResourceMetadata(serverUrl, opts, fetchFn = fetch) {
      const response = await discoverMetadataWithFallback(serverUrl, "oauth-protected-resource", fetchFn, {
        protocolVersion: opts === null || opts === void 0 ? void 0 : opts.protocolVersion,
        metadataUrl: opts === null || opts === void 0 ? void 0 : opts.resourceMetadataUrl
      });
      if (!response || response.status === 404) {
        throw new Error(`Resource server does not implement OAuth 2.0 Protected Resource Metadata.`);
      }
      if (!response.ok) {
        throw new Error(`HTTP ${response.status} trying to load well-known OAuth protected resource metadata.`);
      }
      return auth_js_2.OAuthProtectedResourceMetadataSchema.parse(await response.json());
    }
    async function fetchWithCorsRetry(url, headers, fetchFn = fetch) {
      try {
        return await fetchFn(url, { headers });
      } catch (error) {
        if (error instanceof TypeError) {
          if (headers) {
            return fetchWithCorsRetry(url, void 0, fetchFn);
          } else {
            return void 0;
          }
        }
        throw error;
      }
    }
    function buildWellKnownPath(wellKnownPrefix, pathname = "", options = {}) {
      if (pathname.endsWith("/")) {
        pathname = pathname.slice(0, -1);
      }
      return options.prependPathname ? `${pathname}/.well-known/${wellKnownPrefix}` : `/.well-known/${wellKnownPrefix}${pathname}`;
    }
    async function tryMetadataDiscovery(url, protocolVersion, fetchFn = fetch) {
      const headers = {
        "MCP-Protocol-Version": protocolVersion
      };
      return await fetchWithCorsRetry(url, headers, fetchFn);
    }
    function shouldAttemptFallback(response, pathname) {
      return !response || response.status >= 400 && response.status < 500 && pathname !== "/";
    }
    async function discoverMetadataWithFallback(serverUrl, wellKnownType, fetchFn, opts) {
      var _a, _b;
      const issuer = new URL(serverUrl);
      const protocolVersion = (_a = opts === null || opts === void 0 ? void 0 : opts.protocolVersion) !== null && _a !== void 0 ? _a : types_js_1.LATEST_PROTOCOL_VERSION;
      let url;
      if (opts === null || opts === void 0 ? void 0 : opts.metadataUrl) {
        url = new URL(opts.metadataUrl);
      } else {
        const wellKnownPath = buildWellKnownPath(wellKnownType, issuer.pathname);
        url = new URL(wellKnownPath, (_b = opts === null || opts === void 0 ? void 0 : opts.metadataServerUrl) !== null && _b !== void 0 ? _b : issuer);
        url.search = issuer.search;
      }
      let response = await tryMetadataDiscovery(url, protocolVersion, fetchFn);
      if (!(opts === null || opts === void 0 ? void 0 : opts.metadataUrl) && shouldAttemptFallback(response, issuer.pathname)) {
        const rootUrl = new URL(`/.well-known/${wellKnownType}`, issuer);
        response = await tryMetadataDiscovery(rootUrl, protocolVersion, fetchFn);
      }
      return response;
    }
    async function discoverOAuthMetadata(issuer, { authorizationServerUrl, protocolVersion } = {}, fetchFn = fetch) {
      if (typeof issuer === "string") {
        issuer = new URL(issuer);
      }
      if (!authorizationServerUrl) {
        authorizationServerUrl = issuer;
      }
      if (typeof authorizationServerUrl === "string") {
        authorizationServerUrl = new URL(authorizationServerUrl);
      }
      protocolVersion !== null && protocolVersion !== void 0 ? protocolVersion : protocolVersion = types_js_1.LATEST_PROTOCOL_VERSION;
      const response = await discoverMetadataWithFallback(authorizationServerUrl, "oauth-authorization-server", fetchFn, {
        protocolVersion,
        metadataServerUrl: authorizationServerUrl
      });
      if (!response || response.status === 404) {
        return void 0;
      }
      if (!response.ok) {
        throw new Error(`HTTP ${response.status} trying to load well-known OAuth metadata`);
      }
      return auth_js_2.OAuthMetadataSchema.parse(await response.json());
    }
    function buildDiscoveryUrls(authorizationServerUrl) {
      const url = typeof authorizationServerUrl === "string" ? new URL(authorizationServerUrl) : authorizationServerUrl;
      const hasPath = url.pathname !== "/";
      const urlsToTry = [];
      if (!hasPath) {
        urlsToTry.push({
          url: new URL("/.well-known/oauth-authorization-server", url.origin),
          type: "oauth"
        });
        urlsToTry.push({
          url: new URL(`/.well-known/openid-configuration`, url.origin),
          type: "oidc"
        });
        return urlsToTry;
      }
      let pathname = url.pathname;
      if (pathname.endsWith("/")) {
        pathname = pathname.slice(0, -1);
      }
      urlsToTry.push({
        url: new URL(`/.well-known/oauth-authorization-server${pathname}`, url.origin),
        type: "oauth"
      });
      urlsToTry.push({
        url: new URL("/.well-known/oauth-authorization-server", url.origin),
        type: "oauth"
      });
      urlsToTry.push({
        url: new URL(`/.well-known/openid-configuration${pathname}`, url.origin),
        type: "oidc"
      });
      urlsToTry.push({
        url: new URL(`${pathname}/.well-known/openid-configuration`, url.origin),
        type: "oidc"
      });
      return urlsToTry;
    }
    async function discoverAuthorizationServerMetadata(authorizationServerUrl, { fetchFn = fetch, protocolVersion = types_js_1.LATEST_PROTOCOL_VERSION } = {}) {
      const headers = {
        "MCP-Protocol-Version": protocolVersion,
        Accept: "application/json"
      };
      const urlsToTry = buildDiscoveryUrls(authorizationServerUrl);
      for (const { url: endpointUrl, type } of urlsToTry) {
        const response = await fetchWithCorsRetry(endpointUrl, headers, fetchFn);
        if (!response) {
          continue;
        }
        if (!response.ok) {
          if (response.status >= 400 && response.status < 500) {
            continue;
          }
          throw new Error(`HTTP ${response.status} trying to load ${type === "oauth" ? "OAuth" : "OpenID provider"} metadata from ${endpointUrl}`);
        }
        if (type === "oauth") {
          return auth_js_2.OAuthMetadataSchema.parse(await response.json());
        } else {
          return auth_js_1.OpenIdProviderDiscoveryMetadataSchema.parse(await response.json());
        }
      }
      return void 0;
    }
    async function startAuthorization(authorizationServerUrl, { metadata, clientInformation, redirectUrl, scope, state, resource }) {
      let authorizationUrl;
      if (metadata) {
        authorizationUrl = new URL(metadata.authorization_endpoint);
        if (!metadata.response_types_supported.includes(AUTHORIZATION_CODE_RESPONSE_TYPE)) {
          throw new Error(`Incompatible auth server: does not support response type ${AUTHORIZATION_CODE_RESPONSE_TYPE}`);
        }
        if (metadata.code_challenge_methods_supported && !metadata.code_challenge_methods_supported.includes(AUTHORIZATION_CODE_CHALLENGE_METHOD)) {
          throw new Error(`Incompatible auth server: does not support code challenge method ${AUTHORIZATION_CODE_CHALLENGE_METHOD}`);
        }
      } else {
        authorizationUrl = new URL("/authorize", authorizationServerUrl);
      }
      const challenge = await (0, pkce_challenge_1.default)();
      const codeVerifier = challenge.code_verifier;
      const codeChallenge = challenge.code_challenge;
      authorizationUrl.searchParams.set("response_type", AUTHORIZATION_CODE_RESPONSE_TYPE);
      authorizationUrl.searchParams.set("client_id", clientInformation.client_id);
      authorizationUrl.searchParams.set("code_challenge", codeChallenge);
      authorizationUrl.searchParams.set("code_challenge_method", AUTHORIZATION_CODE_CHALLENGE_METHOD);
      authorizationUrl.searchParams.set("redirect_uri", String(redirectUrl));
      if (state) {
        authorizationUrl.searchParams.set("state", state);
      }
      if (scope) {
        authorizationUrl.searchParams.set("scope", scope);
      }
      if (scope === null || scope === void 0 ? void 0 : scope.includes("offline_access")) {
        authorizationUrl.searchParams.append("prompt", "consent");
      }
      if (resource) {
        authorizationUrl.searchParams.set("resource", resource.href);
      }
      return { authorizationUrl, codeVerifier };
    }
    async function exchangeAuthorization(authorizationServerUrl, { metadata, clientInformation, authorizationCode, codeVerifier, redirectUri, resource, addClientAuthentication, fetchFn }) {
      var _a;
      const grantType = "authorization_code";
      const tokenUrl = (metadata === null || metadata === void 0 ? void 0 : metadata.token_endpoint) ? new URL(metadata.token_endpoint) : new URL("/token", authorizationServerUrl);
      if ((metadata === null || metadata === void 0 ? void 0 : metadata.grant_types_supported) && !metadata.grant_types_supported.includes(grantType)) {
        throw new Error(`Incompatible auth server: does not support grant type ${grantType}`);
      }
      const headers = new Headers({
        "Content-Type": "application/x-www-form-urlencoded",
        Accept: "application/json"
      });
      const params = new URLSearchParams({
        grant_type: grantType,
        code: authorizationCode,
        code_verifier: codeVerifier,
        redirect_uri: String(redirectUri)
      });
      if (addClientAuthentication) {
        addClientAuthentication(headers, params, authorizationServerUrl, metadata);
      } else {
        const supportedMethods = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.token_endpoint_auth_methods_supported) !== null && _a !== void 0 ? _a : [];
        const authMethod = selectClientAuthMethod(clientInformation, supportedMethods);
        applyClientAuthentication(authMethod, clientInformation, headers, params);
      }
      if (resource) {
        params.set("resource", resource.href);
      }
      const response = await (fetchFn !== null && fetchFn !== void 0 ? fetchFn : fetch)(tokenUrl, {
        method: "POST",
        headers,
        body: params
      });
      if (!response.ok) {
        throw await parseErrorResponse(response);
      }
      return auth_js_2.OAuthTokensSchema.parse(await response.json());
    }
    async function refreshAuthorization(authorizationServerUrl, { metadata, clientInformation, refreshToken, resource, addClientAuthentication, fetchFn }) {
      var _a;
      const grantType = "refresh_token";
      let tokenUrl;
      if (metadata) {
        tokenUrl = new URL(metadata.token_endpoint);
        if (metadata.grant_types_supported && !metadata.grant_types_supported.includes(grantType)) {
          throw new Error(`Incompatible auth server: does not support grant type ${grantType}`);
        }
      } else {
        tokenUrl = new URL("/token", authorizationServerUrl);
      }
      const headers = new Headers({
        "Content-Type": "application/x-www-form-urlencoded"
      });
      const params = new URLSearchParams({
        grant_type: grantType,
        refresh_token: refreshToken
      });
      if (addClientAuthentication) {
        addClientAuthentication(headers, params, authorizationServerUrl, metadata);
      } else {
        const supportedMethods = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.token_endpoint_auth_methods_supported) !== null && _a !== void 0 ? _a : [];
        const authMethod = selectClientAuthMethod(clientInformation, supportedMethods);
        applyClientAuthentication(authMethod, clientInformation, headers, params);
      }
      if (resource) {
        params.set("resource", resource.href);
      }
      const response = await (fetchFn !== null && fetchFn !== void 0 ? fetchFn : fetch)(tokenUrl, {
        method: "POST",
        headers,
        body: params
      });
      if (!response.ok) {
        throw await parseErrorResponse(response);
      }
      return auth_js_2.OAuthTokensSchema.parse({ refresh_token: refreshToken, ...await response.json() });
    }
    async function registerClient(authorizationServerUrl, { metadata, clientMetadata, fetchFn }) {
      let registrationUrl;
      if (metadata) {
        if (!metadata.registration_endpoint) {
          throw new Error("Incompatible auth server: does not support dynamic client registration");
        }
        registrationUrl = new URL(metadata.registration_endpoint);
      } else {
        registrationUrl = new URL("/register", authorizationServerUrl);
      }
      const response = await (fetchFn !== null && fetchFn !== void 0 ? fetchFn : fetch)(registrationUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(clientMetadata)
      });
      if (!response.ok) {
        throw await parseErrorResponse(response);
      }
      return auth_js_2.OAuthClientInformationFullSchema.parse(await response.json());
    }
  }
});

// node_modules/.pnpm/@modelcontextprotocol+sdk@1.20.2/node_modules/@modelcontextprotocol/sdk/dist/cjs/client/sse.js
var require_sse = __commonJS({
  "node_modules/.pnpm/@modelcontextprotocol+sdk@1.20.2/node_modules/@modelcontextprotocol/sdk/dist/cjs/client/sse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SSEClientTransport = exports2.SseError = void 0;
    var eventsource_1 = require_dist7();
    var types_js_1 = require_types9();
    var auth_js_1 = require_auth2();
    var SseError = class extends Error {
      constructor(code, message, event) {
        super(`SSE error: ${message}`);
        this.code = code;
        this.event = event;
      }
    };
    exports2.SseError = SseError;
    var SSEClientTransport = class {
      constructor(url, opts) {
        this._url = url;
        this._resourceMetadataUrl = void 0;
        this._eventSourceInit = opts === null || opts === void 0 ? void 0 : opts.eventSourceInit;
        this._requestInit = opts === null || opts === void 0 ? void 0 : opts.requestInit;
        this._authProvider = opts === null || opts === void 0 ? void 0 : opts.authProvider;
        this._fetch = opts === null || opts === void 0 ? void 0 : opts.fetch;
      }
      async _authThenStart() {
        var _a;
        if (!this._authProvider) {
          throw new auth_js_1.UnauthorizedError("No auth provider");
        }
        let result;
        try {
          result = await (0, auth_js_1.auth)(this._authProvider, {
            serverUrl: this._url,
            resourceMetadataUrl: this._resourceMetadataUrl,
            fetchFn: this._fetch
          });
        } catch (error) {
          (_a = this.onerror) === null || _a === void 0 ? void 0 : _a.call(this, error);
          throw error;
        }
        if (result !== "AUTHORIZED") {
          throw new auth_js_1.UnauthorizedError();
        }
        return await this._startOrAuth();
      }
      async _commonHeaders() {
        var _a;
        const headers = {};
        if (this._authProvider) {
          const tokens = await this._authProvider.tokens();
          if (tokens) {
            headers["Authorization"] = `Bearer ${tokens.access_token}`;
          }
        }
        if (this._protocolVersion) {
          headers["mcp-protocol-version"] = this._protocolVersion;
        }
        return new Headers({ ...headers, ...(_a = this._requestInit) === null || _a === void 0 ? void 0 : _a.headers });
      }
      _startOrAuth() {
        var _a, _b, _c;
        const fetchImpl = (_c = (_b = (_a = this === null || this === void 0 ? void 0 : this._eventSourceInit) === null || _a === void 0 ? void 0 : _a.fetch) !== null && _b !== void 0 ? _b : this._fetch) !== null && _c !== void 0 ? _c : fetch;
        return new Promise((resolve, reject) => {
          this._eventSource = new eventsource_1.EventSource(this._url.href, {
            ...this._eventSourceInit,
            fetch: async (url, init) => {
              const headers = await this._commonHeaders();
              headers.set("Accept", "text/event-stream");
              const response = await fetchImpl(url, {
                ...init,
                headers
              });
              if (response.status === 401 && response.headers.has("www-authenticate")) {
                this._resourceMetadataUrl = (0, auth_js_1.extractResourceMetadataUrl)(response);
              }
              return response;
            }
          });
          this._abortController = new AbortController();
          this._eventSource.onerror = (event) => {
            var _a2;
            if (event.code === 401 && this._authProvider) {
              this._authThenStart().then(resolve, reject);
              return;
            }
            const error = new SseError(event.code, event.message, event);
            reject(error);
            (_a2 = this.onerror) === null || _a2 === void 0 ? void 0 : _a2.call(this, error);
          };
          this._eventSource.onopen = () => {
          };
          this._eventSource.addEventListener("endpoint", (event) => {
            var _a2;
            const messageEvent = event;
            try {
              this._endpoint = new URL(messageEvent.data, this._url);
              if (this._endpoint.origin !== this._url.origin) {
                throw new Error(`Endpoint origin does not match connection origin: ${this._endpoint.origin}`);
              }
            } catch (error) {
              reject(error);
              (_a2 = this.onerror) === null || _a2 === void 0 ? void 0 : _a2.call(this, error);
              void this.close();
              return;
            }
            resolve();
          });
          this._eventSource.onmessage = (event) => {
            var _a2, _b2;
            const messageEvent = event;
            let message;
            try {
              message = types_js_1.JSONRPCMessageSchema.parse(JSON.parse(messageEvent.data));
            } catch (error) {
              (_a2 = this.onerror) === null || _a2 === void 0 ? void 0 : _a2.call(this, error);
              return;
            }
            (_b2 = this.onmessage) === null || _b2 === void 0 ? void 0 : _b2.call(this, message);
          };
        });
      }
      async start() {
        if (this._eventSource) {
          throw new Error("SSEClientTransport already started! If using Client class, note that connect() calls start() automatically.");
        }
        return await this._startOrAuth();
      }
      /**
       * Call this method after the user has finished authorizing via their user agent and is redirected back to the MCP client application. This will exchange the authorization code for an access token, enabling the next connection attempt to successfully auth.
       */
      async finishAuth(authorizationCode) {
        if (!this._authProvider) {
          throw new auth_js_1.UnauthorizedError("No auth provider");
        }
        const result = await (0, auth_js_1.auth)(this._authProvider, {
          serverUrl: this._url,
          authorizationCode,
          resourceMetadataUrl: this._resourceMetadataUrl,
          fetchFn: this._fetch
        });
        if (result !== "AUTHORIZED") {
          throw new auth_js_1.UnauthorizedError("Failed to authorize");
        }
      }
      async close() {
        var _a, _b, _c;
        (_a = this._abortController) === null || _a === void 0 ? void 0 : _a.abort();
        (_b = this._eventSource) === null || _b === void 0 ? void 0 : _b.close();
        (_c = this.onclose) === null || _c === void 0 ? void 0 : _c.call(this);
      }
      async send(message) {
        var _a, _b, _c;
        if (!this._endpoint) {
          throw new Error("Not connected");
        }
        try {
          const headers = await this._commonHeaders();
          headers.set("content-type", "application/json");
          const init = {
            ...this._requestInit,
            method: "POST",
            headers,
            body: JSON.stringify(message),
            signal: (_a = this._abortController) === null || _a === void 0 ? void 0 : _a.signal
          };
          const response = await ((_b = this._fetch) !== null && _b !== void 0 ? _b : fetch)(this._endpoint, init);
          if (!response.ok) {
            if (response.status === 401 && this._authProvider) {
              this._resourceMetadataUrl = (0, auth_js_1.extractResourceMetadataUrl)(response);
              const result = await (0, auth_js_1.auth)(this._authProvider, {
                serverUrl: this._url,
                resourceMetadataUrl: this._resourceMetadataUrl,
                fetchFn: this._fetch
              });
              if (result !== "AUTHORIZED") {
                throw new auth_js_1.UnauthorizedError();
              }
              return this.send(message);
            }
            const text = await response.text().catch(() => null);
            throw new Error(`Error POSTing to endpoint (HTTP ${response.status}): ${text}`);
          }
        } catch (error) {
          (_c = this.onerror) === null || _c === void 0 ? void 0 : _c.call(this, error);
          throw error;
        }
      }
      setProtocolVersion(version2) {
        this._protocolVersion = version2;
      }
    };
    exports2.SSEClientTransport = SSEClientTransport;
  }
});

// node_modules/.pnpm/eventsource-parser@3.0.6/node_modules/eventsource-parser/dist/stream.cjs
var require_stream4 = __commonJS({
  "node_modules/.pnpm/eventsource-parser@3.0.6/node_modules/eventsource-parser/dist/stream.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var index = require_dist6();
    var EventSourceParserStream = class extends TransformStream {
      constructor({ onError, onRetry, onComment } = {}) {
        let parser;
        super({
          start(controller) {
            parser = index.createParser({
              onEvent: (event) => {
                controller.enqueue(event);
              },
              onError(error) {
                onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
              },
              onRetry,
              onComment
            });
          },
          transform(chunk) {
            parser.feed(chunk);
          }
        });
      }
    };
    exports2.ParseError = index.ParseError;
    exports2.EventSourceParserStream = EventSourceParserStream;
  }
});

// node_modules/.pnpm/@modelcontextprotocol+sdk@1.20.2/node_modules/@modelcontextprotocol/sdk/dist/cjs/client/streamableHttp.js
var require_streamableHttp = __commonJS({
  "node_modules/.pnpm/@modelcontextprotocol+sdk@1.20.2/node_modules/@modelcontextprotocol/sdk/dist/cjs/client/streamableHttp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StreamableHTTPClientTransport = exports2.StreamableHTTPError = void 0;
    var types_js_1 = require_types9();
    var auth_js_1 = require_auth2();
    var stream_1 = require_stream4();
    var DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS = {
      initialReconnectionDelay: 1e3,
      maxReconnectionDelay: 3e4,
      reconnectionDelayGrowFactor: 1.5,
      maxRetries: 2
    };
    var StreamableHTTPError = class extends Error {
      constructor(code, message) {
        super(`Streamable HTTP error: ${message}`);
        this.code = code;
      }
    };
    exports2.StreamableHTTPError = StreamableHTTPError;
    var StreamableHTTPClientTransport = class {
      constructor(url, opts) {
        var _a;
        this._hasCompletedAuthFlow = false;
        this._url = url;
        this._resourceMetadataUrl = void 0;
        this._requestInit = opts === null || opts === void 0 ? void 0 : opts.requestInit;
        this._authProvider = opts === null || opts === void 0 ? void 0 : opts.authProvider;
        this._fetch = opts === null || opts === void 0 ? void 0 : opts.fetch;
        this._sessionId = opts === null || opts === void 0 ? void 0 : opts.sessionId;
        this._reconnectionOptions = (_a = opts === null || opts === void 0 ? void 0 : opts.reconnectionOptions) !== null && _a !== void 0 ? _a : DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS;
      }
      async _authThenStart() {
        var _a;
        if (!this._authProvider) {
          throw new auth_js_1.UnauthorizedError("No auth provider");
        }
        let result;
        try {
          result = await (0, auth_js_1.auth)(this._authProvider, {
            serverUrl: this._url,
            resourceMetadataUrl: this._resourceMetadataUrl,
            fetchFn: this._fetch
          });
        } catch (error) {
          (_a = this.onerror) === null || _a === void 0 ? void 0 : _a.call(this, error);
          throw error;
        }
        if (result !== "AUTHORIZED") {
          throw new auth_js_1.UnauthorizedError();
        }
        return await this._startOrAuthSse({ resumptionToken: void 0 });
      }
      async _commonHeaders() {
        var _a;
        const headers = {};
        if (this._authProvider) {
          const tokens = await this._authProvider.tokens();
          if (tokens) {
            headers["Authorization"] = `Bearer ${tokens.access_token}`;
          }
        }
        if (this._sessionId) {
          headers["mcp-session-id"] = this._sessionId;
        }
        if (this._protocolVersion) {
          headers["mcp-protocol-version"] = this._protocolVersion;
        }
        const extraHeaders = this._normalizeHeaders((_a = this._requestInit) === null || _a === void 0 ? void 0 : _a.headers);
        return new Headers({
          ...headers,
          ...extraHeaders
        });
      }
      async _startOrAuthSse(options) {
        var _a, _b, _c;
        const { resumptionToken } = options;
        try {
          const headers = await this._commonHeaders();
          headers.set("Accept", "text/event-stream");
          if (resumptionToken) {
            headers.set("last-event-id", resumptionToken);
          }
          const response = await ((_a = this._fetch) !== null && _a !== void 0 ? _a : fetch)(this._url, {
            method: "GET",
            headers,
            signal: (_b = this._abortController) === null || _b === void 0 ? void 0 : _b.signal
          });
          if (!response.ok) {
            if (response.status === 401 && this._authProvider) {
              return await this._authThenStart();
            }
            if (response.status === 405) {
              return;
            }
            throw new StreamableHTTPError(response.status, `Failed to open SSE stream: ${response.statusText}`);
          }
          this._handleSseStream(response.body, options, true);
        } catch (error) {
          (_c = this.onerror) === null || _c === void 0 ? void 0 : _c.call(this, error);
          throw error;
        }
      }
      /**
       * Calculates the next reconnection delay using  backoff algorithm
       *
       * @param attempt Current reconnection attempt count for the specific stream
       * @returns Time to wait in milliseconds before next reconnection attempt
       */
      _getNextReconnectionDelay(attempt) {
        const initialDelay = this._reconnectionOptions.initialReconnectionDelay;
        const growFactor = this._reconnectionOptions.reconnectionDelayGrowFactor;
        const maxDelay = this._reconnectionOptions.maxReconnectionDelay;
        return Math.min(initialDelay * Math.pow(growFactor, attempt), maxDelay);
      }
      _normalizeHeaders(headers) {
        if (!headers)
          return {};
        if (headers instanceof Headers) {
          return Object.fromEntries(headers.entries());
        }
        if (Array.isArray(headers)) {
          return Object.fromEntries(headers);
        }
        return { ...headers };
      }
      /**
       * Schedule a reconnection attempt with exponential backoff
       *
       * @param lastEventId The ID of the last received event for resumability
       * @param attemptCount Current reconnection attempt count for this specific stream
       */
      _scheduleReconnection(options, attemptCount = 0) {
        var _a;
        const maxRetries = this._reconnectionOptions.maxRetries;
        if (maxRetries > 0 && attemptCount >= maxRetries) {
          (_a = this.onerror) === null || _a === void 0 ? void 0 : _a.call(this, new Error(`Maximum reconnection attempts (${maxRetries}) exceeded.`));
          return;
        }
        const delay = this._getNextReconnectionDelay(attemptCount);
        setTimeout(() => {
          this._startOrAuthSse(options).catch((error) => {
            var _a2;
            (_a2 = this.onerror) === null || _a2 === void 0 ? void 0 : _a2.call(this, new Error(`Failed to reconnect SSE stream: ${error instanceof Error ? error.message : String(error)}`));
            this._scheduleReconnection(options, attemptCount + 1);
          });
        }, delay);
      }
      _handleSseStream(stream, options, isReconnectable) {
        if (!stream) {
          return;
        }
        const { onresumptiontoken, replayMessageId } = options;
        let lastEventId;
        const processStream = async () => {
          var _a, _b, _c, _d;
          try {
            const reader = stream.pipeThrough(new TextDecoderStream()).pipeThrough(new stream_1.EventSourceParserStream()).getReader();
            while (true) {
              const { value: event, done } = await reader.read();
              if (done) {
                break;
              }
              if (event.id) {
                lastEventId = event.id;
                onresumptiontoken === null || onresumptiontoken === void 0 ? void 0 : onresumptiontoken(event.id);
              }
              if (!event.event || event.event === "message") {
                try {
                  const message = types_js_1.JSONRPCMessageSchema.parse(JSON.parse(event.data));
                  if (replayMessageId !== void 0 && (0, types_js_1.isJSONRPCResponse)(message)) {
                    message.id = replayMessageId;
                  }
                  (_a = this.onmessage) === null || _a === void 0 ? void 0 : _a.call(this, message);
                } catch (error) {
                  (_b = this.onerror) === null || _b === void 0 ? void 0 : _b.call(this, error);
                }
              }
            }
          } catch (error) {
            (_c = this.onerror) === null || _c === void 0 ? void 0 : _c.call(this, new Error(`SSE stream disconnected: ${error}`));
            if (isReconnectable && this._abortController && !this._abortController.signal.aborted) {
              try {
                this._scheduleReconnection({
                  resumptionToken: lastEventId,
                  onresumptiontoken,
                  replayMessageId
                }, 0);
              } catch (error2) {
                (_d = this.onerror) === null || _d === void 0 ? void 0 : _d.call(this, new Error(`Failed to reconnect: ${error2 instanceof Error ? error2.message : String(error2)}`));
              }
            }
          }
        };
        processStream();
      }
      async start() {
        if (this._abortController) {
          throw new Error("StreamableHTTPClientTransport already started! If using Client class, note that connect() calls start() automatically.");
        }
        this._abortController = new AbortController();
      }
      /**
       * Call this method after the user has finished authorizing via their user agent and is redirected back to the MCP client application. This will exchange the authorization code for an access token, enabling the next connection attempt to successfully auth.
       */
      async finishAuth(authorizationCode) {
        if (!this._authProvider) {
          throw new auth_js_1.UnauthorizedError("No auth provider");
        }
        const result = await (0, auth_js_1.auth)(this._authProvider, {
          serverUrl: this._url,
          authorizationCode,
          resourceMetadataUrl: this._resourceMetadataUrl,
          fetchFn: this._fetch
        });
        if (result !== "AUTHORIZED") {
          throw new auth_js_1.UnauthorizedError("Failed to authorize");
        }
      }
      async close() {
        var _a, _b;
        (_a = this._abortController) === null || _a === void 0 ? void 0 : _a.abort();
        (_b = this.onclose) === null || _b === void 0 ? void 0 : _b.call(this);
      }
      async send(message, options) {
        var _a, _b, _c, _d;
        try {
          const { resumptionToken, onresumptiontoken } = options || {};
          if (resumptionToken) {
            this._startOrAuthSse({ resumptionToken, replayMessageId: (0, types_js_1.isJSONRPCRequest)(message) ? message.id : void 0 }).catch((err) => {
              var _a2;
              return (_a2 = this.onerror) === null || _a2 === void 0 ? void 0 : _a2.call(this, err);
            });
            return;
          }
          const headers = await this._commonHeaders();
          headers.set("content-type", "application/json");
          headers.set("accept", "application/json, text/event-stream");
          const init = {
            ...this._requestInit,
            method: "POST",
            headers,
            body: JSON.stringify(message),
            signal: (_a = this._abortController) === null || _a === void 0 ? void 0 : _a.signal
          };
          const response = await ((_b = this._fetch) !== null && _b !== void 0 ? _b : fetch)(this._url, init);
          const sessionId = response.headers.get("mcp-session-id");
          if (sessionId) {
            this._sessionId = sessionId;
          }
          if (!response.ok) {
            if (response.status === 401 && this._authProvider) {
              if (this._hasCompletedAuthFlow) {
                throw new StreamableHTTPError(401, "Server returned 401 after successful authentication");
              }
              this._resourceMetadataUrl = (0, auth_js_1.extractResourceMetadataUrl)(response);
              const result = await (0, auth_js_1.auth)(this._authProvider, {
                serverUrl: this._url,
                resourceMetadataUrl: this._resourceMetadataUrl,
                fetchFn: this._fetch
              });
              if (result !== "AUTHORIZED") {
                throw new auth_js_1.UnauthorizedError();
              }
              this._hasCompletedAuthFlow = true;
              return this.send(message);
            }
            const text = await response.text().catch(() => null);
            throw new Error(`Error POSTing to endpoint (HTTP ${response.status}): ${text}`);
          }
          this._hasCompletedAuthFlow = false;
          if (response.status === 202) {
            if ((0, types_js_1.isInitializedNotification)(message)) {
              this._startOrAuthSse({ resumptionToken: void 0 }).catch((err) => {
                var _a2;
                return (_a2 = this.onerror) === null || _a2 === void 0 ? void 0 : _a2.call(this, err);
              });
            }
            return;
          }
          const messages = Array.isArray(message) ? message : [message];
          const hasRequests = messages.filter((msg) => "method" in msg && "id" in msg && msg.id !== void 0).length > 0;
          const contentType = response.headers.get("content-type");
          if (hasRequests) {
            if (contentType === null || contentType === void 0 ? void 0 : contentType.includes("text/event-stream")) {
              this._handleSseStream(response.body, { onresumptiontoken }, false);
            } else if (contentType === null || contentType === void 0 ? void 0 : contentType.includes("application/json")) {
              const data = await response.json();
              const responseMessages = Array.isArray(data) ? data.map((msg) => types_js_1.JSONRPCMessageSchema.parse(msg)) : [types_js_1.JSONRPCMessageSchema.parse(data)];
              for (const msg of responseMessages) {
                (_c = this.onmessage) === null || _c === void 0 ? void 0 : _c.call(this, msg);
              }
            } else {
              throw new StreamableHTTPError(-1, `Unexpected content type: ${contentType}`);
            }
          }
        } catch (error) {
          (_d = this.onerror) === null || _d === void 0 ? void 0 : _d.call(this, error);
          throw error;
        }
      }
      get sessionId() {
        return this._sessionId;
      }
      /**
       * Terminates the current session by sending a DELETE request to the server.
       *
       * Clients that no longer need a particular session
       * (e.g., because the user is leaving the client application) SHOULD send an
       * HTTP DELETE to the MCP endpoint with the Mcp-Session-Id header to explicitly
       * terminate the session.
       *
       * The server MAY respond with HTTP 405 Method Not Allowed, indicating that
       * the server does not allow clients to terminate sessions.
       */
      async terminateSession() {
        var _a, _b, _c;
        if (!this._sessionId) {
          return;
        }
        try {
          const headers = await this._commonHeaders();
          const init = {
            ...this._requestInit,
            method: "DELETE",
            headers,
            signal: (_a = this._abortController) === null || _a === void 0 ? void 0 : _a.signal
          };
          const response = await ((_b = this._fetch) !== null && _b !== void 0 ? _b : fetch)(this._url, init);
          if (!response.ok && response.status !== 405) {
            throw new StreamableHTTPError(response.status, `Failed to terminate session: ${response.statusText}`);
          }
          this._sessionId = void 0;
        } catch (error) {
          (_c = this.onerror) === null || _c === void 0 ? void 0 : _c.call(this, error);
          throw error;
        }
      }
      setProtocolVersion(version2) {
        this._protocolVersion = version2;
      }
      get protocolVersion() {
        return this._protocolVersion;
      }
    };
    exports2.StreamableHTTPClientTransport = StreamableHTTPClientTransport;
  }
});

// node_modules/.pnpm/@modelcontextprotocol+sdk@1.20.2/node_modules/@modelcontextprotocol/sdk/dist/cjs/shared/protocol.js
var require_protocol = __commonJS({
  "node_modules/.pnpm/@modelcontextprotocol+sdk@1.20.2/node_modules/@modelcontextprotocol/sdk/dist/cjs/shared/protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Protocol = exports2.DEFAULT_REQUEST_TIMEOUT_MSEC = void 0;
    exports2.mergeCapabilities = mergeCapabilities;
    var types_js_1 = require_types9();
    exports2.DEFAULT_REQUEST_TIMEOUT_MSEC = 6e4;
    var Protocol = class {
      constructor(_options) {
        this._options = _options;
        this._requestMessageId = 0;
        this._requestHandlers = /* @__PURE__ */ new Map();
        this._requestHandlerAbortControllers = /* @__PURE__ */ new Map();
        this._notificationHandlers = /* @__PURE__ */ new Map();
        this._responseHandlers = /* @__PURE__ */ new Map();
        this._progressHandlers = /* @__PURE__ */ new Map();
        this._timeoutInfo = /* @__PURE__ */ new Map();
        this._pendingDebouncedNotifications = /* @__PURE__ */ new Set();
        this.setNotificationHandler(types_js_1.CancelledNotificationSchema, (notification) => {
          const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);
          controller === null || controller === void 0 ? void 0 : controller.abort(notification.params.reason);
        });
        this.setNotificationHandler(types_js_1.ProgressNotificationSchema, (notification) => {
          this._onprogress(notification);
        });
        this.setRequestHandler(
          types_js_1.PingRequestSchema,
          // Automatic pong by default.
          (_request) => ({})
        );
      }
      _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {
        this._timeoutInfo.set(messageId, {
          timeoutId: setTimeout(onTimeout, timeout),
          startTime: Date.now(),
          timeout,
          maxTotalTimeout,
          resetTimeoutOnProgress,
          onTimeout
        });
      }
      _resetTimeout(messageId) {
        const info = this._timeoutInfo.get(messageId);
        if (!info)
          return false;
        const totalElapsed = Date.now() - info.startTime;
        if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {
          this._timeoutInfo.delete(messageId);
          throw new types_js_1.McpError(types_js_1.ErrorCode.RequestTimeout, "Maximum total timeout exceeded", {
            maxTotalTimeout: info.maxTotalTimeout,
            totalElapsed
          });
        }
        clearTimeout(info.timeoutId);
        info.timeoutId = setTimeout(info.onTimeout, info.timeout);
        return true;
      }
      _cleanupTimeout(messageId) {
        const info = this._timeoutInfo.get(messageId);
        if (info) {
          clearTimeout(info.timeoutId);
          this._timeoutInfo.delete(messageId);
        }
      }
      /**
       * Attaches to the given transport, starts it, and starts listening for messages.
       *
       * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
       */
      async connect(transport) {
        var _a, _b, _c;
        this._transport = transport;
        const _onclose = (_a = this.transport) === null || _a === void 0 ? void 0 : _a.onclose;
        this._transport.onclose = () => {
          _onclose === null || _onclose === void 0 ? void 0 : _onclose();
          this._onclose();
        };
        const _onerror = (_b = this.transport) === null || _b === void 0 ? void 0 : _b.onerror;
        this._transport.onerror = (error) => {
          _onerror === null || _onerror === void 0 ? void 0 : _onerror(error);
          this._onerror(error);
        };
        const _onmessage = (_c = this._transport) === null || _c === void 0 ? void 0 : _c.onmessage;
        this._transport.onmessage = (message, extra) => {
          _onmessage === null || _onmessage === void 0 ? void 0 : _onmessage(message, extra);
          if ((0, types_js_1.isJSONRPCResponse)(message) || (0, types_js_1.isJSONRPCError)(message)) {
            this._onresponse(message);
          } else if ((0, types_js_1.isJSONRPCRequest)(message)) {
            this._onrequest(message, extra);
          } else if ((0, types_js_1.isJSONRPCNotification)(message)) {
            this._onnotification(message);
          } else {
            this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));
          }
        };
        await this._transport.start();
      }
      _onclose() {
        var _a;
        const responseHandlers = this._responseHandlers;
        this._responseHandlers = /* @__PURE__ */ new Map();
        this._progressHandlers.clear();
        this._pendingDebouncedNotifications.clear();
        this._transport = void 0;
        (_a = this.onclose) === null || _a === void 0 ? void 0 : _a.call(this);
        const error = new types_js_1.McpError(types_js_1.ErrorCode.ConnectionClosed, "Connection closed");
        for (const handler of responseHandlers.values()) {
          handler(error);
        }
      }
      _onerror(error) {
        var _a;
        (_a = this.onerror) === null || _a === void 0 ? void 0 : _a.call(this, error);
      }
      _onnotification(notification) {
        var _a;
        const handler = (_a = this._notificationHandlers.get(notification.method)) !== null && _a !== void 0 ? _a : this.fallbackNotificationHandler;
        if (handler === void 0) {
          return;
        }
        Promise.resolve().then(() => handler(notification)).catch((error) => this._onerror(new Error(`Uncaught error in notification handler: ${error}`)));
      }
      _onrequest(request, extra) {
        var _a, _b;
        const handler = (_a = this._requestHandlers.get(request.method)) !== null && _a !== void 0 ? _a : this.fallbackRequestHandler;
        const capturedTransport = this._transport;
        if (handler === void 0) {
          capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.send({
            jsonrpc: "2.0",
            id: request.id,
            error: {
              code: types_js_1.ErrorCode.MethodNotFound,
              message: "Method not found"
            }
          }).catch((error) => this._onerror(new Error(`Failed to send an error response: ${error}`)));
          return;
        }
        const abortController = new AbortController();
        this._requestHandlerAbortControllers.set(request.id, abortController);
        const fullExtra = {
          signal: abortController.signal,
          sessionId: capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.sessionId,
          _meta: (_b = request.params) === null || _b === void 0 ? void 0 : _b._meta,
          sendNotification: (notification) => this.notification(notification, { relatedRequestId: request.id }),
          sendRequest: (r, resultSchema, options) => this.request(r, resultSchema, { ...options, relatedRequestId: request.id }),
          authInfo: extra === null || extra === void 0 ? void 0 : extra.authInfo,
          requestId: request.id,
          requestInfo: extra === null || extra === void 0 ? void 0 : extra.requestInfo
        };
        Promise.resolve().then(() => handler(request, fullExtra)).then((result) => {
          if (abortController.signal.aborted) {
            return;
          }
          return capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.send({
            result,
            jsonrpc: "2.0",
            id: request.id
          });
        }, (error) => {
          var _a2;
          if (abortController.signal.aborted) {
            return;
          }
          return capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.send({
            jsonrpc: "2.0",
            id: request.id,
            error: {
              code: Number.isSafeInteger(error["code"]) ? error["code"] : types_js_1.ErrorCode.InternalError,
              message: (_a2 = error.message) !== null && _a2 !== void 0 ? _a2 : "Internal error"
            }
          });
        }).catch((error) => this._onerror(new Error(`Failed to send response: ${error}`))).finally(() => {
          this._requestHandlerAbortControllers.delete(request.id);
        });
      }
      _onprogress(notification) {
        const { progressToken, ...params } = notification.params;
        const messageId = Number(progressToken);
        const handler = this._progressHandlers.get(messageId);
        if (!handler) {
          this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
          return;
        }
        const responseHandler = this._responseHandlers.get(messageId);
        const timeoutInfo = this._timeoutInfo.get(messageId);
        if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) {
          try {
            this._resetTimeout(messageId);
          } catch (error) {
            responseHandler(error);
            return;
          }
        }
        handler(params);
      }
      _onresponse(response) {
        const messageId = Number(response.id);
        const handler = this._responseHandlers.get(messageId);
        if (handler === void 0) {
          this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
          return;
        }
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        if ((0, types_js_1.isJSONRPCResponse)(response)) {
          handler(response);
        } else {
          const error = new types_js_1.McpError(response.error.code, response.error.message, response.error.data);
          handler(error);
        }
      }
      get transport() {
        return this._transport;
      }
      /**
       * Closes the connection.
       */
      async close() {
        var _a;
        await ((_a = this._transport) === null || _a === void 0 ? void 0 : _a.close());
      }
      /**
       * Sends a request and wait for a response.
       *
       * Do not use this method to emit notifications! Use notification() instead.
       */
      request(request, resultSchema, options) {
        const { relatedRequestId, resumptionToken, onresumptiontoken } = options !== null && options !== void 0 ? options : {};
        return new Promise((resolve, reject) => {
          var _a, _b, _c, _d, _e, _f;
          if (!this._transport) {
            reject(new Error("Not connected"));
            return;
          }
          if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.enforceStrictCapabilities) === true) {
            this.assertCapabilityForMethod(request.method);
          }
          (_b = options === null || options === void 0 ? void 0 : options.signal) === null || _b === void 0 ? void 0 : _b.throwIfAborted();
          const messageId = this._requestMessageId++;
          const jsonrpcRequest = {
            ...request,
            jsonrpc: "2.0",
            id: messageId
          };
          if (options === null || options === void 0 ? void 0 : options.onprogress) {
            this._progressHandlers.set(messageId, options.onprogress);
            jsonrpcRequest.params = {
              ...request.params,
              _meta: {
                ...((_c = request.params) === null || _c === void 0 ? void 0 : _c._meta) || {},
                progressToken: messageId
              }
            };
          }
          const cancel = (reason) => {
            var _a2;
            this._responseHandlers.delete(messageId);
            this._progressHandlers.delete(messageId);
            this._cleanupTimeout(messageId);
            (_a2 = this._transport) === null || _a2 === void 0 ? void 0 : _a2.send({
              jsonrpc: "2.0",
              method: "notifications/cancelled",
              params: {
                requestId: messageId,
                reason: String(reason)
              }
            }, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error) => this._onerror(new Error(`Failed to send cancellation: ${error}`)));
            reject(reason);
          };
          this._responseHandlers.set(messageId, (response) => {
            var _a2;
            if ((_a2 = options === null || options === void 0 ? void 0 : options.signal) === null || _a2 === void 0 ? void 0 : _a2.aborted) {
              return;
            }
            if (response instanceof Error) {
              return reject(response);
            }
            try {
              const result = resultSchema.parse(response.result);
              resolve(result);
            } catch (error) {
              reject(error);
            }
          });
          (_d = options === null || options === void 0 ? void 0 : options.signal) === null || _d === void 0 ? void 0 : _d.addEventListener("abort", () => {
            var _a2;
            cancel((_a2 = options === null || options === void 0 ? void 0 : options.signal) === null || _a2 === void 0 ? void 0 : _a2.reason);
          });
          const timeout = (_e = options === null || options === void 0 ? void 0 : options.timeout) !== null && _e !== void 0 ? _e : exports2.DEFAULT_REQUEST_TIMEOUT_MSEC;
          const timeoutHandler = () => cancel(new types_js_1.McpError(types_js_1.ErrorCode.RequestTimeout, "Request timed out", { timeout }));
          this._setupTimeout(messageId, timeout, options === null || options === void 0 ? void 0 : options.maxTotalTimeout, timeoutHandler, (_f = options === null || options === void 0 ? void 0 : options.resetTimeoutOnProgress) !== null && _f !== void 0 ? _f : false);
          this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error) => {
            this._cleanupTimeout(messageId);
            reject(error);
          });
        });
      }
      /**
       * Emits a notification, which is a one-way message that does not expect a response.
       */
      async notification(notification, options) {
        var _a, _b;
        if (!this._transport) {
          throw new Error("Not connected");
        }
        this.assertNotificationCapability(notification.method);
        const debouncedMethods = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.debouncedNotificationMethods) !== null && _b !== void 0 ? _b : [];
        const canDebounce = debouncedMethods.includes(notification.method) && !notification.params && !(options === null || options === void 0 ? void 0 : options.relatedRequestId);
        if (canDebounce) {
          if (this._pendingDebouncedNotifications.has(notification.method)) {
            return;
          }
          this._pendingDebouncedNotifications.add(notification.method);
          Promise.resolve().then(() => {
            var _a2;
            this._pendingDebouncedNotifications.delete(notification.method);
            if (!this._transport) {
              return;
            }
            const jsonrpcNotification2 = {
              ...notification,
              jsonrpc: "2.0"
            };
            (_a2 = this._transport) === null || _a2 === void 0 ? void 0 : _a2.send(jsonrpcNotification2, options).catch((error) => this._onerror(error));
          });
          return;
        }
        const jsonrpcNotification = {
          ...notification,
          jsonrpc: "2.0"
        };
        await this._transport.send(jsonrpcNotification, options);
      }
      /**
       * Registers a handler to invoke when this protocol object receives a request with the given method.
       *
       * Note that this will replace any previous request handler for the same method.
       */
      setRequestHandler(requestSchema, handler) {
        const method = requestSchema.shape.method.value;
        this.assertRequestHandlerCapability(method);
        this._requestHandlers.set(method, (request, extra) => {
          return Promise.resolve(handler(requestSchema.parse(request), extra));
        });
      }
      /**
       * Removes the request handler for the given method.
       */
      removeRequestHandler(method) {
        this._requestHandlers.delete(method);
      }
      /**
       * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
       */
      assertCanSetRequestHandler(method) {
        if (this._requestHandlers.has(method)) {
          throw new Error(`A request handler for ${method} already exists, which would be overridden`);
        }
      }
      /**
       * Registers a handler to invoke when this protocol object receives a notification with the given method.
       *
       * Note that this will replace any previous notification handler for the same method.
       */
      setNotificationHandler(notificationSchema, handler) {
        this._notificationHandlers.set(notificationSchema.shape.method.value, (notification) => Promise.resolve(handler(notificationSchema.parse(notification))));
      }
      /**
       * Removes the notification handler for the given method.
       */
      removeNotificationHandler(method) {
        this._notificationHandlers.delete(method);
      }
    };
    exports2.Protocol = Protocol;
    function mergeCapabilities(base, additional) {
      return Object.entries(additional).reduce((acc, [key, value]) => {
        if (value && typeof value === "object") {
          acc[key] = acc[key] ? { ...acc[key], ...value } : value;
        } else {
          acc[key] = value;
        }
        return acc;
      }, { ...base });
    }
  }
});

// node_modules/.pnpm/uri-js@4.4.1/node_modules/uri-js/dist/es5/uri.all.js
var require_uri_all = __commonJS({
  "node_modules/.pnpm/uri-js@4.4.1/node_modules/uri-js/dist/es5/uri.all.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.URI = global2.URI || {});
    })(exports2, (function(exports3) {
      "use strict";
      function merge() {
        for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
          sets[_key] = arguments[_key];
        }
        if (sets.length > 1) {
          sets[0] = sets[0].slice(0, -1);
          var xl = sets.length - 1;
          for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
          }
          sets[xl] = sets[xl].slice(1);
          return sets.join("");
        } else {
          return sets[0];
        }
      }
      function subexp(str) {
        return "(?:" + str + ")";
      }
      function typeOf(o) {
        return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
      }
      function toUpperCase(str) {
        return str.toUpperCase();
      }
      function toArray(obj) {
        return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
      }
      function assign(target, source) {
        var obj = target;
        if (source) {
          for (var key in source) {
            obj[key] = source[key];
          }
        }
        return obj;
      }
      function buildExps(isIRI2) {
        var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
        return {
          NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
          NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
          OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
          PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
          IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
          IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
          //RFC 6874, with relaxed parsing rules
        };
      }
      var URI_PROTOCOL = buildExps(false);
      var IRI_PROTOCOL = buildExps(true);
      var slicedToArray = /* @__PURE__ */ (function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      })();
      var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
          return arr2;
        } else {
          return Array.from(arr);
        }
      };
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7E]/;
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      var baseMinusTMin = base - tMin;
      var floor = Math.floor;
      var stringFromCharCode = String.fromCharCode;
      function error$1(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, fn) {
        var result = [];
        var length = array.length;
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while (counter < length) {
          var value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      var ucs2encode = function ucs2encode2(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
      };
      var basicToDigit = function basicToDigit2(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      };
      var digitToBasic = function digitToBasic2(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      var adapt = function adapt2(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (
          ;
          /* no initialization */
          delta > baseMinusTMin * tMax >> 1;
          k += base
        ) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var decode = function decode2(input) {
        var output = [];
        var inputLength = input.length;
        var i = 0;
        var n = initialN;
        var bias = initialBias;
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (var j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error$1("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          var oldi = i;
          for (
            var w = 1, k = base;
            ;
            /* no condition */
            k += base
          ) {
            if (index >= inputLength) {
              error$1("invalid-input");
            }
            var digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error$1("overflow");
            }
            i += digit * w;
            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            var baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error$1("overflow");
            }
            w *= baseMinusT;
          }
          var out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error$1("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return String.fromCodePoint.apply(String, output);
      };
      var encode = function encode2(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _currentValue2 = _step.value;
            if (_currentValue2 < 128) {
              output.push(stringFromCharCode(_currentValue2));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          var m = maxInt;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var currentValue = _step2.value;
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error$1("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _currentValue = _step3.value;
              if (_currentValue < n && ++delta > maxInt) {
                error$1("overflow");
              }
              if (_currentValue == n) {
                var q = delta;
                for (
                  var k = base;
                  ;
                  /* no condition */
                  k += base
                ) {
                  var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t) {
                    break;
                  }
                  var qMinusT = q - t;
                  var baseMinusT = base - t;
                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      };
      var toUnicode = function toUnicode2(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      };
      var toASCII = function toASCII2(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      };
      var punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "2.1.0",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      var SCHEMES = {};
      function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16) e = "%0" + c.toString(16).toUpperCase();
        else if (c < 128) e = "%" + c.toString(16).toUpperCase();
        else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        return e;
      }
      function pctDecChars(str) {
        var newStr = "";
        var i = 0;
        var il = str.length;
        while (i < il) {
          var c = parseInt(str.substr(i + 1, 2), 16);
          if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
          } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
              var c2 = parseInt(str.substr(i + 4, 2), 16);
              newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
              newStr += str.substr(i, 6);
            }
            i += 6;
          } else if (c >= 224) {
            if (il - i >= 9) {
              var _c = parseInt(str.substr(i + 4, 2), 16);
              var c3 = parseInt(str.substr(i + 7, 2), 16);
              newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
              newStr += str.substr(i, 9);
            }
            i += 9;
          } else {
            newStr += str.substr(i, 3);
            i += 3;
          }
        }
        return newStr;
      }
      function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved2(str) {
          var decStr = pctDecChars(str);
          return !decStr.match(protocol.UNRESERVED) ? str : decStr;
        }
        if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== void 0) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== void 0) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== void 0) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== void 0) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== void 0) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
      }
      function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
      }
      function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches, 2), address = _matches[1];
        if (address) {
          return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
          return host;
        }
      }
      function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
          var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
          var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
          var lastFields = last.split(":").map(_stripLeadingZeros);
          var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
          var fieldCount = isLastFieldIPv4Address ? 7 : 8;
          var lastFieldsStart = lastFields.length - fieldCount;
          var fields = Array(fieldCount);
          for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
          }
          if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
          }
          var allZeroFields = fields.reduce(function(acc, field, index) {
            if (!field || field === "0") {
              var lastLongest = acc[acc.length - 1];
              if (lastLongest && lastLongest.index + lastLongest.length === index) {
                lastLongest.length++;
              } else {
                acc.push({ index, length: 1 });
              }
            }
            return acc;
          }, []);
          var longestZeroFields = allZeroFields.sort(function(a, b) {
            return b.length - a.length;
          })[0];
          var newHost = void 0;
          if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
          } else {
            newHost = fields.join(":");
          }
          if (zone) {
            newHost += "%" + zone;
          }
          return newHost;
        } else {
          return host;
        }
      }
      var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
      var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
      function parse2(uriString) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
          if (NO_MATCH_IS_UNDEFINED) {
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            if (isNaN(components.port)) {
              components.port = matches[5];
            }
          } else {
            components.scheme = matches[1] || void 0;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
            if (isNaN(components.port)) {
              components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
            }
          }
          if (components.host) {
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
          }
          if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
            components.reference = "same-document";
          } else if (components.scheme === void 0) {
            components.reference = "relative";
          } else if (components.fragment === void 0) {
            components.reference = "absolute";
          } else {
            components.reference = "uri";
          }
          if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
          }
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
              try {
                components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
              } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
              }
            }
            _normalizeComponentEncoding(components, URI_PROTOCOL);
          } else {
            _normalizeComponentEncoding(components, protocol);
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
          }
        } else {
          components.error = components.error || "URI can not be parsed.";
        }
        return components;
      }
      function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
          }));
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      var RDS1 = /^\.\.?\//;
      var RDS2 = /^\/\.(\/|$)/;
      var RDS3 = /^\/\.\.(\/|$)/;
      var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
      function removeDotSegments(input) {
        var output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            var im = input.match(RDS5);
            if (im) {
              var s = im[0];
              input = input.slice(s.length);
              output.push(s);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }
      function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
        if (components.host) {
          if (protocol.IPV6ADDRESS.test(components.host)) {
          } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
            try {
              components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
          }
        }
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme);
          uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          var s = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
          }
          if (authority === void 0) {
            s = s.replace(/^\/\//, "/%2F");
          }
          uriTokens.push(s);
        }
        if (components.query !== void 0) {
          uriTokens.push("?");
          uriTokens.push(components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#");
          uriTokens.push(components.fragment);
        }
        return uriTokens.join("");
      }
      function resolveComponents(base2, relative) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
          base2 = parse2(serialize(base2, options), options);
          relative = parse2(serialize(relative, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
          target.scheme = relative.scheme;
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (!relative.path) {
              target.path = base2.path;
              if (relative.query !== void 0) {
                target.query = relative.query;
              } else {
                target.query = base2.query;
              }
            } else {
              if (relative.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative.path);
              } else {
                if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                  target.path = "/" + relative.path;
                } else if (!base2.path) {
                  target.path = relative.path;
                } else {
                  target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative.query;
            }
            target.userinfo = base2.userinfo;
            target.host = base2.host;
            target.port = base2.port;
          }
          target.scheme = base2.scheme;
        }
        target.fragment = relative.fragment;
        return target;
      }
      function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({ scheme: "null" }, options);
        return serialize(resolveComponents(parse2(baseURI, schemelessOptions), parse2(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
      }
      function normalize(uri, options) {
        if (typeof uri === "string") {
          uri = serialize(parse2(uri, options), options);
        } else if (typeOf(uri) === "object") {
          uri = parse2(serialize(uri, options), options);
        }
        return uri;
      }
      function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = serialize(parse2(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
          uriA = serialize(uriA, options);
        }
        if (typeof uriB === "string") {
          uriB = serialize(parse2(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
          uriB = serialize(uriB, options);
        }
        return uriA === uriB;
      }
      function escapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
      }
      function unescapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
      }
      var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse3(components, options) {
          if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
          }
          return components;
        },
        serialize: function serialize2(components, options) {
          var secure = String(components.scheme).toLowerCase() === "https";
          if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = void 0;
          }
          if (!components.path) {
            components.path = "/";
          }
          return components;
        }
      };
      var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
      };
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse3(components, options) {
          var wsComponents = components;
          wsComponents.secure = isSecure(wsComponents);
          wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
          wsComponents.path = void 0;
          wsComponents.query = void 0;
          return wsComponents;
        },
        serialize: function serialize2(wsComponents, options) {
          if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = void 0;
          }
          if (typeof wsComponents.secure === "boolean") {
            wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
            wsComponents.secure = void 0;
          }
          if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
            wsComponents.path = path && path !== "/" ? path : void 0;
            wsComponents.query = query;
            wsComponents.resourceName = void 0;
          }
          wsComponents.fragment = void 0;
          return wsComponents;
        }
      };
      var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
      };
      var O = {};
      var isIRI = true;
      var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
      var HEXDIG$$ = "[0-9A-Fa-f]";
      var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
      var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
      var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
      var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
      var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
      var UNRESERVED = new RegExp(UNRESERVED$$, "g");
      var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
      var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
      var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
      var NOT_HFVALUE = NOT_HFNAME;
      function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
      }
      var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
          var mailtoComponents = components;
          var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
          mailtoComponents.path = void 0;
          if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
              var hfield = hfields[x].split("=");
              switch (hfield[0]) {
                case "to":
                  var toAddrs = hfield[1].split(",");
                  for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                    to.push(toAddrs[_x]);
                  }
                  break;
                case "subject":
                  mailtoComponents.subject = unescapeComponent(hfield[1], options);
                  break;
                case "body":
                  mailtoComponents.body = unescapeComponent(hfield[1], options);
                  break;
                default:
                  unknownHeaders = true;
                  headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                  break;
              }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
          }
          mailtoComponents.query = void 0;
          for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
              try {
                addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
              } catch (e) {
                mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
              }
            } else {
              addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
          }
          return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
          var components = mailtoComponents;
          var to = toArray(mailtoComponents.to);
          if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
              var toAddr = String(to[x]);
              var atIdx = toAddr.lastIndexOf("@");
              var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
              var domain = toAddr.slice(atIdx + 1);
              try {
                domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
              } catch (e) {
                components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
              }
              to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
          }
          var headers = mailtoComponents.headers = mailtoComponents.headers || {};
          if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
          if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
          var fields = [];
          for (var name in headers) {
            if (headers[name] !== O[name]) {
              fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
          }
          if (fields.length) {
            components.query = fields.join("&");
          }
          return components;
        }
      };
      var URN_PARSE = /^([^\:]+)\:(.*)/;
      var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
          var matches = components.path && components.path.match(URN_PARSE);
          var urnComponents = components;
          if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = void 0;
            if (schemeHandler) {
              urnComponents = schemeHandler.parse(urnComponents, options);
            }
          } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
          }
          return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = urnComponents.nid;
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
          }
          var uriComponents = urnComponents;
          var nss = urnComponents.nss;
          uriComponents.path = (nid || options.nid) + ":" + nss;
          return uriComponents;
        }
      };
      var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
      var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse3(urnComponents, options) {
          var uuidComponents = urnComponents;
          uuidComponents.uuid = uuidComponents.nss;
          uuidComponents.nss = void 0;
          if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
          }
          return uuidComponents;
        },
        serialize: function serialize2(uuidComponents, options) {
          var urnComponents = uuidComponents;
          urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
          return urnComponents;
        }
      };
      SCHEMES[handler.scheme] = handler;
      SCHEMES[handler$1.scheme] = handler$1;
      SCHEMES[handler$2.scheme] = handler$2;
      SCHEMES[handler$3.scheme] = handler$3;
      SCHEMES[handler$4.scheme] = handler$4;
      SCHEMES[handler$5.scheme] = handler$5;
      SCHEMES[handler$6.scheme] = handler$6;
      exports3.SCHEMES = SCHEMES;
      exports3.pctEncChar = pctEncChar;
      exports3.pctDecChars = pctDecChars;
      exports3.parse = parse2;
      exports3.removeDotSegments = removeDotSegments;
      exports3.serialize = serialize;
      exports3.resolveComponents = resolveComponents;
      exports3.resolve = resolve;
      exports3.normalize = normalize;
      exports3.equal = equal;
      exports3.escapeComponent = escapeComponent;
      exports3.unescapeComponent = unescapeComponent;
      Object.defineProperty(exports3, "__esModule", { value: true });
    }));
  }
});

// node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/ucs2length.js"(exports2, module2) {
    "use strict";
    module2.exports = function ucs2length(str) {
      var length = 0, len = str.length, pos = 0, value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) == 56320) pos++;
        }
      }
      return length;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/util.js
var require_util5 = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/util.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      copy,
      checkDataType,
      checkDataTypes,
      coerceToTypes,
      toHash,
      getProperty,
      escapeQuotes,
      equal: require_fast_deep_equal(),
      ucs2length: require_ucs2length(),
      varOccurences,
      varReplace,
      schemaHasRules,
      schemaHasRulesExcept,
      schemaUnknownRules,
      toQuotedString,
      getPathExpr,
      getPath,
      getData,
      unescapeFragment,
      unescapeJsonPointer,
      escapeFragment,
      escapeJsonPointer
    };
    function copy(o, to) {
      to = to || {};
      for (var key in o) to[key] = o[key];
      return to;
    }
    function checkDataType(dataType, data, strictNumbers, negate) {
      var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK = negate ? "!" : "", NOT = negate ? "" : "!";
      switch (dataType) {
        case "null":
          return data + EQUAL + "null";
        case "array":
          return OK + "Array.isArray(" + data + ")";
        case "object":
          return "(" + OK + data + AND + "typeof " + data + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data + "))";
        case "integer":
          return "(typeof " + data + EQUAL + '"number"' + AND + NOT + "(" + data + " % 1)" + AND + data + EQUAL + data + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
        case "number":
          return "(typeof " + data + EQUAL + '"' + dataType + '"' + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
        default:
          return "typeof " + data + EQUAL + '"' + dataType + '"';
      }
    }
    function checkDataTypes(dataTypes, data, strictNumbers) {
      switch (dataTypes.length) {
        case 1:
          return checkDataType(dataTypes[0], data, strictNumbers, true);
        default:
          var code = "";
          var types = toHash(dataTypes);
          if (types.array && types.object) {
            code = types.null ? "(" : "(!" + data + " || ";
            code += "typeof " + data + ' !== "object")';
            delete types.null;
            delete types.array;
            delete types.object;
          }
          if (types.number) delete types.integer;
          for (var t in types)
            code += (code ? " && " : "") + checkDataType(t, data, strictNumbers, true);
          return code;
      }
    }
    var COERCE_TO_TYPES = toHash(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(optionCoerceTypes, dataTypes) {
      if (Array.isArray(dataTypes)) {
        var types = [];
        for (var i = 0; i < dataTypes.length; i++) {
          var t = dataTypes[i];
          if (COERCE_TO_TYPES[t]) types[types.length] = t;
          else if (optionCoerceTypes === "array" && t === "array") types[types.length] = t;
        }
        if (types.length) return types;
      } else if (COERCE_TO_TYPES[dataTypes]) {
        return [dataTypes];
      } else if (optionCoerceTypes === "array" && dataTypes === "array") {
        return ["array"];
      }
    }
    function toHash(arr) {
      var hash = {};
      for (var i = 0; i < arr.length; i++) hash[arr[i]] = true;
      return hash;
    }
    var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var SINGLE_QUOTE = /'|\\/g;
    function getProperty(key) {
      return typeof key == "number" ? "[" + key + "]" : IDENTIFIER.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
    }
    function escapeQuotes(str) {
      return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
    }
    function varOccurences(str, dataVar) {
      dataVar += "[^0-9]";
      var matches = str.match(new RegExp(dataVar, "g"));
      return matches ? matches.length : 0;
    }
    function varReplace(str, dataVar, expr) {
      dataVar += "([^0-9])";
      expr = expr.replace(/\$/g, "$$$$");
      return str.replace(new RegExp(dataVar, "g"), expr + "$1");
    }
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean") return !schema;
      for (var key in schema) if (rules[key]) return true;
    }
    function schemaHasRulesExcept(schema, rules, exceptKeyword) {
      if (typeof schema == "boolean") return !schema && exceptKeyword != "not";
      for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
    }
    function schemaUnknownRules(schema, rules) {
      if (typeof schema == "boolean") return;
      for (var key in schema) if (!rules[key]) return key;
    }
    function toQuotedString(str) {
      return "'" + escapeQuotes(str) + "'";
    }
    function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
      var path = jsonPointers ? "'/' + " + expr + (isNumber ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
      return joinPaths(currentPath, path);
    }
    function getPath(currentPath, prop, jsonPointers) {
      var path = jsonPointers ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
      return joinPaths(currentPath, path);
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, lvl, paths) {
      var up, jsonPointer, data, matches;
      if ($data === "") return "rootData";
      if ($data[0] == "/") {
        if (!JSON_POINTER.test($data)) throw new Error("Invalid JSON-pointer: " + $data);
        jsonPointer = $data;
        data = "rootData";
      } else {
        matches = $data.match(RELATIVE_JSON_POINTER);
        if (!matches) throw new Error("Invalid JSON-pointer: " + $data);
        up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer == "#") {
          if (up >= lvl) throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
          return paths[lvl - up];
        }
        if (up > lvl) throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
        data = "data" + (lvl - up || "");
        if (!jsonPointer) return data;
      }
      var expr = data;
      var segments = jsonPointer.split("/");
      for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        if (segment) {
          data += getProperty(unescapeJsonPointer(segment));
          expr += " && " + data;
        }
      }
      return expr;
    }
    function joinPaths(a, b) {
      if (a == '""') return b;
      return (a + " + " + b).replace(/([^\\])' \+ '/g, "$1");
    }
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    function escapeJsonPointer(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/schema_obj.js
var require_schema_obj = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/schema_obj.js"(exports2, module2) {
    "use strict";
    var util = require_util5();
    module2.exports = SchemaObject;
    function SchemaObject(obj) {
      util.copy(obj, this);
    }
  }
});

// node_modules/.pnpm/json-schema-traverse@0.4.1/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/.pnpm/json-schema-traverse@0.4.1/node_modules/json-schema-traverse/index.js"(exports2, module2) {
    "use strict";
    var traverse = module2.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/resolve.js"(exports2, module2) {
    "use strict";
    var URI = require_uri_all();
    var equal = require_fast_deep_equal();
    var util = require_util5();
    var SchemaObject = require_schema_obj();
    var traverse = require_json_schema_traverse();
    module2.exports = resolve;
    resolve.normalizeId = normalizeId;
    resolve.fullPath = getFullPath;
    resolve.url = resolveUrl;
    resolve.ids = resolveIds;
    resolve.inlineRef = inlineRef;
    resolve.schema = resolveSchema;
    function resolve(compile, root, ref) {
      var refVal = this._refs[ref];
      if (typeof refVal == "string") {
        if (this._refs[refVal]) refVal = this._refs[refVal];
        else return resolve.call(this, compile, root, refVal);
      }
      refVal = refVal || this._schemas[ref];
      if (refVal instanceof SchemaObject) {
        return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
      }
      var res = resolveSchema.call(this, root, ref);
      var schema, v, baseId;
      if (res) {
        schema = res.schema;
        root = res.root;
        baseId = res.baseId;
      }
      if (schema instanceof SchemaObject) {
        v = schema.validate || compile.call(this, schema.schema, root, void 0, baseId);
      } else if (schema !== void 0) {
        v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile.call(this, schema, root, void 0, baseId);
      }
      return v;
    }
    function resolveSchema(root, ref) {
      var p = URI.parse(ref), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root.schema));
      if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
        var id = normalizeId(refPath);
        var refVal = this._refs[id];
        if (typeof refVal == "string") {
          return resolveRecursive.call(this, root, refVal, p);
        } else if (refVal instanceof SchemaObject) {
          if (!refVal.validate) this._compile(refVal);
          root = refVal;
        } else {
          refVal = this._schemas[id];
          if (refVal instanceof SchemaObject) {
            if (!refVal.validate) this._compile(refVal);
            if (id == normalizeId(ref))
              return { schema: refVal, root, baseId };
            root = refVal;
          } else {
            return;
          }
        }
        if (!root.schema) return;
        baseId = getFullPath(this._getId(root.schema));
      }
      return getJsonPointer.call(this, p, baseId, root.schema, root);
    }
    function resolveRecursive(root, ref, parsedRef) {
      var res = resolveSchema.call(this, root, ref);
      if (res) {
        var schema = res.schema;
        var baseId = res.baseId;
        root = res.root;
        var id = this._getId(schema);
        if (id) baseId = resolveUrl(baseId, id);
        return getJsonPointer.call(this, parsedRef, baseId, schema, root);
      }
    }
    var PREVENT_SCOPE_CHANGE = util.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
    function getJsonPointer(parsedRef, baseId, schema, root) {
      parsedRef.fragment = parsedRef.fragment || "";
      if (parsedRef.fragment.slice(0, 1) != "/") return;
      var parts = parsedRef.fragment.split("/");
      for (var i = 1; i < parts.length; i++) {
        var part = parts[i];
        if (part) {
          part = util.unescapeFragment(part);
          schema = schema[part];
          if (schema === void 0) break;
          var id;
          if (!PREVENT_SCOPE_CHANGE[part]) {
            id = this._getId(schema);
            if (id) baseId = resolveUrl(baseId, id);
            if (schema.$ref) {
              var $ref = resolveUrl(baseId, schema.$ref);
              var res = resolveSchema.call(this, root, $ref);
              if (res) {
                schema = res.schema;
                root = res.root;
                baseId = res.baseId;
              }
            }
          }
        }
      }
      if (schema !== void 0 && schema !== root.schema)
        return { schema, root, baseId };
    }
    var SIMPLE_INLINED = util.toHash([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum"
    ]);
    function inlineRef(schema, limit) {
      if (limit === false) return false;
      if (limit === void 0 || limit === true) return checkNoRef(schema);
      else if (limit) return countKeys(schema) <= limit;
    }
    function checkNoRef(schema) {
      var item;
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) {
          item = schema[i];
          if (typeof item == "object" && !checkNoRef(item)) return false;
        }
      } else {
        for (var key in schema) {
          if (key == "$ref") return false;
          item = schema[key];
          if (typeof item == "object" && !checkNoRef(item)) return false;
        }
      }
      return true;
    }
    function countKeys(schema) {
      var count = 0, item;
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) {
          item = schema[i];
          if (typeof item == "object") count += countKeys(item);
          if (count == Infinity) return Infinity;
        }
      } else {
        for (var key in schema) {
          if (key == "$ref") return Infinity;
          if (SIMPLE_INLINED[key]) {
            count++;
          } else {
            item = schema[key];
            if (typeof item == "object") count += countKeys(item) + 1;
            if (count == Infinity) return Infinity;
          }
        }
      }
      return count;
    }
    function getFullPath(id, normalize) {
      if (normalize !== false) id = normalizeId(id);
      var p = URI.parse(id);
      return _getFullPath(p);
    }
    function _getFullPath(p) {
      return URI.serialize(p).split("#")[0] + "#";
    }
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    function resolveUrl(baseId, id) {
      id = normalizeId(id);
      return URI.resolve(baseId, id);
    }
    function resolveIds(schema) {
      var schemaId = normalizeId(this._getId(schema));
      var baseIds = { "": schemaId };
      var fullPaths = { "": getFullPath(schemaId, false) };
      var localRefs = {};
      var self2 = this;
      traverse(schema, { allKeys: true }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (jsonPtr === "") return;
        var id = self2._getId(sch);
        var baseId = baseIds[parentJsonPtr];
        var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
        if (keyIndex !== void 0)
          fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util.escapeFragment(keyIndex));
        if (typeof id == "string") {
          id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);
          var refVal = self2._refs[id];
          if (typeof refVal == "string") refVal = self2._refs[refVal];
          if (refVal && refVal.schema) {
            if (!equal(sch, refVal.schema))
              throw new Error('id "' + id + '" resolves to more than one schema');
          } else if (id != normalizeId(fullPath)) {
            if (id[0] == "#") {
              if (localRefs[id] && !equal(sch, localRefs[id]))
                throw new Error('id "' + id + '" resolves to more than one schema');
              localRefs[id] = sch;
            } else {
              self2._refs[id] = fullPath;
            }
          }
        }
        baseIds[jsonPtr] = baseId;
        fullPaths[jsonPtr] = fullPath;
      });
      return localRefs;
    }
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/error_classes.js
var require_error_classes = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/error_classes.js"(exports2, module2) {
    "use strict";
    var resolve = require_resolve();
    module2.exports = {
      Validation: errorSubclass(ValidationError),
      MissingRef: errorSubclass(MissingRefError)
    };
    function ValidationError(errors) {
      this.message = "validation failed";
      this.errors = errors;
      this.ajv = this.validation = true;
    }
    MissingRefError.message = function(baseId, ref) {
      return "can't resolve reference " + ref + " from id " + baseId;
    };
    function MissingRefError(baseId, ref, message) {
      this.message = message || MissingRefError.message(baseId, ref);
      this.missingRef = resolve.url(baseId, ref);
      this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
    }
    function errorSubclass(Subclass) {
      Subclass.prototype = Object.create(Error.prototype);
      Subclass.prototype.constructor = Subclass;
      return Subclass;
    }
  }
});

// node_modules/.pnpm/fast-json-stable-stringify@2.1.0/node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "node_modules/.pnpm/fast-json-stable-stringify@2.1.0/node_modules/fast-json-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(data, opts) {
      if (!opts) opts = {};
      if (typeof opts === "function") opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && /* @__PURE__ */ (function(f) {
        return function(node) {
          return function(a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      })(opts.cmp);
      var seen = [];
      return (function stringify2(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0) return;
        if (typeof node == "number") return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object") return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i = 0; i < node.length; i++) {
            if (i) out += ",";
            out += stringify2(node[i]) || "null";
          }
          return out + "]";
        }
        if (node === null) return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles) return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = stringify2(node[key]);
          if (!value) continue;
          if (out) out += ",";
          out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      })(data);
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/validate.js
var require_validate3 = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/validate.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_validate(it, $keyword, $ruleType) {
      var out = "";
      var $async = it.schema.$async === true, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, "$ref"), $id = it.self._getId(it.schema);
      if (it.opts.strictKeywords) {
        var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
        if ($unknownKwd) {
          var $keywordsMsg = "unknown keyword: " + $unknownKwd;
          if (it.opts.strictKeywords === "log") it.logger.warn($keywordsMsg);
          else throw new Error($keywordsMsg);
        }
      }
      if (it.isTop) {
        out += " var validate = ";
        if ($async) {
          it.async = true;
          out += "async ";
        }
        out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
        if ($id && (it.opts.sourceCode || it.opts.processCode)) {
          out += " " + ("/*# sourceURL=" + $id + " */") + " ";
        }
      }
      if (typeof it.schema == "boolean" || !($refKeywords || it.schema.$ref)) {
        var $keyword = "false schema";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        if (it.schema === false) {
          if (it.isTop) {
            $breakOnError = true;
          } else {
            out += " var " + $valid + " = false; ";
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) {
              out += " , message: 'boolean schema is false' ";
            }
            if (it.opts.verbose) {
              out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
        } else {
          if (it.isTop) {
            if ($async) {
              out += " return data; ";
            } else {
              out += " validate.errors = null; return true; ";
            }
          } else {
            out += " var " + $valid + " = true; ";
          }
        }
        if (it.isTop) {
          out += " }; return validate; ";
        }
        return out;
      }
      if (it.isTop) {
        var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = "data";
        it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
        it.baseId = it.baseId || it.rootId;
        delete it.isTop;
        it.dataPathArr = [""];
        if (it.schema.default !== void 0 && it.opts.useDefaults && it.opts.strictDefaults) {
          var $defaultMsg = "default is ignored in the schema root";
          if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
          else throw new Error($defaultMsg);
        }
        out += " var vErrors = null; ";
        out += " var errors = 0;     ";
        out += " if (rootData === undefined) rootData = data; ";
      } else {
        var $lvl = it.level, $dataLvl = it.dataLevel, $data = "data" + ($dataLvl || "");
        if ($id) it.baseId = it.resolve.url(it.baseId, $id);
        if ($async && !it.async) throw new Error("async schema in sync schema");
        out += " var errs_" + $lvl + " = errors;";
      }
      var $valid = "valid" + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
      var $errorKeyword;
      var $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);
      if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
        if ($typeIsArray) {
          if ($typeSchema.indexOf("null") == -1) $typeSchema = $typeSchema.concat("null");
        } else if ($typeSchema != "null") {
          $typeSchema = [$typeSchema, "null"];
          $typeIsArray = true;
        }
      }
      if ($typeIsArray && $typeSchema.length == 1) {
        $typeSchema = $typeSchema[0];
        $typeIsArray = false;
      }
      if (it.schema.$ref && $refKeywords) {
        if (it.opts.extendRefs == "fail") {
          throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
        } else if (it.opts.extendRefs !== true) {
          $refKeywords = false;
          it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
        }
      }
      if (it.schema.$comment && it.opts.$comment) {
        out += " " + it.RULES.all.$comment.code(it, "$comment");
      }
      if ($typeSchema) {
        if (it.opts.coerceTypes) {
          var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
        }
        var $rulesGroup = it.RULES.types[$typeSchema];
        if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
          var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
          var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
          out += " if (" + it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) + ") { ";
          if ($coerceToTypes) {
            var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
            out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ";
            if (it.opts.coerceTypes == "array") {
              out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } ";
            }
            out += " if (" + $coerced + " !== undefined) ; ";
            var arr1 = $coerceToTypes;
            if (arr1) {
              var $type, $i = -1, l1 = arr1.length - 1;
              while ($i < l1) {
                $type = arr1[$i += 1];
                if ($type == "string") {
                  out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
                } else if ($type == "number" || $type == "integer") {
                  out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
                  if ($type == "integer") {
                    out += " && !(" + $data + " % 1)";
                  }
                  out += ")) " + $coerced + " = +" + $data + "; ";
                } else if ($type == "boolean") {
                  out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
                } else if ($type == "null") {
                  out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
                } else if (it.opts.coerceTypes == "array" && $type == "array") {
                  out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
                }
              }
            }
            out += " else {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should be ";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } if (" + $coerced + " !== undefined) {  ";
            var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
            out += " " + $data + " = " + $coerced + "; ";
            if (!$dataLvl) {
              out += "if (" + $parentData + " !== undefined)";
            }
            out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
          } else {
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should be ";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
          }
          out += " } ";
        }
      }
      if (it.schema.$ref && !$refKeywords) {
        out += " " + it.RULES.all.$ref.code(it, "$ref") + " ";
        if ($breakOnError) {
          out += " } if (errors === ";
          if ($top) {
            out += "0";
          } else {
            out += "errs_" + $lvl;
          }
          out += ") { ";
          $closingBraces2 += "}";
        }
      } else {
        var arr2 = it.RULES;
        if (arr2) {
          var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
          while (i2 < l2) {
            $rulesGroup = arr2[i2 += 1];
            if ($shouldUseGroup($rulesGroup)) {
              if ($rulesGroup.type) {
                out += " if (" + it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) + ") { ";
              }
              if (it.opts.useDefaults) {
                if ($rulesGroup.type == "object" && it.schema.properties) {
                  var $schema = it.schema.properties, $schemaKeys = Object.keys($schema);
                  var arr3 = $schemaKeys;
                  if (arr3) {
                    var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                    while (i3 < l3) {
                      $propertyKey = arr3[i3 += 1];
                      var $sch = $schema[$propertyKey];
                      if ($sch.default !== void 0) {
                        var $passData = $data + it.util.getProperty($propertyKey);
                        if (it.compositeRule) {
                          if (it.opts.strictDefaults) {
                            var $defaultMsg = "default is ignored for: " + $passData;
                            if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
                            else throw new Error($defaultMsg);
                          }
                        } else {
                          out += " if (" + $passData + " === undefined ";
                          if (it.opts.useDefaults == "empty") {
                            out += " || " + $passData + " === null || " + $passData + " === '' ";
                          }
                          out += " ) " + $passData + " = ";
                          if (it.opts.useDefaults == "shared") {
                            out += " " + it.useDefault($sch.default) + " ";
                          } else {
                            out += " " + JSON.stringify($sch.default) + " ";
                          }
                          out += "; ";
                        }
                      }
                    }
                  }
                } else if ($rulesGroup.type == "array" && Array.isArray(it.schema.items)) {
                  var arr4 = it.schema.items;
                  if (arr4) {
                    var $sch, $i = -1, l4 = arr4.length - 1;
                    while ($i < l4) {
                      $sch = arr4[$i += 1];
                      if ($sch.default !== void 0) {
                        var $passData = $data + "[" + $i + "]";
                        if (it.compositeRule) {
                          if (it.opts.strictDefaults) {
                            var $defaultMsg = "default is ignored for: " + $passData;
                            if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
                            else throw new Error($defaultMsg);
                          }
                        } else {
                          out += " if (" + $passData + " === undefined ";
                          if (it.opts.useDefaults == "empty") {
                            out += " || " + $passData + " === null || " + $passData + " === '' ";
                          }
                          out += " ) " + $passData + " = ";
                          if (it.opts.useDefaults == "shared") {
                            out += " " + it.useDefault($sch.default) + " ";
                          } else {
                            out += " " + JSON.stringify($sch.default) + " ";
                          }
                          out += "; ";
                        }
                      }
                    }
                  }
                }
              }
              var arr5 = $rulesGroup.rules;
              if (arr5) {
                var $rule, i5 = -1, l5 = arr5.length - 1;
                while (i5 < l5) {
                  $rule = arr5[i5 += 1];
                  if ($shouldUseRule($rule)) {
                    var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                    if ($code) {
                      out += " " + $code + " ";
                      if ($breakOnError) {
                        $closingBraces1 += "}";
                      }
                    }
                  }
                }
              }
              if ($breakOnError) {
                out += " " + $closingBraces1 + " ";
                $closingBraces1 = "";
              }
              if ($rulesGroup.type) {
                out += " } ";
                if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                  out += " else { ";
                  var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  if (it.createErrors !== false) {
                    out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                    if ($typeIsArray) {
                      out += "" + $typeSchema.join(",");
                    } else {
                      out += "" + $typeSchema;
                    }
                    out += "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: 'should be ";
                      if ($typeIsArray) {
                        out += "" + $typeSchema.join(",");
                      } else {
                        out += "" + $typeSchema;
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  out += " } ";
                }
              }
              if ($breakOnError) {
                out += " if (errors === ";
                if ($top) {
                  out += "0";
                } else {
                  out += "errs_" + $lvl;
                }
                out += ") { ";
                $closingBraces2 += "}";
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += " " + $closingBraces2 + " ";
      }
      if ($top) {
        if ($async) {
          out += " if (errors === 0) return data;           ";
          out += " else throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; ";
          out += " return errors === 0;       ";
        }
        out += " }; return validate;";
      } else {
        out += " var " + $valid + " = errors === errs_" + $lvl + ";";
      }
      function $shouldUseGroup($rulesGroup2) {
        var rules = $rulesGroup2.rules;
        for (var i = 0; i < rules.length; i++)
          if ($shouldUseRule(rules[i])) return true;
      }
      function $shouldUseRule($rule2) {
        return it.schema[$rule2.keyword] !== void 0 || $rule2.implements && $ruleImplementsSomeKeyword($rule2);
      }
      function $ruleImplementsSomeKeyword($rule2) {
        var impl = $rule2.implements;
        for (var i = 0; i < impl.length; i++)
          if (it.schema[impl[i]] !== void 0) return true;
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/index.js
var require_compile = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/index.js"(exports2, module2) {
    "use strict";
    var resolve = require_resolve();
    var util = require_util5();
    var errorClasses = require_error_classes();
    var stableStringify = require_fast_json_stable_stringify();
    var validateGenerator = require_validate3();
    var ucs2length = util.ucs2length;
    var equal = require_fast_deep_equal();
    var ValidationError = errorClasses.Validation;
    module2.exports = compile;
    function compile(schema, root, localRefs, baseId) {
      var self2 = this, opts = this._opts, refVal = [void 0], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
      root = root || { schema, refVal, refs };
      var c = checkCompiling.call(this, schema, root, baseId);
      var compilation = this._compilations[c.index];
      if (c.compiling) return compilation.callValidate = callValidate;
      var formats = this._formats;
      var RULES = this.RULES;
      try {
        var v = localCompile(schema, root, localRefs, baseId);
        compilation.validate = v;
        var cv = compilation.callValidate;
        if (cv) {
          cv.schema = v.schema;
          cv.errors = null;
          cv.refs = v.refs;
          cv.refVal = v.refVal;
          cv.root = v.root;
          cv.$async = v.$async;
          if (opts.sourceCode) cv.source = v.source;
        }
        return v;
      } finally {
        endCompiling.call(this, schema, root, baseId);
      }
      function callValidate() {
        var validate2 = compilation.validate;
        var result = validate2.apply(this, arguments);
        callValidate.errors = validate2.errors;
        return result;
      }
      function localCompile(_schema, _root, localRefs2, baseId2) {
        var isRoot = !_root || _root && _root.schema == _schema;
        if (_root.schema != root.schema)
          return compile.call(self2, _schema, _root, localRefs2, baseId2);
        var $async = _schema.$async === true;
        var sourceCode = validateGenerator({
          isTop: true,
          schema: _schema,
          isRoot,
          baseId: baseId2,
          root: _root,
          schemaPath: "",
          errSchemaPath: "#",
          errorPath: '""',
          MissingRefError: errorClasses.MissingRef,
          RULES,
          validate: validateGenerator,
          util,
          resolve,
          resolveRef,
          usePattern,
          useDefault,
          useCustomRule,
          opts,
          formats,
          logger: self2.logger,
          self: self2
        });
        sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;
        if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema);
        var validate2;
        try {
          var makeValidate = new Function(
            "self",
            "RULES",
            "formats",
            "root",
            "refVal",
            "defaults",
            "customRules",
            "equal",
            "ucs2length",
            "ValidationError",
            sourceCode
          );
          validate2 = makeValidate(
            self2,
            RULES,
            formats,
            root,
            refVal,
            defaults,
            customRules,
            equal,
            ucs2length,
            ValidationError
          );
          refVal[0] = validate2;
        } catch (e) {
          self2.logger.error("Error compiling schema, function code:", sourceCode);
          throw e;
        }
        validate2.schema = _schema;
        validate2.errors = null;
        validate2.refs = refs;
        validate2.refVal = refVal;
        validate2.root = isRoot ? validate2 : _root;
        if ($async) validate2.$async = true;
        if (opts.sourceCode === true) {
          validate2.source = {
            code: sourceCode,
            patterns,
            defaults
          };
        }
        return validate2;
      }
      function resolveRef(baseId2, ref, isRoot) {
        ref = resolve.url(baseId2, ref);
        var refIndex = refs[ref];
        var _refVal, refCode;
        if (refIndex !== void 0) {
          _refVal = refVal[refIndex];
          refCode = "refVal[" + refIndex + "]";
          return resolvedRef(_refVal, refCode);
        }
        if (!isRoot && root.refs) {
          var rootRefId = root.refs[ref];
          if (rootRefId !== void 0) {
            _refVal = root.refVal[rootRefId];
            refCode = addLocalRef(ref, _refVal);
            return resolvedRef(_refVal, refCode);
          }
        }
        refCode = addLocalRef(ref);
        var v2 = resolve.call(self2, localCompile, root, ref);
        if (v2 === void 0) {
          var localSchema = localRefs && localRefs[ref];
          if (localSchema) {
            v2 = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile.call(self2, localSchema, root, localRefs, baseId2);
          }
        }
        if (v2 === void 0) {
          removeLocalRef(ref);
        } else {
          replaceLocalRef(ref, v2);
          return resolvedRef(v2, refCode);
        }
      }
      function addLocalRef(ref, v2) {
        var refId = refVal.length;
        refVal[refId] = v2;
        refs[ref] = refId;
        return "refVal" + refId;
      }
      function removeLocalRef(ref) {
        delete refs[ref];
      }
      function replaceLocalRef(ref, v2) {
        var refId = refs[ref];
        refVal[refId] = v2;
      }
      function resolvedRef(refVal2, code) {
        return typeof refVal2 == "object" || typeof refVal2 == "boolean" ? { code, schema: refVal2, inline: true } : { code, $async: refVal2 && !!refVal2.$async };
      }
      function usePattern(regexStr) {
        var index = patternsHash[regexStr];
        if (index === void 0) {
          index = patternsHash[regexStr] = patterns.length;
          patterns[index] = regexStr;
        }
        return "pattern" + index;
      }
      function useDefault(value) {
        switch (typeof value) {
          case "boolean":
          case "number":
            return "" + value;
          case "string":
            return util.toQuotedString(value);
          case "object":
            if (value === null) return "null";
            var valueStr = stableStringify(value);
            var index = defaultsHash[valueStr];
            if (index === void 0) {
              index = defaultsHash[valueStr] = defaults.length;
              defaults[index] = value;
            }
            return "default" + index;
        }
      }
      function useCustomRule(rule, schema2, parentSchema, it) {
        if (self2._opts.validateSchema !== false) {
          var deps = rule.definition.dependencies;
          if (deps && !deps.every(function(keyword) {
            return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
          }))
            throw new Error("parent schema must have all required keywords: " + deps.join(","));
          var validateSchema = rule.definition.validateSchema;
          if (validateSchema) {
            var valid = validateSchema(schema2);
            if (!valid) {
              var message = "keyword schema is invalid: " + self2.errorsText(validateSchema.errors);
              if (self2._opts.validateSchema == "log") self2.logger.error(message);
              else throw new Error(message);
            }
          }
        }
        var compile2 = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
        var validate2;
        if (compile2) {
          validate2 = compile2.call(self2, schema2, parentSchema, it);
        } else if (macro) {
          validate2 = macro.call(self2, schema2, parentSchema, it);
          if (opts.validateSchema !== false) self2.validateSchema(validate2, true);
        } else if (inline) {
          validate2 = inline.call(self2, it, rule.keyword, schema2, parentSchema);
        } else {
          validate2 = rule.definition.validate;
          if (!validate2) return;
        }
        if (validate2 === void 0)
          throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
        var index = customRules.length;
        customRules[index] = validate2;
        return {
          code: "customRule" + index,
          validate: validate2
        };
      }
    }
    function checkCompiling(schema, root, baseId) {
      var index = compIndex.call(this, schema, root, baseId);
      if (index >= 0) return { index, compiling: true };
      index = this._compilations.length;
      this._compilations[index] = {
        schema,
        root,
        baseId
      };
      return { index, compiling: false };
    }
    function endCompiling(schema, root, baseId) {
      var i = compIndex.call(this, schema, root, baseId);
      if (i >= 0) this._compilations.splice(i, 1);
    }
    function compIndex(schema, root, baseId) {
      for (var i = 0; i < this._compilations.length; i++) {
        var c = this._compilations[i];
        if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
      }
      return -1;
    }
    function patternCode(i, patterns) {
      return "var pattern" + i + " = new RegExp(" + util.toQuotedString(patterns[i]) + ");";
    }
    function defaultCode(i) {
      return "var default" + i + " = defaults[" + i + "];";
    }
    function refValCode(i, refVal) {
      return refVal[i] === void 0 ? "" : "var refVal" + i + " = refVal[" + i + "];";
    }
    function customRuleCode(i) {
      return "var customRule" + i + " = customRules[" + i + "];";
    }
    function vars(arr, statement) {
      if (!arr.length) return "";
      var code = "";
      for (var i = 0; i < arr.length; i++)
        code += statement(i, arr);
      return code;
    }
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/cache.js
var require_cache2 = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/cache.js"(exports2, module2) {
    "use strict";
    var Cache = module2.exports = function Cache2() {
      this._cache = {};
    };
    Cache.prototype.put = function Cache_put(key, value) {
      this._cache[key] = value;
    };
    Cache.prototype.get = function Cache_get(key) {
      return this._cache[key];
    };
    Cache.prototype.del = function Cache_del(key) {
      delete this._cache[key];
    };
    Cache.prototype.clear = function Cache_clear() {
      this._cache = {};
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/formats.js
var require_formats = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/formats.js"(exports2, module2) {
    "use strict";
    var util = require_util5();
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
    var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
    var URL3 = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
    var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
    var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
    var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
    var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
    module2.exports = formats;
    function formats(mode) {
      mode = mode == "full" ? "full" : "fast";
      return util.copy(formats[mode]);
    }
    formats.fast = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
      "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      "uri-template": URITEMPLATE,
      url: URL3,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
      hostname: HOSTNAME,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: UUID,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": JSON_POINTER,
      "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": RELATIVE_JSON_POINTER
    };
    formats.full = {
      date,
      time,
      "date-time": date_time,
      uri,
      "uri-reference": URIREF,
      "uri-template": URITEMPLATE,
      url: URL3,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: HOSTNAME,
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex,
      uuid: UUID,
      "json-pointer": JSON_POINTER,
      "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
      "relative-json-pointer": RELATIVE_JSON_POINTER
    };
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function date(str) {
      var matches = str.match(DATE);
      if (!matches) return false;
      var year = +matches[1];
      var month = +matches[2];
      var day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function time(str, full) {
      var matches = str.match(TIME);
      if (!matches) return false;
      var hour = matches[1];
      var minute = matches[2];
      var second = matches[3];
      var timeZone = matches[5];
      return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function date_time(str) {
      var dateTime = str.split(DATE_TIME_SEPARATOR);
      return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str)) return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/ref.js
var require_ref = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_ref(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $async, $refCode;
      if ($schema == "#" || $schema == "#/") {
        if (it.isRoot) {
          $async = it.async;
          $refCode = "validate";
        } else {
          $async = it.root.schema.$async === true;
          $refCode = "root.refVal[0]";
        }
      } else {
        var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
        if ($refVal === void 0) {
          var $message = it.MissingRefError.message(it.baseId, $schema);
          if (it.opts.missingRefs == "fail") {
            it.logger.error($message);
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it.util.escapeQuotes($schema) + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'can\\'t resolve reference " + it.util.escapeQuotes($schema) + "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: " + it.util.toQuotedString($schema) + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            if ($breakOnError) {
              out += " if (false) { ";
            }
          } else if (it.opts.missingRefs == "ignore") {
            it.logger.warn($message);
            if ($breakOnError) {
              out += " if (true) { ";
            }
          } else {
            throw new it.MissingRefError(it.baseId, $schema, $message);
          }
        } else if ($refVal.inline) {
          var $it = it.util.copy(it);
          $it.level++;
          var $nextValid = "valid" + $it.level;
          $it.schema = $refVal.schema;
          $it.schemaPath = "";
          $it.errSchemaPath = $schema;
          var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
          out += " " + $code + " ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
          }
        } else {
          $async = $refVal.$async === true || it.async && $refVal.$async !== false;
          $refCode = $refVal.code;
        }
      }
      if ($refCode) {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.opts.passContext) {
          out += " " + $refCode + ".call(this, ";
        } else {
          out += " " + $refCode + "( ";
        }
        out += " " + $data + ", (dataPath || '')";
        if (it.errorPath != '""') {
          out += " + " + it.errorPath;
        }
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
        var __callValidate = out;
        out = $$outStack.pop();
        if ($async) {
          if (!it.async) throw new Error("async schema referenced by sync schema");
          if ($breakOnError) {
            out += " var " + $valid + "; ";
          }
          out += " try { await " + __callValidate + "; ";
          if ($breakOnError) {
            out += " " + $valid + " = true; ";
          }
          out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
          if ($breakOnError) {
            out += " " + $valid + " = false; ";
          }
          out += " } ";
          if ($breakOnError) {
            out += " if (" + $valid + ") { ";
          }
        } else {
          out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
          if ($breakOnError) {
            out += " else { ";
          }
        }
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/allOf.js
var require_allOf = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/allOf.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_allOf(it, $keyword, $ruleType) {
      var out = " ";
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            $allSchemasEmpty = false;
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if ($breakOnError) {
        if ($allSchemasEmpty) {
          out += " if (true) { ";
        } else {
          out += " " + $closingBraces.slice(0, -1) + " ";
        }
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/anyOf.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_anyOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $noEmptySchema = $schema.every(function($sch2) {
        return it.opts.strictKeywords ? typeof $sch2 == "object" && Object.keys($sch2).length > 0 || $sch2 === false : it.util.schemaHasRules($sch2, it.RULES.all);
      });
      if ($noEmptySchema) {
        var $currentBaseId = $it.baseId;
        out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
            $closingBraces += "}";
          }
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should match some schema in anyOf' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it.opts.allErrors) {
          out += " } ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/comment.js
var require_comment = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/comment.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_comment(it, $keyword, $ruleType) {
      var out = " ";
      var $schema = it.schema[$keyword];
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $comment = it.util.toQuotedString($schema);
      if (it.opts.$comment === true) {
        out += " console.log(" + $comment + ");";
      } else if (typeof it.opts.$comment == "function") {
        out += " self._opts.$comment(" + $comment + ", " + it.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/const.js
var require_const = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/const.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_const(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!$isData) {
        out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
      }
      out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be equal to constant' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " }";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/contains.js
var require_contains = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/contains.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_contains(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all);
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if ($nonEmptySchema) {
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        out += " if (" + $nextValid + ") break; }  ";
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $nextValid + ") {";
      } else {
        out += " if (" + $data + ".length == 0) {";
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'should contain a valid item' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } else { ";
      if ($nonEmptySchema) {
        out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
      }
      if (it.opts.allErrors) {
        out += " } ";
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/dependencies.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_dependencies(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;
      for ($property in $schema) {
        if ($property == "__proto__") continue;
        var $sch = $schema[$property];
        var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
        $deps[$property] = $sch;
      }
      out += "var " + $errs + " = errors;";
      var $currentErrorPath = it.errorPath;
      out += "var missing" + $lvl + ";";
      for (var $property in $propertyDeps) {
        $deps = $propertyDeps[$property];
        if ($deps.length) {
          out += " if ( " + $data + it.util.getProperty($property) + " !== undefined ";
          if ($ownProperties) {
            out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
          }
          if ($breakOnError) {
            out += " && ( ";
            var arr1 = $deps;
            if (arr1) {
              var $propertyKey, $i = -1, l1 = arr1.length - 1;
              while ($i < l1) {
                $propertyKey = arr1[$i += 1];
                if ($i) {
                  out += " || ";
                }
                var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                out += " ( ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
              }
            }
            out += ")) {  ";
            var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should have ";
                if ($deps.length == 1) {
                  out += "property " + it.util.escapeQuotes($deps[0]);
                } else {
                  out += "properties " + it.util.escapeQuotes($deps.join(", "));
                }
                out += " when property " + it.util.escapeQuotes($property) + " is present' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
          } else {
            out += " ) { ";
            var arr2 = $deps;
            if (arr2) {
              var $propertyKey, i2 = -1, l2 = arr2.length - 1;
              while (i2 < l2) {
                $propertyKey = arr2[i2 += 1];
                var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") {  var err =   ";
                if (it.createErrors !== false) {
                  out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: 'should have ";
                    if ($deps.length == 1) {
                      out += "property " + it.util.escapeQuotes($deps[0]);
                    } else {
                      out += "properties " + it.util.escapeQuotes($deps.join(", "));
                    }
                    out += " when property " + it.util.escapeQuotes($property) + " is present' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
              }
            }
          }
          out += " }   ";
          if ($breakOnError) {
            $closingBraces += "}";
            out += " else { ";
          }
        }
      }
      it.errorPath = $currentErrorPath;
      var $currentBaseId = $it.baseId;
      for (var $property in $schemaDeps) {
        var $sch = $schemaDeps[$property];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          out += " " + $nextValid + " = true; if ( " + $data + it.util.getProperty($property) + " !== undefined ";
          if ($ownProperties) {
            out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
          }
          out += ") { ";
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + it.util.getProperty($property);
          $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($property);
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
      if ($breakOnError) {
        out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/enum.js
var require_enum2 = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/enum.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_enum(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
      if (!$isData) {
        out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
      }
      out += "var " + $valid + ";";
      if ($isData) {
        out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
      }
      out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
      if ($isData) {
        out += "  }  ";
      }
      out += " if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be equal to one of the allowed values' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " }";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/format.js
var require_format3 = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/format.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_format(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      if (it.opts.format === false) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
        return out;
      }
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
      if ($isData) {
        var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
        out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
        if (it.async) {
          out += " var async" + $lvl + " = " + $format + ".async; ";
        }
        out += " " + $format + " = " + $format + ".validate; } if (  ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
        }
        out += " (";
        if ($unknownFormats != "ignore") {
          out += " (" + $schemaValue + " && !" + $format + " ";
          if ($allowUnknown) {
            out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
          }
          out += ") || ";
        }
        out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
        if (it.async) {
          out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
        } else {
          out += " " + $format + "(" + $data + ") ";
        }
        out += " : " + $format + ".test(" + $data + "))))) {";
      } else {
        var $format = it.formats[$schema];
        if (!$format) {
          if ($unknownFormats == "ignore") {
            it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
            if ($breakOnError) {
              out += " if (true) { ";
            }
            return out;
          } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
            if ($breakOnError) {
              out += " if (true) { ";
            }
            return out;
          } else {
            throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
          }
        }
        var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
        var $formatType = $isObject && $format.type || "string";
        if ($isObject) {
          var $async = $format.async === true;
          $format = $format.validate;
        }
        if ($formatType != $ruleType) {
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        }
        if ($async) {
          if (!it.async) throw new Error("async format in sync schema");
          var $formatRef = "formats" + it.util.getProperty($schema) + ".validate";
          out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
        } else {
          out += " if (! ";
          var $formatRef = "formats" + it.util.getProperty($schema);
          if ($isObject) $formatRef += ".validate";
          if (typeof $format == "function") {
            out += " " + $formatRef + "(" + $data + ") ";
          } else {
            out += " " + $formatRef + ".test(" + $data + ") ";
          }
          out += ") { ";
        }
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
        if ($isData) {
          out += "" + $schemaValue;
        } else {
          out += "" + it.util.toQuotedString($schema);
        }
        out += "  } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should match format "`;
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + it.util.escapeQuotes($schema);
          }
          out += `"' `;
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + it.util.toQuotedString($schema);
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/if.js
var require_if = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/if.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_if(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $thenSch = it.schema["then"], $elseSch = it.schema["else"], $thenPresent = $thenSch !== void 0 && (it.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)), $elsePresent = $elseSch !== void 0 && (it.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)), $currentBaseId = $it.baseId;
      if ($thenPresent || $elsePresent) {
        var $ifClause;
        $it.createErrors = false;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        $it.createErrors = true;
        out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
        it.compositeRule = $it.compositeRule = $wasComposite;
        if ($thenPresent) {
          out += " if (" + $nextValid + ") {  ";
          $it.schema = it.schema["then"];
          $it.schemaPath = it.schemaPath + ".then";
          $it.errSchemaPath = it.errSchemaPath + "/then";
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $nextValid + "; ";
          if ($thenPresent && $elsePresent) {
            $ifClause = "ifClause" + $lvl;
            out += " var " + $ifClause + " = 'then'; ";
          } else {
            $ifClause = "'then'";
          }
          out += " } ";
          if ($elsePresent) {
            out += " else { ";
          }
        } else {
          out += " if (!" + $nextValid + ") { ";
        }
        if ($elsePresent) {
          $it.schema = it.schema["else"];
          $it.schemaPath = it.schemaPath + ".else";
          $it.errSchemaPath = it.errSchemaPath + "/else";
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $nextValid + "; ";
          if ($thenPresent && $elsePresent) {
            $ifClause = "ifClause" + $lvl;
            out += " var " + $ifClause + " = 'else'; ";
          } else {
            $ifClause = "'else'";
          }
          out += " } ";
        }
        out += " if (!" + $valid + ") {   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should match "' + ` + $ifClause + ` + '" schema' `;
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        out += " }   ";
        if ($breakOnError) {
          out += " else { ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/items.js
var require_items = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/items.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_items(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId;
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if (Array.isArray($schema)) {
        var $additionalItems = it.schema.additionalItems;
        if ($additionalItems === false) {
          out += " " + $valid + " = " + $data + ".length <= " + $schema.length + "; ";
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + "/additionalItems";
          out += "  if (!" + $valid + ") {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema.length + " } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should NOT have more than " + $schema.length + " items' ";
            }
            if (it.opts.verbose) {
              out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } ";
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            $closingBraces += "}";
            out += " else { ";
          }
        }
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
              var $passData = $data + "[" + $i + "]";
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + "[" + $i + "]";
              $it.errSchemaPath = $errSchemaPath + "/" + $i;
              $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
              $it.dataPathArr[$dataNxt] = $i;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              out += " }  ";
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
        if (typeof $additionalItems == "object" && (it.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
          $it.schema = $additionalItems;
          $it.schemaPath = it.schemaPath + ".additionalItems";
          $it.errSchemaPath = it.errSchemaPath + "/additionalItems";
          out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema.length + ") {  for (var " + $idx + " = " + $schema.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
          $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
          var $passData = $data + "[" + $idx + "]";
          $it.dataPathArr[$dataNxt] = $idx;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          if ($breakOnError) {
            out += " if (!" + $nextValid + ") break; ";
          }
          out += " } }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      } else if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += "  for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        if ($breakOnError) {
          out += " if (!" + $nextValid + ") break; ";
        }
        out += " }";
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limit.js
var require_limit = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limit.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate__limit(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = void 0;
      if (!($isData || typeof $schema == "number" || $schema === void 0)) {
        throw new Error($keyword + " must be number");
      }
      if (!($isDataExcl || $schemaExcl === void 0 || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) {
        throw new Error($exclusiveKeyword + " must be number or boolean");
      }
      if ($isDataExcl) {
        var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
        out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
        $schemaValueExcl = "schemaExcl" + $lvl;
        out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
        var $errorKeyword = $exclusiveKeyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
        if ($schema === void 0) {
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
          $schemaValue = $schemaValueExcl;
          $isData = $isDataExcl;
        }
      } else {
        var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
        if ($exclIsNumber && $isData) {
          var $opExpr = "'" + $opStr + "'";
          out += " if ( ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
          }
          out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
        } else {
          if ($exclIsNumber && $schema === void 0) {
            $exclusive = true;
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
            $schemaValue = $schemaExcl;
            $notOp += "=";
          } else {
            if ($exclIsNumber) $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema);
            if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
              $exclusive = true;
              $errorKeyword = $exclusiveKeyword;
              $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
              $notOp += "=";
            } else {
              $exclusive = false;
              $opStr += "=";
            }
          }
          var $opExpr = "'" + $opStr + "'";
          out += " if ( ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
          }
          out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
        }
      }
      $errorKeyword = $errorKeyword || $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be " + $opStr + " ";
          if ($isData) {
            out += "' + " + $schemaValue;
          } else {
            out += "" + $schemaValue + "'";
          }
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limitItems.js
var require_limitItems = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limitItems.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate__limitItems(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxItems" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have ";
          if ($keyword == "maxItems") {
            out += "more";
          } else {
            out += "fewer";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " items' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limitLength.js
var require_limitLength = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limitLength.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate__limitLength(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxLength" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      if (it.opts.unicode === false) {
        out += " " + $data + ".length ";
      } else {
        out += " ucs2length(" + $data + ") ";
      }
      out += " " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT be ";
          if ($keyword == "maxLength") {
            out += "longer";
          } else {
            out += "shorter";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " characters' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limitProperties.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate__limitProperties(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxProperties" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have ";
          if ($keyword == "maxProperties") {
            out += "more";
          } else {
            out += "fewer";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " properties' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/multipleOf.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_multipleOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      out += "var division" + $lvl + ";if (";
      if ($isData) {
        out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
      }
      out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
      if (it.opts.multipleOfPrecision) {
        out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it.opts.multipleOfPrecision + " ";
      } else {
        out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
      }
      out += " ) ";
      if ($isData) {
        out += "  )  ";
      }
      out += " ) {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be multiple of ";
          if ($isData) {
            out += "' + " + $schemaValue;
          } else {
            out += "" + $schemaValue + "'";
          }
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/not.js
var require_not = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/not.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_not(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = "valid" + $it.level;
      if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $errs + " = errors;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.createErrors = false;
        var $allErrorsOption;
        if ($it.opts.allErrors) {
          $allErrorsOption = $it.opts.allErrors;
          $it.opts.allErrors = false;
        }
        out += " " + it.validate($it) + " ";
        $it.createErrors = true;
        if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (" + $nextValid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT be valid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it.opts.allErrors) {
          out += " } ";
        }
      } else {
        out += "  var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT be valid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if ($breakOnError) {
          out += " if (false) { ";
        }
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/oneOf.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_oneOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
      out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
          } else {
            out += " var " + $nextValid + " = true; ";
          }
          if ($i) {
            out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ";
            $closingBraces += "}";
          }
          out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
        }
      }
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should match exactly one schema in oneOf' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
      if (it.opts.allErrors) {
        out += " } ";
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/pattern.js
var require_pattern = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/pattern.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_pattern(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it.usePattern($schema);
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
      }
      out += " !" + $regexp + ".test(" + $data + ") ) {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
        if ($isData) {
          out += "" + $schemaValue;
        } else {
          out += "" + it.util.toQuotedString($schema);
        }
        out += "  } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should match pattern "`;
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + it.util.escapeQuotes($schema);
          }
          out += `"' `;
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + it.util.toQuotedString($schema);
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/properties.js
var require_properties = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/properties.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_properties(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
      var $schemaKeys = Object.keys($schema || {}).filter(notProto), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
      var $required = it.schema.required;
      if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
        var $requiredHash = it.util.toHash($required);
      }
      function notProto(p) {
        return p !== "__proto__";
      }
      out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
      if ($ownProperties) {
        out += " var " + $dataProperties + " = undefined;";
      }
      if ($checkAdditional) {
        if ($ownProperties) {
          out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        } else {
          out += " for (var " + $key + " in " + $data + ") { ";
        }
        if ($someProperties) {
          out += " var isAdditional" + $lvl + " = !(false ";
          if ($schemaKeys.length) {
            if ($schemaKeys.length > 8) {
              out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
            } else {
              var arr1 = $schemaKeys;
              if (arr1) {
                var $propertyKey, i1 = -1, l1 = arr1.length - 1;
                while (i1 < l1) {
                  $propertyKey = arr1[i1 += 1];
                  out += " || " + $key + " == " + it.util.toQuotedString($propertyKey) + " ";
                }
              }
            }
          }
          if ($pPropertyKeys.length) {
            var arr2 = $pPropertyKeys;
            if (arr2) {
              var $pProperty, $i = -1, l2 = arr2.length - 1;
              while ($i < l2) {
                $pProperty = arr2[$i += 1];
                out += " || " + it.usePattern($pProperty) + ".test(" + $key + ") ";
              }
            }
          }
          out += " ); if (isAdditional" + $lvl + ") { ";
        }
        if ($removeAdditional == "all") {
          out += " delete " + $data + "[" + $key + "]; ";
        } else {
          var $currentErrorPath = it.errorPath;
          var $additionalProperty = "' + " + $key + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          }
          if ($noAdditional) {
            if ($removeAdditional) {
              out += " delete " + $data + "[" + $key + "]; ";
            } else {
              out += " " + $nextValid + " = false; ";
              var $currErrSchemaPath = $errSchemaPath;
              $errSchemaPath = it.errSchemaPath + "/additionalProperties";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is an invalid additional property";
                  } else {
                    out += "should NOT have additional properties";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              $errSchemaPath = $currErrSchemaPath;
              if ($breakOnError) {
                out += " break; ";
              }
            }
          } else if ($additionalIsSchema) {
            if ($removeAdditional == "failing") {
              out += " var " + $errs + " = errors;  ";
              var $wasComposite = it.compositeRule;
              it.compositeRule = $it.compositeRule = true;
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + ".additionalProperties";
              $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
              it.compositeRule = $it.compositeRule = $wasComposite;
            } else {
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + ".additionalProperties";
              $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              if ($breakOnError) {
                out += " if (!" + $nextValid + ") break; ";
              }
            }
          }
          it.errorPath = $currentErrorPath;
        }
        if ($someProperties) {
          out += " } ";
        }
        out += " }  ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
      var $useDefaults = it.opts.useDefaults && !it.compositeRule;
      if ($schemaKeys.length) {
        var arr3 = $schemaKeys;
        if (arr3) {
          var $propertyKey, i3 = -1, l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $sch = $schema[$propertyKey];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== void 0;
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + $prop;
              $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($propertyKey);
              $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
              $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                $code = it.util.varReplace($code, $nextData, $passData);
                var $useData = $passData;
              } else {
                var $useData = $nextData;
                out += " var " + $nextData + " = " + $passData + "; ";
              }
              if ($hasDefault) {
                out += " " + $code + " ";
              } else {
                if ($requiredHash && $requiredHash[$propertyKey]) {
                  out += " if ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") { " + $nextValid + " = false; ";
                  var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);
                  if (it.opts._errorDataPathProperty) {
                    it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                  }
                  $errSchemaPath = it.errSchemaPath + "/required";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  if (it.createErrors !== false) {
                    out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: '";
                      if (it.opts._errorDataPathProperty) {
                        out += "is a required property";
                      } else {
                        out += "should have required property \\'" + $missingProperty + "\\'";
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  $errSchemaPath = $currErrSchemaPath;
                  it.errorPath = $currentErrorPath;
                  out += " } else { ";
                } else {
                  if ($breakOnError) {
                    out += " if ( " + $useData + " === undefined ";
                    if ($ownProperties) {
                      out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                    }
                    out += ") { " + $nextValid + " = true; } else { ";
                  } else {
                    out += " if (" + $useData + " !== undefined ";
                    if ($ownProperties) {
                      out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                    }
                    out += " ) { ";
                  }
                }
                out += " " + $code + " } ";
              }
            }
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr4 = $pPropertyKeys;
        if (arr4) {
          var $pProperty, i4 = -1, l4 = arr4.length - 1;
          while (i4 < l4) {
            $pProperty = arr4[i4 += 1];
            var $sch = $pProperties[$pProperty];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              $it.schema = $sch;
              $it.schemaPath = it.schemaPath + ".patternProperties" + it.util.getProperty($pProperty);
              $it.errSchemaPath = it.errSchemaPath + "/patternProperties/" + it.util.escapeFragment($pProperty);
              if ($ownProperties) {
                out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
              } else {
                out += " for (var " + $key + " in " + $data + ") { ";
              }
              out += " if (" + it.usePattern($pProperty) + ".test(" + $key + ")) { ";
              $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              if ($breakOnError) {
                out += " if (!" + $nextValid + ") break; ";
              }
              out += " } ";
              if ($breakOnError) {
                out += " else " + $nextValid + " = true; ";
              }
              out += " }  ";
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/propertyNames.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_propertyNames(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      out += "var " + $errs + " = errors;";
      if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
        if ($ownProperties) {
          out += " var " + $dataProperties + " = undefined; ";
        }
        if ($ownProperties) {
          out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        } else {
          out += " for (var " + $key + " in " + $data + ") { ";
        }
        out += " var startErrs" + $lvl + " = errors; ";
        var $passData = $key;
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        if ($breakOnError) {
          out += " break; ";
        }
        out += " } }";
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/required.js
var require_required = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/required.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_required(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $vSchema = "schema" + $lvl;
      if (!$isData) {
        if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
          var $required = [];
          var arr1 = $schema;
          if (arr1) {
            var $property, i1 = -1, l1 = arr1.length - 1;
            while (i1 < l1) {
              $property = arr1[i1 += 1];
              var $propertySch = it.schema.properties[$property];
              if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
                $required[$required.length] = $property;
              }
            }
          }
        } else {
          var $required = $schema;
        }
      }
      if ($isData || $required.length) {
        var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;
        if ($breakOnError) {
          out += " var missing" + $lvl + "; ";
          if ($loopRequired) {
            if (!$isData) {
              out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
            }
            var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            out += " var " + $valid + " = true; ";
            if ($isData) {
              out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
            }
            out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
            if ($ownProperties) {
              out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
            }
            out += "; if (!" + $valid + ") break; } ";
            if ($isData) {
              out += "  }  ";
            }
            out += "  if (!" + $valid + ") {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } else { ";
          } else {
            out += " if ( ";
            var arr2 = $required;
            if (arr2) {
              var $propertyKey, $i = -1, l2 = arr2.length - 1;
              while ($i < l2) {
                $propertyKey = arr2[$i += 1];
                if ($i) {
                  out += " || ";
                }
                var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                out += " ( ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
              }
            }
            out += ") {  ";
            var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } else { ";
          }
        } else {
          if ($loopRequired) {
            if (!$isData) {
              out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
            }
            var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            if ($isData) {
              out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ";
              if (it.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
            }
            out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
            if ($ownProperties) {
              out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
            }
            out += ") {  var err =   ";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
            if ($isData) {
              out += "  }  ";
            }
          } else {
            var arr3 = $required;
            if (arr3) {
              var $propertyKey, i3 = -1, l3 = arr3.length - 1;
              while (i3 < l3) {
                $propertyKey = arr3[i3 += 1];
                var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") {  var err =   ";
                if (it.createErrors !== false) {
                  out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: '";
                    if (it.opts._errorDataPathProperty) {
                      out += "is a required property";
                    } else {
                      out += "should have required property \\'" + $missingProperty + "\\'";
                    }
                    out += "' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
              }
            }
          }
        }
        it.errorPath = $currentErrorPath;
      } else if ($breakOnError) {
        out += " if (true) {";
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/uniqueItems.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (($schema || $isData) && it.opts.uniqueItems !== false) {
        if ($isData) {
          out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
        }
        out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
        var $itemType = it.schema.items && it.schema.items.type, $typeIsArray = Array.isArray($itemType);
        if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) {
          out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
        } else {
          out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
          var $method = "checkDataType" + ($typeIsArray ? "s" : "");
          out += " if (" + it.util[$method]($itemType, "item", it.opts.strictNumbers, true) + ") continue; ";
          if ($typeIsArray) {
            out += ` if (typeof item == 'string') item = '"' + item; `;
          }
          out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
        }
        out += " } ";
        if ($isData) {
          out += "  }  ";
        }
        out += " if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
          }
          if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/index.js
var require_dotjs = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "$ref": require_ref(),
      allOf: require_allOf(),
      anyOf: require_anyOf(),
      "$comment": require_comment(),
      const: require_const(),
      contains: require_contains(),
      dependencies: require_dependencies(),
      "enum": require_enum2(),
      format: require_format3(),
      "if": require_if(),
      items: require_items(),
      maximum: require_limit(),
      minimum: require_limit(),
      maxItems: require_limitItems(),
      minItems: require_limitItems(),
      maxLength: require_limitLength(),
      minLength: require_limitLength(),
      maxProperties: require_limitProperties(),
      minProperties: require_limitProperties(),
      multipleOf: require_multipleOf(),
      not: require_not(),
      oneOf: require_oneOf(),
      pattern: require_pattern(),
      properties: require_properties(),
      propertyNames: require_propertyNames(),
      required: require_required(),
      uniqueItems: require_uniqueItems(),
      validate: require_validate3()
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/rules.js
var require_rules = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/rules.js"(exports2, module2) {
    "use strict";
    var ruleModules = require_dotjs();
    var toHash = require_util5().toHash;
    module2.exports = function rules() {
      var RULES = [
        {
          type: "number",
          rules: [
            { "maximum": ["exclusiveMaximum"] },
            { "minimum": ["exclusiveMinimum"] },
            "multipleOf",
            "format"
          ]
        },
        {
          type: "string",
          rules: ["maxLength", "minLength", "pattern", "format"]
        },
        {
          type: "array",
          rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
        },
        {
          type: "object",
          rules: [
            "maxProperties",
            "minProperties",
            "required",
            "dependencies",
            "propertyNames",
            { "properties": ["additionalProperties", "patternProperties"] }
          ]
        },
        { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }
      ];
      var ALL = ["type", "$comment"];
      var KEYWORDS = [
        "$schema",
        "$id",
        "id",
        "$data",
        "$async",
        "title",
        "description",
        "default",
        "definitions",
        "examples",
        "readOnly",
        "writeOnly",
        "contentMediaType",
        "contentEncoding",
        "additionalItems",
        "then",
        "else"
      ];
      var TYPES = ["number", "integer", "string", "array", "object", "boolean", "null"];
      RULES.all = toHash(ALL);
      RULES.types = toHash(TYPES);
      RULES.forEach(function(group) {
        group.rules = group.rules.map(function(keyword) {
          var implKeywords;
          if (typeof keyword == "object") {
            var key = Object.keys(keyword)[0];
            implKeywords = keyword[key];
            keyword = key;
            implKeywords.forEach(function(k) {
              ALL.push(k);
              RULES.all[k] = true;
            });
          }
          ALL.push(keyword);
          var rule = RULES.all[keyword] = {
            keyword,
            code: ruleModules[keyword],
            implements: implKeywords
          };
          return rule;
        });
        RULES.all.$comment = {
          keyword: "$comment",
          code: ruleModules.$comment
        };
        if (group.type) RULES.types[group.type] = group;
      });
      RULES.keywords = toHash(ALL.concat(KEYWORDS));
      RULES.custom = {};
      return RULES;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/data.js
var require_data3 = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/data.js"(exports2, module2) {
    "use strict";
    var KEYWORDS = [
      "multipleOf",
      "maximum",
      "exclusiveMaximum",
      "minimum",
      "exclusiveMinimum",
      "maxLength",
      "minLength",
      "pattern",
      "additionalItems",
      "maxItems",
      "minItems",
      "uniqueItems",
      "maxProperties",
      "minProperties",
      "required",
      "additionalProperties",
      "enum",
      "format",
      "const"
    ];
    module2.exports = function(metaSchema, keywordsJsonPointers) {
      for (var i = 0; i < keywordsJsonPointers.length; i++) {
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        var segments = keywordsJsonPointers[i].split("/");
        var keywords = metaSchema;
        var j;
        for (j = 1; j < segments.length; j++)
          keywords = keywords[segments[j]];
        for (j = 0; j < KEYWORDS.length; j++) {
          var key = KEYWORDS[j];
          var schema = keywords[key];
          if (schema) {
            keywords[key] = {
              anyOf: [
                schema,
                { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
              ]
            };
          }
        }
      }
      return metaSchema;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/async.js
var require_async = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/async.js"(exports2, module2) {
    "use strict";
    var MissingRefError = require_error_classes().MissingRef;
    module2.exports = compileAsync;
    function compileAsync(schema, meta, callback) {
      var self2 = this;
      if (typeof this._opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      if (typeof meta == "function") {
        callback = meta;
        meta = void 0;
      }
      var p = loadMetaSchemaOf(schema).then(function() {
        var schemaObj = self2._addSchema(schema, void 0, meta);
        return schemaObj.validate || _compileAsync(schemaObj);
      });
      if (callback) {
        p.then(
          function(v) {
            callback(null, v);
          },
          callback
        );
      }
      return p;
      function loadMetaSchemaOf(sch) {
        var $schema = sch.$schema;
        return $schema && !self2.getSchema($schema) ? compileAsync.call(self2, { $ref: $schema }, true) : Promise.resolve();
      }
      function _compileAsync(schemaObj) {
        try {
          return self2._compile(schemaObj);
        } catch (e) {
          if (e instanceof MissingRefError) return loadMissingSchema(e);
          throw e;
        }
        function loadMissingSchema(e) {
          var ref = e.missingSchema;
          if (added(ref)) throw new Error("Schema " + ref + " is loaded but " + e.missingRef + " cannot be resolved");
          var schemaPromise = self2._loadingSchemas[ref];
          if (!schemaPromise) {
            schemaPromise = self2._loadingSchemas[ref] = self2._opts.loadSchema(ref);
            schemaPromise.then(removePromise, removePromise);
          }
          return schemaPromise.then(function(sch) {
            if (!added(ref)) {
              return loadMetaSchemaOf(sch).then(function() {
                if (!added(ref)) self2.addSchema(sch, ref, void 0, meta);
              });
            }
          }).then(function() {
            return _compileAsync(schemaObj);
          });
          function removePromise() {
            delete self2._loadingSchemas[ref];
          }
          function added(ref2) {
            return self2._refs[ref2] || self2._schemas[ref2];
          }
        }
      }
    }
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/custom.js
var require_custom = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/custom.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_custom(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
      var $compile, $inline, $macro, $ruleValidate, $validateCode;
      if ($isData && $rDef.$data) {
        $validateCode = "keywordValidate" + $lvl;
        var $validateSchema = $rDef.validateSchema;
        out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
      } else {
        $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
        if (!$ruleValidate) return;
        $schemaValue = "validate.schema" + $schemaPath;
        $validateCode = $ruleValidate.code;
        $compile = $rDef.compile;
        $inline = $rDef.inline;
        $macro = $rDef.macro;
      }
      var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
      if ($asyncKeyword && !it.async) throw new Error("async keyword in sync schema");
      if (!($inline || $macro)) {
        out += "" + $ruleErrs + " = null;";
      }
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if ($isData && $rDef.$data) {
        $closingBraces += "}";
        out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
        if ($validateSchema) {
          $closingBraces += "}";
          out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
        }
      }
      if ($inline) {
        if ($rDef.statements) {
          out += " " + $ruleValidate.validate + " ";
        } else {
          out += " " + $valid + " = " + $ruleValidate.validate + "; ";
        }
      } else if ($macro) {
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        $it.schema = $ruleValidate.validate;
        $it.schemaPath = "";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $code;
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        out += "  " + $validateCode + ".call( ";
        if (it.opts.passContext) {
          out += "this";
        } else {
          out += "self";
        }
        if ($compile || $rDef.schema === false) {
          out += " , " + $data + " ";
        } else {
          out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it.schemaPath + " ";
        }
        out += " , (dataPath || '')";
        if (it.errorPath != '""') {
          out += " + " + it.errorPath;
        }
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
        var def_callRuleValidate = out;
        out = $$outStack.pop();
        if ($rDef.errors === false) {
          out += " " + $valid + " = ";
          if ($asyncKeyword) {
            out += "await ";
          }
          out += "" + def_callRuleValidate + "; ";
        } else {
          if ($asyncKeyword) {
            $ruleErrs = "customErrors" + $lvl;
            out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
          } else {
            out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
          }
        }
      }
      if ($rDef.modifying) {
        out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
      }
      out += "" + $closingBraces;
      if ($rDef.valid) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      } else {
        out += " if ( ";
        if ($rDef.valid === void 0) {
          out += " !";
          if ($macro) {
            out += "" + $nextValid;
          } else {
            out += "" + $valid;
          }
        } else {
          out += " " + !$rDef.valid + " ";
        }
        out += ") { ";
        $errorKeyword = $rule.keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        var def_customError = out;
        out = $$outStack.pop();
        if ($inline) {
          if ($rDef.errors) {
            if ($rDef.errors != "full") {
              out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it.opts.verbose) {
                out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
              }
              out += " } ";
            }
          } else {
            if ($rDef.errors === false) {
              out += " " + def_customError + " ";
            } else {
              out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it.opts.verbose) {
                out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
              }
              out += " } } ";
            }
          }
        } else if ($macro) {
          out += "   var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
            if (it.opts.messages !== false) {
              out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError(vErrors); ";
            } else {
              out += " validate.errors = vErrors; return false; ";
            }
          }
        } else {
          if ($rDef.errors === false) {
            out += " " + def_customError + " ";
          } else {
            out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
            if (it.opts.verbose) {
              out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            }
            out += " } } else { " + def_customError + " } ";
          }
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
      }
      return out;
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/refs/json-schema-draft-07.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [
            { $ref: "#/definitions/nonNegativeInteger" },
            { default: 0 }
          ]
        },
        simpleTypes: {
          enum: [
            "array",
            "boolean",
            "integer",
            "null",
            "number",
            "object",
            "string"
          ]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [
            { $ref: "#" },
            { $ref: "#/definitions/schemaArray" }
          ],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [
              { $ref: "#" },
              { $ref: "#/definitions/stringArray" }
            ]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/definition_schema.js
var require_definition_schema = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/definition_schema.js"(exports2, module2) {
    "use strict";
    var metaSchema = require_json_schema_draft_07();
    module2.exports = {
      $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
      definitions: {
        simpleTypes: metaSchema.definitions.simpleTypes
      },
      type: "object",
      dependencies: {
        schema: ["validate"],
        $data: ["validate"],
        statements: ["inline"],
        valid: { not: { required: ["macro"] } }
      },
      properties: {
        type: metaSchema.properties.type,
        schema: { type: "boolean" },
        statements: { type: "boolean" },
        dependencies: {
          type: "array",
          items: { type: "string" }
        },
        metaSchema: { type: "object" },
        modifying: { type: "boolean" },
        valid: { type: "boolean" },
        $data: { type: "boolean" },
        async: { type: "boolean" },
        errors: {
          anyOf: [
            { type: "boolean" },
            { const: "full" }
          ]
        }
      }
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/keyword.js
var require_keyword = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/keyword.js"(exports2, module2) {
    "use strict";
    var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
    var customRuleCode = require_custom();
    var definitionSchema = require_definition_schema();
    module2.exports = {
      add: addKeyword,
      get: getKeyword,
      remove: removeKeyword,
      validate: validateKeyword
    };
    function addKeyword(keyword, definition) {
      var RULES = this.RULES;
      if (RULES.keywords[keyword])
        throw new Error("Keyword " + keyword + " is already defined");
      if (!IDENTIFIER.test(keyword))
        throw new Error("Keyword " + keyword + " is not a valid identifier");
      if (definition) {
        this.validateKeyword(definition, true);
        var dataType = definition.type;
        if (Array.isArray(dataType)) {
          for (var i = 0; i < dataType.length; i++)
            _addRule(keyword, dataType[i], definition);
        } else {
          _addRule(keyword, dataType, definition);
        }
        var metaSchema = definition.metaSchema;
        if (metaSchema) {
          if (definition.$data && this._opts.$data) {
            metaSchema = {
              anyOf: [
                metaSchema,
                { "$ref": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
              ]
            };
          }
          definition.validateSchema = this.compile(metaSchema, true);
        }
      }
      RULES.keywords[keyword] = RULES.all[keyword] = true;
      function _addRule(keyword2, dataType2, definition2) {
        var ruleGroup;
        for (var i2 = 0; i2 < RULES.length; i2++) {
          var rg = RULES[i2];
          if (rg.type == dataType2) {
            ruleGroup = rg;
            break;
          }
        }
        if (!ruleGroup) {
          ruleGroup = { type: dataType2, rules: [] };
          RULES.push(ruleGroup);
        }
        var rule = {
          keyword: keyword2,
          definition: definition2,
          custom: true,
          code: customRuleCode,
          implements: definition2.implements
        };
        ruleGroup.rules.push(rule);
        RULES.custom[keyword2] = rule;
      }
      return this;
    }
    function getKeyword(keyword) {
      var rule = this.RULES.custom[keyword];
      return rule ? rule.definition : this.RULES.keywords[keyword] || false;
    }
    function removeKeyword(keyword) {
      var RULES = this.RULES;
      delete RULES.keywords[keyword];
      delete RULES.all[keyword];
      delete RULES.custom[keyword];
      for (var i = 0; i < RULES.length; i++) {
        var rules = RULES[i].rules;
        for (var j = 0; j < rules.length; j++) {
          if (rules[j].keyword == keyword) {
            rules.splice(j, 1);
            break;
          }
        }
      }
      return this;
    }
    function validateKeyword(definition, throwError) {
      validateKeyword.errors = null;
      var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
      if (v(definition)) return true;
      validateKeyword.errors = v.errors;
      if (throwError)
        throw new Error("custom keyword definition is invalid: " + this.errorsText(v.errors));
      else
        return false;
    }
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/refs/data.json
var require_data4 = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/refs/data.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON Schema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [
            { format: "relative-json-pointer" },
            { format: "json-pointer" }
          ]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/ajv.js
var require_ajv = __commonJS({
  "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/ajv.js"(exports2, module2) {
    "use strict";
    var compileSchema = require_compile();
    var resolve = require_resolve();
    var Cache = require_cache2();
    var SchemaObject = require_schema_obj();
    var stableStringify = require_fast_json_stable_stringify();
    var formats = require_formats();
    var rules = require_rules();
    var $dataMetaSchema = require_data3();
    var util = require_util5();
    module2.exports = Ajv;
    Ajv.prototype.validate = validate2;
    Ajv.prototype.compile = compile;
    Ajv.prototype.addSchema = addSchema;
    Ajv.prototype.addMetaSchema = addMetaSchema;
    Ajv.prototype.validateSchema = validateSchema;
    Ajv.prototype.getSchema = getSchema;
    Ajv.prototype.removeSchema = removeSchema;
    Ajv.prototype.addFormat = addFormat;
    Ajv.prototype.errorsText = errorsText;
    Ajv.prototype._addSchema = _addSchema;
    Ajv.prototype._compile = _compile;
    Ajv.prototype.compileAsync = require_async();
    var customKeyword = require_keyword();
    Ajv.prototype.addKeyword = customKeyword.add;
    Ajv.prototype.getKeyword = customKeyword.get;
    Ajv.prototype.removeKeyword = customKeyword.remove;
    Ajv.prototype.validateKeyword = customKeyword.validate;
    var errorClasses = require_error_classes();
    Ajv.ValidationError = errorClasses.Validation;
    Ajv.MissingRefError = errorClasses.MissingRef;
    Ajv.$dataMetaSchema = $dataMetaSchema;
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"];
    var META_SUPPORT_DATA = ["/properties"];
    function Ajv(opts) {
      if (!(this instanceof Ajv)) return new Ajv(opts);
      opts = this._opts = util.copy(opts) || {};
      setLogger(this);
      this._schemas = {};
      this._refs = {};
      this._fragments = {};
      this._formats = formats(opts.format);
      this._cache = opts.cache || new Cache();
      this._loadingSchemas = {};
      this._compilations = [];
      this.RULES = rules();
      this._getId = chooseGetId(opts);
      opts.loopRequired = opts.loopRequired || Infinity;
      if (opts.errorDataPath == "property") opts._errorDataPathProperty = true;
      if (opts.serialize === void 0) opts.serialize = stableStringify;
      this._metaOpts = getMetaSchemaOptions(this);
      if (opts.formats) addInitialFormats(this);
      if (opts.keywords) addInitialKeywords(this);
      addDefaultMetaSchema(this);
      if (typeof opts.meta == "object") this.addMetaSchema(opts.meta);
      if (opts.nullable) this.addKeyword("nullable", { metaSchema: { type: "boolean" } });
      addInitialSchemas(this);
    }
    function validate2(schemaKeyRef, data) {
      var v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
      } else {
        var schemaObj = this._addSchema(schemaKeyRef);
        v = schemaObj.validate || this._compile(schemaObj);
      }
      var valid = v(data);
      if (v.$async !== true) this.errors = v.errors;
      return valid;
    }
    function compile(schema, _meta) {
      var schemaObj = this._addSchema(schema, void 0, _meta);
      return schemaObj.validate || this._compile(schemaObj);
    }
    function addSchema(schema, key, _skipValidation, _meta) {
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) this.addSchema(schema[i], void 0, _skipValidation, _meta);
        return this;
      }
      var id = this._getId(schema);
      if (id !== void 0 && typeof id != "string")
        throw new Error("schema id must be string");
      key = resolve.normalizeId(key || id);
      checkUnique(this, key);
      this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
      return this;
    }
    function addMetaSchema(schema, key, skipValidation) {
      this.addSchema(schema, key, skipValidation, true);
      return this;
    }
    function validateSchema(schema, throwOrLogError) {
      var $schema = schema.$schema;
      if ($schema !== void 0 && typeof $schema != "string")
        throw new Error("$schema must be a string");
      $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
      if (!$schema) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      var valid = this.validate($schema, schema);
      if (!valid && throwOrLogError) {
        var message = "schema is invalid: " + this.errorsText();
        if (this._opts.validateSchema == "log") this.logger.error(message);
        else throw new Error(message);
      }
      return valid;
    }
    function defaultMeta(self2) {
      var meta = self2._opts.meta;
      self2._opts.defaultMeta = typeof meta == "object" ? self2._getId(meta) || meta : self2.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0;
      return self2._opts.defaultMeta;
    }
    function getSchema(keyRef) {
      var schemaObj = _getSchemaObj(this, keyRef);
      switch (typeof schemaObj) {
        case "object":
          return schemaObj.validate || this._compile(schemaObj);
        case "string":
          return this.getSchema(schemaObj);
        case "undefined":
          return _getSchemaFragment(this, keyRef);
      }
    }
    function _getSchemaFragment(self2, ref) {
      var res = resolve.schema.call(self2, { schema: {} }, ref);
      if (res) {
        var schema = res.schema, root = res.root, baseId = res.baseId;
        var v = compileSchema.call(self2, schema, root, void 0, baseId);
        self2._fragments[ref] = new SchemaObject({
          ref,
          fragment: true,
          schema,
          root,
          baseId,
          validate: v
        });
        return v;
      }
    }
    function _getSchemaObj(self2, keyRef) {
      keyRef = resolve.normalizeId(keyRef);
      return self2._schemas[keyRef] || self2._refs[keyRef] || self2._fragments[keyRef];
    }
    function removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        _removeAllSchemas(this, this._schemas, schemaKeyRef);
        _removeAllSchemas(this, this._refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          _removeAllSchemas(this, this._schemas);
          _removeAllSchemas(this, this._refs);
          this._cache.clear();
          return this;
        case "string":
          var schemaObj = _getSchemaObj(this, schemaKeyRef);
          if (schemaObj) this._cache.del(schemaObj.cacheKey);
          delete this._schemas[schemaKeyRef];
          delete this._refs[schemaKeyRef];
          return this;
        case "object":
          var serialize = this._opts.serialize;
          var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
          this._cache.del(cacheKey);
          var id = this._getId(schemaKeyRef);
          if (id) {
            id = resolve.normalizeId(id);
            delete this._schemas[id];
            delete this._refs[id];
          }
      }
      return this;
    }
    function _removeAllSchemas(self2, schemas, regex) {
      for (var keyRef in schemas) {
        var schemaObj = schemas[keyRef];
        if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
          self2._cache.del(schemaObj.cacheKey);
          delete schemas[keyRef];
        }
      }
    }
    function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
      if (typeof schema != "object" && typeof schema != "boolean")
        throw new Error("schema should be object or boolean");
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schema) : schema;
      var cached = this._cache.get(cacheKey);
      if (cached) return cached;
      shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
      var id = resolve.normalizeId(this._getId(schema));
      if (id && shouldAddSchema) checkUnique(this, id);
      var willValidate = this._opts.validateSchema !== false && !skipValidation;
      var recursiveMeta;
      if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
        this.validateSchema(schema, true);
      var localRefs = resolve.ids.call(this, schema);
      var schemaObj = new SchemaObject({
        id,
        schema,
        localRefs,
        cacheKey,
        meta
      });
      if (id[0] != "#" && shouldAddSchema) this._refs[id] = schemaObj;
      this._cache.put(cacheKey, schemaObj);
      if (willValidate && recursiveMeta) this.validateSchema(schema, true);
      return schemaObj;
    }
    function _compile(schemaObj, root) {
      if (schemaObj.compiling) {
        schemaObj.validate = callValidate;
        callValidate.schema = schemaObj.schema;
        callValidate.errors = null;
        callValidate.root = root ? root : callValidate;
        if (schemaObj.schema.$async === true)
          callValidate.$async = true;
        return callValidate;
      }
      schemaObj.compiling = true;
      var currentOpts;
      if (schemaObj.meta) {
        currentOpts = this._opts;
        this._opts = this._metaOpts;
      }
      var v;
      try {
        v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
      } catch (e) {
        delete schemaObj.validate;
        throw e;
      } finally {
        schemaObj.compiling = false;
        if (schemaObj.meta) this._opts = currentOpts;
      }
      schemaObj.validate = v;
      schemaObj.refs = v.refs;
      schemaObj.refVal = v.refVal;
      schemaObj.root = v.root;
      return v;
      function callValidate() {
        var _validate = schemaObj.validate;
        var result = _validate.apply(this, arguments);
        callValidate.errors = _validate.errors;
        return result;
      }
    }
    function chooseGetId(opts) {
      switch (opts.schemaId) {
        case "auto":
          return _get$IdOrId;
        case "id":
          return _getId;
        default:
          return _get$Id;
      }
    }
    function _getId(schema) {
      if (schema.$id) this.logger.warn("schema $id ignored", schema.$id);
      return schema.id;
    }
    function _get$Id(schema) {
      if (schema.id) this.logger.warn("schema id ignored", schema.id);
      return schema.$id;
    }
    function _get$IdOrId(schema) {
      if (schema.$id && schema.id && schema.$id != schema.id)
        throw new Error("schema $id is different from id");
      return schema.$id || schema.id;
    }
    function errorsText(errors, options) {
      errors = errors || this.errors;
      if (!errors) return "No errors";
      options = options || {};
      var separator = options.separator === void 0 ? ", " : options.separator;
      var dataVar = options.dataVar === void 0 ? "data" : options.dataVar;
      var text = "";
      for (var i = 0; i < errors.length; i++) {
        var e = errors[i];
        if (e) text += dataVar + e.dataPath + " " + e.message + separator;
      }
      return text.slice(0, -separator.length);
    }
    function addFormat(name, format) {
      if (typeof format == "string") format = new RegExp(format);
      this._formats[name] = format;
      return this;
    }
    function addDefaultMetaSchema(self2) {
      var $dataSchema;
      if (self2._opts.$data) {
        $dataSchema = require_data4();
        self2.addMetaSchema($dataSchema, $dataSchema.$id, true);
      }
      if (self2._opts.meta === false) return;
      var metaSchema = require_json_schema_draft_07();
      if (self2._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
      self2.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
      self2._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    function addInitialSchemas(self2) {
      var optsSchemas = self2._opts.schemas;
      if (!optsSchemas) return;
      if (Array.isArray(optsSchemas)) self2.addSchema(optsSchemas);
      else for (var key in optsSchemas) self2.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats(self2) {
      for (var name in self2._opts.formats) {
        var format = self2._opts.formats[name];
        self2.addFormat(name, format);
      }
    }
    function addInitialKeywords(self2) {
      for (var name in self2._opts.keywords) {
        var keyword = self2._opts.keywords[name];
        self2.addKeyword(name, keyword);
      }
    }
    function checkUnique(self2, id) {
      if (self2._schemas[id] || self2._refs[id])
        throw new Error('schema with key or id "' + id + '" already exists');
    }
    function getMetaSchemaOptions(self2) {
      var metaOpts = util.copy(self2._opts);
      for (var i = 0; i < META_IGNORE_OPTIONS.length; i++)
        delete metaOpts[META_IGNORE_OPTIONS[i]];
      return metaOpts;
    }
    function setLogger(self2) {
      var logger = self2._opts.logger;
      if (logger === false) {
        self2.logger = { log: noop, warn: noop, error: noop };
      } else {
        if (logger === void 0) logger = console;
        if (!(typeof logger == "object" && logger.log && logger.warn && logger.error))
          throw new Error("logger must implement log, warn and error methods");
        self2.logger = logger;
      }
    }
    function noop() {
    }
  }
});

// node_modules/.pnpm/@modelcontextprotocol+sdk@1.20.2/node_modules/@modelcontextprotocol/sdk/dist/cjs/client/index.js
var require_client2 = __commonJS({
  "node_modules/.pnpm/@modelcontextprotocol+sdk@1.20.2/node_modules/@modelcontextprotocol/sdk/dist/cjs/client/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Client = void 0;
    var protocol_js_1 = require_protocol();
    var types_js_1 = require_types9();
    var ajv_1 = __importDefault(require_ajv());
    var Client = class extends protocol_js_1.Protocol {
      /**
       * Initializes this client with the given name and version information.
       */
      constructor(_clientInfo, options) {
        var _a;
        super(options);
        this._clientInfo = _clientInfo;
        this._cachedToolOutputValidators = /* @__PURE__ */ new Map();
        this._capabilities = (_a = options === null || options === void 0 ? void 0 : options.capabilities) !== null && _a !== void 0 ? _a : {};
        this._ajv = new ajv_1.default();
      }
      /**
       * Registers new capabilities. This can only be called before connecting to a transport.
       *
       * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
       */
      registerCapabilities(capabilities) {
        if (this.transport) {
          throw new Error("Cannot register capabilities after connecting to transport");
        }
        this._capabilities = (0, protocol_js_1.mergeCapabilities)(this._capabilities, capabilities);
      }
      assertCapability(capability, method) {
        var _a;
        if (!((_a = this._serverCapabilities) === null || _a === void 0 ? void 0 : _a[capability])) {
          throw new Error(`Server does not support ${capability} (required for ${method})`);
        }
      }
      async connect(transport, options) {
        await super.connect(transport);
        if (transport.sessionId !== void 0) {
          return;
        }
        try {
          const result = await this.request({
            method: "initialize",
            params: {
              protocolVersion: types_js_1.LATEST_PROTOCOL_VERSION,
              capabilities: this._capabilities,
              clientInfo: this._clientInfo
            }
          }, types_js_1.InitializeResultSchema, options);
          if (result === void 0) {
            throw new Error(`Server sent invalid initialize result: ${result}`);
          }
          if (!types_js_1.SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {
            throw new Error(`Server's protocol version is not supported: ${result.protocolVersion}`);
          }
          this._serverCapabilities = result.capabilities;
          this._serverVersion = result.serverInfo;
          if (transport.setProtocolVersion) {
            transport.setProtocolVersion(result.protocolVersion);
          }
          this._instructions = result.instructions;
          await this.notification({
            method: "notifications/initialized"
          });
        } catch (error) {
          void this.close();
          throw error;
        }
      }
      /**
       * After initialization has completed, this will be populated with the server's reported capabilities.
       */
      getServerCapabilities() {
        return this._serverCapabilities;
      }
      /**
       * After initialization has completed, this will be populated with information about the server's name and version.
       */
      getServerVersion() {
        return this._serverVersion;
      }
      /**
       * After initialization has completed, this may be populated with information about the server's instructions.
       */
      getInstructions() {
        return this._instructions;
      }
      assertCapabilityForMethod(method) {
        var _a, _b, _c, _d, _e;
        switch (method) {
          case "logging/setLevel":
            if (!((_a = this._serverCapabilities) === null || _a === void 0 ? void 0 : _a.logging)) {
              throw new Error(`Server does not support logging (required for ${method})`);
            }
            break;
          case "prompts/get":
          case "prompts/list":
            if (!((_b = this._serverCapabilities) === null || _b === void 0 ? void 0 : _b.prompts)) {
              throw new Error(`Server does not support prompts (required for ${method})`);
            }
            break;
          case "resources/list":
          case "resources/templates/list":
          case "resources/read":
          case "resources/subscribe":
          case "resources/unsubscribe":
            if (!((_c = this._serverCapabilities) === null || _c === void 0 ? void 0 : _c.resources)) {
              throw new Error(`Server does not support resources (required for ${method})`);
            }
            if (method === "resources/subscribe" && !this._serverCapabilities.resources.subscribe) {
              throw new Error(`Server does not support resource subscriptions (required for ${method})`);
            }
            break;
          case "tools/call":
          case "tools/list":
            if (!((_d = this._serverCapabilities) === null || _d === void 0 ? void 0 : _d.tools)) {
              throw new Error(`Server does not support tools (required for ${method})`);
            }
            break;
          case "completion/complete":
            if (!((_e = this._serverCapabilities) === null || _e === void 0 ? void 0 : _e.completions)) {
              throw new Error(`Server does not support completions (required for ${method})`);
            }
            break;
          case "initialize":
            break;
          case "ping":
            break;
        }
      }
      assertNotificationCapability(method) {
        var _a;
        switch (method) {
          case "notifications/roots/list_changed":
            if (!((_a = this._capabilities.roots) === null || _a === void 0 ? void 0 : _a.listChanged)) {
              throw new Error(`Client does not support roots list changed notifications (required for ${method})`);
            }
            break;
          case "notifications/initialized":
            break;
          case "notifications/cancelled":
            break;
          case "notifications/progress":
            break;
        }
      }
      assertRequestHandlerCapability(method) {
        switch (method) {
          case "sampling/createMessage":
            if (!this._capabilities.sampling) {
              throw new Error(`Client does not support sampling capability (required for ${method})`);
            }
            break;
          case "elicitation/create":
            if (!this._capabilities.elicitation) {
              throw new Error(`Client does not support elicitation capability (required for ${method})`);
            }
            break;
          case "roots/list":
            if (!this._capabilities.roots) {
              throw new Error(`Client does not support roots capability (required for ${method})`);
            }
            break;
          case "ping":
            break;
        }
      }
      async ping(options) {
        return this.request({ method: "ping" }, types_js_1.EmptyResultSchema, options);
      }
      async complete(params, options) {
        return this.request({ method: "completion/complete", params }, types_js_1.CompleteResultSchema, options);
      }
      async setLoggingLevel(level, options) {
        return this.request({ method: "logging/setLevel", params: { level } }, types_js_1.EmptyResultSchema, options);
      }
      async getPrompt(params, options) {
        return this.request({ method: "prompts/get", params }, types_js_1.GetPromptResultSchema, options);
      }
      async listPrompts(params, options) {
        return this.request({ method: "prompts/list", params }, types_js_1.ListPromptsResultSchema, options);
      }
      async listResources(params, options) {
        return this.request({ method: "resources/list", params }, types_js_1.ListResourcesResultSchema, options);
      }
      async listResourceTemplates(params, options) {
        return this.request({ method: "resources/templates/list", params }, types_js_1.ListResourceTemplatesResultSchema, options);
      }
      async readResource(params, options) {
        return this.request({ method: "resources/read", params }, types_js_1.ReadResourceResultSchema, options);
      }
      async subscribeResource(params, options) {
        return this.request({ method: "resources/subscribe", params }, types_js_1.EmptyResultSchema, options);
      }
      async unsubscribeResource(params, options) {
        return this.request({ method: "resources/unsubscribe", params }, types_js_1.EmptyResultSchema, options);
      }
      async callTool(params, resultSchema = types_js_1.CallToolResultSchema, options) {
        const result = await this.request({ method: "tools/call", params }, resultSchema, options);
        const validator = this.getToolOutputValidator(params.name);
        if (validator) {
          if (!result.structuredContent && !result.isError) {
            throw new types_js_1.McpError(types_js_1.ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`);
          }
          if (result.structuredContent) {
            try {
              const isValid = validator(result.structuredContent);
              if (!isValid) {
                throw new types_js_1.McpError(types_js_1.ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${this._ajv.errorsText(validator.errors)}`);
              }
            } catch (error) {
              if (error instanceof types_js_1.McpError) {
                throw error;
              }
              throw new types_js_1.McpError(types_js_1.ErrorCode.InvalidParams, `Failed to validate structured content: ${error instanceof Error ? error.message : String(error)}`);
            }
          }
        }
        return result;
      }
      cacheToolOutputSchemas(tools) {
        this._cachedToolOutputValidators.clear();
        for (const tool of tools) {
          if (tool.outputSchema) {
            try {
              const validator = this._ajv.compile(tool.outputSchema);
              this._cachedToolOutputValidators.set(tool.name, validator);
            } catch (_a) {
            }
          }
        }
      }
      getToolOutputValidator(toolName) {
        return this._cachedToolOutputValidators.get(toolName);
      }
      async listTools(params, options) {
        const result = await this.request({ method: "tools/list", params }, types_js_1.ListToolsResultSchema, options);
        this.cacheToolOutputSchemas(result.tools);
        return result;
      }
      async sendRootsListChanged() {
        return this.notification({ method: "notifications/roots/list_changed" });
      }
    };
    exports2.Client = Client;
  }
});

// node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js
var require_windows = __commonJS({
  "node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs = require("fs");
    function checkPathExt(path, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat, path, options) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path, options);
    }
    function isexe(path, options, cb) {
      fs.stat(path, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path, options));
      });
    }
    function sync(path, options) {
      return checkStat(fs.statSync(path), path, options);
    }
  }
});

// node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js
var require_mode = __commonJS({
  "node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs = require("fs");
    function isexe(path, options, cb) {
      fs.stat(path, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options));
      });
    }
    function sync(path, options) {
      return checkStat(fs.statSync(path), options);
    }
    function checkStat(stat, options) {
      return stat.isFile() && checkMode(stat, options);
    }
    function checkMode(stat, options) {
      var mod = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js
var require_isexe = __commonJS({
  "node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js"(exports2, module2) {
    var fs = require("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve, reject) {
          isexe(path, options || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve(is);
            }
          });
        });
      }
      core(path, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path, options) {
      try {
        return core.sync(path, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});

// node_modules/.pnpm/which@2.0.2/node_modules/which/which.js
var require_which = __commonJS({
  "node_modules/.pnpm/which@2.0.2/node_modules/which/which.js"(exports2, module2) {
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path = require("path");
    var COLON = isWindows ? ";" : ":";
    var isexe = require_isexe();
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
        // windows always checks the cwd first
        ...isWindows ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
        "").split(colon)
      ];
      const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows ? pathExtExe.split(colon) : [""];
      if (isWindows) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    var which = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      const step = (i) => new Promise((resolve, reject) => {
        if (i === pathEnv.length)
          return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve(subStep(p, i, 0));
      });
      const subStep = (p, i, ii) => new Promise((resolve, reject) => {
        if (ii === pathExt.length)
          return resolve(step(i + 1));
        const ext = pathExt[ii];
        isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found.push(p + ext);
            else
              return resolve(p + ext);
          }
          return resolve(subStep(p, i, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    var whichSync = (cmd, opt) => {
      opt = opt || {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (let i = 0; i < pathEnv.length; i++) {
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          const cur = p + pathExt[j];
          try {
            const is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which;
    which.sync = whichSync;
  }
});

// node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js
var require_path_key = __commonJS({
  "node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js"(exports2, module2) {
    "use strict";
    var pathKey = (options = {}) => {
      const environment = options.env || process.env;
      const platform = options.platform || process.platform;
      if (platform !== "win32") {
        return "PATH";
      }
      return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
    };
    module2.exports = pathKey;
    module2.exports.default = pathKey;
  }
});

// node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS({
  "node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/resolveCommand.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var which = require_which();
    var getPathKey = require_path_key();
    function resolveCommandAttempt(parsed, withoutPathExt) {
      const env = parsed.options.env || process.env;
      const cwd = process.cwd();
      const hasCustomCwd = parsed.options.cwd != null;
      const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
      if (shouldSwitchCwd) {
        try {
          process.chdir(parsed.options.cwd);
        } catch (err) {
        }
      }
      let resolved;
      try {
        resolved = which.sync(parsed.command, {
          path: env[getPathKey({ env })],
          pathExt: withoutPathExt ? path.delimiter : void 0
        });
      } catch (e) {
      } finally {
        if (shouldSwitchCwd) {
          process.chdir(cwd);
        }
      }
      if (resolved) {
        resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
      }
      return resolved;
    }
    function resolveCommand(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
    }
    module2.exports = resolveCommand;
  }
});

// node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS({
  "node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/escape.js"(exports2, module2) {
    "use strict";
    var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg) {
      arg = arg.replace(metaCharsRegExp, "^$1");
      return arg;
    }
    function escapeArgument(arg, doubleEscapeMetaChars) {
      arg = `${arg}`;
      arg = arg.replace(/(?=(\\+?)?)\1"/g, '$1$1\\"');
      arg = arg.replace(/(?=(\\+?)?)\1$/, "$1$1");
      arg = `"${arg}"`;
      arg = arg.replace(metaCharsRegExp, "^$1");
      if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, "^$1");
      }
      return arg;
    }
    module2.exports.command = escapeCommand;
    module2.exports.argument = escapeArgument;
  }
});

// node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS({
  "node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = /^#!(.*)/;
  }
});

// node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js
var require_shebang_command = __commonJS({
  "node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js"(exports2, module2) {
    "use strict";
    var shebangRegex = require_shebang_regex();
    module2.exports = (string = "") => {
      const match = string.match(shebangRegex);
      if (!match) {
        return null;
      }
      const [path, argument] = match[0].replace(/#! ?/, "").split(" ");
      const binary = path.split("/").pop();
      if (binary === "env") {
        return argument;
      }
      return argument ? `${binary} ${argument}` : binary;
    };
  }
});

// node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS({
  "node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/readShebang.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var shebangCommand = require_shebang_command();
    function readShebang(command) {
      const size = 150;
      const buffer = Buffer.alloc(size);
      let fd;
      try {
        fd = fs.openSync(command, "r");
        fs.readSync(fd, buffer, 0, size, 0);
        fs.closeSync(fd);
      } catch (e) {
      }
      return shebangCommand(buffer.toString());
    }
    module2.exports = readShebang;
  }
});

// node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/parse.js
var require_parse6 = __commonJS({
  "node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/parse.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var resolveCommand = require_resolveCommand();
    var escape = require_escape();
    var readShebang = require_readShebang();
    var isWin = process.platform === "win32";
    var isExecutableRegExp = /\.(?:com|exe)$/i;
    var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);
      const shebang = parsed.file && readShebang(parsed.file);
      if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        return resolveCommand(parsed);
      }
      return parsed.file;
    }
    function parseNonShell(parsed) {
      if (!isWin) {
        return parsed;
      }
      const commandFile = detectShebang(parsed);
      const needsShell = !isExecutableRegExp.test(commandFile);
      if (parsed.options.forceShell || needsShell) {
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        parsed.command = path.normalize(parsed.command);
        parsed.command = escape.command(parsed.command);
        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
        const shellCommand = [parsed.command].concat(parsed.args).join(" ");
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
        parsed.command = process.env.comspec || "cmd.exe";
        parsed.options.windowsVerbatimArguments = true;
      }
      return parsed;
    }
    function parse2(command, args, options) {
      if (args && !Array.isArray(args)) {
        options = args;
        args = null;
      }
      args = args ? args.slice(0) : [];
      options = Object.assign({}, options);
      const parsed = {
        command,
        args,
        options,
        file: void 0,
        original: {
          command,
          args
        }
      };
      return options.shell ? parsed : parseNonShell(parsed);
    }
    module2.exports = parse2;
  }
});

// node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS({
  "node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/enoent.js"(exports2, module2) {
    "use strict";
    var isWin = process.platform === "win32";
    function notFoundError(original, syscall) {
      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
      });
    }
    function hookChildProcess(cp, parsed) {
      if (!isWin) {
        return;
      }
      const originalEmit = cp.emit;
      cp.emit = function(name, arg1) {
        if (name === "exit") {
          const err = verifyENOENT(arg1, parsed);
          if (err) {
            return originalEmit.call(cp, "error", err);
          }
        }
        return originalEmit.apply(cp, arguments);
      };
    }
    function verifyENOENT(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawn");
      }
      return null;
    }
    function verifyENOENTSync(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawnSync");
      }
      return null;
    }
    module2.exports = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
  }
});

// node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS({
  "node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/index.js"(exports2, module2) {
    "use strict";
    var cp = require("child_process");
    var parse2 = require_parse6();
    var enoent = require_enoent();
    function spawn(command, args, options) {
      const parsed = parse2(command, args, options);
      const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      enoent.hookChildProcess(spawned, parsed);
      return spawned;
    }
    function spawnSync(command, args, options) {
      const parsed = parse2(command, args, options);
      const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
      result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
      return result;
    }
    module2.exports = spawn;
    module2.exports.spawn = spawn;
    module2.exports.sync = spawnSync;
    module2.exports._parse = parse2;
    module2.exports._enoent = enoent;
  }
});

// node_modules/.pnpm/@modelcontextprotocol+sdk@1.20.2/node_modules/@modelcontextprotocol/sdk/dist/cjs/shared/stdio.js
var require_stdio = __commonJS({
  "node_modules/.pnpm/@modelcontextprotocol+sdk@1.20.2/node_modules/@modelcontextprotocol/sdk/dist/cjs/shared/stdio.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadBuffer = void 0;
    exports2.deserializeMessage = deserializeMessage;
    exports2.serializeMessage = serializeMessage;
    var types_js_1 = require_types9();
    var ReadBuffer = class {
      append(chunk) {
        this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;
      }
      readMessage() {
        if (!this._buffer) {
          return null;
        }
        const index = this._buffer.indexOf("\n");
        if (index === -1) {
          return null;
        }
        const line = this._buffer.toString("utf8", 0, index).replace(/\r$/, "");
        this._buffer = this._buffer.subarray(index + 1);
        return deserializeMessage(line);
      }
      clear() {
        this._buffer = void 0;
      }
    };
    exports2.ReadBuffer = ReadBuffer;
    function deserializeMessage(line) {
      return types_js_1.JSONRPCMessageSchema.parse(JSON.parse(line));
    }
    function serializeMessage(message) {
      return JSON.stringify(message) + "\n";
    }
  }
});

// node_modules/.pnpm/@modelcontextprotocol+sdk@1.20.2/node_modules/@modelcontextprotocol/sdk/dist/cjs/client/stdio.js
var require_stdio2 = __commonJS({
  "node_modules/.pnpm/@modelcontextprotocol+sdk@1.20.2/node_modules/@modelcontextprotocol/sdk/dist/cjs/client/stdio.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StdioClientTransport = exports2.DEFAULT_INHERITED_ENV_VARS = void 0;
    exports2.getDefaultEnvironment = getDefaultEnvironment;
    var cross_spawn_1 = __importDefault(require_cross_spawn());
    var node_process_1 = __importDefault(require("node:process"));
    var node_stream_1 = require("node:stream");
    var stdio_js_1 = require_stdio();
    exports2.DEFAULT_INHERITED_ENV_VARS = node_process_1.default.platform === "win32" ? [
      "APPDATA",
      "HOMEDRIVE",
      "HOMEPATH",
      "LOCALAPPDATA",
      "PATH",
      "PROCESSOR_ARCHITECTURE",
      "SYSTEMDRIVE",
      "SYSTEMROOT",
      "TEMP",
      "USERNAME",
      "USERPROFILE",
      "PROGRAMFILES"
    ] : (
      /* list inspired by the default env inheritance of sudo */
      ["HOME", "LOGNAME", "PATH", "SHELL", "TERM", "USER"]
    );
    function getDefaultEnvironment() {
      const env = {};
      for (const key of exports2.DEFAULT_INHERITED_ENV_VARS) {
        const value = node_process_1.default.env[key];
        if (value === void 0) {
          continue;
        }
        if (value.startsWith("()")) {
          continue;
        }
        env[key] = value;
      }
      return env;
    }
    var StdioClientTransport = class {
      constructor(server) {
        this._abortController = new AbortController();
        this._readBuffer = new stdio_js_1.ReadBuffer();
        this._stderrStream = null;
        this._serverParams = server;
        if (server.stderr === "pipe" || server.stderr === "overlapped") {
          this._stderrStream = new node_stream_1.PassThrough();
        }
      }
      /**
       * Starts the server process and prepares to communicate with it.
       */
      async start() {
        if (this._process) {
          throw new Error("StdioClientTransport already started! If using Client class, note that connect() calls start() automatically.");
        }
        return new Promise((resolve, reject) => {
          var _a, _b, _c, _d, _e;
          this._process = (0, cross_spawn_1.default)(this._serverParams.command, (_a = this._serverParams.args) !== null && _a !== void 0 ? _a : [], {
            // merge default env with server env because mcp server needs some env vars
            env: {
              ...getDefaultEnvironment(),
              ...this._serverParams.env
            },
            stdio: ["pipe", "pipe", (_b = this._serverParams.stderr) !== null && _b !== void 0 ? _b : "inherit"],
            shell: false,
            signal: this._abortController.signal,
            windowsHide: node_process_1.default.platform === "win32" && isElectron(),
            cwd: this._serverParams.cwd
          });
          this._process.on("error", (error) => {
            var _a2, _b2;
            if (error.name === "AbortError") {
              (_a2 = this.onclose) === null || _a2 === void 0 ? void 0 : _a2.call(this);
              return;
            }
            reject(error);
            (_b2 = this.onerror) === null || _b2 === void 0 ? void 0 : _b2.call(this, error);
          });
          this._process.on("spawn", () => {
            resolve();
          });
          this._process.on("close", (_code) => {
            var _a2;
            this._process = void 0;
            (_a2 = this.onclose) === null || _a2 === void 0 ? void 0 : _a2.call(this);
          });
          (_c = this._process.stdin) === null || _c === void 0 ? void 0 : _c.on("error", (error) => {
            var _a2;
            (_a2 = this.onerror) === null || _a2 === void 0 ? void 0 : _a2.call(this, error);
          });
          (_d = this._process.stdout) === null || _d === void 0 ? void 0 : _d.on("data", (chunk) => {
            this._readBuffer.append(chunk);
            this.processReadBuffer();
          });
          (_e = this._process.stdout) === null || _e === void 0 ? void 0 : _e.on("error", (error) => {
            var _a2;
            (_a2 = this.onerror) === null || _a2 === void 0 ? void 0 : _a2.call(this, error);
          });
          if (this._stderrStream && this._process.stderr) {
            this._process.stderr.pipe(this._stderrStream);
          }
        });
      }
      /**
       * The stderr stream of the child process, if `StdioServerParameters.stderr` was set to "pipe" or "overlapped".
       *
       * If stderr piping was requested, a PassThrough stream is returned _immediately_, allowing callers to
       * attach listeners before the start method is invoked. This prevents loss of any early
       * error output emitted by the child process.
       */
      get stderr() {
        var _a, _b;
        if (this._stderrStream) {
          return this._stderrStream;
        }
        return (_b = (_a = this._process) === null || _a === void 0 ? void 0 : _a.stderr) !== null && _b !== void 0 ? _b : null;
      }
      /**
       * The child process pid spawned by this transport.
       *
       * This is only available after the transport has been started.
       */
      get pid() {
        var _a, _b;
        return (_b = (_a = this._process) === null || _a === void 0 ? void 0 : _a.pid) !== null && _b !== void 0 ? _b : null;
      }
      processReadBuffer() {
        var _a, _b;
        while (true) {
          try {
            const message = this._readBuffer.readMessage();
            if (message === null) {
              break;
            }
            (_a = this.onmessage) === null || _a === void 0 ? void 0 : _a.call(this, message);
          } catch (error) {
            (_b = this.onerror) === null || _b === void 0 ? void 0 : _b.call(this, error);
          }
        }
      }
      async close() {
        this._abortController.abort();
        this._process = void 0;
        this._readBuffer.clear();
      }
      send(message) {
        return new Promise((resolve) => {
          var _a;
          if (!((_a = this._process) === null || _a === void 0 ? void 0 : _a.stdin)) {
            throw new Error("Not connected");
          }
          const json = (0, stdio_js_1.serializeMessage)(message);
          if (this._process.stdin.write(json)) {
            resolve();
          } else {
            this._process.stdin.once("drain", resolve);
          }
        });
      }
    };
    exports2.StdioClientTransport = StdioClientTransport;
    function isElectron() {
      return "type" in node_process_1.default;
    }
  }
});

// node_modules/.pnpm/@langchain+mcp-adapters@1.0_422fcda27cc657832245d1643c939873/node_modules/@langchain/mcp-adapters/dist/connection.cjs
var require_connection = __commonJS({
  "node_modules/.pnpm/@langchain+mcp-adapters@1.0_422fcda27cc657832245d1643c939873/node_modules/@langchain/mcp-adapters/dist/connection.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime();
    var require_logging2 = require_logging();
    var require_package2 = require_package();
    var __modelcontextprotocol_sdk_client_sse_js = require_rolldown_runtime5.__toESM(require_sse());
    var __modelcontextprotocol_sdk_client_streamableHttp_js = require_rolldown_runtime5.__toESM(require_streamableHttp());
    var __modelcontextprotocol_sdk_client_index_js = require_rolldown_runtime5.__toESM(require_client2());
    var __modelcontextprotocol_sdk_client_stdio_js = require_rolldown_runtime5.__toESM(require_stdio2());
    var __modelcontextprotocol_sdk_types_js = require_rolldown_runtime5.__toESM(require_types9());
    var debugLog = require_logging2.getDebugLog("connection");
    var transportTypes = [
      "http",
      "sse",
      "stdio"
    ];
    var ConnectionManager = class {
      #connections = /* @__PURE__ */ new Map();
      #hooks;
      constructor(hooks = {}) {
        this.#hooks = hooks;
      }
      async createClient(...args) {
        const [type, serverName, options] = args;
        if (!transportTypes.includes(type)) throw new Error(`Invalid transport type: ${type}`);
        const transport = type === "http" ? await this.#createStreamableHTTPTransport(serverName, options) : type === "sse" ? await this.#createSSETransport(serverName, options) : await this.#createStdioTransport(options);
        const mcpClient = new __modelcontextprotocol_sdk_client_index_js.Client({
          name: require_package2.default.name,
          version: require_package2.default.version
        });
        await mcpClient.connect(transport);
        if (this.#hooks.onMessage) mcpClient.setNotificationHandler(__modelcontextprotocol_sdk_types_js.LoggingMessageNotificationSchema, (notification) => this.#hooks.onMessage?.(notification.params, {
          server: serverName,
          options
        }));
        if (this.#hooks.onInitialized) mcpClient.setNotificationHandler(__modelcontextprotocol_sdk_types_js.InitializedNotificationSchema, () => this.#hooks.onInitialized?.({
          server: serverName,
          options
        }));
        if (this.#hooks.onCancelled) mcpClient.setNotificationHandler(__modelcontextprotocol_sdk_types_js.CancelledNotificationSchema, (notification) => this.#hooks.onCancelled?.(notification.params, {
          server: serverName,
          options
        }));
        if (this.#hooks.onPromptsListChanged) mcpClient.setNotificationHandler(__modelcontextprotocol_sdk_types_js.PromptListChangedNotificationSchema, () => this.#hooks.onPromptsListChanged?.({
          server: serverName,
          options
        }));
        if (this.#hooks.onResourcesListChanged) mcpClient.setNotificationHandler(__modelcontextprotocol_sdk_types_js.ResourceListChangedNotificationSchema, () => this.#hooks.onResourcesListChanged?.({
          server: serverName,
          options
        }));
        if (this.#hooks.onResourcesUpdated) mcpClient.setNotificationHandler(__modelcontextprotocol_sdk_types_js.ResourceUpdatedNotificationSchema, (notification) => this.#hooks.onResourcesUpdated?.(notification.params, {
          server: serverName,
          options
        }));
        if (this.#hooks.onRootsListChanged) mcpClient.setNotificationHandler(__modelcontextprotocol_sdk_types_js.RootsListChangedNotificationSchema, () => this.#hooks.onRootsListChanged?.({
          server: serverName,
          options
        }));
        if (this.#hooks.onToolsListChanged) mcpClient.setNotificationHandler(__modelcontextprotocol_sdk_types_js.ToolListChangedNotificationSchema, () => this.#hooks.onToolsListChanged?.({
          server: serverName,
          options
        }));
        const key = type === "stdio" ? { serverName } : {
          serverName,
          headers: serializeHeaders(options.headers),
          authProvider: options.authProvider
        };
        const forkClient = (headers) => {
          return this.#forkClient(key, headers);
        };
        const client = new Proxy(mcpClient, { get(target, prop) {
          if (prop === "fork") return forkClient.bind(this);
          return target[prop];
        } });
        this.#connections.set(key, {
          transport,
          client,
          transportOptions: options,
          closeCallback: async () => client.close()
        });
        return client;
      }
      /**
      * Allows to fork a client with a new set of headers
      */
      #forkClient(key, headers) {
        const [, connection] = [...this.#connections.entries()].find(([k]) => key === k) ?? [];
        if (!connection) throw new Error("Transport not found");
        const type = connection.transportOptions.type ?? connection.transportOptions.transport;
        if (type === "stdio") throw new Error("Forking stdio transport is not supported");
        return this.createClient(type, key.serverName, {
          ...connection.transportOptions,
          headers
        });
      }
      get(options) {
        if (typeof options === "string") return this.#queryConnection({ serverName: options })?.connection.client;
        return this.#queryConnection(options)?.connection.client;
      }
      /**
      * Get all clients
      * @returns All clients
      */
      getAllClients() {
        return Array.from(this.#connections.values()).map((connection) => connection.client);
      }
      /**
      * Find the connection based on the parameter provided. This approach makes sure
      * that `this.get({ serverName })` and `this.get({ serverName, headers: undefined, authProvider: undefined })`
      * will return the same connection.
      *
      * @param options - The options for the transport
      * @returns The connection and the key
      */
      #queryConnection(options) {
        const headers = serializeHeaders(options.headers);
        const [key, connection] = [...this.#connections.entries()].find(([key$1]) => {
          if (options.headers && options.authProvider) return key$1.serverName === options.serverName && key$1.headers === headers && key$1.authProvider === options.authProvider;
          if (options.headers && !options.authProvider) return key$1.serverName === options.serverName && key$1.headers === headers;
          if (options.authProvider && !options.headers) return key$1.serverName === options.serverName && key$1.authProvider === options.authProvider;
          return key$1.serverName === options.serverName;
        }) ?? [];
        if (key && connection) return {
          key,
          connection
        };
        return void 0;
      }
      has(options) {
        return Boolean(typeof options === "string" ? this.get(options) : this.get(options));
      }
      /**
      * Delete the transport based on server name and connection configuration.
      * @param options - The options for the transport, if not provided, all transports are deleted
      */
      async delete(options) {
        if (!options) {
          await Promise.all(Array.from(this.#connections.values()).map((connection) => connection.closeCallback()));
          this.#connections.clear();
          return;
        }
        const result = this.#queryConnection(options);
        if (result) {
          await result.connection.closeCallback();
          this.#connections.delete(result.key);
        }
      }
      getTransport(opts) {
        if ("listTools" in opts) {
          const connection = [...this.#connections.values()].find((connection$1) => connection$1.client === opts);
          return connection?.transport;
        }
        const result = this.#queryConnection(opts);
        if (result) return result.connection.transport;
        return void 0;
      }
      async #createStreamableHTTPTransport(serverName, args) {
        const { url, headers, reconnect, authProvider } = args;
        const options = {
          ...authProvider ? { authProvider } : {},
          ...headers ? { requestInit: { headers } } : {}
        };
        if (reconnect != null) {
          const reconnectionOptions = {
            initialReconnectionDelay: reconnect?.delayMs ?? 1e3,
            maxReconnectionDelay: reconnect?.delayMs ?? 3e4,
            maxRetries: reconnect?.maxAttempts ?? 2,
            reconnectionDelayGrowFactor: 1.5
          };
          if (reconnect.enabled === false) reconnectionOptions.maxRetries = 0;
          options.reconnectionOptions = reconnectionOptions;
        }
        if (options.requestInit?.headers) debugLog(`DEBUG: Using custom headers for SSE transport to server "${serverName}"`);
        if (options.authProvider) debugLog(`DEBUG: Using OAuth authentication for Streamable HTTP transport to server "${serverName}"`);
        if (options.reconnectionOptions) if (options.reconnectionOptions.maxRetries === 0) debugLog(`DEBUG: Disabling reconnection for Streamable HTTP transport to server "${serverName}"`);
        else debugLog(`DEBUG: Using custom reconnection options for Streamable HTTP transport to server "${serverName}"`);
        return Object.keys(options).length > 0 ? new __modelcontextprotocol_sdk_client_streamableHttp_js.StreamableHTTPClientTransport(new URL(url), options) : new __modelcontextprotocol_sdk_client_streamableHttp_js.StreamableHTTPClientTransport(new URL(url));
      }
      /**
      * Create an SSE transport with appropriate EventSource implementation
      *
      * @param serverName - The name of the server
      * @param url - The URL of the server
      * @param headers - The headers to send with the request
      * @param authProvider - The OAuth client provider to use for authentication
      * @returns The SSE transport
      */
      async #createSSETransport(serverName, args) {
        const { url, headers, authProvider } = args;
        const options = {};
        if (authProvider) {
          options.authProvider = authProvider;
          debugLog(`DEBUG: Using OAuth authentication for SSE transport to server "${serverName}"`);
        }
        if (headers) {
          options.eventSourceInit = { fetch: async (url$1, init) => {
            const requestHeaders = new Headers(init?.headers);
            if (authProvider) {
              const tokens = await authProvider.tokens();
              if (tokens) requestHeaders.set("Authorization", `Bearer ${tokens.access_token}`);
            }
            Object.entries(headers).forEach(([key, value]) => {
              requestHeaders.set(key, value);
            });
            requestHeaders.set("Accept", "text/event-stream");
            return fetch(url$1, {
              ...init,
              headers: requestHeaders
            });
          } };
          options.requestInit = { headers };
          debugLog(`DEBUG: Using custom headers for SSE transport to server "${serverName}"`);
        }
        return new __modelcontextprotocol_sdk_client_sse_js.SSEClientTransport(new URL(url), options);
      }
      #createStdioTransport(options) {
        const { command, args, env, stderr } = options;
        return new __modelcontextprotocol_sdk_client_stdio_js.StdioClientTransport({
          command,
          args,
          stderr,
          ...env ? { env: {
            PATH: process.env.PATH,
            ...env
          } } : {}
        });
      }
    };
    function serializeHeaders(headers) {
      if (!headers) return;
      return Object.entries(headers).sort(([a], [b]) => a.localeCompare(b)).map(([key, value]) => `${key}: ${value}`).join("\n");
    }
    exports2.ConnectionManager = ConnectionManager;
  }
});

// node_modules/.pnpm/@langchain+mcp-adapters@1.0_422fcda27cc657832245d1643c939873/node_modules/@langchain/mcp-adapters/dist/client.cjs
var require_client3 = __commonJS({
  "node_modules/.pnpm/@langchain+mcp-adapters@1.0_422fcda27cc657832245d1643c939873/node_modules/@langchain/mcp-adapters/dist/client.cjs"(exports2) {
    var require_rolldown_runtime5 = require_rolldown_runtime();
    var require_types10 = require_types2();
    var require_logging2 = require_logging();
    var require_tools5 = require_tools4();
    var require_connection2 = require_connection();
    var zod_v3 = require_rolldown_runtime5.__toESM(require_v3());
    var debugLog = require_logging2.getDebugLog();
    var MCPClientError = class extends Error {
      constructor(message, serverName) {
        super(message);
        this.serverName = serverName;
        this.name = "MCPClientError";
      }
    };
    function isResolvedStdioConnection(connection) {
      if (typeof connection !== "object" || connection === null || Array.isArray(connection)) return false;
      if ("transport" in connection && connection.transport === "stdio") return true;
      if ("type" in connection && connection.type === "stdio") return true;
      if ("command" in connection && typeof connection.command === "string") return true;
      return false;
    }
    function isResolvedStreamableHTTPConnection(connection) {
      if (typeof connection !== "object" || connection === null || Array.isArray(connection)) return false;
      if ("transport" in connection && typeof connection.transport === "string" && ["http", "sse"].includes(connection.transport) || "type" in connection && typeof connection.type === "string" && ["http", "sse"].includes(connection.type)) return true;
      if ("url" in connection && typeof connection.url === "string") try {
        new URL(connection.url);
        return true;
      } catch {
        return false;
      }
      return false;
    }
    var MultiServerMCPClient2 = class {
      /**
      * Cached map of server names to tools
      */
      #serverNameToTools = {};
      /**
      * Configured MCP servers
      */
      #mcpServers;
      /**
      * Cached map of server names to load tools options
      */
      #loadToolsOptions = {};
      /**
      * Connection manager
      */
      #clientConnections;
      /**
      * Resolved client config
      */
      #config;
      /**
      * Returns clone of server config for inspection purposes.
      *
      * Client does not support config modifications.
      */
      get config() {
        return JSON.parse(JSON.stringify(this.#config));
      }
      /**
      * Create a new MultiServerMCPClient.
      *
      * @param config - Configuration object
      */
      constructor(config) {
        let parsedServerConfig;
        const configSchema = require_types10.clientConfigSchema;
        if ("mcpServers" in config) parsedServerConfig = configSchema.parse(config);
        else {
          const parsedMcpServers = zod_v3.z.record(require_types10.connectionSchema).parse(config);
          parsedServerConfig = configSchema.parse({ mcpServers: parsedMcpServers });
        }
        if (Object.keys(parsedServerConfig.mcpServers).length === 0) throw new MCPClientError("No MCP servers provided");
        for (const [serverName, serverConfig] of Object.entries(parsedServerConfig.mcpServers)) {
          const outputHandling = require_types10._resolveAndApplyOverrideHandlingOverrides(parsedServerConfig.outputHandling, serverConfig.outputHandling);
          const defaultToolTimeout = parsedServerConfig.defaultToolTimeout ?? serverConfig.defaultToolTimeout;
          this.#loadToolsOptions[serverName] = {
            throwOnLoadError: parsedServerConfig.throwOnLoadError,
            prefixToolNameWithServerName: parsedServerConfig.prefixToolNameWithServerName,
            additionalToolNamePrefix: parsedServerConfig.additionalToolNamePrefix,
            useStandardContentBlocks: parsedServerConfig.useStandardContentBlocks,
            ...Object.keys(outputHandling).length > 0 ? { outputHandling } : {},
            ...defaultToolTimeout ? { defaultToolTimeout } : {},
            onProgress: parsedServerConfig.onProgress,
            beforeToolCall: parsedServerConfig.beforeToolCall,
            afterToolCall: parsedServerConfig.afterToolCall
          };
        }
        this.#config = parsedServerConfig;
        this.#mcpServers = parsedServerConfig.mcpServers;
        this.#clientConnections = new require_connection2.ConnectionManager(parsedServerConfig);
      }
      /**
      * Proactively initialize connections to all servers. This will be called automatically when
      * methods requiring an active connection (like {@link getTools} or {@link getClient}) are called,
      * but you can call it directly to ensure all connections are established before using the tools.
      *
      * @returns A map of server names to arrays of tools
      * @throws {MCPClientError} If initialization fails
      */
      async initializeConnections(customTransportOptions) {
        if (!this.#mcpServers || Object.keys(this.#mcpServers).length === 0) throw new MCPClientError("No connections to initialize");
        for (const [serverName, connection] of Object.entries(this.#mcpServers)) if (isResolvedStdioConnection(connection)) {
          debugLog(`INFO: Initializing stdio connection to server "${serverName}"...`);
          if (this.#clientConnections.has(serverName)) continue;
          await this._initializeStdioConnection(serverName, connection);
        } else if (isResolvedStreamableHTTPConnection(connection)) {
          const { authProvider, headers } = customTransportOptions ?? {};
          const updatedConnection = {
            ...connection,
            authProvider: authProvider ?? connection.authProvider,
            headers: {
              ...headers,
              ...connection.headers
            }
          };
          const key = {
            serverName,
            headers: updatedConnection.headers,
            authProvider: updatedConnection.authProvider
          };
          if (this.#clientConnections.has(key)) continue;
          if (connection.type === "sse" || connection.transport === "sse") await this._initializeSSEConnection(serverName, updatedConnection);
          else await this._initializeStreamableHTTPConnection(serverName, updatedConnection);
        } else throw new MCPClientError(`Unsupported transport type for server "${serverName}"`, serverName);
        return this.#serverNameToTools;
      }
      async getTools(...args) {
        if (args.length === 0 || args.every((arg) => typeof arg === "string")) {
          await this.initializeConnections();
          const servers$1 = args;
          return servers$1.length === 0 ? this._getAllToolsAsFlatArray() : this._getToolsFromServers(servers$1);
        }
        const [servers, options] = args;
        await this.initializeConnections(options);
        return servers.length === 0 ? this._getAllToolsAsFlatArray() : this._getToolsFromServers(servers);
      }
      async setLoggingLevel(...args) {
        if (args.length === 1 && typeof args[0] === "string") {
          const level$1 = args[0];
          await Promise.all(this.#clientConnections.getAllClients().map((client) => client.setLoggingLevel(level$1)));
          return;
        }
        const [serverName, level] = args;
        await this.#clientConnections.get(serverName)?.setLoggingLevel(level);
      }
      /**
      * Get a the MCP client for a specific server. Useful for fetching prompts or resources from that server.
      *
      * @param serverName - The name of the server
      * @returns The client for the server, or undefined if the server is not connected
      */
      async getClient(serverName, options) {
        await this.initializeConnections(options);
        return this.#clientConnections.get({
          serverName,
          headers: options?.headers,
          authProvider: options?.authProvider
        });
      }
      /**
      * Close all connections.
      */
      async close() {
        debugLog(`INFO: Closing all MCP connections...`);
        this.#serverNameToTools = {};
        await this.#clientConnections.delete();
        debugLog(`INFO: All MCP connections closed`);
      }
      /**
      * Initialize a stdio connection
      */
      async _initializeStdioConnection(serverName, connection) {
        const { command, args, restart } = connection;
        debugLog(`DEBUG: Creating stdio transport for server "${serverName}" with command: ${command} ${args.join(" ")}`);
        try {
          const client = await this.#clientConnections.createClient("stdio", serverName, connection);
          const transport = this.#clientConnections.getTransport({ serverName });
          if (restart?.enabled) this._setupStdioRestart(serverName, transport, connection, restart);
          await this._loadToolsForServer(serverName, client);
        } catch (error) {
          throw new MCPClientError(`Failed to connect to stdio server "${serverName}": ${error}`, serverName);
        }
      }
      /**
      * Set up stdio restart handling
      */
      _setupStdioRestart(serverName, transport, connection, restart) {
        const originalOnClose = transport.onclose;
        transport.onclose = async () => {
          if (originalOnClose) await originalOnClose();
          if (this.#clientConnections.get(serverName)) {
            debugLog(`INFO: Process for server "${serverName}" exited, attempting to restart...`);
            await this._attemptReconnect(serverName, connection, restart.maxAttempts, restart.delayMs);
          }
        };
      }
      _getHttpErrorCode(error) {
        const streamableError = error;
        let { code } = streamableError;
        if (code == null) {
          const m = streamableError.message.match(/\(HTTP (\d\d\d)\)/);
          if (m && m.length > 1) code = parseInt(m[1], 10);
        }
        return code;
      }
      _createAuthenticationErrorMessage(serverName, url, transport, originalError) {
        return `Authentication failed for ${transport} server "${serverName}" at ${url}. Please check your credentials, authorization headers, or OAuth configuration. Original error: ${originalError}`;
      }
      _toSSEConnectionURL(url) {
        const urlObj = new URL(url);
        const pathnameParts = urlObj.pathname.split("/");
        const lastPart = pathnameParts.at(-1);
        if (lastPart && lastPart === "mcp") pathnameParts[pathnameParts.length - 1] = "sse";
        urlObj.pathname = pathnameParts.join("/");
        return urlObj.toString();
      }
      /**
      * Initialize a streamable HTTP connection
      */
      async _initializeStreamableHTTPConnection(serverName, connection) {
        const { url, type: typeField, transport: transportField } = connection;
        const automaticSSEFallback = connection.automaticSSEFallback ?? true;
        const transportType = typeField || transportField;
        debugLog(`DEBUG: Creating Streamable HTTP transport for server "${serverName}" with URL: ${url}`);
        if (transportType === "http" || transportType == null) try {
          const client = await this.#clientConnections.createClient("http", serverName, connection);
          await this._loadToolsForServer(serverName, client);
        } catch (error) {
          const code = this._getHttpErrorCode(error);
          if (automaticSSEFallback && code != null && code >= 400 && code < 500) try {
            await this._initializeSSEConnection(serverName, connection);
          } catch (firstSSEError) {
            const sseUrl = this._toSSEConnectionURL(url);
            if (sseUrl !== url) try {
              await this._initializeSSEConnection(serverName, {
                ...connection,
                url: sseUrl
              });
            } catch (secondSSEError) {
              if (code === 401) throw new MCPClientError(this._createAuthenticationErrorMessage(serverName, url, "HTTP", `${error}. Also tried SSE fallback at ${url} and ${sseUrl}, but both failed with authentication errors.`), serverName);
              throw new MCPClientError(`Failed to connect to streamable HTTP server "${serverName}, url: ${url}": ${error}. Additionally, tried falling back to SSE at ${url} and ${sseUrl}, but this also failed: ${secondSSEError}`, serverName);
            }
            else {
              if (code === 401) throw new MCPClientError(this._createAuthenticationErrorMessage(serverName, url, "HTTP", `${error}. Also tried SSE fallback at ${url}, but it failed with authentication error: ${firstSSEError}`), serverName);
              throw new MCPClientError(`Failed to connect to streamable HTTP server after trying to fall back to SSE: "${serverName}, url: ${url}": ${error} (SSE fallback failed with error ${firstSSEError})`, serverName);
            }
          }
          else {
            if (code === 401) throw new MCPClientError(this._createAuthenticationErrorMessage(serverName, url, "HTTP", `${error}`), serverName);
            throw new MCPClientError(`Failed to connect to streamable HTTP server "${serverName}, url: ${url}": ${error}`, serverName);
          }
        }
      }
      /**
      * Initialize an SSE connection
      *
      * Don't call this directly unless SSE transport is explicitly requested. Otherwise,
      * use _initializeStreamableHTTPConnection and it'll fall back to SSE if needed for
      * backwards compatibility.
      *
      * @param serverName - The name of the server
      * @param connection - The connection configuration
      */
      async _initializeSSEConnection(serverName, connection) {
        const { url, headers, reconnect, authProvider } = connection;
        try {
          const client = await this.#clientConnections.createClient("sse", serverName, connection);
          const transport = this.#clientConnections.getTransport({
            serverName,
            headers,
            authProvider
          });
          if (reconnect?.enabled) this._setupSSEReconnect(serverName, transport, connection, reconnect);
          await this._loadToolsForServer(serverName, client);
        } catch (error) {
          if (error && error.name === "MCPClientError") throw error;
          const isAuthError = error && this._getHttpErrorCode(error) === 401;
          if (isAuthError) throw new MCPClientError(this._createAuthenticationErrorMessage(serverName, url, "SSE", `${error}`), serverName);
          throw new MCPClientError(`Failed to create SSE transport for server "${serverName}, url: ${url}": ${error}`, serverName);
        }
      }
      /**
      * Set up reconnect handling for SSE (Streamable HTTP reconnects are more complex and are handled internally by the SDK)
      */
      _setupSSEReconnect(serverName, transport, connection, reconnect) {
        const originalOnClose = transport.onclose;
        transport.onclose = async () => {
          if (originalOnClose) await originalOnClose();
          if (this.#clientConnections.get({
            serverName,
            headers: connection.headers,
            authProvider: connection.authProvider
          })) {
            debugLog(`INFO: HTTP connection for server "${serverName}" closed, attempting to reconnect...`);
            await this._attemptReconnect(serverName, connection, reconnect.maxAttempts, reconnect.delayMs);
          }
        };
      }
      /**
      * Load tools for a specific server
      */
      async _loadToolsForServer(serverName, client) {
        try {
          debugLog(`DEBUG: Loading tools for server "${serverName}"...`);
          const tools = await require_tools5.loadMcpTools(serverName, client, this.#loadToolsOptions[serverName]);
          this.#serverNameToTools[serverName] = tools;
          debugLog(`INFO: Successfully loaded ${tools.length} tools from server "${serverName}"`);
        } catch (error) {
          throw new MCPClientError(`Failed to load tools from server "${serverName}": ${error}`);
        }
      }
      /**
      * Attempt to reconnect to a server after a connection failure.
      *
      * @param serverName - The name of the server to reconnect to
      * @param connection - The connection configuration
      * @param maxAttempts - Maximum number of reconnection attempts
      * @param delayMs - Delay in milliseconds between reconnection attempts
      * @private
      */
      async _attemptReconnect(serverName, connection, maxAttempts = 3, delayMs = 1e3) {
        let connected = false;
        let attempts = 0;
        if ("headers" in connection || "authProvider" in connection) {
          const { headers, authProvider } = connection;
          await this.#cleanupServerResources({
            serverName,
            authProvider,
            headers
          });
        } else await this.#cleanupServerResources({ serverName });
        while (!connected && (maxAttempts === void 0 || attempts < maxAttempts)) {
          attempts += 1;
          debugLog(`INFO: Reconnection attempt ${attempts}${maxAttempts ? `/${maxAttempts}` : ""} for server "${serverName}"`);
          try {
            if (delayMs) await new Promise((resolve) => {
              setTimeout(resolve, delayMs);
            });
            if (isResolvedStdioConnection(connection)) await this._initializeStdioConnection(serverName, connection);
            else if (isResolvedStreamableHTTPConnection(connection)) if (connection.type === "sse" || connection.transport === "sse") await this._initializeSSEConnection(serverName, connection);
            else await this._initializeStreamableHTTPConnection(serverName, connection);
            const key = "headers" in connection ? {
              serverName,
              headers: connection.headers,
              authProvider: connection.authProvider
            } : { serverName };
            if (this.#clientConnections.has(key)) {
              connected = true;
              debugLog(`INFO: Successfully reconnected to server "${serverName}"`);
            }
          } catch (error) {
            debugLog(`ERROR: Failed to reconnect to server "${serverName}" (attempt ${attempts}): ${error}`);
          }
        }
        if (!connected) debugLog(`ERROR: Failed to reconnect to server "${serverName}" after ${attempts} attempts`);
      }
      /**
      * Clean up resources for a specific server
      */
      async #cleanupServerResources(transportOptions) {
        const { serverName, authProvider, headers } = transportOptions;
        delete this.#serverNameToTools[serverName];
        await this.#clientConnections.delete({
          serverName,
          authProvider,
          headers
        });
      }
      /**
      * Get all tools from all servers as a flat array.
      *
      * @returns A flattened array of all tools
      */
      _getAllToolsAsFlatArray() {
        const allTools = [];
        for (const tools of Object.values(this.#serverNameToTools)) allTools.push(...tools);
        return allTools;
      }
      /**
      * Get tools from specific servers as a flat array.
      *
      * @param serverNames - Names of servers to get tools from
      * @returns A flattened array of tools from the specified servers
      */
      _getToolsFromServers(serverNames) {
        const allTools = [];
        for (const serverName of serverNames) {
          const tools = this.#serverNameToTools[serverName];
          if (tools) allTools.push(...tools);
        }
        return allTools;
      }
    };
    exports2.MultiServerMCPClient = MultiServerMCPClient2;
  }
});

// node_modules/.pnpm/@langchain+mcp-adapters@1.0_422fcda27cc657832245d1643c939873/node_modules/@langchain/mcp-adapters/dist/index.cjs
var require_dist8 = __commonJS({
  "node_modules/.pnpm/@langchain+mcp-adapters@1.0_422fcda27cc657832245d1643c939873/node_modules/@langchain/mcp-adapters/dist/index.cjs"(exports2) {
    var require_tools5 = require_tools4();
    var require_client4 = require_client3();
    exports2.MultiServerMCPClient = require_client4.MultiServerMCPClient;
    exports2.loadMcpTools = require_tools5.loadMcpTools;
  }
});

// src/data.js
var require_data5 = __commonJS({
  "src/data.js"(exports2, module2) {
    var webFrame = require("electron").webFrame;
    var feature_suffix = "anywhere\u52A9\u624B^_^";
    var defaultConfig2 = {
      config: {
        providers: {
          "0": {
            name: "default",
            url: "https://api.openai.com/v1",
            api_key: "",
            modelList: [],
            enable: true
          }
        },
        providerOrder: ["0"],
        prompts: {
          AI: {
            type: "over",
            prompt: `\u4F60\u662F\u4E00\u4E2AAI\u52A9\u624B`,
            showMode: "window",
            model: "0|gpt-4o",
            enable: true,
            icon: "",
            stream: true,
            temperature: 0.7,
            isTemperature: false,
            isDirectSend_file: false,
            isDirectSend_normal: true,
            ifTextNecessary: false,
            voice: null,
            reasoning_effort: "default",
            window_width: 540,
            window_height: 700,
            position_x: 0,
            position_y: 0,
            autoCloseOnBlur: true,
            isAlwaysOnTop: true
          }
        },
        mcpServers: {},
        language: "zh",
        tags: {},
        skipLineBreak: false,
        CtrlEnterToSend: false,
        showNotification: true,
        isDarkMode: false,
        fix_position: false,
        isAlwaysOnTop_global: true,
        autoCloseOnBlur_global: true,
        zoom: 1,
        webdav: {
          url: "",
          username: "",
          password: "",
          path: "/anywhere",
          dataPath: "/anywhere_data"
        },
        voiceList: [
          "alloy-\u{1F469}",
          "echo-\u{1F468}\u200D\u{1F9B0}\u6E05\u6670",
          "nova-\u{1F469}\u6E05\u6670",
          "sage-\u{1F467}\u5E74\u8F7B",
          "shimmer-\u{1F467}\u660E\u4EAE",
          "fable-\u{1F610}\u4E2D\u6027",
          "coral-\u{1F469}\u5BA2\u670D",
          "ash-\u{1F9D4}\u200D\u2642\uFE0F\u5546\u4E1A",
          "ballad-\u{1F468}\u6545\u4E8B",
          "verse-\u{1F468}\u8BD7\u6B4C",
          "onyx-\u{1F468}\u200D\u{1F9B0}\u65B0\u95FB",
          "Zephyr-\u{1F467}\u660E\u4EAE",
          "Puck-\u{1F466}\u6B22\u5FEB",
          "Charon-\u{1F466}\u4FE1\u606F\u4E30\u5BCC",
          "Kore-\u{1F469}\u575A\u5B9A",
          "Fenrir-\u{1F468}\u200D\u{1F9B0}\u6613\u6FC0\u52A8",
          "Leda-\u{1F467}\u5E74\u8F7B",
          "Orus-\u{1F468}\u200D\u{1F9B0}\u9274\u5B9A",
          "Aoede-\u{1F469}\u8F7B\u677E",
          "Callirrhoe-\u{1F469}\u968F\u548C",
          "Autonoe-\u{1F469}\u660E\u4EAE",
          "Enceladus-\u{1F9D4}\u200D\u2642\uFE0F\u547C\u5438\u611F",
          "Iapetus-\u{1F466}\u6E05\u6670",
          "Umbriel-\u{1F466}\u968F\u548C",
          "Algieba-\u{1F466}\u5E73\u6ED1",
          "Despina-\u{1F469}\u5E73\u6ED1",
          "Erinome-\u{1F469}\u6E05\u6670",
          "Algenib-\u{1F468}\u200D\u{1F9B0}\u6C99\u54D1",
          "Rasalgethi-\u{1F468}\u200D\u{1F9B0}\u4FE1\u606F\u4E30\u5BCC",
          "Laomedeia-\u{1F469}\u6B22\u5FEB",
          "Achernar-\u{1F469}\u8F7B\u67D4",
          "Alnilam-\u{1F466}\u575A\u5B9A",
          "Schedar-\u{1F466}\u5E73\u7A33",
          "Gacrux-\u{1F469}\u6210\u719F",
          "Pulcherrima-\u{1F469}\u5411\u524D",
          "Achird-\u{1F466}\u53CB\u597D",
          "Zubenelgenubi-\u{1F466}\u4F11\u95F2",
          "Vindemiatrix-\u{1F469}\u6E29\u67D4",
          "Sadachbia-\u{1F468}\u200D\u{1F9B0}\u6D3B\u6CFC",
          "Sadaltager-\u{1F468}\u200D\u{1F9B0}\u535A\u5B66",
          "Sulafat-\u{1F469}\u6E29\u6696"
        ]
      }
    };
    function splitConfigForStorage(fullConfig) {
      const { prompts, providers, mcpServers, ...restOfConfig } = fullConfig;
      return {
        baseConfigPart: { config: restOfConfig },
        promptsPart: prompts,
        providersPart: providers,
        mcpServersPart: mcpServers
      };
    }
    function getConfig2() {
      let configDoc = utools.db.get("config");
      if (!configDoc) {
        console.log("Anywhere: Initializing configuration for a new user.");
        const { baseConfigPart, promptsPart, providersPart, mcpServersPart } = splitConfigForStorage(defaultConfig2.config);
        utools.db.put({ _id: "config", data: baseConfigPart });
        utools.db.put({ _id: "prompts", data: promptsPart });
        utools.db.put({ _id: "providers", data: providersPart });
        utools.db.put({ _id: "mcpServers", data: mcpServersPart });
        return defaultConfig2;
      }
      if (configDoc.data.config && configDoc.data.config.prompts) {
        console.warn("Anywhere: Old configuration format detected. Starting migration.");
        const oldFullConfig = configDoc.data.config;
        const { baseConfigPart, promptsPart, providersPart, mcpServersPart } = splitConfigForStorage(oldFullConfig);
        utools.db.put({ _id: "prompts", data: promptsPart });
        utools.db.put({ _id: "providers", data: providersPart });
        utools.db.put({ _id: "mcpServers", data: mcpServersPart });
        const updateResult = utools.db.put({
          _id: "config",
          data: baseConfigPart,
          _rev: configDoc._rev
        });
        if (updateResult.ok) {
          console.log("Anywhere: Migration successful. Old config cleaned.");
        } else {
          console.error("Anywhere: Migration failed to update old config document.", updateResult.message);
        }
        configDoc = utools.db.get("config");
      }
      const fullConfigData = configDoc.data;
      const promptsDoc = utools.db.get("prompts");
      fullConfigData.config.prompts = promptsDoc ? promptsDoc.data : defaultConfig2.config.prompts;
      const providersDoc = utools.db.get("providers");
      fullConfigData.config.providers = providersDoc ? providersDoc.data : defaultConfig2.config.providers;
      const mcpServersDoc = utools.db.get("mcpServers");
      fullConfigData.config.mcpServers = mcpServersDoc ? mcpServersDoc.data : defaultConfig2.config.mcpServers || {};
      return fullConfigData;
    }
    function checkConfig(config) {
      let flag = false;
      if (config.version !== "1.7.3") {
        config.version = "1.7.3";
        flag = true;
      }
      if (config.isAlwaysOnTop_global === void 0) {
        config.isAlwaysOnTop_global = true;
        flag = true;
      }
      if (config.autoCloseOnBlur_global === void 0) {
        config.autoCloseOnBlur_global = true;
        flag = true;
      }
      if (config.window_width || config.window_height) {
        delete config.window_width;
        delete config.window_height;
        flag = true;
      }
      if (config.stream !== void 0) {
        delete config.stream;
        flag = true;
      }
      if (config.autoCloseOnBlur !== void 0) {
        delete config.autoCloseOnBlur;
        flag = true;
      }
      if (config.isAlwaysOnTop !== void 0) {
        delete config.isAlwaysOnTop;
        flag = true;
      }
      if (config.CtrlEnterToSend == void 0) {
        config.CtrlEnterToSend = false;
        flag = true;
      }
      if (config.showNotification == void 0) {
        config.showNotification = false;
        flag = true;
      }
      if (config.position_x || config.position_y) {
        delete config.position_x;
        delete config.position_y;
        flag = true;
      }
      if (config.fix_position == void 0) {
        config.fix_position = false;
        flag = true;
      }
      if (config.zoom == void 0) {
        config.zoom = 1;
        flag = true;
      }
      if (config.inputLayout) {
        delete config.inputLayout;
        flag = true;
      }
      if (config.mcpServers === void 0) {
        config.mcpServers = {};
        flag = true;
      }
      if (config.voiceList === void 0) {
        config.voiceList = [
          "alloy-\u{1F469}",
          "echo-\u{1F468}\u200D\u{1F9B0}\u6E05\u6670",
          "nova-\u{1F469}\u6E05\u6670",
          "sage-\u{1F467}\u5E74\u8F7B",
          "shimmer-\u{1F467}\u660E\u4EAE",
          "fable-\u{1F610}\u4E2D\u6027",
          "coral-\u{1F469}\u5BA2\u670D",
          "ash-\u{1F9D4}\u200D\u2642\uFE0F\u5546\u4E1A",
          "ballad-\u{1F468}\u6545\u4E8B",
          "verse-\u{1F468}\u8BD7\u6B4C",
          "onyx-\u{1F468}\u200D\u{1F9B0}\u65B0\u95FB",
          "Zephyr-\u{1F467}\u660E\u4EAE",
          "Puck-\u{1F466}\u6B22\u5FEB",
          "Charon-\u{1F466}\u4FE1\u606F\u4E30\u5BCC",
          "Kore-\u{1F469}\u575A\u5B9A",
          "Fenrir-\u{1F468}\u200D\u{1F9B0}\u6613\u6FC0\u52A8",
          "Leda-\u{1F467}\u5E74\u8F7B",
          "Orus-\u{1F468}\u200D\u{1F9B0}\u9274\u5B9A",
          "Aoede-\u{1F469}\u8F7B\u677E",
          "Callirrhoe-\u{1F469}\u968F\u548C",
          "Autonoe-\u{1F469}\u660E\u4EAE",
          "Enceladus-\u{1F9D4}\u200D\u2642\uFE0F\u547C\u5438\u611F",
          "Iapetus-\u{1F466}\u6E05\u6670",
          "Umbriel-\u{1F466}\u968F\u548C",
          "Algieba-\u{1F466}\u5E73\u6ED1",
          "Despina-\u{1F469}\u5E73\u6ED1",
          "Erinome-\u{1F469}\u6E05\u6670",
          "Algenib-\u{1F468}\u200D\u{1F9B0}\u6C99\u54D1",
          "Rasalgethi-\u{1F468}\u200D\u{1F9B0}\u4FE1\u606F\u4E30\u5BCC",
          "Laomedeia-\u{1F469}\u6B22\u5FEB",
          "Achernar-\u{1F469}\u8F7B\u67D4",
          "Alnilam-\u{1F466}\u575A\u5B9A",
          "Schedar-\u{1F466}\u5E73\u7A33",
          "Gacrux-\u{1F469}\u6210\u719F",
          "Pulcherrima-\u{1F469}\u5411\u524D",
          "Achird-\u{1F466}\u53CB\u597D",
          "Zubenelgenubi-\u{1F466}\u4F11\u95F2",
          "Vindemiatrix-\u{1F469}\u6E29\u67D4",
          "Sadachbia-\u{1F468}\u200D\u{1F9B0}\u6D3B\u6CFC",
          "Sadaltager-\u{1F468}\u200D\u{1F9B0}\u535A\u5B66",
          "Sulafat-\u{1F469}\u6E29\u6696"
        ];
        flag = true;
      }
      if (config.webdav == void 0) {
        config.webdav = {
          url: "",
          username: "",
          password: "",
          path: "/anywhere",
          dataPath: "/anywhere_data"
        };
        flag = true;
      }
      if (config.webdav.dataPath == void 0) {
        config.webdav.dataPath = "/anywhere_data";
        flag = true;
      }
      if (config.apiUrl) {
        config.providers["0"] = {
          name: "default",
          url: config.apiUrl,
          api_key: config.apiKey,
          modelList: [config.modelSelect].concat(config.ModelsListByUser),
          enable: true
        };
        delete config.apiUrl;
        delete config.apiKey;
        delete config.modelList;
        delete config.ModelsListByUser;
        delete config.modelSelect;
        delete config.activeProviderId;
        config.providerOrder.unshift("0");
        flag = true;
      }
      for (let key in config.prompts) {
        if (config.prompts[key].isAlwaysOnTop === void 0) {
          config.prompts[key].isAlwaysOnTop = true;
          flag = true;
        }
        if (config.prompts[key].autoCloseOnBlur === void 0) {
          config.prompts[key].autoCloseOnBlur = true;
          flag = true;
        }
        if (config.prompts[key].window_width === void 0) {
          config.prompts[key].window_width = 540;
          flag = true;
        }
        if (config.prompts[key].window_height === void 0) {
          config.prompts[key].window_height = 700;
          flag = true;
        }
        if (config.prompts[key].position_x === void 0) {
          config.prompts[key].position_x = 0;
          flag = true;
        }
        if (config.prompts[key].position_y === void 0) {
          config.prompts[key].position_y = 0;
          flag = true;
        }
        if (config.prompts[key].stream === void 0) {
          config.prompts[key].stream = true;
          flag = true;
        }
        if (config.prompts[key].voice === void 0 || config.prompts[key].voice === null) {
          config.prompts[key].voice = "";
          flag = true;
        }
        if (config.prompts[key].enable === void 0) {
          config.prompts[key].enable = true;
          flag = true;
        }
        if (config.prompts[key].isTemperature === void 0) {
          config.prompts[key].isTemperature = false;
          config.prompts[key].temperature = 0.7;
          flag = true;
        }
        if (config.prompts[key].icon === void 0) {
          config.prompts[key].icon = "";
          flag = true;
        }
        if (config.prompts[key].isDirectSend_file === void 0) {
          if (config.prompts[key].isDirectSend === void 0) {
            config.prompts[key].isDirectSend_file = false;
          } else {
            config.prompts[key].isDirectSend_file = config.prompts[key].isDirectSend;
            delete config.prompts[key].isDirectSend;
          }
          flag = true;
        }
        if (config.prompts[key].isDirectSend_normal === void 0) {
          config.prompts[key].isDirectSend_normal = true;
          flag = true;
        }
        if (config.prompts[key].ifTextNecessary === void 0) {
          config.prompts[key].ifTextNecessary = false;
          flag = true;
        }
        if (config.prompts[key].reasoning_effort === void 0) {
          config.prompts[key].reasoning_effort = "default";
          flag = true;
        }
      }
      if (!config.tags) {
        config.tags = {};
        flag = true;
      }
      if (!config.language) {
        config.language = "zh";
        flag = true;
      }
      if (config.tool_list) {
        delete config.tool_list;
        flag = true;
      }
      if (config.ModelsListByUser) {
        delete config.ModelsListByUser;
        flag = true;
      }
      if (config.promptOrder) {
        delete config.promptOrder;
        flag = true;
      }
      for (let key in config.prompts) {
        if (config.prompts[key].idex || config.prompts[key].idex === 0) {
          delete config.prompts[key].idex;
          flag = true;
        }
      }
      for (let key in config.providers) {
        if (config.providers[key].modelSelect) {
          delete config.providers[key].modelSelect;
          flag = true;
        }
        if (delete config.providers[key].modelListByUser) {
          delete config.providers[key].modelListByUser;
          flag = true;
        }
        if (config.providers[key].enable === void 0) {
          config.providers[key].enable = true;
          flag = true;
        }
      }
      if (config.providerOrder.length === 0) {
        for (let key in config.providers) {
          config.providerOrder.push(key);
        }
        flag = true;
      }
      for (let i = 0; i < config.providerOrder.length; i++) {
        if (typeof config.providerOrder[i] !== "string") {
          config.providerOrder[i] = config.providerOrder[i].toString();
          flag = true;
        }
        if (!config.providers[config.providerOrder[i]]) {
          config.providerOrder.splice(i, 1);
          flag = true;
        }
      }
      for (let key in config.prompts) {
        if (config.prompts[key].model) {
          let model = config.prompts[key].model.split("|");
          if (model.length === 2) {
            if (!config.providers[model[0]]) {
              config.prompts[key].model = "";
              flag = true;
            }
          }
        } else {
          config.prompts[key].model = `${config.providerOrder[0]}|${config.providers[config.providerOrder[0]].modelList[0]}`;
          flag = true;
        }
        if (config.prompts[key].model === "") {
          config.prompts[key].model = `${config.providerOrder[0]}|${config.providers[config.providerOrder[0]].modelList[0]}`;
          flag = true;
        }
      }
      if (config.isDarkMode === void 0) {
        config.isDarkMode = false;
        flag = true;
      }
      if (flag) {
        updateConfig2({ "config": config });
      }
    }
    function saveSetting2(keyPath, value) {
      const rootKey = keyPath.split(".")[0];
      let docId;
      let targetKeyPath = keyPath;
      let isBaseConfig = false;
      if (rootKey === "prompts") {
        docId = "prompts";
        targetKeyPath = keyPath.substring("prompts.".length);
      } else if (rootKey === "providers") {
        docId = "providers";
        targetKeyPath = keyPath.substring("providers.".length);
      } else if (rootKey === "mcpServers") {
        docId = "mcpServers";
        targetKeyPath = keyPath.substring("mcpServers.".length);
      } else {
        docId = "config";
        isBaseConfig = true;
      }
      const doc = utools.db.get(docId);
      if (!doc) {
        console.error(`Config document "${docId}" not found, cannot save setting.`);
        return { success: false, message: `Config document "${docId}" not found` };
      }
      let dataToUpdate = doc.data;
      if (isBaseConfig) {
        dataToUpdate = dataToUpdate.config;
      }
      const keys = targetKeyPath.split(".");
      let current = dataToUpdate;
      for (let i = 0; i < keys.length - 1; i++) {
        const key = keys[i];
        if (!current[key] || typeof current[key] !== "object") {
          current[key] = {};
        }
        current = current[key];
      }
      current[keys[keys.length - 1]] = value;
      const finalData = isBaseConfig ? { config: dataToUpdate } : dataToUpdate;
      const result = utools.db.put({
        _id: docId,
        data: finalData,
        _rev: doc._rev
      });
      if (result.ok) {
        return { success: true };
      } else {
        return { success: false, message: result.message };
      }
    }
    function updateConfigWithoutFeatures(newConfig) {
      const plainConfig = JSON.parse(JSON.stringify(newConfig.config));
      const { baseConfigPart, promptsPart, providersPart, mcpServersPart } = splitConfigForStorage(plainConfig);
      let configDoc = utools.db.get("config");
      utools.db.put({
        _id: "config",
        data: baseConfigPart,
        _rev: configDoc ? configDoc._rev : void 0
      });
      let promptsDoc = utools.db.get("prompts");
      utools.db.put({
        _id: "prompts",
        data: promptsPart,
        _rev: promptsDoc ? promptsDoc._rev : void 0
      });
      let providersDoc = utools.db.get("providers");
      utools.db.put({
        _id: "providers",
        data: providersPart,
        _rev: providersDoc ? providersDoc._rev : void 0
      });
      let mcpServersDoc = utools.db.get("mcpServers");
      utools.db.put({
        _id: "mcpServers",
        data: mcpServersPart,
        _rev: mcpServersDoc ? mcpServersDoc._rev : void 0
      });
    }
    function updateConfig2(newConfig) {
      const features = utools.getFeatures();
      const featuresMap = new Map(features.map((feature) => [feature.code, feature]));
      const currentPrompts = newConfig.config.prompts || {};
      const enabledPromptKeys = /* @__PURE__ */ new Set();
      for (let key in currentPrompts) {
        const prompt = currentPrompts[key];
        if (prompt.enable) {
          enabledPromptKeys.add(key);
          const featureCode = key;
          const functionCmdCode = key + feature_suffix;
          const expectedMatchFeature = {
            code: featureCode,
            explain: key,
            mainHide: true,
            cmds: [],
            icon: prompt.icon || ""
          };
          if (prompt.type === "general") {
            expectedMatchFeature.cmds.push({ type: "over", label: key, "maxLength": 1e38 });
            expectedMatchFeature.cmds.push({ type: "img", label: key });
            expectedMatchFeature.cmds.push({ type: "files", label: key, fileType: "file", match: prompt.showMode === "window" ? "/\\.(png|jpeg|jpg|webp|docx|xlsx|xls|csv|pdf|mp3|wav|txt|md|markdown|json|xml|html|htm|css|csv|yml|py|js|ts|java|c|cpp|h|hpp|cs|go|php|rb|rs|sh|sql|vue)$/i" : "/\\.(png|jpeg|jpg|webp|pdf|mp3|wav|txt|md|markdown|json|xml|html|htm|css|csv|yml|py|js|ts|java|c|cpp|h|hpp|cs|go|php|rb|rs|sh|sql|vue)$/i" });
          } else if (prompt.type === "files") {
            expectedMatchFeature.cmds.push({ type: "files", label: key, fileType: "file", match: prompt.showMode === "window" ? "/\\.(png|jpeg|jpg|webp|docx|xlsx|xls|csv|pdf|mp3|wav|txt|md|markdown|json|xml|html|htm|css|csv|yml|py|js|ts|java|c|cpp|h|hpp|cs|go|php|rb|rs|sh|sql|vue)$/i" : "/\\.(png|jpeg|jpg|webp|pdf|mp3|wav|txt|md|markdown|json|xml|html|htm|css|csv|yml|py|js|ts|java|c|cpp|h|hpp|cs|go|php|rb|rs|sh|sql|vue)$/i" });
          } else if (prompt.type === "img") {
            expectedMatchFeature.cmds.push({ type: "img", label: key });
          } else if (prompt.type === "over") {
            expectedMatchFeature.cmds.push({ type: "over", label: key, "maxLength": 1e38 });
          }
          utools.setFeature(expectedMatchFeature);
          if (prompt.showMode === "window") {
            utools.setFeature({
              code: functionCmdCode,
              explain: key,
              mainHide: true,
              cmds: [key],
              icon: prompt.icon || ""
            });
          } else {
            if (featuresMap.has(functionCmdCode)) {
              utools.removeFeature(functionCmdCode);
            }
          }
        }
      }
      for (const [code, feature] of featuresMap) {
        if (code === "Anywhere Settings" || code === "Resume Conversation") continue;
        const promptKey = feature.explain;
        if (!enabledPromptKeys.has(promptKey) || currentPrompts[promptKey] && currentPrompts[promptKey].showMode !== "window" && code.endsWith(feature_suffix)) {
          utools.removeFeature(code);
        }
      }
      updateConfigWithoutFeatures(newConfig);
    }
    function getUser2() {
      return utools.getUser();
    }
    function getPosition(config, promptCode) {
      const promptConfig = config.prompts[promptCode];
      const width = promptConfig?.window_width || 540;
      const height = promptConfig?.window_height || 700;
      let windowX = 0, windowY = 0;
      if (config.fix_position && promptConfig && promptConfig.position_x && promptConfig.position_y) {
        let set_position = {
          x: promptConfig.position_x,
          y: promptConfig.position_y
        };
        const displays = utools.getAllDisplays();
        const primaryDisplay = utools.getPrimaryDisplay();
        const currentDisplay = displays.find(
          (display) => set_position.x >= display.bounds.x && set_position.x < display.bounds.x + display.bounds.width && set_position.y >= display.bounds.y && set_position.y < display.bounds.y + display.bounds.height
        ) || primaryDisplay;
        windowX = Math.floor(set_position.x);
        windowY = Math.floor(set_position.y);
        if (currentDisplay) {
          windowX = Math.max(windowX, currentDisplay.bounds.x);
          windowX = Math.min(windowX, currentDisplay.bounds.x + currentDisplay.bounds.width - width);
          windowY = Math.max(windowY, currentDisplay.bounds.y);
          windowY = Math.min(windowY, currentDisplay.bounds.y + currentDisplay.bounds.height - height);
          if (windowY + height > currentDisplay.bounds.y + currentDisplay.bounds.height) {
            windowY = currentDisplay.bounds.y + currentDisplay.bounds.height - height;
          }
        }
      } else {
        const mouse_position = utools.getCursorScreenPoint();
        const displays = utools.getAllDisplays();
        const primaryDisplay = utools.getPrimaryDisplay();
        const currentDisplay = displays.find(
          (display) => mouse_position.x >= display.bounds.x && mouse_position.x < display.bounds.x + display.bounds.width && mouse_position.y >= display.bounds.y && mouse_position.y < display.bounds.y + display.bounds.height
        ) || primaryDisplay;
        windowX = Math.floor(mouse_position.x - width / 2);
        windowY = Math.floor(mouse_position.y);
        if (currentDisplay) {
          windowX = Math.max(windowX, currentDisplay.bounds.x);
          windowX = Math.min(windowX, currentDisplay.bounds.x + currentDisplay.bounds.width - width);
          windowY = Math.max(windowY, currentDisplay.bounds.y);
          windowY = Math.min(windowY, currentDisplay.bounds.y + currentDisplay.bounds.height - height);
          if (windowY + height > currentDisplay.bounds.y + currentDisplay.bounds.height) {
            windowY = currentDisplay.bounds.y + currentDisplay.bounds.height - height;
          }
        }
      }
      return { x: windowX, y: windowY, width, height };
    }
    function getRandomItem2(list) {
      if (typeof list === "string") {
        if (list.includes(",")) {
          list = list.split(",");
          list = list.filter((item) => item.trim() !== "");
        } else if (list.includes("\uFF0C")) {
          list = list.split("\uFF0C");
          list = list.filter((item) => item.trim() !== "");
        } else {
          return list;
        }
      }
      if (list.length === 0) {
        return "";
      } else {
        const resault = list[Math.floor(Math.random() * list.length)];
        return resault;
      }
    }
    async function chatOpenAI2(history, config, modelInfo, CODE, signal, selectedVoice = null, overrideReasoningEffort = null) {
      let apiUrl = "";
      let apiKey = "";
      let model = "";
      if (modelInfo.includes("|")) {
        const [providerId, modelName] = modelInfo.split("|");
        const provider = config.providers[providerId];
        if (provider) {
          apiUrl = provider.url;
          apiKey = provider.api_key;
          model = modelName;
        }
      }
      if (config.prompts[CODE] && config.prompts[CODE].ifTextNecessary) {
        const now = /* @__PURE__ */ new Date();
        const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}-${String(now.getDate()).padStart(2, "0")} ${String(now.getHours()).padStart(2, "0")}:${String(now.getMinutes()).padStart(2, "0")}`;
        let content = history[history.length - 1].content;
        if (typeof content === "string") {
          history[history.length - 1].content = timestamp + "\n\n" + content;
        } else if (Array.isArray(content)) {
          let flag = false;
          for (let i = 0; i < content.length; i++) {
            if (content[i].type === "text" && content[i].text && !(content[i].text.toLowerCase().startsWith("file name:") && content[i].text.toLowerCase().endsWith("file end"))) {
              content[i].text = timestamp + "\n\n" + content[i].text;
              flag = true;
              break;
            }
          }
          if (!flag) {
            history[history.length - 1].content.push({
              type: "text",
              text: timestamp
            });
          }
        }
      }
      let payload = {
        model,
        messages: history
      };
      if (selectedVoice && typeof selectedVoice === "string") {
        payload.stream = false;
        const voiceForAPI = selectedVoice.split("-")[0].trim();
        payload.modalities = ["text", "audio"];
        payload.audio = { voice: voiceForAPI, format: "wav" };
      } else {
        if (config.prompts[CODE] && typeof config.prompts[CODE].stream === "boolean") {
          payload.stream = config.prompts[CODE].stream;
        } else {
          payload.stream = true;
        }
      }
      if (config.prompts[CODE] && config.prompts[CODE].isTemperature) {
        payload.temperature = config.prompts[CODE].temperature;
      }
      const reasoningEffort = overrideReasoningEffort;
      if (reasoningEffort && reasoningEffort !== "default") {
        payload.reasoning_effort = reasoningEffort;
      }
      const response = await fetch(apiUrl + "/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer " + getRandomItem2(apiKey)
        },
        body: JSON.stringify(payload),
        signal
        //  signal  fetch
      });
      return response;
    }
    function copyText2(content) {
      utools.copyText(content);
    }
    async function sethotkey2(prompt_name, auto_copy) {
      console.log("sethotkey");
      utools.redirectHotKeySetting(prompt_name, auto_copy);
    }
    async function openWindow(config, msg) {
      const { x, y, width, height } = getPosition(config, msg.originalCode || msg.code);
      const promptCode = msg.originalCode || msg.code;
      const promptConfig = config.prompts[promptCode];
      const isAlwaysOnTop = promptConfig?.isAlwaysOnTop ?? true;
      let channel2 = "window";
      const ubWindow = utools.createBrowserWindow(
        "./window/index.html",
        {
          show: true,
          title: "Anywhere",
          useContentSize: true,
          frame: true,
          width,
          height,
          alwaysOnTop: isAlwaysOnTop,
          // 
          shellOpenPath: true,
          x,
          y,
          webPreferences: {
            preload: "./window_preload.js",
            devTools: true
          }
        },
        () => {
          ubWindow.webContents.send(channel2, msg);
          ubWindow.webContents.show();
          ubWindow.setAlwaysOnTop(isAlwaysOnTop, "floating");
          ubWindow.setFullScreen(false);
        }
      );
    }
    async function coderedirect(label, payload) {
      utools.redirect(label, payload);
    }
    function setZoomFactor2(factor) {
      webFrame.setZoomFactor(factor);
    }
    async function savePromptWindowSettings2(promptKey, settings) {
      const promptsDoc = utools.db.get("prompts");
      if (!promptsDoc || !promptsDoc.data) {
        return { success: false, message: "Prompts document not found" };
      }
      const promptsData = promptsDoc.data;
      if (!promptsData[promptKey]) {
        return { success: false, message: "Prompt not found in document" };
      }
      promptsData[promptKey] = {
        ...promptsData[promptKey],
        ...settings
      };
      const result = utools.db.put({
        _id: "prompts",
        data: promptsData,
        _rev: promptsDoc._rev
      });
      if (result.ok) {
        return { success: true };
      } else {
        return { success: false, message: result.message };
      }
    }
    module2.exports = {
      getConfig: getConfig2,
      checkConfig,
      updateConfig: updateConfig2,
      saveSetting: saveSetting2,
      updateConfigWithoutFeatures,
      savePromptWindowSettings: savePromptWindowSettings2,
      getUser: getUser2,
      getPosition,
      getRandomItem: getRandomItem2,
      chatOpenAI: chatOpenAI2,
      copyText: copyText2,
      sethotkey: sethotkey2,
      openWindow,
      coderedirect,
      setZoomFactor: setZoomFactor2,
      feature_suffix,
      defaultConfig: defaultConfig2
    };
  }
});

// src/file.js
var require_file = __commonJS({
  "src/file.js"(exports2, module2) {
    var fs = require("fs/promises");
    var fs_node = require("node:fs");
    var path = require("path");
    var parseTextFile = async (base64Data) => {
      const s = base64Data.split(",")[1];
      if (!s) throw new Error("Invalid base64 data for text file");
      const bs = atob(s);
      const ia = new Uint8Array(bs.length);
      for (let i = 0; i < bs.length; i++) ia[i] = bs.charCodeAt(i);
      return new TextDecoder().decode(ia);
    };
    var fileHandlers = {
      text: {
        extensions: [
          // Common text files
          ".txt",
          ".md",
          ".markdown",
          ".json",
          ".xml",
          ".html",
          ".css",
          ".csv",
          ".srt",
          // Common code files
          ".py",
          ".js",
          ".ts",
          ".java",
          ".c",
          ".cpp",
          ".h",
          ".hpp",
          ".cs",
          ".go",
          ".php",
          ".rb",
          ".rs",
          ".sh",
          ".sql",
          ".vue"
        ],
        handler: async (file) => {
          const textContent = await parseTextFile(file.url);
          return { type: "text", text: `file name:${file.name}
file content:${textContent}
file end` };
        }
      },
      // docx: {
      //     extensions: ['.docx'],
      //     handler: async (file) => {
      //         const textContent = await parseWord(file.url);
      //         return { type: "text", text: `file name:${file.name}\nfile content:${textContent}\nfile end` };
      //     }
      // },
      image: {
        extensions: [".png", ".jpg", ".jpeg", ".webp"],
        // Strictly adhere to original types
        handler: async (file) => {
          return { type: "image_url", image_url: { url: file.url } };
        }
      },
      audio: {
        extensions: [".mp3", ".wav"],
        // Strictly adhere to original types
        handler: async (file) => {
          const commaIndex = file.url.indexOf(",");
          if (commaIndex > -1) {
            return {
              type: "input_audio",
              input_audio: {
                data: file.url.substring(commaIndex + 1),
                format: file.name.split(".").pop().toLowerCase()
              }
            };
          }
          console.log(`\u97F3\u9891\u6587\u4EF6 ${file.name} \u683C\u5F0F\u4E0D\u6B63\u786E`);
          return null;
        }
      },
      pdf: {
        extensions: [".pdf"],
        handler: async (file) => {
          return {
            type: "file",
            file: {
              filename: file.name,
              file_data: file.url
            }
          };
        }
      }
    };
    var getFileHandler = (fileName) => {
      if (!fileName) return null;
      const extension = ("." + fileName.split(".").pop()).toLowerCase();
      for (const category in fileHandlers) {
        if (fileHandlers[category].extensions.includes(extension)) {
          return fileHandlers[category].handler;
        }
      }
      return null;
    };
    var extensionToMimeType = {
      // 
      ".txt": "text/plain",
      ".md": "text/markdown",
      ".markdown": "text/markdown",
      ".json": "application/json",
      ".xml": "application/xml",
      ".html": "text/html",
      ".css": "text/css",
      ".csv": "text/csv",
      ".py": "text/plain",
      //  'application/x-python'
      ".js": "application/javascript",
      ".ts": "application/typescript",
      ".java": "text/x-java-source",
      ".c": "text/plain",
      ".cpp": "text/plain",
      ".h": "text/plain",
      ".hpp": "text/plain",
      ".cs": "text/plain",
      ".go": "text/plain",
      ".php": "application/x-httpd-php",
      ".rb": "application/x-ruby",
      ".rs": "text/rust",
      ".sh": "application/x-sh",
      ".sql": "application/sql",
      ".vue": "text/plain",
      // 
      ".docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      ".pdf": "application/pdf",
      // 
      ".png": "image/png",
      ".jpg": "image/jpeg",
      ".jpeg": "image/jpeg",
      ".webp": "image/webp",
      // 
      ".mp3": "audio/mpeg",
      ".wav": "audio/wav"
    };
    var handleFilePath2 = async (filePath) => {
      try {
        await fs.access(filePath);
        const fileBuffer = await fs.readFile(filePath);
        const fileName = path.basename(filePath);
        const extension = path.extname(fileName).toLowerCase();
        const mimeType = extensionToMimeType[extension] || "application/octet-stream";
        const fileObject = new File([fileBuffer], fileName, { type: mimeType });
        return fileObject;
      } catch (error) {
        console.error(`\u5904\u7406\u6587\u4EF6\u8DEF\u5F84\u5931\u8D25: ${filePath}`, error);
        return null;
      }
    };
    async function sendfileDirect(filePathList) {
      if (!filePathList || filePathList.length === 0) {
        return [];
      }
      const contentPromises = filePathList.map(async (item) => {
        try {
          const filePath = item.path;
          if (!filePath || typeof filePath !== "string") {
            return null;
          }
          const fileObject = await handleFilePath2(filePath);
          if (!fileObject) {
            utools.showNotification("\u65E0\u6CD5\u8BFB\u53D6\u6216\u8BBF\u95EE\u6587\u4EF6:", filePath);
            return null;
          }
          const handler = getFileHandler(fileObject.name);
          if (!handler) {
            utools.showNotification(`\u4E0D\u652F\u6301\u7684\u6587\u4EF6\u7C7B\u578B: ${fileObject.name}`);
            return null;
          }
          const base64String = fileObject.stream ? Buffer.from(await fileObject.arrayBuffer()).toString("base64") : "";
          const dataUrl = `data:${fileObject.type};base64,${base64String}`;
          const fileForHandler = {
            name: fileObject.name,
            size: fileObject.size,
            type: fileObject.type,
            url: dataUrl
          };
          const processedContent = await handler(fileForHandler);
          return processedContent;
        } catch (error) {
          utools.showNotification("\u5904\u7406\u6587\u4EF6\u8DEF\u5F84\u65F6\u51FA\u9519:", item.path, error);
          return null;
        }
      });
      const contentList = (await Promise.all(contentPromises)).filter(Boolean);
      return contentList;
    }
    function saveFile2(options) {
      return new Promise((resolve, reject) => {
        try {
          const { fileContent, ...dialogOptions } = options;
          const savePath = utools.showSaveDialog(dialogOptions);
          if (!savePath) {
            return reject(new Error("\u7528\u6237\u53D6\u6D88\u4E86\u4FDD\u5B58\u64CD\u4F5C"));
          }
          fs_node.writeFileSync(savePath, fileContent, "utf-8");
          resolve({ success: true, path: savePath });
        } catch (error) {
          reject(error);
        }
      });
    }
    module2.exports = {
      handleFilePath: handleFilePath2,
      // (=>)
      sendfileDirect,
      //=>=>=>
      saveFile: saveFile2
    };
  }
});

// src/window_preload.js
var { ipcRenderer } = require("electron");
var { MultiServerMCPClient } = require_dist8();
var {
  getConfig,
  updateConfig,
  saveSetting,
  getUser,
  getRandomItem,
  chatOpenAI,
  copyText,
  sethotkey,
  setZoomFactor,
  defaultConfig,
  savePromptWindowSettings
} = require_data5();
var {
  handleFilePath,
  saveFile
} = require_file();
var channel = "window";
var mcpClientInstance = null;
var langchainToolMap = /* @__PURE__ */ new Map();
async function initializeMcpClient(activeServersConfig) {
  if (mcpClientInstance) {
    await mcpClientInstance.close();
    mcpClientInstance = null;
    langchainToolMap.clear();
  }
  if (!activeServersConfig || Object.keys(activeServersConfig).length === 0) {
    return { openaiFormattedTools: [] };
  }
  mcpClientInstance = new MultiServerMCPClient(activeServersConfig);
  const tools = await mcpClientInstance.getTools();
  langchainToolMap = new Map(tools.map((t) => [t.name, t]));
  const openaiFormattedTools = tools.map((tool) => {
    if (!tool.schema) {
      console.error(`Tool '${tool.name}' is missing schema definition.`);
      return null;
    }
    return {
      type: "function",
      function: {
        name: tool.name,
        description: tool.description,
        parameters: tool.schema
      }
    };
  }).filter(Boolean);
  return { openaiFormattedTools };
}
async function closeMcpClient() {
  if (mcpClientInstance) {
    await mcpClientInstance.close();
    mcpClientInstance = null;
    langchainToolMap.clear();
  }
}
async function invokeMcpTool(toolName, toolArgs) {
  const toolToCall = langchainToolMap.get(toolName);
  if (!toolToCall) {
    throw new Error(`Tool "${toolName}" not found in the current MCP client.`);
  }
  return await toolToCall.invoke(toolArgs);
}
window.preload = {
  receiveMsg: (callback) => {
    ipcRenderer.on(channel, (event, data) => {
      parentId = event.senderId;
      if (data) {
        callback(data);
      }
    });
  }
};
window.addEventListener("DOMContentLoaded", () => {
  document.addEventListener("click", (event) => {
    let target = event.target;
    while (target && target.tagName !== "A") {
      target = target.parentNode;
    }
    if (target && target.tagName === "A" && target.href) {
      event.preventDefault();
      utools.shellOpenExternal(target.href);
    }
  });
});
window.api = {
  getConfig,
  updateConfig,
  saveSetting,
  getUser,
  getRandomItem,
  chatOpenAI,
  copyText,
  handleFilePath,
  saveFile,
  sethotkey,
  setZoomFactor,
  defaultConfig,
  savePromptWindowSettings,
  desktopCaptureSources: utools.desktopCaptureSources,
  copyImage: utools.copyImage,
  // --- Exposing MCP functions to the renderer process ---
  initializeMcpClient,
  closeMcpClient,
  invokeMcpTool
};
/*! Bundled license information:

@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs:
  (*!
  * https://github.com/Starcounter-Jack/JSON-Patch
  * (c) 2017-2022 Joachim Wester
  * MIT licensed
  *)

@langchain/core/dist/utils/sax-js/sax.cjs:
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)

mustache/mustache.js:
  (*!
   * mustache.js - Logic-less {{mustache}} templates with JavaScript
   * http://github.com/janl/mustache.js
   *)

uri-js/dist/es5/uri.all.js:
  (** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js *)
*/
