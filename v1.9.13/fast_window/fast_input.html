<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anywhere Clip</title>
    <style>
        :root {
            /* 浅色模式：星星风格 */
            --bg-color: rgba(255, 255, 255, 0.98);
            --text-color: #1F2937;
            --border-color: rgba(0, 0, 0, 0.08);
            --hover-bg: rgba(0, 0, 0, 0.05);
            --accent-color: #3B82F6;
            --success-color: #10B981;
            --error-color: #EF4444;
            --input-color: #8B5CF6; /* 拖拽按钮紫色 */
            --shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
            
            /* 星星粒子颜色 */
            --p-color-1: #FFD700; /* 金黄 */
            --p-color-2: #FFFFFF; /* 纯白 */
            --p-color-3: #FDE68A; /* 浅黄 */
        }

        html.dark {
            /* 深色模式：灰尘精灵风格 */
            --bg-color: rgba(30, 30, 30, 0.98);
            --text-color: #F3F4F6;
            --border-color: rgba(255, 255, 255, 0.12);
            --hover-bg: rgba(255, 255, 255, 0.15);
            --shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
            --input-color: #A78BFA;
            
            /* 灰尘粒子颜色 */
            --p-color-1: #000000;
            --p-color-2: #2d2d2d;
            --p-color-3: #1a1a1a;
        }

        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: transparent;
            font-family: system-ui, -apple-system, sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }

        #particle-stage {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 5; 
        }

        /* 主窗口容器 */
        #container {
            width: 300px;
            height: 50px;
            background-color: var(--bg-color);
            border-radius: 50px !important;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow);
            
            display: flex;
            align-items: center;
            padding: 0 6px;
            box-sizing: border-box;
            
            position: relative;
            z-index: 10;
            
            opacity: 1;
            transform: scale(1);
            transition: opacity 0.3s, transform 0.3s;
        }

        #container.vanish {
            opacity: 0;
            transform: scale(0.8);
            transition: opacity 0.1s ease-out, transform 0.1s ease-out;
            pointer-events: none;
        }

        /* 通用按钮样式 */
        .control-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s, transform 0.1s;
            color: var(--text-color);
            position: relative;
        }

        .control-btn:hover { background-color: var(--hover-bg); transform: scale(1.05); }
        .control-btn:active { transform: scale(0.95); }

        /* 左侧区域：关闭 -> 复制 */
        .left-zone {
            width: 38px;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        /* 状态A: 关闭 */
        .control-btn.close:hover { color: var(--error-color); background-color: rgba(239, 68, 68, 0.1); }
        /* 状态B: 复制 */
        .control-btn.copy:hover { color: var(--success-color); background-color: rgba(16, 185, 129, 0.1); }

        /* 图标切换动画 */
        .icon-layer {
            position: absolute;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .icon-hidden {
            opacity: 0;
            transform: scale(0.5);
            pointer-events: none;
        }
        .icon-visible {
            opacity: 1;
            transform: scale(1);
        }

        /* 中间内容区 */
        .content-zone {
            flex-grow: 1;
            height: 100%;
            display: flex;
            align-items: center;
            overflow: hidden;
            position: relative;
            padding: 0 2px;
            -webkit-app-region: drag; 
        }

        #text-display {
            font-size: 14px;
            color: var(--text-color);
            width: 100%;
            white-space: nowrap;
            overflow: hidden; 
            opacity: 0;
            transition: opacity 0.2s;
            display: block; 
            text-align: left;
        }
        #text-display.visible { opacity: 1; }

        /* 中央加载动画 */
        #center-loader {
            position: absolute;
            left: 50%; top: 50%; transform: translate(-50%, -50%);
            display: flex; gap: 5px;
            pointer-events: none;
        }
        .dot { 
            width: 6px; height: 6px; 
            background-color: var(--text-color); opacity: 0.6; 
            border-radius: 50%; 
            animation: bounce 1.4s infinite ease-in-out both; 
        }
        .dot:nth-child(1) { animation-delay: -0.32s; } 
        .dot:nth-child(2) { animation-delay: -0.16s; }
        @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1); } }

        /* 右侧区域：加载圈 -> 输入按钮 */
        .right-zone {
            width: 38px;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .stream-spinner {
            width: 16px; height: 16px;
            border: 2px solid rgba(128,128,128,0.2);
            border-left-color: var(--text-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: none;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* 输入按钮 */
        .control-btn.input {
            display: none; /* 默认隐藏 */
        }
        .control-btn.input:hover { color: var(--input-color); background-color: rgba(139, 92, 246, 0.1); }
        .control-btn.input.dragging { opacity: 0.5; cursor: grabbing; }

        /* 完成状态下的样式变更 */
        #container.finished {
            animation: golden-flash 0.6s ease-out;
        }
        #container.finished .stream-spinner { display: none !important; }
        #container.finished .control-btn.input { display: flex !important; }

        /* ================= 粒子动画 ================= */
        .particle {
            position: absolute;
            pointer-events: none;
            will-change: transform, opacity;
            border-radius: 50%;
        }

        @keyframes star-flicker {
            0% { transform: translate(0, 0) scale(0.2) rotate(0deg); opacity: 1; }
            50% { opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) scale(0) rotate(180deg); opacity: 0; }
        }

        @keyframes soot-dissolve {
            0% { transform: translate(0, 0) scale(1); opacity: 0.9; }
            20% { transform: translate(calc(var(--tx) * 0.2), calc(var(--ty) * 0.2)) scale(1.2); }
            100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
        }
        @keyframes golden-flash {
            0% { 
                border-color: var(--border-color); 
                box-shadow: var(--shadow); 
            }
            25% { 
                border-color: #F59E0B; /* 金黄色边框 */
                box-shadow: 0 0 20px rgba(245, 158, 11, 0.6), var(--shadow); /* 金黄色光晕 */
            }
            100% { 
                border-color: var(--border-color); 
                box-shadow: var(--shadow); 
            }
        }

    </style>
</head>
<body>
    <div id="particle-stage"></div>

    <div id="container">
        <!-- 左侧：关闭/复制 (合并) -->
        <div class="left-zone">
            <div id="btn-left" class="control-btn close" title="关闭 (Esc)">
                <!-- 关闭图标 -->
                <svg id="icon-close" class="icon-layer icon-visible" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
                <!-- 复制图标 -->
                <svg id="icon-copy" class="icon-layer icon-hidden" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                </svg>
                <!-- 成功勾选 -->
                <svg id="icon-check" class="icon-layer icon-hidden" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" style="color: var(--success-color);">
                    <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
            </div>
        </div>

        <!-- 中间：内容 -->
        <div class="content-zone">
            <div id="center-loader">
                <div class="dot"></div><div class="dot"></div><div class="dot"></div>
            </div>
            <div id="text-display"></div>
        </div>

        <!-- 右侧：流式加载 / 输入 -->
        <div class="right-zone">
            <div id="stream-loader" class="stream-spinner"></div>
            
            <div id="btn-input" class="control-btn input" draggable="true" title="拖拽到目标窗口输入 / 点击模拟打字">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="4 7 4 4 20 4 20 7"></polyline>
                    <line x1="9" y1="20" x2="15" y2="20"></line>
                    <line x1="12" y1="4" x2="12" y2="20"></line>
                </svg>
            </div>
        </div>
    </div>

    <script>
        const container = document.getElementById('container');
        const particleStage = document.getElementById('particle-stage');
        const centerLoader = document.getElementById('center-loader');
        const textDisplay = document.getElementById('text-display');
        const btnLeft = document.getElementById('btn-left');
        const btnInput = document.getElementById('btn-input');
        const streamLoader = document.getElementById('stream-loader');
        
        // Icons
        const iconClose = document.getElementById('icon-close');
        const iconCopy = document.getElementById('icon-copy');
        const iconCheck = document.getElementById('icon-check');

        // 数据状态
        let fullTextData = ""; // 后端接收到的完整数据
        let visualText = "";   // 屏幕上当前显示的动画数据
        
        let isTaskFinished = false; 
        let isClosing = false;
        let isTyping = false;
        let isRendering = false; // 是否正在执行动画循环
        
        let shutdownTimer = null; 
        let animationTimer = null; 
        let isDarkMode = false;

        const EDGE_PADDING = 10; 

        // --- 核心：打字机动画循环 ---
        function renderLoop() {
            // 如果显示的文字少于接收到的文字，继续渲染
            if (visualText.length < fullTextData.length) {
                isRendering = true;
                
                // 确保UI已切换到显示状态
                if (centerLoader.style.display !== 'none') {
                    centerLoader.style.display = 'none';
                    textDisplay.classList.add('visible');
                    streamLoader.style.display = 'block';
                }

                // 动态步长算法：积压越多，跑得越快，保证流畅且不卡顿
                // 最小1字符，最大为剩余长度的1/5（追赶效应）
                const lag = fullTextData.length - visualText.length;
                const step = Math.max(1, Math.ceil(lag / 5)); 
                
                // 追加文本
                visualText += fullTextData.substr(visualText.length, step);
                
                // 更新 DOM
                textDisplay.textContent = visualText.replace(/[\r\n]+/g, ' ');
                textDisplay.scrollLeft = textDisplay.scrollWidth; // 自动跟随滚动

                requestAnimationFrame(renderLoop);
            } else {
                isRendering = false;
                // 如果任务已完成且动画已播放完毕，确保加载圈隐藏
                if (isTaskFinished) {
                    streamLoader.style.display = 'none';
                }
            }
        }

        if (window.preload && window.preload.receiveMsg) {
            // 1. 初始化配置
            window.preload.receiveMsg((data) => {
                const { config } = data;
                isDarkMode = config.isDarkMode;
                if (isDarkMode) document.documentElement.classList.add('dark');
                
                // 初始状态：显示中间加载点
                if (centerLoader.style.display !== 'none') {
                    centerLoader.style.display = 'none';
                    textDisplay.classList.add('visible');
                    streamLoader.style.display = 'block';
                }
            });

            // 2. 监听流式数据
            if (window.preload.onStreamUpdate) {
                window.preload.onStreamUpdate((data) => {
                    const { type, payload } = data;

                    if (type === 'chunk') {
                        // 仅累加数据，不直接操作DOM，交给 renderLoop
                        fullTextData += payload;
                        if (!isRendering) renderLoop();
                    } 
                    else if (type === 'done') {
                        handleTaskFinish(); // 标记完成
                    } 
                    else if (type === 'error') {
                        // 错误情况直接显示，不走动画
                        fullTextData = "Error: " + payload;
                        visualText = fullTextData; 
                        handleTaskFinish(true);
                    }
                });
            }
        }

        function handleTaskFinish(isError = false) {
            isTaskFinished = true;
            
            // 注意：这里不再强制覆盖 textDisplay.textContent
            // 让 renderLoop 自然跑完剩余的文字
            
            if (isError) {
                textDisplay.textContent = fullTextData;
                textDisplay.style.color = 'var(--error-color)';
                centerLoader.style.display = 'none';
                streamLoader.style.display = 'none';
            } else {
                // 如果动画已经追平，立即隐藏加载圈；否则 renderLoop 会在追平后隐藏它
                if (!isRendering) {
                    streamLoader.style.display = 'none';
                }
            }

            // 切换 UI 状态 -> 完成 (金边闪烁)
            container.classList.add('finished');
            
            // 左侧按钮：从 Close 变为 Copy
            btnLeft.classList.remove('close');
            btnLeft.classList.add('copy');
            btnLeft.title = "复制并关闭";
            
            iconClose.classList.remove('icon-visible');
            iconClose.classList.add('icon-hidden');
            iconCopy.classList.remove('icon-hidden');
            iconCopy.classList.add('icon-visible');

            // 自动复制完整文本
            window.api.copyText(fullTextData);
            checkShutdownLogic();
        }

        function checkShutdownLogic() {
            if (!isTaskFinished || isClosing || isTyping) return;
            if (!document.hasFocus()) {
                startCountdown();
            }
        }

        function startCountdown() {
            if (shutdownTimer) clearTimeout(shutdownTimer);
            if (isTyping) return;
            
            console.log("Start 3s countdown...");
            shutdownTimer = setTimeout(() => {
                playCloseAnimation();
            }, 3000);
        }

        function playCloseAnimation() {
            if (isClosing) return;
            isClosing = true;
            
            spawnParticles();
            container.classList.add('vanish');

            animationTimer = setTimeout(() => {
                window.api.closeWindow({ x: window.screenX, y: window.screenY });
            }, 1000);
        }

        function restoreWindow() {
            console.log("Interrupted! Restoring...");
            if (shutdownTimer) clearTimeout(shutdownTimer);
            if (animationTimer) clearTimeout(animationTimer);
            shutdownTimer = null;
            animationTimer = null;
            isClosing = false;

            container.classList.remove('vanish');
            particleStage.innerHTML = ''; 
        }

        window.addEventListener('blur', () => {
            if (isTaskFinished && !isClosing && !isTyping) {
                startCountdown();
            }
        });

        window.addEventListener('focus', restoreWindow);
        document.addEventListener('mousedown', restoreWindow);

        // 左侧按钮逻辑
        btnLeft.addEventListener('click', (e) => {
            e.stopPropagation();
            if (!isTaskFinished) {
                // 未完成 -> 关闭
                playCloseAnimation();
            } else {
                // 已完成 -> 复制并关闭
                window.api.copyText(fullTextData);
                
                // 勾选动画
                iconCopy.classList.remove('icon-visible');
                iconCopy.classList.add('icon-hidden');
                iconCheck.classList.remove('icon-hidden');
                iconCheck.classList.add('icon-visible');
                
                playCloseAnimation();
            }
        });

        // --- 右侧输入按钮逻辑 ---
        
        // 1. 拖拽开始
        btnInput.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData("text/plain", fullTextData);
            btnInput.classList.add('dragging');
            restoreWindow(); 
            isTyping = true; // 锁定状态，防止失焦关闭
        });

        // 2. 拖拽结束 -> 立即输入 -> 延时关闭
        btnInput.addEventListener('dragend', (e) => {
            btnInput.classList.remove('dragging');
            
            if (window.api.typeText) {
                window.api.typeText(fullTextData);
            }
            setTimeout(() => {
                isTyping = false;
                playCloseAnimation();
            }, 1000); 
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') playCloseAnimation();
        });

        // ================= 粒子特效 (保持不变) =================

        function spawnParticles() {
            const winW = window.innerWidth;
            const winH = window.innerHeight;
            const rect = container.getBoundingClientRect();
            const particleCount = 200; 

            for (let i = 0; i < particleCount; i++) {
                const p = document.createElement('div');
                p.classList.add('particle');
                p.style.position = 'absolute';
                
                const safeX = 25; 
                const safeY = 10;
                const spawnW = rect.width - safeX * 2;
                const spawnH = rect.height - safeY * 2;

                const offsetX = Math.random() * spawnW + safeX;
                const offsetY = Math.random() * spawnH + safeY;
                
                const startX = rect.left + offsetX;
                const startY = rect.top + offsetY;

                p.style.left = startX + 'px';
                p.style.top = startY + 'px';

                if (isDarkMode) {
                    // --- 深色模式：灰尘精灵 ---
                    const size = 3 + Math.random() * 5; 
                    p.style.width = size + 'px';
                    p.style.height = size + 'px';
                    p.style.borderRadius = '50%';
                    
                    const randC = Math.random();
                    if(randC > 0.6) p.style.backgroundColor = 'var(--p-color-1)';
                    else if(randC > 0.3) p.style.backgroundColor = 'var(--p-color-2)';
                    else p.style.backgroundColor = 'var(--p-color-3)';
                    
                    p.style.filter = 'blur(0.5px)';

                    let tx = (Math.random() - 0.5) * 20; 
                    if (startX + tx < EDGE_PADDING) tx = Math.abs(tx);
                    if (startX + tx > winW - EDGE_PADDING) tx = -Math.abs(tx);

                    p.style.setProperty('--tx', tx + 'px');
                    p.style.animation = `star-flicker ${1.2 + Math.random() * 0.5}s ease-out forwards`;

                } else {
                    // --- 浅色模式：星光 ---
                    const size = 6 + Math.random() * 8;
                    p.style.width = size + 'px';
                    p.style.height = size + 'px';
                    
                    if (Math.random() > 0.4) {
                        p.style.clipPath = 'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)';
                        p.style.borderRadius = '0';
                    } else {
                        p.style.borderRadius = '50%';
                    }

                    const randC = Math.random();
                    if(randC > 0.6) p.style.backgroundColor = 'var(--p-color-1)';
                    else if(randC > 0.2) p.style.backgroundColor = 'var(--p-color-2)';
                    else p.style.backgroundColor = 'var(--p-color-3)';
                    
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 10 + Math.random() * 20; 
                    
                    let moveX = Math.cos(angle) * dist;
                    let moveY = Math.sin(angle) * dist;

                    const endX = startX + moveX;
                    const endY = startY + moveY;

                    if (endX < EDGE_PADDING || endX > winW - EDGE_PADDING) moveX = -moveX;
                    if (endY < EDGE_PADDING || endY > winH - EDGE_PADDING) moveY = -moveY;

                    p.style.setProperty('--tx', moveX + 'px');
                    p.style.setProperty('--ty', moveY + 'px');
                    
                    p.style.animation = `star-flicker ${1.2 + Math.random() * 0.5}s ease-out forwards`;
                }

                p.style.animationDelay = (Math.random() * 0.1) + 's';
                particleStage.appendChild(p);
            }
        }
    </script>
</body>
</html>